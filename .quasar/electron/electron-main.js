var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod4) => function __require() {
  return mod4 || (0, cb[__getOwnPropNames(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
  isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target, "default", { value: mod4, enumerable: true }) : target,
  mod4
));

// node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode6(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode7(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode6,
    decodeUnsafe,
    decode: decode7
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "node_modules/multiformats/esm/vendor/base-x.js"() {
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// node_modules/multiformats/esm/src/bytes.js
var empty, equals, coerce, fromString, toString;
var init_bytes = __esm({
  "node_modules/multiformats/esm/src/bytes.js"() {
    empty = new Uint8Array(0);
    equals = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    fromString = (str) => new TextEncoder().encode(str);
    toString = (b) => new TextDecoder().decode(b);
  }
});

// node_modules/multiformats/esm/src/bases/base.js
var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode, encode, rfc4648;
var init_base = __esm({
  "node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name2, prefix, baseEncode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name2, prefix, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    ComposedDecoder = class {
      constructor(decoders2) {
        this.decoders = decoders2;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec = class {
      constructor(name2, prefix, baseEncode, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name2, prefix, baseEncode);
        this.decoder = new Decoder(name2, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from = ({ name: name2, prefix, encode: encode6, decode: decode7 }) => new Codec(name2, prefix, encode6, decode7);
    baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
      const { encode: encode6, decode: decode7 } = base_x_default(alphabet2, name2);
      return from({
        prefix,
        name: name2,
        encode: encode6,
        decode: (text) => coerce(decode7(text))
      });
    };
    decode = (string2, alphabet2, bitsPerChar, name2) => {
      const codes5 = {};
      for (let i = 0; i < alphabet2.length; ++i) {
        codes5[alphabet2[i]] = i;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes5[string2[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name2} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from({
        prefix,
        name: name2,
        encode(input) {
          return encode(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode(input, alphabet2, bitsPerChar, name2);
        }
      });
    };
  }
});

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity;
var init_identity = __esm({
  "node_modules/multiformats/esm/src/bases/identity.js"() {
    init_base();
    init_bytes();
    identity = from({
      prefix: "\0",
      name: "identity",
      encode: (buf) => toString(buf),
      decode: (str) => fromString(str)
    });
  }
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2;
var init_base2 = __esm({
  "node_modules/multiformats/esm/src/bases/base2.js"() {
    init_base();
    base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "node_modules/multiformats/esm/src/bases/base8.js"() {
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "node_modules/multiformats/esm/src/bases/base10.js"() {
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "node_modules/multiformats/esm/src/bases/base16.js"() {
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "node_modules/multiformats/esm/src/bases/base36.js"() {
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "node_modules/multiformats/esm/src/bases/base64.js"() {
    init_base();
    base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
function encode2(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode2(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
var init_base256emoji = __esm({
  "node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_base();
    alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars = alphabet.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    base256emoji = from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode2,
      decode: decode2
    });
  }
});

// node_modules/multiformats/esm/vendor/varint.js
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode3, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "node_modules/multiformats/esm/vendor/varint.js"() {
    encode_1 = encode3;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode3 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode3,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// node_modules/multiformats/esm/src/varint.js
var decode4, encodeTo, encodingLength;
var init_varint2 = __esm({
  "node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode4 = (data) => {
      const code2 = varint_default.decode(data);
      return [
        code2,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    };
    encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
  }
});

// node_modules/multiformats/esm/src/hashes/digest.js
var create, decode5, equals2, Digest;
var init_digest = __esm({
  "node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create = (code2, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = encodingLength(code2);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo(code2, bytes, 0);
      encodeTo(size, bytes, sizeOffset);
      bytes.set(digest2, digestOffset);
      return new Digest(code2, size, digest2, bytes);
    };
    decode5 = (multihash) => {
      const bytes = coerce(multihash);
      const [code2, sizeOffset] = decode4(bytes);
      const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
      const digest2 = bytes.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code2, size, digest2, bytes);
    };
    equals2 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
      }
    };
    Digest = class {
      constructor(code2, size, digest2, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes;
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/hasher.js
var from2, Hasher;
var init_hasher = __esm({
  "node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from2 = ({ name: name2, code: code2, encode: encode6 }) => new Hasher(name2, code2, encode6);
    Hasher = class {
      constructor(name2, code2, encode6) {
        this.name = name2;
        this.code = code2;
        this.encode = encode6;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/sha2.js
var sha2_exports = {};
__export(sha2_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var import_crypto, sha256, sha512;
var init_sha2 = __esm({
  "node_modules/multiformats/esm/src/hashes/sha2.js"() {
    import_crypto = __toESM(require("crypto"), 1);
    init_hasher();
    init_bytes();
    sha256 = from2({
      name: "sha2-256",
      code: 18,
      encode: (input) => coerce(import_crypto.default.createHash("sha256").update(input).digest())
    });
    sha512 = from2({
      name: "sha2-512",
      code: 19,
      encode: (input) => coerce(import_crypto.default.createHash("sha512").update(input).digest())
    });
  }
});

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code, name, encode4, digest, identity2;
var init_identity2 = __esm({
  "node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_bytes();
    init_digest();
    code = 0;
    name = "identity";
    encode4 = coerce;
    digest = (input) => create(code, encode4(input));
    identity2 = {
      code,
      name,
      encode: encode4,
      digest
    };
  }
});

// node_modules/multiformats/esm/src/codecs/raw.js
var init_raw = __esm({
  "node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_bytes();
  }
});

// node_modules/multiformats/esm/src/codecs/json.js
var textEncoder, textDecoder;
var init_json = __esm({
  "node_modules/multiformats/esm/src/codecs/json.js"() {
    textEncoder = new TextEncoder();
    textDecoder = new TextDecoder();
  }
});

// node_modules/multiformats/esm/src/cid.js
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class {
      constructor(version2, code2, multihash, bytes) {
        this.code = code2;
        this.version = version2;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest: digest2 } = this.multihash;
            const multihash = create(code2, digest2);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes, version: version2, _baseCache } = this;
        switch (version2) {
          case 0:
            return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
          default:
            return toStringV1(bytes, _baseCache, base3 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version2, code: code2, multihash, bytes } = value;
          return new CID(version2, code2, multihash, bytes || encodeCID(version2, code2, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version2, multihash, code: code2 } = value;
          const digest2 = decode5(multihash);
          return CID.create(version2, code2, digest2);
        } else {
          return null;
        }
      }
      static create(version2, code2, digest2) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version2) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version2, code2, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version2, code2, digest2.bytes);
            return new CID(version2, code2, digest2, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code2, digest2) {
        return CID.create(1, code2, digest2);
      }
      static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
        return [
          cid,
          bytes.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length2] = decode4(initialBytes.subarray(offset));
          offset += length2;
          return i;
        };
        let version2 = next();
        let codec = DAG_PB_CODE;
        if (version2 === 18) {
          version2 = 0;
          offset = 0;
        } else if (version2 === 1) {
          codec = next();
        }
        if (version2 !== 0 && version2 !== 1) {
          throw new RangeError(`Invalid CID version ${version2}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version2,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base3) {
        const [prefix, bytes] = parseCIDtoBytes(source, base3);
        const cid = CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base3 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes, cache, base3) => {
      const { prefix } = base3;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes, cache, base3) => {
      const { prefix } = base3;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version2, code2, multihash) => {
      const codeOffset = encodingLength(version2);
      const hashOffset = codeOffset + encodingLength(code2);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version2, bytes, 0);
      encodeTo(code2, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version = "0.0.0-dev";
    deprecate = (range, message2) => {
      if (range.test(version)) {
        console.warn(message2);
      } else {
        throw new Error(message2);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// node_modules/multiformats/esm/src/index.js
var init_src = __esm({
  "node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// node_modules/multiformats/esm/src/basics.js
var bases, hashes;
var init_basics = __esm({
  "node_modules/multiformats/esm/src/basics.js"() {
    init_identity();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2();
    init_identity2();
    init_raw();
    init_json();
    init_src();
    bases = {
      ...identity_exports,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports,
      ...base256emoji_exports
    };
    hashes = {
      ...sha2_exports,
      ...identity_exports2
    };
  }
});

// node_modules/uint8arrays/esm/src/alloc.js
function alloc(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
    return globalThis.Buffer.alloc(size);
  }
  return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(size);
  }
  return new Uint8Array(size);
}
var init_alloc = __esm({
  "node_modules/uint8arrays/esm/src/alloc.js"() {
  }
});

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode6, decode7) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode6
    },
    decoder: { decode: decode7 }
  };
}
var string, ascii, BASES, bases_default;
var init_bases = __esm({
  "node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_basics();
    init_alloc();
    string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i = 0; i < buf.length; i++) {
        string2 += String.fromCharCode(buf[i]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = allocUnsafe(str.length);
      for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    });
    BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});

// node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var init_to_string = __esm({
  "node_modules/uint8arrays/esm/src/to-string.js"() {
    init_bases();
  }
});

// node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}
var init_concat = __esm({
  "node_modules/uint8arrays/esm/src/concat.js"() {
    init_alloc();
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base642 = exports2;
    base642.length = function length2(string2) {
      var p = string2.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string2.charAt(p) === "=")
        ++n;
      return Math.ceil(string2.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base642.encode = function encode6(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode7(string2, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string2.length; ) {
        var c = string2.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter2;
    function EventEmitter2() {
      this._listeners = {};
    }
    EventEmitter2.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter2.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter2.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign3 << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign3 << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign3 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string2) {
      var len = 0, c = 0;
      for (var i = 0; i < string2.length; ++i) {
        c = string2.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string2, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string2.length; ++i) {
        c1 = string2.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc2, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc2(size2);
        if (offset + size2 > SIZE) {
          slab = alloc2(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits2;
    var util = require_minimal();
    function LongBits2(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits2.zero = new LongBits2(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits2.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign3 = value < 0;
      if (sign3)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign3) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits2(lo, hi);
    };
    LongBits2.from = function from3(value) {
      if (typeof value === "number")
        return LongBits2.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits2.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits2.prototype.toNumber = function toNumber(unsigned2) {
      if (!unsigned2 && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits2.prototype.toLong = function toLong(unsigned2) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits2.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits2(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits2.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits2.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.length = function length2() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned2) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned2);
      return bits.toNumber(Boolean(unsigned2));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src2[keys[i]];
      return dst;
    }
    util.merge = merge2;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get() {
            return name2;
          },
          set: void 0,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name2)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util = require_minimal();
    var BufferWriter;
    var LongBits2 = util.LongBits;
    var base642 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create4 = function create5() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create4();
    Writer2.alloc = function alloc2(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer2.alloc = util.pool(Writer2.alloc, util.Array.prototype.subarray);
    Writer2.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits2.fromNumber(value)) : this.uint32(value);
    };
    Writer2.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits2.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits2.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits2.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer2.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer2.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer2.alloc(len = base642.length(value));
        base642.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer2.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create4();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader2;
    var util = require_minimal();
    var BufferReader;
    var LongBits2 = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader2, writeLength) {
      return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
    }
    function Reader2(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader2(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader2(buffer);
      throw Error("illegal buffer");
    };
    var create4 = function create5() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader2.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader2.create = create4();
    Reader2.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader2.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader2.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader2.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits2(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader2.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader2.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader2.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader2.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader2.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader2.prototype.bytes = function read_bytes() {
      var length2 = this.uint32(), start = this.pos, end = this.pos + length2;
      if (end > this.len)
        throw indexOutOfRange(this, length2);
      this.pos += length2;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader2.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader2.prototype.skip = function skip(length2) {
      if (typeof length2 === "number") {
        if (this.pos + length2 > this.len)
          throw indexOutOfRange(this, length2);
        this.pos += length2;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader2.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader2._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader2.create = create4();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader2.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader2 = require_reader();
    (BufferReader.prototype = Object.create(Reader2.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader2.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(true);
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString5();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString5(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString5;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch(filename, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      } else if (!options2)
        options2 = {};
      if (!callback)
        return asPromise(fetch, this, filename, options2);
      if (!options2.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options2, callback) : err ? callback(err) : callback(null, options2.binary ? contents : contents.toString("utf8"));
        });
      return fetch.xhr(filename, options2, callback);
    }
    fetch.xhr = function fetch_xhr(filename, options2, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options2.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i = 0; i < xhr.responseText.length; ++i)
              buffer.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      };
      if (options2.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path2 = exports2;
    var isAbsolute = path2.isAbsolute = function isAbsolute2(path3) {
      return /^(?:\/|\w+:)/.test(path3);
    };
    var normalize = path2.normalize = function normalize2(path3) {
      path3 = path3.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      var parts = path3.split("/"), absolute = isAbsolute(path3), prefix = "";
      if (absolute)
        prefix = parts.shift() + "/";
      for (var i = 0; i < parts.length; ) {
        if (parts[i] === "..") {
          if (i > 0 && parts[i - 1] !== "..")
            parts.splice(--i, 2);
          else if (absolute)
            parts.splice(i, 1);
          else
            ++i;
        } else if (parts[i] === ".")
          parts.splice(i, 1);
        else
          ++i;
      }
      return prefix + parts.join("/");
    };
    path2.resolve = function resolve(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types = exports2;
    var util = require_util();
    var s = [
      "double",
      "float",
      "int32",
      "uint32",
      "sint32",
      "fixed32",
      "sfixed32",
      "int64",
      "uint64",
      "sint64",
      "fixed64",
      "sfixed64",
      "bool",
      "string",
      "bytes"
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length)
        o[s[i + offset]] = values[i++];
      return o;
    }
    types.basic = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2,
      2
    ]);
    types.defaults = bake([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      false,
      "",
      util.emptyArray,
      null
    ]);
    types.long = bake([
      0,
      0,
      0,
      1,
      1
    ], 7);
    types.mapKey = bake([
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2
    ], 2);
    types.packed = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON(name2, json) {
      return new Field(name2, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field(name2, id, type, rule, extend, options2, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options2 = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options2;
        options2 = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name2, options2);
      if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types.long[type] !== void 0 : false;
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field.prototype.setOption = function setOption(name2, value, ifNotSet) {
      if (name2 === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name2, value, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      } else if (this.options && this.options.proto3_optional) {
        this.typeDefault = null;
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util = require_util();
    function OneOf(name2, fieldNames, options2, comment) {
      if (!Array.isArray(fieldNames)) {
        options2 = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name2, options2);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name2, json) {
      return new OneOf(name2, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
          if (!oneof.fieldsArray[i].parent)
            oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1)
        this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length)
        fieldNames[index] = arguments[index++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var util = require_util();
    var OneOf = require_oneof();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = function fromJSON(name2, json) {
      return new Namespace(name2, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved, id) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved, name2) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (reserved[i] === name2)
            return true;
      }
      return false;
    };
    function Namespace(name2, options2) {
      ReflectionObject.call(this, name2, options2);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names3 = Object.keys(nestedJson), i = 0, nested; i < names3.length; ++i) {
          nested = nestedJson[names3[i]];
          ns.add(
            (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names3[i], nested)
          );
        }
      }
      return this;
    };
    Namespace.prototype.get = function get(name2) {
      return this.nested && this.nested[name2] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name2) {
      if (this.nested && this.nested[name2] instanceof Enum)
        return this.nested[name2].values;
      throw Error("no such enum: " + name2);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i)
              object.add(nested[i]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define2(path2, json) {
      if (util.isString(path2))
        path2 = path2.split(".");
      else if (!Array.isArray(path2))
        throw TypeError("illegal path");
      if (path2 && path2.length && path2[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path2.length > 0) {
        var part = path2.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i = 0;
      while (i < nested.length)
        if (nested[i] instanceof Namespace)
          nested[i++].resolveAll();
        else
          nested[i++].resolve();
      return this.resolve();
    };
    Namespace.prototype.lookup = function lookup(path2, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path2) && path2.length) {
        if (path2 === ".")
          return this.root;
        path2 = path2.split(".");
      } else if (!path2.length)
        return this;
      if (path2[0] === "")
        return this.root.lookup(path2.slice(1), filterTypes);
      var found = this.get(path2[0]);
      if (found) {
        if (path2.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace && (found = found.lookup(path2.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i = 0; i < this.nestedArray.length; ++i)
          if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path2, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path2, filterTypes);
    };
    Namespace.prototype.lookupType = function lookupType(path2) {
      var found = this.lookup(path2, [Type]);
      if (!found)
        throw Error("no such type: " + path2);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path2) {
      var found = this.lookup(path2, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path2 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path2) {
      var found = this.lookup(path2, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path2 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path2) {
      var found = this.lookup(path2, [Service]);
      if (!found)
        throw Error("no such Service '" + path2 + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types = require_types();
    var util = require_util();
    function MapField(name2, id, keyType, type, options2, comment) {
      Field.call(this, name2, id, type, void 0, void 0, options2, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name2, json) {
      return new MapField(name2, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (types.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util();
    function Method(name2, type, requestType, responseType, requestStream, responseStream, options2, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options2 = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options2 = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name2, options2);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name2, json) {
      return new Method(name2, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util();
    var rpc = require_rpc();
    function Service(name2, options2) {
      Namespace.call(this, name2, options2);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON(name2, json) {
      var service = new Service(name2, json.options);
      if (json.methods)
        for (var names3 = Object.keys(json.methods), i = 0; i < names3.length; ++i)
          service.add(Method.fromJSON(names3[i], json.methods[names3[i]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get(name2) {
      return this.methods[name2] || Namespace.prototype.get.call(this, name2);
    };
    Service.prototype.resolveAll = function resolveAll() {
      var methods3 = this.methodsArray;
      for (var i = 0; i < methods3.length; ++i)
        methods3[i].resolve();
      return Namespace.prototype.resolve.call(this);
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create4(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          this[keys[i]] = properties[keys[i]];
    }
    Message.create = function create4(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode6(message2, writer) {
      return this.$type.encode(message2, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.$type.encodeDelimited(message2, writer);
    };
    Message.decode = function decode7(reader2) {
      return this.$type.decode(reader2);
    };
    Message.decodeDelimited = function decodeDelimited(reader2) {
      return this.$type.decodeDelimited(reader2);
    };
    Message.verify = function verify3(message2) {
      return this.$type.verify(message2);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message2, options2) {
      return this.$type.toObject(message2, options2);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group)
        gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i = 0;
      for (; i < mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
        gen("case %i: {", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types.defaults[field.keyType] !== void 0)
            gen("k=%j", types.defaults[field.keyType]);
          else
            gen("k=null");
          if (types.defaults[type] !== void 0)
            gen("value=%j", types.defaults[type]);
          else
            gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types.basic[type] === void 0)
            gen("value=types[%i].decode(r,r.uint32())", i);
          else
            gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types.long[field.keyType] !== void 0)
            gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else
            gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types.packed[type] !== void 0)
            gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types.basic[type] === void 0)
            gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
          else
            gen("%s.push(r.%s())", ref, type);
        } else if (types.basic[type] === void 0)
          gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else
          gen("%s=r.%s()", ref, type);
        gen("break")("}");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required)
          gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util = require_util();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)
            gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length)
        gen("var p={}");
      for (var i = 0; i < mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
        if (field.optional)
          gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1)
              gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref);
        }
        if (field.optional)
          gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util = require_util();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field.repeated)
                gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else
          gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length)
        return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i, prop + "[ks[i]]")("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i, prop + "[i]")("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum))
            gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(gen, field, i, prop);
          if (!(field.resolvedType instanceof Enum))
            gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else
          gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i)
          gen("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i)
          gen("d%s={}", util.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum)
            gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long)
            gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else
            gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(gen, field, index, prop + "[ks2[j]]")("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(gen, field, index, prop + "[j]")("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(gen, field, index, prop);
          if (field.partOf)
            gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name2 = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name2);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message2, options2) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name2 = "";
        if (options2 && options2.json && message2.type_url && message2.value) {
          name2 = message2.type_url.substring(message2.type_url.lastIndexOf("/") + 1);
          prefix = message2.type_url.substring(0, message2.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name2);
          if (type)
            message2 = type.decode(message2.value);
        }
        if (!(message2 instanceof this.ctor) && message2 instanceof Message) {
          var object = message2.$type.toObject(message2, options2);
          var messageName = message2.$type.fullName[0] === "." ? message2.$type.fullName.slice(1) : message2.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name2 = prefix + messageName;
          object["@type"] = name2;
          return object;
        }
        return this.toObject(message2, options2);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message();
    var Reader2 = require_reader();
    var Writer2 = require_writer();
    var util = require_util();
    var encoder = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name2, options2) {
      Namespace.call(this, name2, options2);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names3 = Object.keys(this.fields), i = 0; i < names3.length; ++i) {
            var field = this.fields[names3[i]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < this.fieldsArray.length; ++i)
            this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < this.oneofsArray.length; ++i)
            ctorProperties[this._oneofsArray[i].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i].oneof),
              set: util.oneOfSetter(this._oneofsArray[i].oneof)
            };
          if (i)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map)
          gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated)
          gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON(name2, json) {
      var type = new Type(name2, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names3 = Object.keys(json.fields), i = 0;
      for (; i < names3.length; ++i)
        type.add(
          (typeof json.fields[names3[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names3[i], json.fields[names3[i]])
        );
      if (json.oneofs)
        for (names3 = Object.keys(json.oneofs), i = 0; i < names3.length; ++i)
          type.add(OneOf.fromJSON(names3[i], json.oneofs[names3[i]]));
      if (json.nested)
        for (names3 = Object.keys(json.nested), i = 0; i < names3.length; ++i) {
          var nested = json.nested[names3[i]];
          type.add(
            (nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names3[i], nested)
          );
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length)
        fields[i++].resolve();
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length)
        oneofs[i++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    };
    Type.prototype.get = function get(name2) {
      return this.fields[name2] || this.oneofs && this.oneofs[name2] || this.nested && this.nested[name2] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Type.prototype.isReservedName = function isReservedName(name2) {
      return Namespace.isReservedName(this.reserved, name2);
    };
    Type.prototype.create = function create4(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types = [];
      for (var i = 0; i < this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer: Writer2,
        types,
        util
      });
      this.decode = decoder(this)({
        Reader: Reader2,
        types,
        util
      });
      this.verify = verifier(this)({
        types,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types,
        util
      });
      this.toObject = converter.toObject(this)({
        types,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message2, writer) {
      return this.setup().encode(message2, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message2, writer) {
      return this.encode(message2, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader2, length2) {
      return this.setup().decode(reader2, length2);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader2) {
      if (!(reader2 instanceof Reader2))
        reader2 = Reader2.create(reader2);
      return this.decode(reader2, reader2.uint32());
    };
    Type.prototype.verify = function verify_setup(message2) {
      return this.setup().verify(message2);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message2, options2) {
      return this.setup().toObject(message2, options2);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root;
    var Namespace = require_namespace();
    ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var parse;
    var common;
    function Root(options2) {
      Namespace.call(this, "", options2);
      this.deferred = [];
      this.files = [];
    }
    Root.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root.prototype.resolvePath = util.path.resolve;
    Root.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root.prototype.load = function load(filename, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = void 0;
      }
      var self2 = this;
      if (!callback)
        return util.asPromise(load, self2, filename, options2);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback)
          return;
        var cb = callback;
        callback = null;
        if (sync)
          throw err;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common)
            return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse.filename = filename2;
            var parsed = parse(source, self2, options2), resolved2, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                  fetch(resolved2);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                  fetch(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch(filename2, weak) {
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync)
            process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback)
              return;
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename))
        filename = [filename];
      for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self2.resolvePath("", filename[i]))
          fetch(resolved);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root.prototype.loadSync = function loadSync(filename, options2) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options2, SYNC);
    };
    Root.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0 && !object.extensionField) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i = 0; i < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i]))
              this.deferred.splice(i, 1);
            else
              ++i;
        for (var j = 0; j < object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0) {
          if (object.extensionField) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1)
              this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i = 0; i < object.nestedArray.length; ++i)
          this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length)
          array[index] = object[keys[index++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key = array[index++], val = array[index++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name2) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name2);
    };
    util.safeProp = function safeProp(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a, b) {
      return a.id - b.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path2, value) {
      function setProp(dst2, path3, value2) {
        var part = path3.shift();
        if (part === "__proto__") {
          return dst2;
        }
        if (path3.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path3, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path2)
        throw TypeError("path must be specified");
      path2 = path2.split(".");
      return setProp(dst, path2, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util = require_util();
    var Root;
    function ReflectionObject(name2, options2) {
      if (!util.isString(name2))
        throw TypeError("name must be a string");
      if (options2 && !util.isObject(options2))
        throw TypeError("options must be an object");
      this.options = options2;
      this.parsedOptions = null;
      this.name = name2;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      fullName: {
        get: function() {
          var path2 = [this.name], ptr = this.parent;
          while (ptr) {
            path2.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path2.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent) {
      if (this.parent && this.parent !== parent)
        this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name2) {
      if (this.options)
        return this.options[name2];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name2, value, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name2] === void 0)
        (this.options || (this.options = {}))[name2] = value;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name2, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name2);
        });
        if (opt) {
          var newValue = opt[name2];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name2] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name2] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options2, ifNotSet) {
      if (options2)
        for (var keys = Object.keys(options2), i = 0; i < keys.length; ++i)
          this.setOption(keys[i], options2[keys[i]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString5() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util = require_util();
    function Enum(name2, values, options2, comment, comments, valuesOptions) {
      ReflectionObject.call(this, name2, options2);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.valuesOptions = valuesOptions;
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
          if (typeof values[keys[i]] === "number")
            this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    Enum.fromJSON = function fromJSON(name2, json) {
      var enm = new Enum(name2, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "valuesOptions",
        this.valuesOptions,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name2, id, comment, options2) {
      if (!util.isString(name2))
        throw TypeError("name must be a string");
      if (!util.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name2] !== void 0)
        throw Error("duplicate name '" + name2 + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name2))
        throw Error("name '" + name2 + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name2] = id;
      } else
        this.valuesById[this.values[name2] = id] = name2;
      if (options2) {
        if (this.valuesOptions === void 0)
          this.valuesOptions = {};
        this.valuesOptions[name2] = options2 || null;
      }
      this.comments[name2] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name2) {
      if (!util.isString(name2))
        throw TypeError("name must be a string");
      var val = this.values[name2];
      if (val == null)
        throw Error("name '" + name2 + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name2];
      delete this.comments[name2];
      if (this.valuesOptions)
        delete this.valuesOptions[name2];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name2) {
      return Namespace.isReservedName(this.reserved, name2);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref;
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
        ref = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
          if (wireType === void 0)
            gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else
            gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref + "[i]");
            else
              gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional)
            gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref);
          else
            gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types();
    protobuf.util = require_util();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape2(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape2;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length2 = source.length, line = 1, lastCommentLine = 0, comments = {};
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
          throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape2(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start, end, isLeading) {
        var comment = {
          type: source.charAt(start++),
          lineEmpty: false,
          leading: isLeading
        };
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c;
        do {
          if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
            comment.lineEmpty = true;
            break;
          }
        } while (c === " " || c === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
          lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        comment.text = lines.join("\n").trim();
        comments[line] = comment;
        lastCommentLine = line;
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length2 && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString();
        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length2)
            return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length2)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length2) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length2) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                  isLeadingComment = true;
                }
                ++line;
                repeat = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length2) {
                      break;
                    }
                    offset++;
                    if (!isLeadingComment) {
                      break;
                    }
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length2, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                  isLeadingComment = true;
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length2) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
                isLeadingComment = true;
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length2 && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip(expected, optional) {
        var actual = peek(), equals4 = actual === expected;
        if (equals4) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        var comment;
        if (trailingLine === void 0) {
          comment = comments[line - 1];
          delete comments[line - 1];
          if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
            ret = comment.leading ? comment.text : null;
          }
        } else {
          if (lastCommentLine < trailingLine) {
            peek();
          }
          comment = comments[trailingLine];
          delete comments[trailingLine];
          if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
            ret = comment.leading ? null : comment.text;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = parse;
    parse.filename = null;
    parse.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root = require_root();
    var Type = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service2();
    var Method = require_method();
    var types = require_types();
    var util = require_util();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse(source, root, options2) {
      if (!(root instanceof Root)) {
        options2 = root;
        root = new Root();
      }
      if (!options2)
        options2 = parse.defaults;
      var preferTrailingComment = options2.preferTrailingComment || false;
      var tn = tokenize(source, options2.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options2.keepCase ? function(name2) {
        return name2;
      } : util.camelCase;
      function illegal(token2, name2, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
          parse.filename = null;
        return Error("illegal " + (name2 || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(token2, true);
        } catch (e) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
            target.push(readString());
          else
            target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
        } while (skip(",", true));
        skip(";");
      }
      function parseNumber(token2, insideTryCatch) {
        var sign3 = 1;
        if (token2.charAt(0) === "-") {
          sign3 = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign3 * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign3 * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign3 * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign3 * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign3 * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString();
        skip(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2")
          throw illegal(syntax, "syntax");
        skip(";");
      }
      function parseCommon(parent, token2) {
        switch (token2) {
          case "option":
            parseOption(parent, token2);
            skip(";");
            return true;
          case "message":
            parseType(parent, token2);
            return true;
          case "enum":
            parseEnum(parent, token2);
            return true;
          case "service":
            parseService(parent, token2);
            return true;
          case "extend":
            parseExtension(parent, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse.filename;
        }
        if (skip("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent.add(type);
      }
      function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent, rule);
          return;
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name2 = next();
        if (!nameRe.test(name2))
          throw illegal(name2, "name");
        name2 = applyCase(name2);
        skip("=");
        var field = new Field(name2, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name2);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent.add(oneof);
        } else {
          parent.add(field);
        }
        if (!isProto3 && field.repeated && (types.packed[type] !== void 0 || types.basic[type] === void 0))
          field.setOption("packed", false, true);
      }
      function parseGroup(parent, rule) {
        var name2 = next();
        if (!nameRe.test(name2))
          throw illegal(name2, "name");
        var fieldName = util.lcFirst(name2);
        if (name2 === fieldName)
          name2 = util.ucFirst(name2);
        skip("=");
        var id = parseId(next());
        var type = new Type(name2);
        type.group = true;
        var field = new Field(fieldName, id, name2, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "message":
              parseType(type, token2);
              break;
            case "enum":
              parseEnum(type, token2);
              break;
            default:
              throw illegal(token2);
          }
        });
        parent.add(type).add(field);
      }
      function parseMapField(parent) {
        skip("<");
        var keyType = next();
        if (types.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip(">");
        var name2 = next();
        if (!nameRe.test(name2))
          throw illegal(name2, "name");
        skip("=");
        var field = new MapField(applyCase(name2), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent.add(field);
      }
      function parseOneOf(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent.add(oneof);
      }
      function parseEnum(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent.add(enm);
      }
      function parseEnumValue(parent, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip("=");
        var value = parseId(next(), true), dummy = {
          options: void 0
        };
        dummy.setOption = function(name2, value2) {
          if (this.options === void 0)
            this.options = {};
          this.options[name2] = value2;
        };
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent.add(token2, value, dummy.comment, dummy.options);
      }
      function parseOption(parent, token2) {
        var isCustom = skip("(", true);
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name2 = token2;
        var option = name2;
        var propName;
        if (isCustom) {
          skip(")");
          name2 = "(" + name2 + ")";
          option = name2;
          token2 = peek();
          if (fqTypeRefRe.test(token2)) {
            propName = token2.slice(1);
            name2 += token2;
            next();
          }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name2);
        setParsedOption(parent, option, optionValue, propName);
      }
      function parseOptionValue(parent, name2) {
        if (skip("{", true)) {
          var objectResult = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token = next())) {
              throw illegal(token, "name");
            }
            var value;
            var propName = token;
            skip(":", true);
            if (peek() === "{")
              value = parseOptionValue(parent, name2 + "." + token);
            else if (peek() === "[") {
              value = [];
              var lastValue;
              if (skip("[", true)) {
                do {
                  lastValue = readValue(true);
                  value.push(lastValue);
                } while (skip(",", true));
                skip("]");
                if (typeof lastValue !== "undefined") {
                  setOption(parent, name2 + "." + token, lastValue);
                }
              }
            } else {
              value = readValue(true);
              setOption(parent, name2 + "." + token, value);
            }
            var prevValue = objectResult[propName];
            if (prevValue)
              value = [].concat(prevValue).concat(value);
            objectResult[propName] = value;
            skip(",", true);
            skip(";", true);
          }
          return objectResult;
        }
        var simpleValue = readValue(true);
        setOption(parent, name2, simpleValue);
        return simpleValue;
      }
      function setOption(parent, name2, value) {
        if (parent.setOption)
          parent.setOption(name2, value);
      }
      function setParsedOption(parent, name2, value, propName) {
        if (parent.setParsedOption)
          parent.setParsedOption(name2, value, propName);
      }
      function parseInlineOptions(parent) {
        if (skip("[", true)) {
          do {
            parseOption(parent, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent;
      }
      function parseService(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3))
            return;
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent.add(service);
      }
      function parseMethod(parent, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name2 = token2, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip(")");
        var method = new Method(name2, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip(";");
          } else
            throw illegal(token3);
        });
        parent.add(method);
      }
      function parseExtension(parent, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent, token3, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent, "proto3_optional", reference);
              } else {
                parseField(parent, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token);
            skip(";");
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      parse.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
  }
});

// node_modules/protobufjs/src/common.js
var require_common = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name2, json) {
      if (!commonRe.test(name2)) {
        name2 = "google/protobuf/" + name2 + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common[name2] = json;
    }
    common("any", {
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      Timestamp: timeType
    });
    common("empty", {
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = function get(file) {
      return common[file] || null;
    };
  }
});

// node_modules/protobufjs/src/index.js
var require_src = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src();
  }
});

// node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf, codec) {
  const reader2 = Reader.create(buf instanceof Uint8Array ? buf : buf.subarray());
  return codec.decode(reader2);
}
var import_protobufjs, Reader, methods;
var init_decode = __esm({
  "node_modules/protons-runtime/dist/src/decode.js"() {
    import_protobufjs = __toESM(require_protobufjs(), 1);
    Reader = import_protobufjs.default.Reader;
    methods = [
      "uint64",
      "int64",
      "sint64",
      "fixed64",
      "sfixed64"
    ];
    methods.forEach((method) => {
      const original = Reader.prototype[method];
      Reader.prototype[method] = function() {
        return BigInt(original.call(this).toString());
      };
    });
  }
});

// node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message2, codec) {
  const w = Writer.create();
  codec.encode(message2, w, {
    lengthDelimited: false
  });
  return w.finish();
}
var import_protobufjs2, Writer, methods2;
var init_encode = __esm({
  "node_modules/protons-runtime/dist/src/encode.js"() {
    import_protobufjs2 = __toESM(require_protobufjs(), 1);
    Writer = import_protobufjs2.default.Writer;
    methods2 = [
      "uint64",
      "int64",
      "sint64",
      "fixed64",
      "sfixed64"
    ];
    methods2.forEach((method) => {
      const original = Writer.prototype[method];
      Writer.prototype[method] = function(val) {
        return original.call(this, val.toString());
      };
    });
  }
});

// node_modules/protons-runtime/dist/src/codec.js
function createCodec2(name2, type, encode6, decode7) {
  return {
    name: name2,
    type,
    encode: encode6,
    decode: decode7
  };
}
var CODEC_TYPES;
var init_codec = __esm({
  "node_modules/protons-runtime/dist/src/codec.js"() {
    (function(CODEC_TYPES2) {
      CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
      CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
      CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
      CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
      CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
      CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
    })(CODEC_TYPES || (CODEC_TYPES = {}));
  }
});

// node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode6 = function enumEncode(val, writer) {
    const enumValue = findValue(val);
    writer.int32(enumValue);
  };
  const decode7 = function enumDecode(reader2) {
    const val = reader2.uint32();
    return findValue(val);
  };
  return createCodec2("enum", CODEC_TYPES.VARINT, encode6, decode7);
}
var init_enum = __esm({
  "node_modules/protons-runtime/dist/src/codecs/enum.js"() {
    init_codec();
  }
});

// node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode6, decode7) {
  return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode6, decode7);
}
var init_message = __esm({
  "node_modules/protons-runtime/dist/src/codecs/message.js"() {
    init_codec();
  }
});

// node_modules/protons-runtime/dist/src/index.js
var init_src2 = __esm({
  "node_modules/protons-runtime/dist/src/index.js"() {
    init_decode();
    init_encode();
    init_enum();
    init_message();
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/keys.js
var keys_exports = {};
__export(keys_exports, {
  KeyType: () => KeyType,
  PrivateKey: () => PrivateKey,
  PublicKey: () => PublicKey
});
var KeyType, __KeyTypeValues, PublicKey, PrivateKey;
var init_keys = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/keys.js"() {
    init_src2();
    (function(KeyType2) {
      KeyType2["RSA"] = "RSA";
      KeyType2["Ed25519"] = "Ed25519";
      KeyType2["Secp256k1"] = "Secp256k1";
    })(KeyType || (KeyType = {}));
    (function(__KeyTypeValues2) {
      __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
      __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
      __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
    })(__KeyTypeValues || (__KeyTypeValues = {}));
    (function(KeyType2) {
      KeyType2.codec = () => {
        return enumeration(__KeyTypeValues);
      };
    })(KeyType || (KeyType = {}));
    (function(PublicKey2) {
      let _codec;
      PublicKey2.codec = () => {
        if (_codec == null) {
          _codec = message((obj, writer, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              writer.fork();
            }
            if (obj.Type != null) {
              writer.uint32(8);
              KeyType.codec().encode(obj.Type, writer);
            } else {
              throw new Error('Protocol error: required field "Type" was not found in object');
            }
            if (obj.Data != null) {
              writer.uint32(18);
              writer.bytes(obj.Data);
            } else {
              throw new Error('Protocol error: required field "Data" was not found in object');
            }
            if (opts.lengthDelimited !== false) {
              writer.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              Type: KeyType.RSA,
              Data: new Uint8Array(0)
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.Type = KeyType.codec().decode(reader2);
                  break;
                case 2:
                  obj.Data = reader2.bytes();
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            if (obj.Type == null) {
              throw new Error('Protocol error: value for required field "Type" was not found in protobuf');
            }
            if (obj.Data == null) {
              throw new Error('Protocol error: value for required field "Data" was not found in protobuf');
            }
            return obj;
          });
        }
        return _codec;
      };
      PublicKey2.encode = (obj) => {
        return encodeMessage(obj, PublicKey2.codec());
      };
      PublicKey2.decode = (buf) => {
        return decodeMessage(buf, PublicKey2.codec());
      };
    })(PublicKey || (PublicKey = {}));
    (function(PrivateKey2) {
      let _codec;
      PrivateKey2.codec = () => {
        if (_codec == null) {
          _codec = message((obj, writer, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              writer.fork();
            }
            if (obj.Type != null) {
              writer.uint32(8);
              KeyType.codec().encode(obj.Type, writer);
            } else {
              throw new Error('Protocol error: required field "Type" was not found in object');
            }
            if (obj.Data != null) {
              writer.uint32(18);
              writer.bytes(obj.Data);
            } else {
              throw new Error('Protocol error: required field "Data" was not found in object');
            }
            if (opts.lengthDelimited !== false) {
              writer.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              Type: KeyType.RSA,
              Data: new Uint8Array(0)
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.Type = KeyType.codec().decode(reader2);
                  break;
                case 2:
                  obj.Data = reader2.bytes();
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            if (obj.Type == null) {
              throw new Error('Protocol error: value for required field "Type" was not found in protobuf');
            }
            if (obj.Data == null) {
              throw new Error('Protocol error: value for required field "Data" was not found in protobuf');
            }
            return obj;
          });
        }
        return _codec;
      };
      PrivateKey2.encode = (obj) => {
        return encodeMessage(obj, PrivateKey2.codec());
      };
      PrivateKey2.decode = (buf) => {
        return decodeMessage(buf, PrivateKey2.codec());
      };
    })(PrivateKey || (PrivateKey = {}));
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet2, maxline) {
      if (typeof alphabet2 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet2);
      } else {
        var i = 0;
        var base3 = alphabet2.length;
        var first = alphabet2.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length; ++i) {
          for (var j = 0, carry = input[i]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base3;
            carry = carry / base3 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base3);
            carry = carry / base3 | 0;
          }
        }
        for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
          output += first;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output += alphabet2[digits[i]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet2) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet2 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table2 = _reverseAlphabets[alphabet2];
      if (!table2) {
        table2 = _reverseAlphabets[alphabet2] = [];
        for (var i = 0; i < alphabet2.length; ++i) {
          table2[alphabet2.charCodeAt(i)] = i;
        }
      }
      input = input.replace(/\s/g, "");
      var base3 = alphabet2.length;
      var first = alphabet2.charAt(0);
      var bytes = [0];
      for (var i = 0; i < input.length; i++) {
        var value = table2[input.charCodeAt(i)];
        if (value === void 0) {
          return;
        }
        for (var j = 0, carry = value; j < bytes.length; ++j) {
          carry += bytes[j] * base3;
          bytes[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet2) {
      var i = 0;
      var base3 = alphabet2.length;
      var first = alphabet2.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length(); ++i) {
        for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base3;
          carry = carry / base3 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base3);
          carry = carry / base3 | 0;
        }
      }
      var output = "";
      for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
        output += first;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output += alphabet2[digits[i]];
      }
      return output;
    }
  }
});

// node_modules/node-forge/lib/util.js
var require_util2 = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge5 = require_forge();
    var baseN = require_baseN();
    var util = module2.exports = forge5.util = forge5.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = function() {
      if (util.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x) {
      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i = 0; i < arr.length; ++i) {
              this.putByte(arr[i]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      var bytes = "";
      do {
        n -= 8;
        bytes += String.fromCharCode(i >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util.ByteStringBuffer.prototype.setAt = function(i, b) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.length; ++i) {
        var b = this.data.charCodeAt(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options2) {
      options2 = options2 || {};
      this.read = options2.readOffset || 0;
      this.growSize = options2.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b);
      var isArrayBufferView = util.isArrayBufferView(b);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options2 ? options2.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options2) {
        this.write = options2.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src2 = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src2);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util.isArrayBufferView(bytes)) {
        var src2 = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src2.byteLength - src2.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src2);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes)) {
        var src2 = new Uint8Array(bytes);
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src2, this.write);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
        var src2 = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src2);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes instanceof util.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 65535);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.data.setInt16(this.write, i >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i >> n & 255);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util.DataBuffer.prototype.setAt = function(i, b) {
      this.data.setUint8(i, b);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src2 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src2.byteLength);
        dst.set(src2);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b = this.data.getUint8(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = "";
      var i = 0;
      if (hex.length & true) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes) {
      return util.createBuffer(bytes).toHex();
    };
    util.int32ToBytes = function(i) {
      return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0, j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output ? j - offset : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i = 0, j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j - offset : out.subarray(0, j);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.text.utf8.decode = function(bytes) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output ? j - offset : out;
    };
    util.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util.deflate = function(api, bytes, raw) {
      bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util.encode64(bytes)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty2 = true;
        for (var prop in obj) {
          empty2 = false;
          break;
        }
        if (empty2) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util.getItem = function(api, id, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util.removeItem = function(api, id, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util.clearItems = function(api, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match = re.exec(format)) {
        part = format.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code2 = match[0][1];
        switch (code2) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code2 + "?>");
        }
      }
      parts.push(format.substring(last));
      return parts.join("");
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i.length > 3 ? i.length % 3 : 0;
      return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util.hexToBytes(ip[i]);
        if (bytes.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes);
      }
      return b.getBytes();
    };
    util.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util.bytesToIPv6(bytes);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes.length; ++i) {
        ip.push(bytes.charCodeAt(i));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes.length; i += 2) {
        var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      if ("cores" in util && !options2.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et)
              ;
            self.postMessage({ st, et });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map2(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map2(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge5 = require_forge();
    forge5.pki = forge5.pki || {};
    var oids = module2.exports = forge5.pki.oids = forge5.oids = forge5.oids || {};
    function _IN(id, name2) {
      oids[id] = name2;
      oids[name2] = id;
    }
    function _I_(id, name2) {
      oids[id] = name2;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge5 = require_forge();
    require_util2();
    require_oids();
    var asn1 = module2.exports = forge5.asn1 = forge5.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options2) {
      if (forge5.util.isArray(value)) {
        var tmp = [];
        for (var i = 0; i < value.length; ++i) {
          if (value[i] !== void 0) {
            tmp.push(value[i]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge5.util.isArray(value),
        value
      };
      if (options2 && "bitStringContents" in options2) {
        obj.bitStringContents = options2.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options2) {
      var copy;
      if (forge5.util.isArray(obj)) {
        copy = [];
        for (var i = 0; i < obj.length; ++i) {
          copy.push(asn1.copy(obj[i], options2));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options2)
      };
      if (options2 && !options2.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options2) {
      if (forge5.util.isArray(obj1)) {
        if (!forge5.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i = 0; i < obj1.length; ++i) {
          if (!asn1.equals(obj1[i], obj2[i])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options2 && options2.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b2 & 128;
      if (!longForm) {
        length2 = b2;
      } else {
        length2 = b.getInt((b2 & 127) << 3);
      }
      return length2;
    };
    function _checkBufferLength(bytes, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b2 & 128;
      if (!longForm) {
        length2 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length2 = bytes.getInt(longFormBytes << 3);
      }
      if (length2 < 0) {
        throw new Error("Negative length: " + length2);
      }
      return length2;
    };
    asn1.fromDer = function(bytes, options2) {
      if (options2 === void 0) {
        options2 = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options2 === "boolean") {
        options2 = {
          strict: options2,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options2)) {
        options2.strict = true;
      }
      if (!("parseAllBytes" in options2)) {
        options2.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options2)) {
        options2.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge5.util.createBuffer(bytes);
      }
      var byteCount = bytes.length();
      var value = _fromDer(bytes, bytes.length(), 0, options2);
      if (options2.parseAllBytes && bytes.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes.length();
        throw error;
      }
      return value;
    };
    function _fromDer(bytes, remaining, depth, options2) {
      var start;
      _checkBufferLength(bytes, remaining, 2);
      var b1 = bytes.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes.length();
      var length2 = _getValueLength(bytes, remaining);
      remaining -= start - bytes.length();
      if (length2 !== void 0 && length2 > remaining) {
        if (options2.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = length2;
          throw error;
        }
        length2 = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length2 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes.length();
            value.push(_fromDer(bytes, remaining, depth + 1, options2));
            remaining -= start - bytes.length();
          }
        } else {
          while (length2 > 0) {
            start = bytes.length();
            value.push(_fromDer(bytes, length2, depth + 1, options2));
            remaining -= start - bytes.length();
            length2 -= start - bytes.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length2);
      }
      if (value === void 0 && options2.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length2 > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes.length();
            var subOptions = {
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
            var used = start - bytes.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length2 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length2 === void 0) {
          if (options2.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length2 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length2 > 0; length2 -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes.getBytes(length2);
          remaining -= length2;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes = forge5.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge5.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b1);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes = forge5.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b;
      for (var i = 2; i < values.length; ++i) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i], 10);
        do {
          b = value & 127;
          value = value >>> 7;
          if (!last) {
            b |= 128;
          }
          valueBytes.push(b);
          last = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes.putByte(valueBytes[n]);
        }
      }
      return bytes;
    };
    asn1.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge5.util.createBuffer(bytes);
      }
      var b = bytes.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value = 0;
      while (bytes.length() > 0) {
        b = bytes.getByte();
        value = value << 7;
        if (b & 128) {
          value += b & 127;
        } else {
          oid += "." + (value + b);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge5.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge5.util.createBuffer(bytes);
      }
      var n = bytes.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge5.util.isArray(v.value)) {
            var j = 0;
            for (var i = 0; rval && i < v.value.length; ++i) {
              rval = v.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                if (rval) {
                  ++j;
                } else if (v.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v.tagClass) {
          errors.push(
            "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v.type) {
          errors.push(
            "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i = 0; i < level * indentation; ++i) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if (i + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge5.pki && forge5.pki.oids) {
            if (oid in forge5.pki.oids) {
              rval += " (" + forge5.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge5.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge5.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge5.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge5.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge5.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge5.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge5 = require_forge();
    require_util2();
    module2.exports = forge5.cipher = forge5.cipher || {};
    forge5.cipher.algorithms = forge5.cipher.algorithms || {};
    forge5.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge5.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge5.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge5.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge5.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge5.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge5.cipher.registerAlgorithm = function(name2, algorithm) {
      name2 = name2.toUpperCase();
      forge5.cipher.algorithms[name2] = algorithm;
    };
    forge5.cipher.getAlgorithm = function(name2) {
      name2 = name2.toUpperCase();
      if (name2 in forge5.cipher.algorithms) {
        return forge5.cipher.algorithms[name2];
      }
      return null;
    };
    var BlockCipher = forge5.cipher.BlockCipher = function(options2) {
      this.algorithm = options2.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options2.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options2.decrypt;
      this.algorithm.initialize(options2);
    };
    BlockCipher.prototype.start = function(options2) {
      options2 = options2 || {};
      var opts = {};
      for (var key in options2) {
        opts[key] = options2[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge5.util.createBuffer();
      this.output = options2.output || forge5.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options2 = {};
      options2.decrypt = this._decrypt;
      options2.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options2)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options2)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options2)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge5 = require_forge();
    require_util2();
    forge5.cipher = forge5.cipher || {};
    var modes = module2.exports = forge5.cipher.modes = forge5.cipher.modes || {};
    modes.ecb = function(options2) {
      options2 = options2 || {};
      this.name = "ECB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options2) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options2) {
      var padding2 = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding2, padding2);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options2) {
      if (options2.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options2) {
      options2 = options2 || {};
      this.name = "CBC";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options2) {
      if (options2.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options2.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options2) {
      var padding2 = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding2, padding2);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options2) {
      if (options2.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options2) {
      options2 = options2 || {};
      this.name = "CFB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge5.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options2) {
      options2 = options2 || {};
      this.name = "OFB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge5.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options2) {
      options2 = options2 || {};
      this.name = "CTR";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge5.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options2) {
      options2 = options2 || {};
      this.name = "GCM";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge5.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge5.util.createBuffer(options2.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options2) {
        additionalData = forge5.util.createBuffer(options2.additionalData);
      } else {
        additionalData = forge5.util.createBuffer();
      }
      if ("tagLength" in options2) {
        this._tagLength = options2.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options2.decrypt) {
        this._tag = forge5.util.createBuffer(options2.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge5.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options2) {
      var rval = true;
      if (options2.decrypt && options2.overflow) {
        output.truncate(this.blockSize - options2.overflow);
      }
      this.tag = forge5.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options2.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = i / 8 | 0;
        var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
        var ah = this._m[i][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = i / perInt | 0;
        var shft = (perInt - 1 - i % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m[2 * i], m[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m[i];
          var m_j = m[j];
          m[i + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m[i ^ half];
        m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge5.util.createBuffer(iv);
      }
      if (forge5.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge5.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge5.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i = 0; i < blocks; ++i) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge5 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util2();
    module2.exports = forge5.aes = forge5.aes || {};
    forge5.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge5.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge5.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge5.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge5.aes.Algorithm = function(name2, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name2;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge5.aes.Algorithm.prototype.initialize = function(options2) {
      if (this._init) {
        return;
      }
      var key = options2.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge5.util.createBuffer(key);
      } else if (forge5.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge5.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      if (!forge5.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge5.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options2.decrypt && !encryptOp);
      this._init = true;
    };
    forge5.aes._expandKey = function(key, decrypt2) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt2);
    };
    forge5.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge5.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge5.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge5.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge5.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge5.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge5.cipher.modes.gcm);
    function registerAlgorithm(name2, mode) {
      var factory = function() {
        return new forge5.aes.Algorithm(name2, mode);
      };
      forge5.cipher.registerAlgorithm(name2, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = i + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt2) {
      var w = key.slice(0);
      var temp, iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i] = w[i - Nk] ^ temp;
      }
      if (decrypt2) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
          if (i === 0 || i === end - Nb) {
            wnew[i] = w[wi];
            wnew[i + 1] = w[wi + 3];
            wnew[i + 2] = w[wi + 2];
            wnew[i + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt2) {
      var Nr = w.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt2) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a, b, c, d, a2, b2, c2;
      a = input[0] ^ w[0];
      b = input[decrypt2 ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt2 ? 1 : 3] ^ w[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
      output[decrypt2 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
      output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
      output[decrypt2 ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
    }
    function _createCipher(options2) {
      options2 = options2 || {};
      var mode = (options2.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options2.decrypt) {
        cipher = forge5.cipher.createDecipher(algorithm, options2.key);
      } else {
        cipher = forge5.cipher.createCipher(algorithm, options2.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options3) {
        var output = null;
        if (options3 instanceof forge5.util.ByteBuffer) {
          output = options3;
          options3 = {};
        }
        options3 = options3 || {};
        options3.output = output;
        options3.iv = iv;
        start.call(cipher, options3);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge5 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util2();
    module2.exports = forge5.des = forge5.des || {};
    forge5.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge5.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge5.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge5.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge5.des.Algorithm = function(name2, mode) {
      var self2 = this;
      self2.name = name2;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge5.des.Algorithm.prototype.initialize = function(options2) {
      if (this._init) {
        return;
      }
      var key = forge5.util.createBuffer(options2.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge5.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge5.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge5.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge5.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge5.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge5.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge5.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge5.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge5.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge5.cipher.modes.ctr);
    function registerAlgorithm(name2, mode) {
      var factory = function() {
        return new forge5.des.Algorithm(name2, mode);
      };
      forge5.cipher.registerAlgorithm(name2, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt2) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right ^ keys[i];
          var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options2) {
      options2 = options2 || {};
      var mode = (options2.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options2.decrypt) {
        cipher = forge5.cipher.createDecipher(algorithm, options2.key);
      } else {
        cipher = forge5.cipher.createCipher(algorithm, options2.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options3) {
        var output = null;
        if (options3 instanceof forge5.util.ByteBuffer) {
          output = options3;
          options3 = {};
        }
        options3 = options3 || {};
        options3.output = output;
        options3.iv = iv;
        start.call(cipher, options3);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge5 = require_forge();
    module2.exports = forge5.md = forge5.md || {};
    forge5.md.algorithms = forge5.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge5 = require_forge();
    require_md();
    require_util2();
    var hmac = module2.exports = forge5.hmac = forge5.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge5.md.algorithms) {
              _md = forge5.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge5.util.createBuffer(key);
          } else if (forge5.util.isArray(key)) {
            var tmp = key;
            key = forge5.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge5.util.createBuffer();
          _opadding = forge5.util.createBuffer();
          keylen = key.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key.at(i);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge5 = require_forge();
    require_hmac();
    require_md();
    require_util2();
    var pkcs5 = forge5.pkcs5 = forge5.pkcs5 || {};
    var crypto9;
    if (forge5.util.isNodejs && !forge5.options.usePureJavaScript) {
      crypto9 = require("crypto");
    }
    module2.exports = forge5.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge5.util.isNodejs && !forge5.options.usePureJavaScript && crypto9.pbkdf2 && (md === null || typeof md !== "object") && (crypto9.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p = Buffer.from(p, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto9.pbkdf2Sync.length === 4) {
            return crypto9.pbkdf2Sync(p, s, c, dkLen).toString("binary");
          }
          return crypto9.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
        }
        if (crypto9.pbkdf2Sync.length === 4) {
          return crypto9.pbkdf2(p, s, c, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto9.pbkdf2(p, s, c, dkLen, md, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge5.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge5.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge5.hmac.create();
      prf.start(md, p);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge5.util.int32ToBytes(i));
          xor = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge5.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i < len ? xor : xor.substr(0, r);
        }
        return dk;
      }
      var i = 1, j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge5.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge5.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge5.util.setImmediate(inner);
        }
        dk += i < len ? xor : xor.substr(0, r);
        ++i;
        outer();
      }
      outer();
    };
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge5 = require_forge();
    require_util2();
    var pem = module2.exports = forge5.pem = forge5.pem || {};
    pem.encode = function(msg, options2) {
      options2 = options2 || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge5.util.encode64(msg.body, options2.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge5.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i = 0; i < header.values.length; ++i) {
        values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length2 = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length2) {
        if (length2 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length2 = i - candidate - 1;
          candidate = -1;
          ++i;
        } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
          candidate = i;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge5 = require_forge();
    require_md();
    require_util2();
    var sha2562 = module2.exports = forge5.sha256 = forge5.sha256 || {};
    forge5.md.sha256 = forge5.md.algorithms.sha256 = sha2562;
    sha2562.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge5.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge5.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge5.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge5.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge5.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge5.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
      var len = bytes.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w[i] = bytes.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w[i - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w[i - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i = 0; i < 64; ++i) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h + s1 + ch + _k[i] + w[i];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge5 = require_forge();
    require_util2();
    var _crypto = null;
    if (forge5.util.isNodejs && !forge5.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require("crypto");
    }
    var prng = module2.exports = forge5.prng = forge5.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0,
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge5.util.createBuffer();
        ctx.key = null;
        generate2();
        function generate2(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge5.util.nextTick(function() {
              _reseed(generate2);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge5.util.setImmediate(generate2);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge5.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge5.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b = forge5.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i2 = 0; i2 < entropy.length; ++i2) {
                b.putInt32(entropy[i2]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i2 = 0; i2 < 3; ++i2) {
              next = seed >>> (i2 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(next & 255);
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i2 = 0; i2 < count; ++i2) {
          ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i2, n) {
        var bytes = "";
        for (var x = 0; x < n; x += 8) {
          bytes += String.fromCharCode(i2 >> x & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge5 = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util2();
    (function() {
      if (forge5.random && forge5.random.getBytes) {
        module2.exports = forge5.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge5.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge5.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge5.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge5.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge5.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge5.md.sha256;
        function spawnPrng() {
          var ctx = forge5.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge5.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge5.options.usePureJavaScript || !forge5.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge5.random) {
          forge5.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge5.random[key] = _ctx[key];
          }
        }
        forge5.random.createInstance = spawnPrng;
        module2.exports = forge5.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge5 = require_forge();
    require_util2();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word2, bits) {
      return word2 << bits & 65535 | (word2 & 65535) >> 16 - bits;
    };
    var ror = function(word2, bits) {
      return (word2 & 65535) >> bits | word2 << 16 - bits & 65535;
    };
    module2.exports = forge5.rc2 = forge5.rc2 || {};
    forge5.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge5.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher = function(key, bits, encrypt2) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i, j, K = [];
      key = forge5.rc2.expandKey(key, bits);
      for (i = 0; i < 64; i++) {
        K.push(key.getInt16Le());
      }
      if (encrypt2) {
        mixRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            R[i] = rol(R[i], s[i]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[R[(i + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s[i]);
            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K[R[(i + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt2) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt2 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt2) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      };
      var cipher = null;
      cipher = {
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge5.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge5.util.createBuffer();
          _output = output || new forge5.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        finish: function(pad) {
          var rval = true;
          if (encrypt2) {
            if (pad) {
              rval = pad(8, _input, !encrypt2);
            } else {
              var padding2 = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding2, padding2);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt2) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt2);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge5.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge5.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge5.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge5.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge5.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge5.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge5 = require_forge();
    module2.exports = forge5.jsbn = forge5.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a)
          this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a)
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    forge5.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i++] + w.data[j] + c;
        c = Math.floor(v / 67108864);
        w.data[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 32767;
        var h = this.data[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 16383;
        var h = this.data[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r.data[i] = this.data[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this.data[i] & (1 << p) - 1) << k - p;
            d |= this.data[--i] >> (p += this.DB - k);
          } else {
            d = this.data[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this.data[i] - a.data[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i)
        r.data[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r.data[i - n] = this.data[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r.data[i + ds + 1] = this.data[i] >> cbs | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r.data[i] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
        r.data[i - ds] = this.data[i] >> bs;
      }
      if (bs > 0)
        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] - a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r.data[i++] = this.DV + c;
      else if (c > 0)
        r.data[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < y.t; ++i)
        r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r.data[i + x.t] -= x.DV;
          r.data[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this.data[i] & (1 << p) - 1) << 8 - p;
            d |= this.data[--i] >> (p += this.DB - 8);
          } else {
            d = this.data[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f, m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r.data[i] = op(this.data[i], a.data[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r.data[i] = op(this.data[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r.data[i] = op(f, a.data[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r.data[i] = this.DM & ~this.data[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0)
          return i * this.DB + lbit(this.data[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this.data[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] + a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r.data[i++] = c;
      else if (c < -1)
        r.data[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r.data[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a.data[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e.data[j] >> i - k1 & km;
        else {
          w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e.data[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this.data[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this.data[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i = 0; i < t; ++i) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        nextBytes: function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge5 = require_forge();
    require_md();
    require_util2();
    var sha1 = module2.exports = forge5.sha1 = forge5.sha1 || {};
    forge5.md.sha1 = forge5.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge5.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge5.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge5.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge5.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge5.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge5.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t, a, b, c, d, e, f, i;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes.getInt32();
          w[i] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 20; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 32; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 40; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 60; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b & c | d & (b ^ c);
          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 80; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge5 = require_forge();
    require_util2();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge5.pkcs1 = forge5.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message2, options2) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options2 === "string") {
        label = options2;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options2) {
        label = options2.label || void 0;
        seed = options2.seed || void 0;
        md = options2.md || void 0;
        if (options2.mgf1 && options2.mgf1.md) {
          mgf1Md = options2.mgf1.md;
        }
      }
      if (!md) {
        md = forge5.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message2.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message2.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message2.length;
      for (var i = 0; i < PS_length; i++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message2;
      if (!seed) {
        seed = forge5.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge5.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge5.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options2) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options2 === "string") {
        label = options2;
        md = arguments[3] || void 0;
      } else if (options2) {
        label = options2.label || void 0;
        md = options2.md || void 0;
        if (options2.mgf1 && options2.mgf1.md) {
          mgf1Md = options2.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge5.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge5.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge5.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y !== "\0";
      for (var i = 0; i < md.digestLength; ++i) {
        error |= lHash.charAt(i) !== lHashPrime.charAt(i);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code2 = db.charCodeAt(j);
        var is_0 = code2 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code2 & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash) {
      if (!hash) {
        hash = forge5.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash.digestLength);
      for (var i = 0; i < count; ++i) {
        var c = String.fromCharCode(
          i >> 24 & 255,
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
        );
        hash.start();
        hash.update(seed + c);
        t += hash.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge5 = require_forge();
    require_util2();
    require_jsbn();
    require_random();
    (function() {
      if (forge5.prime) {
        module2.exports = forge5.prime;
        return;
      }
      var prime = module2.exports = forge5.prime = forge5.prime || {};
      var BigInteger = forge5.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x, y) {
        return x | y;
      };
      prime.generateProbablePrime = function(bits, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = options2 || {};
        var algorithm = options2.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options2.prng || forge5.random;
        var rng = {
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b.charCodeAt(i);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options2, callback) {
        if ("workers" in options2) {
          return primeincFindPrimeWithWorkers(bits, rng, options2, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options2, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options2, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options2) {
          mrTests = options2.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options2) {
          maxBlockTime = options2.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
        forge5.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options2, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options2, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options2.workers;
        var workLoad = options2.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options2.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge5.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate2();
          });
        }
        generate2();
        function generate2() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i = 0; i < numWorkers; ++i) {
            workers[i] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i2 = 0; i2 < workers.length; ++i2) {
                workers[i2].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge5 = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util2();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge5.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge5.util.isNodejs ? require("crypto") : null;
    var asn1 = forge5.asn1;
    var util = forge5.util;
    forge5.pki = forge5.pki || {};
    module2.exports = forge5.pki.rsa = forge5.rsa = forge5.rsa || {};
    var pki = forge5.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge5.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest2 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest2);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(
          forge5.util.bytesToHex(forge5.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge5.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge5.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge5.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge5.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge5.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge5.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options2) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options2 = options2 || {};
      var prng = options2.prng || forge5.random;
      var rng = {
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      var algorithm = options2.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d,
              state.p,
              state.q,
              d.mod(state.p1),
              d.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options2, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options2 = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options2 = e;
            e = void 0;
          }
        } else {
          options2 = bits;
          callback = e;
          bits = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options2 === "function") {
            callback = options2;
            options2 = void 0;
          }
        } else {
          callback = options2;
          options2 = e;
          e = void 0;
        }
      }
      options2 = options2 || {};
      if (bits === void 0) {
        bits = options2.bits || 2048;
      }
      if (e === void 0) {
        e = options2.e || 65537;
      }
      if (!forge5.options.usePureJavaScript && !options2.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair2) {
              return util.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair2.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge5.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair2 = e2.target.result;
              var exportOp = util.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair2.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge5.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair2 = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair2.privateKey),
              publicKey: pki.publicKeyFromPem(keypair2.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options2);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options2, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key2, pub) {
              return _encodePkcs1_v1_5(m, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key2) {
              return forge5.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest2, signature, scheme, options2) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options2 === void 0) {
          options2 = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options2)) {
          options2._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest3, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options2._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge5.oids.md2 || oid === forge5.oids.md5 || oid === forge5.oids.sha1 || oid === forge5.oids.sha224 || oid === forge5.oids.sha256 || oid === forge5.oids.sha384 || oid === forge5.oids.sha512 || oid === forge5.oids["sha512-224"] || oid === forge5.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge5.oids.md2 || oid === forge5.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest3 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest3, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest3 === d2;
            }
          };
        }
        var d = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest2, d, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key2) {
              return forge5.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d2, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge5.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n, e, d, p, q, dP, dQ, qInv;
      n = forge5.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge5.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge5.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge5.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge5.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge5.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge5.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge5.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16),
        new BigInteger(d, 16),
        new BigInteger(p, 16),
        new BigInteger(q, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n = forge5.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge5.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge5.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge5.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge5.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      var opts = {
        algorithm: {
          name: options2.algorithm || "PRIMEINC",
          options: {
            workers: options2.workers || 2,
            workLoad: options2.workLoad || 100,
            workerScript: options2.workerScript
          }
        }
      };
      if ("prng" in options2) {
        opts.prng = options2.prng;
      }
      generate2();
      function generate2() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge5.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate2();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate2();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d,
            state.p,
            state.q,
            d.mod(state.p1),
            d.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes = forge5.util.hexToBytes(hex);
      if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge5.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x) {
      var bytes = forge5.util.hexToBytes(x.toString(16));
      var buffer = new Uint8Array(bytes.length);
      for (var i = 0; i < bytes.length; ++i) {
        buffer[i] = bytes.charCodeAt(i);
      }
      return buffer;
    }
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    var forge5 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util2();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge5.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge5.asn1;
    var pki = forge5.pki = forge5.pki || {};
    module2.exports = pki.pbe = forge5.pbe = forge5.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options2) {
      options2 = options2 || {};
      options2.saltSize = options2.saltSize || 8;
      options2.count = options2.count || 2048;
      options2.algorithm = options2.algorithm || "aes128";
      options2.prfAlgorithm = options2.prfAlgorithm || "sha1";
      var salt = forge5.random.getBytesSync(options2.saltSize);
      var count = options2.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options2.algorithm.indexOf("aes") === 0 || options2.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options2.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge5.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge5.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge5.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge5.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options2.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options2.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge5.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge5.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                params
              ]),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options2.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge5.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge5.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options2.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        encryptionAlgorithm,
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge5.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge5.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge5.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options2) {
      options2 = options2 || {};
      if (!options2.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options2);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options2.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge5.random.getBytesSync(16);
          cipherFn = forge5.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge5.random.getBytesSync(16);
          cipherFn = forge5.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge5.random.getBytesSync(16);
          cipherFn = forge5.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge5.random.getBytesSync(8);
          cipherFn = forge5.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge5.random.getBytesSync(8);
          cipherFn = forge5.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options2.algorithm + '".');
          error.algorithm = options2.algorithm;
          throw error;
      }
      var dk = forge5.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge5.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge5.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge5.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge5.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge5.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge5.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge5.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge5.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge5.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge5.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge5.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge5.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge5.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge5.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge5.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge5.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge5.util.ByteBuffer();
      var passBuf = new forge5.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge5.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge5.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge5.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf = new forge5.util.ByteBuffer();
        buf.putBytes(D.bytes());
        buf.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B = new forge5.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge5.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge5.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge5.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge5.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge5.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge5.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge5.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge5.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge5.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge5.util.createBuffer(capture.salt);
      var count = forge5.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge5.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge5.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge5.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge5.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash(md, password + salt)];
      for (var length2 = 16, i = 1; length2 < dkLen; ++i, length2 += 16) {
        digests.push(hash(md, digests[i - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash(md, bytes) {
      return md.start().update(bytes).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge5.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge5.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge5.util.hexToBytes(dkLen.toString(16))
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code2, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code2 === "object") {
        props = code2;
        code2 = "";
      }
      if (code2) {
        props.code = code2;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(string2, "utf8");
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
var init_from_string = __esm({
  "node_modules/uint8arrays/esm/src/from-string.js"() {
    init_bases();
  }
});

// node_modules/@libp2p/crypto/dist/src/hmac/lengths.js
var lengths_default;
var init_lengths = __esm({
  "node_modules/@libp2p/crypto/dist/src/hmac/lengths.js"() {
    lengths_default = {
      SHA1: 20,
      SHA256: 32,
      SHA512: 64
    };
  }
});

// node_modules/@libp2p/crypto/dist/src/hmac/index.js
async function create2(hash, secret) {
  const res = {
    async digest(data) {
      const hmac = import_crypto2.default.createHmac(hash.toLowerCase(), secret);
      hmac.update(data);
      return hmac.digest();
    },
    length: lengths_default[hash]
  };
  return res;
}
var import_crypto2;
var init_hmac = __esm({
  "node_modules/@libp2p/crypto/dist/src/hmac/index.js"() {
    import_crypto2 = __toESM(require("crypto"), 1);
    init_lengths();
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js
async function keyStretcher(cipherType, hash, secret) {
  const cipher = cipherMap[cipherType];
  if (cipher == null) {
    const allowed = Object.keys(cipherMap).join(" / ");
    throw (0, import_err_code.default)(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), "ERR_INVALID_CIPHER_TYPE");
  }
  if (hash == null) {
    throw (0, import_err_code.default)(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
  }
  const cipherKeySize = cipher.keySize;
  const ivSize = cipher.ivSize;
  const hmacKeySize = 20;
  const seed = fromString2("key expansion");
  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
  const m = await create2(hash, secret);
  let a = await m.digest(seed);
  const result = [];
  let j = 0;
  while (j < resultLength) {
    const b = await m.digest(concat([a, seed]));
    let todo = b.length;
    if (j + todo > resultLength) {
      todo = resultLength - j;
    }
    result.push(b);
    j += todo;
    a = await m.digest(a);
  }
  const half = resultLength / 2;
  const resultBuffer = concat(result);
  const r1 = resultBuffer.slice(0, half);
  const r2 = resultBuffer.slice(half, resultLength);
  const createKey = (res) => ({
    iv: res.slice(0, ivSize),
    cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
    macKey: res.slice(ivSize + cipherKeySize)
  });
  return {
    k1: createKey(r1),
    k2: createKey(r2)
  };
}
var import_err_code, cipherMap;
var init_key_stretcher = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js"() {
    import_err_code = __toESM(require_err_code(), 1);
    init_concat();
    init_from_string();
    init_hmac();
    cipherMap = {
      "AES-128": {
        ivSize: 16,
        keySize: 16
      },
      "AES-256": {
        ivSize: 16,
        keySize: 32
      },
      Blowfish: {
        ivSize: 8,
        keySize: 32
      }
    };
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/ecdh.js
async function generateEphmeralKeyPair(curve) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw (0, import_err_code2.default)(new Error(`Unknown curve: ${curve}. Must be ${names}`), "ERR_INVALID_CURVE");
  }
  const ecdh = import_crypto3.default.createECDH(curves[curve]);
  ecdh.generateKeys();
  return {
    key: ecdh.getPublicKey(),
    async genSharedKey(theirPub, forcePrivate) {
      if (forcePrivate != null) {
        ecdh.setPrivateKey(forcePrivate.private);
      }
      return ecdh.computeSecret(theirPub);
    }
  };
}
var import_crypto3, import_err_code2, curves, curveTypes, names;
var init_ecdh = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/ecdh.js"() {
    import_crypto3 = __toESM(require("crypto"), 1);
    import_err_code2 = __toESM(require_err_code(), 1);
    curves = {
      "P-256": "prime256v1",
      "P-384": "secp384r1",
      "P-521": "secp521r1"
    };
    curveTypes = Object.keys(curves);
    names = curveTypes.join(" / ");
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js
var ephemeral_keys_default;
var init_ephemeral_keys = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js"() {
    init_ecdh();
    ephemeral_keys_default = generateEphmeralKeyPair;
  }
});

// node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.js
function create3(opts) {
  const algorithm = (opts == null ? void 0 : opts.algorithm) ?? "aes-128-gcm";
  const keyLength = (opts == null ? void 0 : opts.keyLength) ?? 16;
  const nonceLength = (opts == null ? void 0 : opts.nonceLength) ?? 12;
  const digest2 = (opts == null ? void 0 : opts.digest) ?? "sha256";
  const saltLength = (opts == null ? void 0 : opts.saltLength) ?? 16;
  const iterations = (opts == null ? void 0 : opts.iterations) ?? 32767;
  const algorithmTagLength = (opts == null ? void 0 : opts.algorithmTagLength) ?? 16;
  async function encryptWithKey(data, key) {
    const nonce = import_crypto4.default.randomBytes(nonceLength);
    const cipher2 = import_crypto4.default.createCipheriv(algorithm, key, nonce);
    const ciphertext = concat([cipher2.update(data), cipher2.final()]);
    return concat([nonce, ciphertext, cipher2.getAuthTag()]);
  }
  async function encrypt2(data, password) {
    const salt = import_crypto4.default.randomBytes(saltLength);
    if (typeof password === "string") {
      password = fromString2(password);
    }
    const key = import_crypto4.default.pbkdf2Sync(password, salt, iterations, keyLength, digest2);
    return concat([salt, await encryptWithKey(Uint8Array.from(data), key)]);
  }
  async function decryptWithKey(ciphertextAndNonce, key) {
    const nonce = ciphertextAndNonce.slice(0, nonceLength);
    const ciphertext = ciphertextAndNonce.slice(nonceLength, ciphertextAndNonce.length - algorithmTagLength);
    const tag = ciphertextAndNonce.slice(ciphertext.length + nonceLength);
    const cipher2 = import_crypto4.default.createDecipheriv(algorithm, key, nonce);
    cipher2.setAuthTag(tag);
    return concat([cipher2.update(ciphertext), cipher2.final()]);
  }
  async function decrypt2(data, password) {
    const salt = data.slice(0, saltLength);
    const ciphertextAndNonce = data.slice(saltLength);
    if (typeof password === "string") {
      password = fromString2(password);
    }
    const key = import_crypto4.default.pbkdf2Sync(password, salt, iterations, keyLength, digest2);
    return await decryptWithKey(ciphertextAndNonce, key);
  }
  const cipher = {
    encrypt: encrypt2,
    decrypt: decrypt2
  };
  return cipher;
}
var import_crypto4;
var init_aes_gcm = __esm({
  "node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.js"() {
    import_crypto4 = __toESM(require("crypto"), 1);
    init_concat();
    init_from_string();
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/importer.js
async function importer(privateKey, password) {
  const encryptedKey = base64.decode(privateKey);
  const cipher = create3();
  return await cipher.decrypt(encryptedKey, password);
}
var init_importer = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/importer.js"() {
    init_base64();
    init_aes_gcm();
  }
});

// node_modules/uint8arrays/esm/src/equals.js
function equals3(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
var init_equals = __esm({
  "node_modules/uint8arrays/esm/src/equals.js"() {
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge5 = require_forge();
    require_md();
    require_util2();
    var sha5122 = module2.exports = forge5.sha512 = forge5.sha512 || {};
    forge5.md.sha512 = forge5.md.algorithms.sha512 = sha5122;
    var sha384 = forge5.sha384 = forge5.sha512.sha384 = forge5.sha512.sha384 || {};
    sha384.create = function() {
      return sha5122.create("SHA-384");
    };
    forge5.md.sha384 = forge5.md.algorithms.sha384 = sha384;
    forge5.sha512.sha256 = forge5.sha512.sha256 || {
      create: function() {
        return sha5122.create("SHA-512/256");
      }
    };
    forge5.md["sha512/256"] = forge5.md.algorithms["sha512/256"] = forge5.sha512.sha256;
    forge5.sha512.sha224 = forge5.sha512.sha224 || {
      create: function() {
        return sha5122.create("SHA-512/224");
      }
    };
    forge5.md["sha512/224"] = forge5.md.algorithms["sha512/224"] = forge5.sha512.sha224;
    sha5122.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge5.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge5.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge5.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge5.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h[i] = _h[i].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge5.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h[i][0]);
          if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge5.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i, hi, lo, w2, w7, w15, w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w[i][0] = bytes.getInt32() >>> 0;
          w[i][1] = bytes.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w2 = w[i - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w[i - 7];
          w16 = w[i - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w[i][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/@noble/secp256k1/lib/esm/index.js
function weistrass(x) {
  const { a, b } = CURVE;
  const x2 = mod2(x * x);
  const x3 = mod2(x2 * x);
  return mod2(x3 + a * x + b);
}
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
  }
  return { r, s };
}
function concatBytes(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length2);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n <= num && num < POW_2_256))
    throw new Error("Expected number < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
  const b = hexToBytes(numTo32bStr(num));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumber(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod2(a, b = CURVE.P) {
  const result = a % b;
  return result >= _0n ? result : b + result;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  const { P } = CURVE;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow2(b3, _3n) * b3 % P;
  const b9 = pow2(b6, _3n) * b3 % P;
  const b11 = pow2(b9, _2n) * b2 % P;
  const b22 = pow2(b11, _11n) * b11 % P;
  const b44 = pow2(b22, _22n) * b22 % P;
  const b88 = pow2(b44, _44n) * b44 % P;
  const b176 = pow2(b88, _88n) * b88 % P;
  const b220 = pow2(b176, _44n) * b44 % P;
  const b223 = pow2(b220, _3n) * b3 % P;
  const t1 = pow2(b223, _23n) * b22 % P;
  const t2 = pow2(t1, _6n) * b2 % P;
  return pow2(t2, _2n);
}
function invert(number, modulo = CURVE.P) {
  if (number === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod2(number, modulo);
  let b = modulo;
  let x = _0n, y = _1n, u = _1n, v = _0n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    scratch[i] = acc;
    return mod2(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    scratch[i] = mod2(acc * scratch[i], p);
    return mod2(acc * num, p);
  }, inverted);
  return scratch;
}
function splitScalarEndo(k) {
  const { n } = CURVE;
  const { a1, b1, a2, b2, POW_2_128 } = ENDO;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = mod2(k - c1 * a1 - c2 * a2, n);
  let k2 = mod2(-c1 * b1 - c2 * b2, n);
  const k1neg = k1 > POW_2_128;
  const k2neg = k2 > POW_2_128;
  if (k1neg)
    k1 = n - k1;
  if (k2neg)
    k2 = n - k2;
  if (k1 > POW_2_128 || k2 > POW_2_128) {
    throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function truncateHash(hash) {
  const { n } = CURVE;
  const byteLength = hash.length;
  const delta = byteLength * 8 - 256;
  let h = bytesToNumber(hash);
  if (delta > 0)
    h = h >> BigInt(delta);
  if (h >= n)
    h -= n;
  return h;
}
function isWithinCurveOrder(num) {
  return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
  return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d) {
  const k = bytesToNumber(kBytes);
  if (!isWithinCurveOrder(k))
    return;
  const { n } = CURVE;
  const q = Point.BASE.multiply(k);
  const r = mod2(q.x, n);
  if (r === _0n)
    return;
  const s = mod2(invert(k, n) * mod2(m + d * r, n), n);
  if (s === _0n)
    return;
  const sig = new Signature(r, s);
  const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 64)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== 32)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point.fromHex(publicKey);
  }
}
function normalizeSignature(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error) {
    return Signature.fromCompact(signature);
  }
}
function getPublicKey(privateKey, isCompressed = false) {
  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function bits2int(bytes) {
  const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;
  return bytesToNumber(slice);
}
function bits2octets(bytes) {
  const z1 = bits2int(bytes);
  const z2 = mod2(z1, CURVE.n);
  return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes(msgHash);
  const d = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils.randomBytes(32);
    const e = ensureBytes(extraEntropy);
    if (e.length !== 32)
      throw new Error("sign: Expected 32 bytes of extra data");
    seedArgs.push(e);
  }
  const seed = concatBytes(...seedArgs);
  const m = bits2int(h1);
  return { seed, m, d };
}
function finalizeSig(recSig, opts) {
  let { sig, recovery } = recSig;
  const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  if (canonical && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
async function sign(msgHash, privKey, opts = {}) {
  const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  let sig;
  const drbg = new HmacDrbg();
  await drbg.reseed(seed);
  while (!(sig = kmdToSig(await drbg.generate(), m, d)))
    await drbg.reseed();
  return finalizeSig(sig, opts);
}
function verify(signature, msgHash, publicKey, opts = vopts) {
  let sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes(msgHash);
  } catch (error) {
    return false;
  }
  const { r, s } = sig;
  if (opts.strict && sig.hasHighS())
    return false;
  const h = truncateHash(msgHash);
  let P;
  try {
    P = normalizePublicKey(publicKey);
  } catch (error) {
    return false;
  }
  const { n } = CURVE;
  const sinv = invert(s, n);
  const u1 = mod2(h * sinv, n);
  const u2 = mod2(r * sinv, n);
  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
  if (!R)
    return false;
  const v = mod2(R.x, n);
  return v === r;
}
var nodeCrypto, _0n, _1n, _2n, _3n, _8n, CURVE, USE_ENDOMORPHISM, ShaError, JacobianPoint, pointPrecomputes, Point, Signature, hexes, POW_2_256, divNearest, ENDO, _sha256Sync, _hmacSha256Sync, HmacDrbg, vopts, crypto5, TAGGED_HASH_PREFIXES, utils;
var init_esm = __esm({
  "node_modules/@noble/secp256k1/lib/esm/index.js"() {
    nodeCrypto = __toESM(require("crypto"), 1);
    _0n = BigInt(0);
    _1n = BigInt(1);
    _2n = BigInt(2);
    _3n = BigInt(3);
    _8n = BigInt(8);
    CURVE = Object.freeze({
      a: _0n,
      b: BigInt(7),
      P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: _1n,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    });
    USE_ENDOMORPHISM = CURVE.a === _0n;
    ShaError = class extends Error {
      constructor(message2) {
        super(message2);
      }
    };
    JacobianPoint = class {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      static fromAffine(p) {
        if (!(p instanceof Point)) {
          throw new TypeError("JacobianPoint#fromAffine: expected Point");
        }
        return new JacobianPoint(p.x, p.y, _1n);
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
      }
      equals(other) {
        if (!(other instanceof JacobianPoint))
          throw new TypeError("JacobianPoint expected");
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod2(Z1 * Z1);
        const Z2Z2 = mod2(Z2 * Z2);
        const U1 = mod2(X1 * Z2Z2);
        const U2 = mod2(X2 * Z1Z1);
        const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
        const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
      }
      negate() {
        return new JacobianPoint(this.x, mod2(-this.y), this.z);
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod2(X1 * X1);
        const B = mod2(Y1 * Y1);
        const C = mod2(B * B);
        const x1b = X1 + B;
        const D = mod2(_2n * (mod2(x1b * x1b) - A - C));
        const E = mod2(_3n * A);
        const F = mod2(E * E);
        const X3 = mod2(F - _2n * D);
        const Y3 = mod2(E * (D - X3) - _8n * C);
        const Z3 = mod2(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
      }
      add(other) {
        if (!(other instanceof JacobianPoint))
          throw new TypeError("JacobianPoint expected");
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
          return this;
        if (X1 === _0n || Y1 === _0n)
          return other;
        const Z1Z1 = mod2(Z1 * Z1);
        const Z2Z2 = mod2(Z2 * Z2);
        const U1 = mod2(X1 * Z2Z2);
        const U2 = mod2(X2 * Z1Z1);
        const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
        const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
        const H = mod2(U2 - U1);
        const r = mod2(S2 - S1);
        if (H === _0n) {
          if (r === _0n) {
            return this.double();
          } else {
            return JacobianPoint.ZERO;
          }
        }
        const HH = mod2(H * H);
        const HHH = mod2(H * HH);
        const V2 = mod2(U1 * HH);
        const X3 = mod2(r * r - HHH - _2n * V2);
        const Y3 = mod2(r * (V2 - X3) - S1 * HHH);
        const Z3 = mod2(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === "bigint" && scalar === _0n)
          return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n)
          return this;
        if (!USE_ENDOMORPHISM) {
          let p = P0;
          let d2 = this;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d2);
            d2 = d2.double();
            n >>= _1n;
          }
          return p;
        }
        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n)
            k1p = k1p.add(d);
          if (k2 & _1n)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new JacobianPoint(mod2(k2p.x * CURVE.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
      }
      precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base3 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base3 = p;
          points.push(base3);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base3 = base3.add(p);
            points.push(base3);
          }
          p = base3.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
          affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = JacobianPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.ZERO;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          if (wbits === 0) {
            let pr = precomputes[offset];
            if (window2 % 2)
              pr = pr.negate();
            f = f.add(pr);
          } else {
            let cached = precomputes[offset + Math.abs(wbits) - 1];
            if (wbits < 0)
              cached = cached.negate();
            p = p.add(cached);
          }
        }
        return { p, f };
      }
      multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
          const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
          let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
          let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new JacobianPoint(mod2(k2p.x * CURVE.beta), k2p.y, k2p.z);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(n, affinePoint);
          point = p;
          fake = f;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
      }
      toAffine(invZ = invert(this.z)) {
        const { x, y, z } = this;
        const iz1 = invZ;
        const iz2 = mod2(iz1 * iz1);
        const iz3 = mod2(iz2 * iz1);
        const ax = mod2(x * iz2);
        const ay = mod2(y * iz3);
        const zz = mod2(z * iz1);
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point(ax, ay);
      }
    };
    JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
    JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
    pointPrecomputes = /* @__PURE__ */ new WeakMap();
    Point = class {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      hasEvenY() {
        return this.y % _2n === _0n;
      }
      static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weistrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
          if (isYOdd)
            y = mod2(-y);
        } else {
          const isFirstByteOdd = (bytes[0] & 1) === 1;
          if (isFirstByteOdd !== isYOdd)
            y = mod2(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
      }
      static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, 33));
        const y = bytesToNumber(bytes.subarray(33, 65));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
      }
      static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === 32 || len === 33 && (header === 2 || header === 3)) {
          return this.fromCompressedHex(bytes);
        }
        if (len === 65 && header === 4)
          return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
      }
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
      }
      static fromSignature(msgHash, signature, recovery) {
        msgHash = ensureBytes(msgHash);
        const h = truncateHash(msgHash);
        const { r, s } = normalizeSignature(signature);
        if (recovery !== 0 && recovery !== 1) {
          throw new Error("Cannot recover signature: invalid recovery bit");
        }
        const prefix = recovery & 1 ? "03" : "02";
        const R = Point.fromHex(prefix + numTo32bStr(r));
        const { n } = CURVE;
        const rinv = invert(r, n);
        const u1 = mod2(-h * rinv, n);
        const u2 = mod2(s * rinv, n);
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("Cannot recover signature: point at infinify");
        Q.assertValidity();
        return Q;
      }
      toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
      }
      toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
          const prefix = this.hasEvenY() ? "02" : "03";
          return `${prefix}${x}`;
        } else {
          return `04${x}${numTo32bStr(this.y)}`;
        }
      }
      toHexX() {
        return this.toHex(true).slice(2);
      }
      toRawX() {
        return this.toRawBytes(true).slice(1);
      }
      assertValidity() {
        const msg = "Point is not on elliptic curve";
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
          throw new Error(msg);
        const left = mod2(y * y);
        const right = weistrass(x);
        if (mod2(left - right) !== _0n)
          throw new Error(msg);
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new Point(this.x, mod2(-this.y));
      }
      double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
      }
      add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
      }
    };
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _0n);
    Signature = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const arr = hex instanceof Uint8Array;
        const name2 = "Signature.fromCompact";
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`${name2}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
          throw new Error(`${name2}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
      }
      static fromDER(hex) {
        const arr = hex instanceof Uint8Array;
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
      }
      static fromHex(hex) {
        return this.fromDER(hex);
      }
      assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
          throw new Error("Invalid Signature: r must be 0 < r < n");
        if (!isWithinCurveOrder(s))
          throw new Error("Invalid Signature: s must be 0 < s < n");
      }
      hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
      }
      toDERRawBytes(isCompressed = false) {
        return hexToBytes(this.toDERHex(isCompressed));
      }
      toDERHex(isCompressed = false) {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        if (isCompressed)
          return sHex;
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const rLen = numberToHexUnpadded(rHex.length / 2);
        const sLen = numberToHexUnpadded(sHex.length / 2);
        const length2 = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
        return `30${length2}02${rLen}${rHex}02${sLen}${sHex}`;
      }
      toRawBytes() {
        return this.toDERRawBytes();
      }
      toHex() {
        return this.toDERHex();
      }
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
    };
    hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    divNearest = (a, b) => (a + b / _2n) / b;
    ENDO = {
      a1: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
      b1: -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
      a2: BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
      b2: BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
      POW_2_128: BigInt("0x100000000000000000000000000000000")
    };
    HmacDrbg = class {
      constructor() {
        this.v = new Uint8Array(32).fill(1);
        this.k = new Uint8Array(32).fill(0);
        this.counter = 0;
      }
      hmac(...values) {
        return utils.hmacSha256(this.k, ...values);
      }
      hmacSync(...values) {
        return _hmacSha256Sync(this.k, ...values);
      }
      checkSync() {
        if (typeof _hmacSha256Sync !== "function")
          throw new ShaError("hmacSha256Sync needs to be set");
      }
      incr() {
        if (this.counter >= 1e3)
          throw new Error("Tried 1,000 k values for sign(), all were invalid");
        this.counter += 1;
      }
      async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0)
          return;
        this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
        this.v = await this.hmac(this.v);
      }
      reseedSync(seed = new Uint8Array()) {
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0)
          return;
        this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
        this.v = this.hmacSync(this.v);
      }
      async generate() {
        this.incr();
        this.v = await this.hmac(this.v);
        return this.v;
      }
      generateSync() {
        this.checkSync();
        this.incr();
        this.v = this.hmacSync(this.v);
        return this.v;
      }
    };
    vopts = { strict: true };
    Point.BASE._setWindowSize(8);
    crypto5 = {
      node: nodeCrypto,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    TAGGED_HASH_PREFIXES = {};
    utils = {
      bytesToHex,
      hexToBytes,
      concatBytes,
      mod: mod2,
      invert,
      isValidPrivateKey(privateKey) {
        try {
          normalizePrivateKey(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      _bigintTo32Bytes: numTo32b,
      _normalizePrivateKey: normalizePrivateKey,
      hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024)
          throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
        const num = mod2(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto5.web) {
          return crypto5.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto5.node) {
          const { randomBytes: randomBytes2 } = crypto5.node;
          return Uint8Array.from(randomBytes2(bytesLength));
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => {
        return utils.hashToPrivateKey(utils.randomBytes(40));
      },
      sha256: async (...messages2) => {
        if (crypto5.web) {
          const buffer = await crypto5.web.subtle.digest("SHA-256", concatBytes(...messages2));
          return new Uint8Array(buffer);
        } else if (crypto5.node) {
          const { createHash } = crypto5.node;
          const hash = createHash("sha256");
          messages2.forEach((m) => hash.update(m));
          return Uint8Array.from(hash.digest());
        } else {
          throw new Error("The environment doesn't have sha256 function");
        }
      },
      hmacSha256: async (key, ...messages2) => {
        if (crypto5.web) {
          const ckey = await crypto5.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
          const message2 = concatBytes(...messages2);
          const buffer = await crypto5.web.subtle.sign("HMAC", ckey, message2);
          return new Uint8Array(buffer);
        } else if (crypto5.node) {
          const { createHmac } = crypto5.node;
          const hash = createHmac("sha256", key);
          messages2.forEach((m) => hash.update(m));
          return Uint8Array.from(hash.digest());
        } else {
          throw new Error("The environment doesn't have hmac-sha256 function");
        }
      },
      sha256Sync: void 0,
      hmacSha256Sync: void 0,
      taggedHash: async (tag, ...messages2) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
          tagP = concatBytes(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return utils.sha256(tagP, ...messages2);
      },
      taggedHashSync: (tag, ...messages2) => {
        if (typeof _sha256Sync !== "function")
          throw new ShaError("sha256Sync is undefined, you need to set it");
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
          tagP = concatBytes(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages2);
      },
      precompute(windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
      }
    };
    Object.defineProperties(utils, {
      sha256Sync: {
        configurable: false,
        get() {
          return _sha256Sync;
        },
        set(val) {
          if (!_sha256Sync)
            _sha256Sync = val;
        }
      },
      hmacSha256Sync: {
        configurable: false,
        get() {
          return _hmacSha256Sync;
        },
        set(val) {
          if (!_hmacSha256Sync)
            _hmacSha256Sync = val;
        }
      }
    });
  }
});

// node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes(length2) {
  if (isNaN(length2) || length2 <= 0) {
    throw (0, import_err_code3.default)(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
  }
  return utils.randomBytes(length2);
}
var import_err_code3;
var init_random_bytes = __esm({
  "node_modules/@libp2p/crypto/dist/src/random-bytes.js"() {
    init_esm();
    import_err_code3 = __toESM(require_err_code(), 1);
  }
});

// node_modules/@libp2p/crypto/dist/src/util.js
function bigIntegerToUintBase64url(num, len) {
  let buf = Uint8Array.from(num.abs().toByteArray());
  buf = buf[0] === 0 ? buf.slice(1) : buf;
  if (len != null) {
    if (buf.length > len)
      throw new Error("byte array longer than desired length");
    buf = concat([new Uint8Array(len - buf.length), buf]);
  }
  return toString2(buf, "base64url");
}
function base64urlToBigInteger(str) {
  const buf = base64urlToBuffer(str);
  return new import_forge.default.jsbn.BigInteger(toString2(buf, "base16"), 16);
}
function base64urlToBuffer(str, len) {
  let buf = fromString2(str, "base64urlpad");
  if (len != null) {
    if (buf.length > len)
      throw new Error("byte array longer than desired length");
    buf = concat([new Uint8Array(len - buf.length), buf]);
  }
  return buf;
}
var import_util, import_jsbn, import_forge;
var init_util = __esm({
  "node_modules/@libp2p/crypto/dist/src/util.js"() {
    import_util = __toESM(require_util2(), 1);
    import_jsbn = __toESM(require_jsbn(), 1);
    import_forge = __toESM(require_forge(), 1);
    init_from_string();
    init_to_string();
    init_concat();
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js
var rsa_utils_exports = {};
__export(rsa_utils_exports, {
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkixToJwk: () => pkixToJwk
});
function pkcs1ToJwk(bytes) {
  const asn1 = import_forge2.default.asn1.fromDer(toString2(bytes, "ascii"));
  const privateKey = import_forge2.default.pki.privateKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(privateKey.n),
    e: bigIntegerToUintBase64url(privateKey.e),
    d: bigIntegerToUintBase64url(privateKey.d),
    p: bigIntegerToUintBase64url(privateKey.p),
    q: bigIntegerToUintBase64url(privateKey.q),
    dp: bigIntegerToUintBase64url(privateKey.dP),
    dq: bigIntegerToUintBase64url(privateKey.dQ),
    qi: bigIntegerToUintBase64url(privateKey.qInv),
    alg: "RS256"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw (0, import_err_code4.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge2.default.pki.privateKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e),
    d: base64urlToBigInteger(jwk.d),
    p: base64urlToBigInteger(jwk.p),
    q: base64urlToBigInteger(jwk.q),
    dP: base64urlToBigInteger(jwk.dp),
    dQ: base64urlToBigInteger(jwk.dq),
    qInv: base64urlToBigInteger(jwk.qi)
  });
  return fromString2(import_forge2.default.asn1.toDer(asn1).getBytes(), "ascii");
}
function pkixToJwk(bytes) {
  const asn1 = import_forge2.default.asn1.fromDer(toString2(bytes, "ascii"));
  const publicKey = import_forge2.default.pki.publicKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(publicKey.n),
    e: bigIntegerToUintBase64url(publicKey.e)
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw (0, import_err_code4.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge2.default.pki.publicKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e)
  });
  return fromString2(import_forge2.default.asn1.toDer(asn1).getBytes(), "ascii");
}
var import_asn1, import_rsa, import_forge2, import_err_code4;
var init_rsa_utils = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js"() {
    import_asn1 = __toESM(require_asn1(), 1);
    import_rsa = __toESM(require_rsa(), 1);
    import_forge2 = __toESM(require_forge(), 1);
    init_util();
    init_from_string();
    init_to_string();
    import_err_code4 = __toESM(require_err_code(), 1);
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/rsa.js
async function generateKey(bits) {
  const key = await keypair("rsa", {
    modulusLength: bits,
    publicKeyEncoding: { type: "pkcs1", format: "jwk" },
    privateKeyEncoding: { type: "pkcs1", format: "jwk" }
  });
  return {
    privateKey: key.privateKey,
    publicKey: key.publicKey
  };
}
async function unmarshalPrivateKey(key) {
  if (key == null) {
    throw (0, import_err_code5.default)(new Error("Missing key parameter"), "ERR_MISSING_KEY");
  }
  return {
    privateKey: key,
    publicKey: {
      kty: key.kty,
      n: key.n,
      e: key.e
    }
  };
}
async function hashAndSign(key, msg) {
  return import_crypto5.default.createSign("RSA-SHA256").update(msg).sign({ format: "jwk", key });
}
async function hashAndVerify(key, sig, msg) {
  return import_crypto5.default.createVerify("RSA-SHA256").update(msg).verify({ format: "jwk", key }, sig);
}
function encrypt(key, bytes) {
  return import_crypto5.default.publicEncrypt({ format: "jwk", key, padding }, bytes);
}
function decrypt(key, bytes) {
  return import_crypto5.default.privateDecrypt({ format: "jwk", key, padding }, bytes);
}
var import_crypto5, import_util3, import_err_code5, keypair, padding;
var init_rsa = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/rsa.js"() {
    import_crypto5 = __toESM(require("crypto"), 1);
    import_util3 = require("util");
    import_err_code5 = __toESM(require_err_code(), 1);
    init_random_bytes();
    init_rsa_utils();
    keypair = (0, import_util3.promisify)(import_crypto5.default.generateKeyPair);
    padding = import_crypto5.default.constants.RSA_PKCS1_PADDING;
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/exporter.js
async function exporter(privateKey, password) {
  const cipher = create3();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base64.encode(encryptedKey);
}
var init_exporter = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/exporter.js"() {
    init_base64();
    init_aes_gcm();
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var rsa_class_exports = {};
__export(rsa_class_exports, {
  RsaPrivateKey: () => RsaPrivateKey,
  RsaPublicKey: () => RsaPublicKey,
  fromJwk: () => fromJwk,
  generateKeyPair: () => generateKeyPair,
  unmarshalRsaPrivateKey: () => unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey: () => unmarshalRsaPublicKey
});
async function unmarshalRsaPrivateKey(bytes) {
  const jwk = rsa_utils_exports.pkcs1ToJwk(bytes);
  const keys = await unmarshalPrivateKey(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
function unmarshalRsaPublicKey(bytes) {
  const jwk = rsa_utils_exports.pkixToJwk(bytes);
  return new RsaPublicKey(jwk);
}
async function fromJwk(jwk) {
  const keys = await unmarshalPrivateKey(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
async function generateKeyPair(bits) {
  const keys = await generateKey(bits);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
var import_err_code6, import_sha512, import_forge3, RsaPublicKey, RsaPrivateKey;
var init_rsa_class = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js"() {
    init_sha2();
    import_err_code6 = __toESM(require_err_code(), 1);
    init_equals();
    init_to_string();
    import_sha512 = __toESM(require_sha512(), 1);
    import_forge3 = __toESM(require_forge(), 1);
    init_rsa();
    init_keys();
    init_exporter();
    RsaPublicKey = class {
      constructor(key) {
        this._key = key;
      }
      async verify(data, sig) {
        return await hashAndVerify(this._key, sig, data);
      }
      marshal() {
        return rsa_utils_exports.jwkToPkix(this._key);
      }
      get bytes() {
        return PublicKey.encode({
          Type: KeyType.RSA,
          Data: this.marshal()
        }).subarray();
      }
      encrypt(bytes) {
        return encrypt(this._key, bytes);
      }
      equals(key) {
        return equals3(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha256.digest(this.bytes);
        return bytes;
      }
    };
    RsaPrivateKey = class {
      constructor(key, publicKey) {
        this._key = key;
        this._publicKey = publicKey;
      }
      genSecret() {
        return randomBytes(16);
      }
      async sign(message2) {
        return await hashAndSign(this._key, message2);
      }
      get public() {
        if (this._publicKey == null) {
          throw (0, import_err_code6.default)(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
        }
        return new RsaPublicKey(this._publicKey);
      }
      decrypt(bytes) {
        return decrypt(this._key, bytes);
      }
      marshal() {
        return rsa_utils_exports.jwkToPkcs1(this._key);
      }
      get bytes() {
        return PrivateKey.encode({
          Type: KeyType.RSA,
          Data: this.marshal()
        }).subarray();
      }
      equals(key) {
        return equals3(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha256.digest(this.bytes);
        return bytes;
      }
      async id() {
        const hash = await this.public.hash();
        return toString2(hash, "base58btc");
      }
      async export(password, format = "pkcs-8") {
        if (format === "pkcs-8") {
          const buffer = new import_forge3.default.util.ByteBuffer(this.marshal());
          const asn1 = import_forge3.default.asn1.fromDer(buffer);
          const privateKey = import_forge3.default.pki.privateKeyFromAsn1(asn1);
          const options2 = {
            algorithm: "aes256",
            count: 1e4,
            saltSize: 128 / 8,
            prfAlgorithm: "sha512"
          };
          return import_forge3.default.pki.encryptRsaPrivateKey(privateKey, password, options2);
        } else if (format === "libp2p-key") {
          return await exporter(this.bytes, password);
        } else {
          throw (0, import_err_code6.default)(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
  }
});

// node_modules/@noble/ed25519/lib/esm/index.js
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
function concatBytes2(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length2);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes2[uint8a[i]];
  }
  return hex;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function numberTo32BytesBE(num) {
  const length2 = 32;
  const hex = num.toString(16).padStart(length2 * 2, "0");
  return hexToBytes2(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod3(num) & _1n2) === _1n2;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex2(Uint8Array.from(uint8a).reverse()));
}
function bytes255ToNumberLE(bytes) {
  return mod3(bytesToNumberLE(bytes) & MAX_255B);
}
function mod3(a, b = CURVE2.P) {
  const res = a % b;
  return res >= _0n2 ? res : b + res;
}
function invert2(number, modulo = CURVE2.P) {
  if (number === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod3(number, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod3(x, modulo);
}
function invertBatch2(nums, p = CURVE2.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n2)
      return acc;
    tmp[i] = acc;
    return mod3(acc * num, p);
  }, _1n2);
  const inverted = invert2(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n2)
      return acc;
    tmp[i] = mod3(acc * tmp[i], p);
    return mod3(acc * num, p);
  }, inverted);
  return tmp;
}
function pow22(x, power) {
  const { P } = CURVE2;
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE2;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow22(b2, _2n2) * b2 % P;
  const b5 = pow22(b4, _1n2) * x % P;
  const b10 = pow22(b5, _5n) * b5 % P;
  const b20 = pow22(b10, _10n) * b10 % P;
  const b40 = pow22(b20, _20n) * b20 % P;
  const b80 = pow22(b40, _40n) * b40 % P;
  const b160 = pow22(b80, _80n) * b80 % P;
  const b240 = pow22(b160, _80n) * b80 % P;
  const b250 = pow22(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow22(b250, _2n2) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v3 = mod3(v * v * v);
  const v7 = mod3(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod3(u * v3 * pow);
  const vx2 = mod3(v * x * x);
  const root1 = x;
  const root2 = mod3(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod3(-u);
  const noRoot = vx2 === mod3(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod3(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number) {
  return uvRatio(_1n2, number);
}
function modlLE(hash) {
  return mod3(bytesToNumberLE(hash), CURVE2.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}
function ensureBytes2(hex, expectedLength) {
  const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes2(hex);
  if (typeof expectedLength === "number" && bytes.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes;
}
function normalizeScalar2(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n2 < num)
        return num;
    } else {
      if (_0n2 <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar2(key, POW_2_2562)) : ensureBytes2(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point2.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix, scalar, point, pointBytes };
}
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils2.sha512(checkPrivateKey(key)));
}
async function getPublicKey2(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign2(message2, privateKey) {
  message2 = ensureBytes2(message2);
  const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils2.sha512(prefix, message2));
  const R = Point2.BASE.multiply(r);
  const k = modlLE(await utils2.sha512(R.toRawBytes(), pointBytes, message2));
  const s = mod3(r + k * scalar, CURVE2.l);
  return new Signature2(R, s).toRawBytes();
}
function prepareVerification(sig, message2, publicKey) {
  message2 = ensureBytes2(message2);
  if (!(publicKey instanceof Point2))
    publicKey = Point2.fromHex(publicKey, false);
  const { r, s } = sig instanceof Signature2 ? sig.assertValidity() : Signature2.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
  return { r, s, SB, pub: publicKey, msg: message2 };
}
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE2.h).equals(ExtendedPoint.ZERO);
}
async function verify2(sig, message2, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message2, publicKey);
  const hashed = await utils2.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
var nodeCrypto2, _0n2, _1n2, _2n2, CU_O, CURVE2, POW_2_2562, SQRT_M1, SQRT_D, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, ExtendedPoint, RistrettoPoint, pointPrecomputes2, Point2, Signature2, hexes2, MAX_255B, _sha512Sync, crypto7, utils2;
var init_esm2 = __esm({
  "node_modules/@noble/ed25519/lib/esm/index.js"() {
    nodeCrypto2 = __toESM(require("crypto"), 1);
    _0n2 = BigInt(0);
    _1n2 = BigInt(1);
    _2n2 = BigInt(2);
    CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
    CURVE2 = Object.freeze({
      a: BigInt(-1),
      d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
      P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
      l: CU_O,
      n: CU_O,
      h: BigInt(8),
      Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
      Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
    });
    POW_2_2562 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
    SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    ExtendedPoint = class {
      constructor(x, y, z, t) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.t = t;
      }
      static fromAffine(p) {
        if (!(p instanceof Point2)) {
          throw new TypeError("ExtendedPoint#fromAffine: expected Point");
        }
        if (p.equals(Point2.ZERO))
          return ExtendedPoint.ZERO;
        return new ExtendedPoint(p.x, p.y, _1n2, mod3(p.x * p.y));
      }
      static toAffineBatch(points) {
        const toInv = invertBatch2(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
      }
      equals(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const X1Z2 = mod3(X1 * Z2);
        const X2Z1 = mod3(X2 * Z1);
        const Y1Z2 = mod3(Y1 * Z2);
        const Y2Z1 = mod3(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      negate() {
        return new ExtendedPoint(mod3(-this.x), this.y, this.z, mod3(-this.t));
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const { a } = CURVE2;
        const A = mod3(X1 * X1);
        const B = mod3(Y1 * Y1);
        const C = mod3(_2n2 * mod3(Z1 * Z1));
        const D = mod3(a * A);
        const x1y1 = X1 + Y1;
        const E = mod3(mod3(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = mod3(E * F);
        const Y3 = mod3(G * H);
        const T3 = mod3(E * H);
        const Z3 = mod3(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
      }
      add(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1, t: T1 } = this;
        const { x: X2, y: Y2, z: Z2, t: T2 } = other;
        const A = mod3((Y1 - X1) * (Y2 + X2));
        const B = mod3((Y1 + X1) * (Y2 - X2));
        const F = mod3(B - A);
        if (F === _0n2)
          return this.double();
        const C = mod3(Z1 * _2n2 * T2);
        const D = mod3(T1 * _2n2 * Z2);
        const E = D + C;
        const G = B + A;
        const H = D - C;
        const X3 = mod3(E * F);
        const Y3 = mod3(G * H);
        const T3 = mod3(E * H);
        const Z3 = mod3(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      precomputeWindow(W) {
        const windows = 1 + 256 / W;
        const points = [];
        let p = this;
        let base3 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base3 = p;
          points.push(base3);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base3 = base3.add(p);
            points.push(base3);
          }
          p = base3.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(ExtendedPoint.BASE))
          affinePoint = Point2.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = ExtendedPoint.normalizeZ(precomputes);
            pointPrecomputes2.set(affinePoint, precomputes);
          }
        }
        let p = ExtendedPoint.ZERO;
        let f = ExtendedPoint.ZERO;
        const windows = 1 + 256 / W;
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n2;
          }
          if (wbits === 0) {
            let pr = precomputes[offset];
            if (window2 % 2)
              pr = pr.negate();
            f = f.add(pr);
          } else {
            let cached = precomputes[offset + Math.abs(wbits) - 1];
            if (wbits < 0)
              cached = cached.negate();
            p = p.add(cached);
          }
        }
        return ExtendedPoint.normalizeZ([p, f])[0];
      }
      multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar2(scalar, CURVE2.l), affinePoint);
      }
      multiplyUnsafe(scalar) {
        let n = normalizeScalar2(scalar, CURVE2.l, false);
        const G = ExtendedPoint.BASE;
        const P0 = ExtendedPoint.ZERO;
        if (n === _0n2)
          return P0;
        if (this.equals(P0) || n === _1n2)
          return this;
        if (this.equals(G))
          return this.wNAF(n);
        let p = P0;
        let d = this;
        while (n > _0n2) {
          if (n & _1n2)
            p = p.add(d);
          d = d.double();
          n >>= _1n2;
        }
        return p;
      }
      isSmallOrder() {
        return this.multiplyUnsafe(CURVE2.h).equals(ExtendedPoint.ZERO);
      }
      isTorsionFree() {
        return this.multiplyUnsafe(CURVE2.l).equals(ExtendedPoint.ZERO);
      }
      toAffine(invZ = invert2(this.z)) {
        const { x, y, z } = this;
        const ax = mod3(x * invZ);
        const ay = mod3(y * invZ);
        const zz = mod3(z * invZ);
        if (zz !== _1n2)
          throw new Error("invZ was invalid");
        return new Point2(ax, ay);
      }
      fromRistrettoBytes() {
        legacyRist();
      }
      toRistrettoBytes() {
        legacyRist();
      }
      fromRistrettoHash() {
        legacyRist();
      }
    };
    ExtendedPoint.BASE = new ExtendedPoint(CURVE2.Gx, CURVE2.Gy, _1n2, mod3(CURVE2.Gx * CURVE2.Gy));
    ExtendedPoint.ZERO = new ExtendedPoint(_0n2, _1n2, _1n2, _0n2);
    RistrettoPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      static calcElligatorRistrettoMap(r0) {
        const { d } = CURVE2;
        const r = mod3(SQRT_M1 * r0 * r0);
        const Ns = mod3((r + _1n2) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod3((c - d * r) * mod3(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod3(s * r0);
        if (!edIsNegative(s_))
          s_ = mod3(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod3(c * (r - _1n2) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod3((s + s) * D);
        const W1 = mod3(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod3(_1n2 - s2);
        const W3 = mod3(_1n2 + s2);
        return new ExtendedPoint(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
      }
      static hashToCurve(hex) {
        hex = ensureBytes2(hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = this.calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = this.calcElligatorRistrettoMap(r2);
        return new RistrettoPoint(R1.add(R2));
      }
      static fromHex(hex) {
        hex = ensureBytes2(hex, 32);
        const { a, d } = CURVE2;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s = bytes255ToNumberLE(hex);
        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
          throw new Error(emsg);
        const s2 = mod3(s * s);
        const u1 = mod3(_1n2 + a * s2);
        const u2 = mod3(_1n2 - a * s2);
        const u1_2 = mod3(u1 * u1);
        const u2_2 = mod3(u2 * u2);
        const v = mod3(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod3(v * u2_2));
        const Dx = mod3(I * u2);
        const Dy = mod3(I * Dx * v);
        let x = mod3((s + s) * Dx);
        if (edIsNegative(x))
          x = mod3(-x);
        const y = mod3(u1 * Dy);
        const t = mod3(x * y);
        if (!isValid || edIsNegative(t) || y === _0n2)
          throw new Error(emsg);
        return new RistrettoPoint(new ExtendedPoint(x, y, _1n2, t));
      }
      toRawBytes() {
        let { x, y, z, t } = this.ep;
        const u1 = mod3(mod3(z + y) * mod3(z - y));
        const u2 = mod3(x * y);
        const u2sq = mod3(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
        const D1 = mod3(invsqrt * u1);
        const D2 = mod3(invsqrt * u2);
        const zInv = mod3(D1 * D2 * t);
        let D;
        if (edIsNegative(t * zInv)) {
          let _x = mod3(y * SQRT_M1);
          let _y = mod3(x * SQRT_M1);
          x = _x;
          y = _y;
          D = mod3(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if (edIsNegative(x * zInv))
          y = mod3(-y);
        let s = mod3((z - y) * D);
        if (edIsNegative(s))
          s = mod3(-s);
        return numberTo32BytesLE(s);
      }
      toHex() {
        return bytesToHex2(this.toRawBytes());
      }
      toString() {
        return this.toHex();
      }
      equals(other) {
        assertRstPoint(other);
        const a = this.ep;
        const b = other.ep;
        const one = mod3(a.x * b.y) === mod3(a.y * b.x);
        const two = mod3(a.y * b.y) === mod3(a.x * b.x);
        return one || two;
      }
      add(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.add(other.ep));
      }
      subtract(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return new RistrettoPoint(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
      }
    };
    RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
    RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
    pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
    Point2 = class {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes2.delete(this);
      }
      static fromHex(hex, strict = true) {
        const { d, P } = CURVE2;
        hex = ensureBytes2(hex, 32);
        const normed = hex.slice();
        normed[31] = hex[31] & ~128;
        const y = bytesToNumberLE(normed);
        if (strict && y >= P)
          throw new Error("Expected 0 < hex < P");
        if (!strict && y >= POW_2_2562)
          throw new Error("Expected 0 < hex < 2**256");
        const y2 = mod3(y * y);
        const u = mod3(y2 - _1n2);
        const v = mod3(d * y2 + _1n2);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n2) === _1n2;
        const isLastByteOdd = (hex[31] & 128) !== 0;
        if (isLastByteOdd !== isXOdd) {
          x = mod3(-x);
        }
        return new Point2(x, y);
      }
      static async fromPrivateKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).point;
      }
      toRawBytes() {
        const bytes = numberTo32BytesLE(this.y);
        bytes[31] |= this.x & _1n2 ? 128 : 0;
        return bytes;
      }
      toHex() {
        return bytesToHex2(this.toRawBytes());
      }
      toX25519() {
        const { y } = this;
        const u = mod3((_1n2 + y) * invert2(_1n2 - y));
        return numberTo32BytesLE(u);
      }
      isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new Point2(mod3(-this.x), this.y);
      }
      add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
    };
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy);
    Point2.ZERO = new Point2(_0n2, _1n2);
    Signature2 = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromHex(hex) {
        const bytes = ensureBytes2(hex, 64);
        const r = Point2.fromHex(bytes.slice(0, 32), false);
        const s = bytesToNumberLE(bytes.slice(32, 64));
        return new Signature2(r, s);
      }
      assertValidity() {
        const { r, s } = this;
        if (!(r instanceof Point2))
          throw new Error("Expected Point instance");
        normalizeScalar2(s, CURVE2.l, false);
        return this;
      }
      toRawBytes() {
        const u8 = new Uint8Array(64);
        u8.set(this.r.toRawBytes());
        u8.set(numberTo32BytesLE(this.s), 32);
        return u8;
      }
      toHex() {
        return bytesToHex2(this.toRawBytes());
      }
    };
    hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    Point2.BASE._setWindowSize(8);
    crypto7 = {
      node: nodeCrypto2,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    utils2 = {
      bytesToHex: bytesToHex2,
      hexToBytes: hexToBytes2,
      concatBytes: concatBytes2,
      getExtendedPublicKey,
      mod: mod3,
      invert: invert2,
      TORSION_SUBGROUP: [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ],
      hashToPrivateScalar: (hash) => {
        hash = ensureBytes2(hash);
        if (hash.length < 40 || hash.length > 1024)
          throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
        return mod3(bytesToNumberLE(hash), CURVE2.l - _1n2) + _1n2;
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto7.web) {
          return crypto7.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto7.node) {
          const { randomBytes: randomBytes2 } = crypto7.node;
          return new Uint8Array(randomBytes2(bytesLength).buffer);
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => {
        return utils2.randomBytes(32);
      },
      sha512: async (...messages2) => {
        const message2 = concatBytes2(...messages2);
        if (crypto7.web) {
          const buffer = await crypto7.web.subtle.digest("SHA-512", message2.buffer);
          return new Uint8Array(buffer);
        } else if (crypto7.node) {
          return Uint8Array.from(crypto7.node.createHash("sha512").update(message2).digest());
        } else {
          throw new Error("The environment doesn't have sha512 function");
        }
      },
      precompute(windowSize = 8, point = Point2.BASE) {
        const cached = point.equals(Point2.BASE) ? point : new Point2(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_2n2);
        return cached;
      },
      sha512Sync: void 0
    };
    Object.defineProperties(utils2, {
      sha512Sync: {
        configurable: false,
        get() {
          return _sha512Sync;
        },
        set(val) {
          if (!_sha512Sync)
            _sha512Sync = val;
        }
      }
    });
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/ed25519.js
async function generateKey2() {
  const privateKeyRaw = utils2.randomPrivateKey();
  const publicKey = await getPublicKey2(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function generateKeyFromSeed(seed) {
  if (seed.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed;
  const publicKey = await getPublicKey2(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function hashAndSign2(privateKey, msg) {
  const privateKeyRaw = privateKey.slice(0, KEYS_BYTE_LENGTH);
  return await sign2(msg, privateKeyRaw);
}
async function hashAndVerify2(publicKey, sig, msg) {
  return await verify2(sig, msg, publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
    privateKey[i] = privateKeyRaw[i];
    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
  }
  return privateKey;
}
var PUBLIC_KEY_BYTE_LENGTH, PRIVATE_KEY_BYTE_LENGTH, KEYS_BYTE_LENGTH;
var init_ed25519 = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/ed25519.js"() {
    init_esm2();
    PUBLIC_KEY_BYTE_LENGTH = 32;
    PRIVATE_KEY_BYTE_LENGTH = 64;
    KEYS_BYTE_LENGTH = 32;
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var ed25519_class_exports = {};
__export(ed25519_class_exports, {
  Ed25519PrivateKey: () => Ed25519PrivateKey,
  Ed25519PublicKey: () => Ed25519PublicKey,
  generateKeyPair: () => generateKeyPair2,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed,
  unmarshalEd25519PrivateKey: () => unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey: () => unmarshalEd25519PublicKey
});
function unmarshalEd25519PrivateKey(bytes) {
  if (bytes.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes = ensureKey(bytes, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes.slice(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes.slice(PRIVATE_KEY_BYTE_LENGTH, bytes.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes = ensureKey(bytes, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes.slice(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes.slice(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureKey(bytes, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes);
}
async function generateKeyPair2() {
  const { privateKey, publicKey } = await generateKey2();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
async function generateKeyPairFromSeed(seed) {
  const { privateKey, publicKey } = await generateKeyFromSeed(seed);
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureKey(key, length2) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length2) {
    throw (0, import_err_code7.default)(new Error(`Key must be a Uint8Array of length ${length2}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
  }
  return key;
}
var import_err_code7, Ed25519PublicKey, Ed25519PrivateKey;
var init_ed25519_class = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js"() {
    import_err_code7 = __toESM(require_err_code(), 1);
    init_equals();
    init_sha2();
    init_base58();
    init_identity2();
    init_ed25519();
    init_keys();
    init_exporter();
    Ed25519PublicKey = class {
      constructor(key) {
        this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
      }
      async verify(data, sig) {
        return await hashAndVerify2(this._key, sig, data);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return PublicKey.encode({
          Type: KeyType.Ed25519,
          Data: this.marshal()
        }).subarray();
      }
      equals(key) {
        return equals3(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha256.digest(this.bytes);
        return bytes;
      }
    };
    Ed25519PrivateKey = class {
      constructor(key, publicKey) {
        this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
        this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
      }
      async sign(message2) {
        return await hashAndSign2(this._key, message2);
      }
      get public() {
        return new Ed25519PublicKey(this._publicKey);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return PrivateKey.encode({
          Type: KeyType.Ed25519,
          Data: this.marshal()
        }).subarray();
      }
      equals(key) {
        return equals3(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha256.digest(this.bytes);
        return bytes;
      }
      async id() {
        const encoding = await identity2.digest(this.public.bytes);
        return base58btc.encode(encoding.bytes).substring(1);
      }
      async export(password, format = "libp2p-key") {
        if (format === "libp2p-key") {
          return await exporter(this.bytes, password);
        } else {
          throw (0, import_err_code7.default)(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1.js
function generateKey3() {
  return utils.randomPrivateKey();
}
async function hashAndSign3(key, msg) {
  const { digest: digest2 } = await sha256.digest(msg);
  try {
    return await sign(digest2, key);
  } catch (err) {
    throw (0, import_err_code8.default)(err, "ERR_INVALID_INPUT");
  }
}
async function hashAndVerify3(key, sig, msg) {
  try {
    const { digest: digest2 } = await sha256.digest(msg);
    return verify(sig, digest2, key);
  } catch (err) {
    throw (0, import_err_code8.default)(err, "ERR_INVALID_INPUT");
  }
}
function compressPublicKey(key) {
  const point = Point.fromHex(key).toRawBytes(true);
  return point;
}
function validatePrivateKey(key) {
  try {
    getPublicKey(key, true);
  } catch (err) {
    throw (0, import_err_code8.default)(err, "ERR_INVALID_PRIVATE_KEY");
  }
}
function validatePublicKey(key) {
  try {
    Point.fromHex(key);
  } catch (err) {
    throw (0, import_err_code8.default)(err, "ERR_INVALID_PUBLIC_KEY");
  }
}
function computePublicKey(privateKey) {
  try {
    return getPublicKey(privateKey, true);
  } catch (err) {
    throw (0, import_err_code8.default)(err, "ERR_INVALID_PRIVATE_KEY");
  }
}
var import_err_code8;
var init_secp256k1 = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/secp256k1.js"() {
    import_err_code8 = __toESM(require_err_code(), 1);
    init_esm();
    init_sha2();
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var secp256k1_class_exports = {};
__export(secp256k1_class_exports, {
  Secp256k1PrivateKey: () => Secp256k1PrivateKey,
  Secp256k1PublicKey: () => Secp256k1PublicKey,
  generateKeyPair: () => generateKeyPair3,
  unmarshalSecp256k1PrivateKey: () => unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey: () => unmarshalSecp256k1PublicKey
});
function unmarshalSecp256k1PrivateKey(bytes) {
  return new Secp256k1PrivateKey(bytes);
}
function unmarshalSecp256k1PublicKey(bytes) {
  return new Secp256k1PublicKey(bytes);
}
async function generateKeyPair3() {
  const privateKeyBytes = await generateKey3();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
var import_err_code9, Secp256k1PublicKey, Secp256k1PrivateKey;
var init_secp256k1_class = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js"() {
    init_sha2();
    import_err_code9 = __toESM(require_err_code(), 1);
    init_equals();
    init_to_string();
    init_secp256k1();
    init_exporter();
    init_keys();
    Secp256k1PublicKey = class {
      constructor(key) {
        validatePublicKey(key);
        this._key = key;
      }
      async verify(data, sig) {
        return await hashAndVerify3(this._key, sig, data);
      }
      marshal() {
        return compressPublicKey(this._key);
      }
      get bytes() {
        return PublicKey.encode({
          Type: KeyType.Secp256k1,
          Data: this.marshal()
        }).subarray();
      }
      equals(key) {
        return equals3(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha256.digest(this.bytes);
        return bytes;
      }
    };
    Secp256k1PrivateKey = class {
      constructor(key, publicKey) {
        this._key = key;
        this._publicKey = publicKey ?? computePublicKey(key);
        validatePrivateKey(this._key);
        validatePublicKey(this._publicKey);
      }
      async sign(message2) {
        return await hashAndSign3(this._key, message2);
      }
      get public() {
        return new Secp256k1PublicKey(this._publicKey);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return PrivateKey.encode({
          Type: KeyType.Secp256k1,
          Data: this.marshal()
        }).subarray();
      }
      equals(key) {
        return equals3(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha256.digest(this.bytes);
        return bytes;
      }
      async id() {
        const hash = await this.public.hash();
        return toString2(hash, "base58btc");
      }
      async export(password, format = "libp2p-key") {
        if (format === "libp2p-key") {
          return await exporter(this.bytes, password);
        } else {
          throw (0, import_err_code9.default)(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
  }
});

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var keys_exports2 = {};
__export(keys_exports2, {
  generateEphemeralKeyPair: () => ephemeral_keys_default,
  generateKeyPair: () => generateKeyPair4,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed2,
  importKey: () => importKey,
  keyStretcher: () => keyStretcher,
  keysPBM: () => keys_exports,
  marshalPrivateKey: () => marshalPrivateKey,
  marshalPublicKey: () => marshalPublicKey,
  supportedKeys: () => supportedKeys,
  unmarshalPrivateKey: () => unmarshalPrivateKey2,
  unmarshalPublicKey: () => unmarshalPublicKey
});
function unsupportedKey(type) {
  const supported = Object.keys(supportedKeys).join(" / ");
  return (0, import_err_code10.default)(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
}
function typeToKey(type) {
  type = type.toLowerCase();
  if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
    return supportedKeys[type];
  }
  throw unsupportedKey(type);
}
async function generateKeyPair4(type, bits) {
  return await typeToKey(type).generateKeyPair(bits ?? 2048);
}
async function generateKeyPairFromSeed2(type, seed, bits) {
  if (type.toLowerCase() !== "ed25519") {
    throw (0, import_err_code10.default)(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
  }
  return await generateKeyPairFromSeed(seed);
}
function unmarshalPublicKey(buf) {
  const decoded = PublicKey.decode(buf);
  const data = decoded.Data;
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey(decoded.Type);
  }
}
function marshalPublicKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function unmarshalPrivateKey2(buf) {
  const decoded = PrivateKey.decode(buf);
  const data = decoded.Data;
  switch (decoded.Type) {
    case KeyType.RSA:
      return await supportedKeys.rsa.unmarshalRsaPrivateKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
    default:
      throw unsupportedKey(decoded.Type);
  }
}
function marshalPrivateKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function importKey(encryptedKey, password) {
  try {
    const key2 = await importer(encryptedKey, password);
    return await unmarshalPrivateKey2(key2);
  } catch (_) {
  }
  const key = import_forge4.default.pki.decryptRsaPrivateKey(encryptedKey, password);
  if (key === null) {
    throw (0, import_err_code10.default)(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
  }
  let der = import_forge4.default.asn1.toDer(import_forge4.default.pki.privateKeyToAsn1(key));
  der = fromString2(der.getBytes(), "ascii");
  return await supportedKeys.rsa.unmarshalRsaPrivateKey(der);
}
var import_asn12, import_pbe, import_forge4, import_err_code10, supportedKeys;
var init_keys2 = __esm({
  "node_modules/@libp2p/crypto/dist/src/keys/index.js"() {
    init_keys();
    import_asn12 = __toESM(require_asn1(), 1);
    import_pbe = __toESM(require_pbe(), 1);
    import_forge4 = __toESM(require_forge(), 1);
    import_err_code10 = __toESM(require_err_code(), 1);
    init_from_string();
    init_key_stretcher();
    init_ephemeral_keys();
    init_importer();
    init_rsa_class();
    init_ed25519_class();
    init_secp256k1_class();
    supportedKeys = {
      rsa: rsa_class_exports,
      ed25519: ed25519_class_exports,
      secp256k1: secp256k1_class_exports
    };
  }
});

// node_modules/@libp2p/interface-peer-id/dist/src/index.js
var symbol;
var init_src3 = __esm({
  "node_modules/@libp2p/interface-peer-id/dist/src/index.js"() {
    symbol = Symbol.for("@libp2p/peer-id");
  }
});

// node_modules/@libp2p/peer-id/dist/src/index.js
function peerIdFromString(str, decoder) {
  decoder = decoder ?? baseDecoder;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode5(base58btc.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf) {
  try {
    const multihash = decode5(buf);
    if (multihash.code === identity2.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha256.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID.decode(buf));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha256.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity2.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}
async function peerIdFromKeys(publicKey, privateKey) {
  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
    return new Ed25519PeerIdImpl({ multihash: create(identity2.code, publicKey), privateKey });
  }
  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
    return new Secp256k1PeerIdImpl({ multihash: create(identity2.code, publicKey), privateKey });
  }
  return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });
}
var import_err_code11, baseDecoder, LIBP2P_KEY_CODE, MARSHALLED_ED225519_PUBLIC_KEY_LENGTH, MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH, PeerIdImpl, RSAPeerIdImpl, Ed25519PeerIdImpl, Secp256k1PeerIdImpl;
var init_src4 = __esm({
  "node_modules/@libp2p/peer-id/dist/src/index.js"() {
    init_cid();
    init_basics();
    init_base58();
    init_digest();
    init_identity2();
    init_equals();
    init_sha2();
    import_err_code11 = __toESM(require_err_code(), 1);
    init_src3();
    baseDecoder = Object.values(bases).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases.identity.decoder);
    LIBP2P_KEY_CODE = 114;
    MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
    MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
    PeerIdImpl = class {
      constructor(init) {
        this.type = init.type;
        this.multihash = init.multihash;
        this.privateKey = init.privateKey;
        Object.defineProperty(this, "string", {
          enumerable: false,
          writable: true
        });
      }
      get [Symbol.toStringTag]() {
        return `PeerId(${this.toString()})`;
      }
      get [symbol]() {
        return true;
      }
      toString() {
        if (this.string == null) {
          this.string = base58btc.encode(this.multihash.bytes).slice(1);
        }
        return this.string;
      }
      toCID() {
        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
      }
      toBytes() {
        return this.multihash.bytes;
      }
      toJSON() {
        return this.toString();
      }
      equals(id) {
        var _a2;
        if (id instanceof Uint8Array) {
          return equals3(this.multihash.bytes, id);
        } else if (typeof id === "string") {
          return peerIdFromString(id).equals(this);
        } else if (((_a2 = id == null ? void 0 : id.multihash) == null ? void 0 : _a2.bytes) != null) {
          return equals3(this.multihash.bytes, id.multihash.bytes);
        } else {
          throw new Error("not valid Id");
        }
      }
    };
    RSAPeerIdImpl = class extends PeerIdImpl {
      constructor(init) {
        super({ ...init, type: "RSA" });
        this.type = "RSA";
        this.publicKey = init.publicKey;
      }
    };
    Ed25519PeerIdImpl = class extends PeerIdImpl {
      constructor(init) {
        super({ ...init, type: "Ed25519" });
        this.type = "Ed25519";
        this.publicKey = init.multihash.digest;
      }
    };
    Secp256k1PeerIdImpl = class extends PeerIdImpl {
      constructor(init) {
        super({ ...init, type: "secp256k1" });
        this.type = "secp256k1";
        this.publicKey = init.multihash.digest;
      }
    };
  }
});

// node_modules/@libp2p/peer-id-factory/dist/src/proto.js
var PeerIdProto;
var init_proto = __esm({
  "node_modules/@libp2p/peer-id-factory/dist/src/proto.js"() {
    init_src2();
    (function(PeerIdProto2) {
      let _codec;
      PeerIdProto2.codec = () => {
        if (_codec == null) {
          _codec = message((obj, writer, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              writer.fork();
            }
            if (obj.id != null) {
              writer.uint32(10);
              writer.bytes(obj.id);
            } else {
              throw new Error('Protocol error: required field "id" was not found in object');
            }
            if (obj.pubKey != null) {
              writer.uint32(18);
              writer.bytes(obj.pubKey);
            }
            if (obj.privKey != null) {
              writer.uint32(26);
              writer.bytes(obj.privKey);
            }
            if (opts.lengthDelimited !== false) {
              writer.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              id: new Uint8Array(0)
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.id = reader2.bytes();
                  break;
                case 2:
                  obj.pubKey = reader2.bytes();
                  break;
                case 3:
                  obj.privKey = reader2.bytes();
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            if (obj.id == null) {
              throw new Error('Protocol error: value for required field "id" was not found in protobuf');
            }
            return obj;
          });
        }
        return _codec;
      };
      PeerIdProto2.encode = (obj) => {
        return encodeMessage(obj, PeerIdProto2.codec());
      };
      PeerIdProto2.decode = (buf) => {
        return decodeMessage(buf, PeerIdProto2.codec());
      };
    })(PeerIdProto || (PeerIdProto = {}));
  }
});

// node_modules/@libp2p/peer-id-factory/dist/src/index.js
var src_exports = {};
__export(src_exports, {
  createEd25519PeerId: () => createEd25519PeerId,
  createFromJSON: () => createFromJSON,
  createFromPrivKey: () => createFromPrivKey,
  createFromProtobuf: () => createFromProtobuf,
  createFromPubKey: () => createFromPubKey,
  createRSAPeerId: () => createRSAPeerId,
  createSecp256k1PeerId: () => createSecp256k1PeerId,
  exportToProtobuf: () => exportToProtobuf
});
async function createFromPubKey(publicKey) {
  return await peerIdFromKeys(marshalPublicKey(publicKey));
}
async function createFromPrivKey(privateKey) {
  return await peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey));
}
function exportToProtobuf(peerId, excludePrivateKey) {
  return PeerIdProto.encode({
    id: peerId.multihash.bytes,
    pubKey: peerId.publicKey,
    privKey: excludePrivateKey === true || peerId.privateKey == null ? void 0 : peerId.privateKey
  });
}
async function createFromProtobuf(buf) {
  const { id, privKey, pubKey } = PeerIdProto.decode(buf);
  return await createFromParts(id, privKey, pubKey);
}
async function createFromJSON(obj) {
  return await createFromParts(fromString2(obj.id, "base58btc"), obj.privKey != null ? fromString2(obj.privKey, "base64pad") : void 0, obj.pubKey != null ? fromString2(obj.pubKey, "base64pad") : void 0);
}
async function createFromParts(multihash, privKey, pubKey) {
  if (privKey != null) {
    const key = await unmarshalPrivateKey2(privKey);
    return await createFromPrivKey(key);
  } else if (pubKey != null) {
    const key = await unmarshalPublicKey(pubKey);
    return await createFromPubKey(key);
  }
  return peerIdFromBytes(multihash);
}
var createEd25519PeerId, createSecp256k1PeerId, createRSAPeerId;
var init_src5 = __esm({
  "node_modules/@libp2p/peer-id-factory/dist/src/index.js"() {
    init_keys2();
    init_from_string();
    init_src4();
    init_proto();
    createEd25519PeerId = async () => {
      const key = await generateKeyPair4("Ed25519");
      const id = await createFromPrivKey(key);
      if (id.type === "Ed25519") {
        return id;
      }
      throw new Error(`Generated unexpected PeerId type "${id.type}"`);
    };
    createSecp256k1PeerId = async () => {
      const key = await generateKeyPair4("secp256k1");
      const id = await createFromPrivKey(key);
      if (id.type === "secp256k1") {
        return id;
      }
      throw new Error(`Generated unexpected PeerId type "${id.type}"`);
    };
    createRSAPeerId = async (opts) => {
      const key = await generateKeyPair4("RSA", (opts == null ? void 0 : opts.bits) ?? 2048);
      const id = await createFromPrivKey(key);
      if (id.type === "RSA") {
        return id;
      }
      throw new Error(`Generated unexpected PeerId type "${id.type}"`);
    };
  }
});

// node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign3) => sign3 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log4(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@libp2p/logger/dist/src/index.js
function logger(name2) {
  return Object.assign((0, import_debug.default)(name2), {
    error: (0, import_debug.default)(`${name2}:error`),
    trace: (0, import_debug.default)(`${name2}:trace`)
  });
}
var import_debug;
var init_src6 = __esm({
  "node_modules/@libp2p/logger/dist/src/index.js"() {
    import_debug = __toESM(require_src2(), 1);
    init_base58();
    init_base32();
    init_base64();
    import_debug.default.formatters.b = (v) => {
      return v == null ? "undefined" : base58btc.baseEncode(v);
    };
    import_debug.default.formatters.t = (v) => {
      return v == null ? "undefined" : base32.baseEncode(v);
    };
    import_debug.default.formatters.m = (v) => {
      return v == null ? "undefined" : base64.baseEncode(v);
    };
    import_debug.default.formatters.p = (v) => {
      return v == null ? "undefined" : v.toString();
    };
    import_debug.default.formatters.c = (v) => {
      return v == null ? "undefined" : v.toString();
    };
    import_debug.default.formatters.k = (v) => {
      return v == null ? "undefined" : v.toString();
    };
  }
});

// node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO, FIFO;
var init_fifo = __esm({
  "node_modules/it-pushable/dist/src/fifo.js"() {
    FixedFIFO = class {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
          throw new Error("Max size for a FixedFIFO should be a power of two");
        }
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      push(data) {
        if (this.buffer[this.top] !== void 0) {
          return false;
        }
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last = this.buffer[this.btm];
        if (last === void 0) {
          return void 0;
        }
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last;
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
    FIFO = class {
      constructor(options2 = {}) {
        this.hwm = options2.splitLimit ?? 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
        this.size = 0;
      }
      calculateSize(obj) {
        if ((obj == null ? void 0 : obj.byteLength) != null) {
          return obj.byteLength;
        }
        return 1;
      }
      push(val) {
        if ((val == null ? void 0 : val.value) != null) {
          this.size += this.calculateSize(val.value);
        }
        if (!this.head.push(val)) {
          const prev = this.head;
          this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        let val = this.tail.shift();
        if (val === void 0 && this.tail.next != null) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          val = this.tail.shift();
        }
        if ((val == null ? void 0 : val.value) != null) {
          this.size -= this.calculateSize(val.value);
        }
        return val;
      }
      isEmpty() {
        return this.head.isEmpty();
      }
    };
  }
});

// node_modules/it-pushable/dist/src/index.js
function pushable(options2 = {}) {
  const getNext = (buffer) => {
    const next = buffer.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      value: next.value
    };
  };
  return _pushable(getNext, options2);
}
function _pushable(getNext, options2) {
  options2 = options2 ?? {};
  let onEnd = options2.onEnd;
  let buffer = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  const waitNext = async () => {
    if (!buffer.isEmpty()) {
      return getNext(buffer);
    }
    if (ended) {
      return { done: true };
    }
    return await new Promise((resolve, reject) => {
      onNext = (next) => {
        onNext = null;
        buffer.push(next);
        try {
          resolve(getNext(buffer));
        } catch (err) {
          reject(err);
        }
        return pushable2;
      };
    });
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer.push({ error: err });
    return pushable2;
  };
  const push = (value) => {
    if (ended) {
      return pushable2;
    }
    if ((options2 == null ? void 0 : options2.objectMode) !== true && (value == null ? void 0 : value.byteLength) == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer.size;
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    }
  };
  return pushable2;
}
var init_src7 = __esm({
  "node_modules/it-pushable/dist/src/index.js"() {
    init_fifo();
  }
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({
  "node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
    module2.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
          throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      push(data) {
        if (this.buffer[this.top] !== void 0)
          return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last = this.buffer[this.btm];
        if (last === void 0)
          return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last;
      }
      peek() {
        return this.buffer[this.btm];
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({
  "node_modules/fast-fifo/index.js"(exports2, module2) {
    var FixedFIFO2 = require_fixed_size();
    module2.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO2(this.hwm);
        this.tail = this.head;
      }
      push(val) {
        if (!this.head.push(val)) {
          const prev = this.head;
          this.head = prev.next = new FixedFIFO2(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      peek() {
        return this.tail.peek();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
    };
  }
});

// node_modules/it-merge/node_modules/it-pushable/index.js
var require_it_pushable = __commonJS({
  "node_modules/it-merge/node_modules/it-pushable/index.js"(exports2, module2) {
    var FIFO2 = require_fast_fifo();
    module2.exports = (options2) => {
      options2 = options2 || {};
      let onEnd;
      if (typeof options2 === "function") {
        onEnd = options2;
        options2 = {};
      } else {
        onEnd = options2.onEnd;
      }
      let buffer = new FIFO2();
      let pushable2, onNext, ended;
      const waitNext = () => {
        if (!buffer.isEmpty()) {
          if (options2.writev) {
            let next2;
            const values = [];
            while (!buffer.isEmpty()) {
              next2 = buffer.shift();
              if (next2.error)
                throw next2.error;
              values.push(next2.value);
            }
            return { done: next2.done, value: values };
          }
          const next = buffer.shift();
          if (next.error)
            throw next.error;
          return next;
        }
        if (ended)
          return { done: true };
        return new Promise((resolve, reject) => {
          onNext = (next) => {
            onNext = null;
            if (next.error) {
              reject(next.error);
            } else {
              if (options2.writev && !next.done) {
                resolve({ done: next.done, value: [next.value] });
              } else {
                resolve(next);
              }
            }
            return pushable2;
          };
        });
      };
      const bufferNext = (next) => {
        if (onNext)
          return onNext(next);
        buffer.push(next);
        return pushable2;
      };
      const bufferError = (err) => {
        buffer = new FIFO2();
        if (onNext)
          return onNext({ error: err });
        buffer.push({ error: err });
        return pushable2;
      };
      const push = (value) => {
        if (ended)
          return pushable2;
        return bufferNext({ done: false, value });
      };
      const end = (err) => {
        if (ended)
          return pushable2;
        ended = true;
        return err ? bufferError(err) : bufferNext({ done: true });
      };
      const _return = () => {
        buffer = new FIFO2();
        end();
        return { done: true };
      };
      const _throw = (err) => {
        end(err);
        return { done: true };
      };
      pushable2 = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next: waitNext,
        return: _return,
        throw: _throw,
        push,
        end
      };
      if (!onEnd)
        return pushable2;
      const _pushable2 = pushable2;
      pushable2 = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          return _pushable2.next();
        },
        throw(err) {
          _pushable2.throw(err);
          if (onEnd) {
            onEnd(err);
            onEnd = null;
          }
          return { done: true };
        },
        return() {
          _pushable2.return();
          if (onEnd) {
            onEnd();
            onEnd = null;
          }
          return { done: true };
        },
        push,
        end(err) {
          _pushable2.end(err);
          if (onEnd) {
            onEnd(err);
            onEnd = null;
          }
          return pushable2;
        }
      };
      return pushable2;
    };
  }
});

// node_modules/it-merge/index.js
var require_it_merge = __commonJS({
  "node_modules/it-merge/index.js"(exports2, module2) {
    "use strict";
    var pushable2 = require_it_pushable();
    var merge2 = async function* (...sources) {
      const output = pushable2();
      setTimeout(async () => {
        try {
          await Promise.all(
            sources.map(async (source) => {
              for await (const item of source) {
                output.push(item);
              }
            })
          );
          output.end();
        } catch (err) {
          output.end(err);
        }
      }, 0);
      yield* output;
    };
    module2.exports = merge2;
  }
});

// node_modules/it-pipe/dist/src/index.js
function pipe(first, ...rest) {
  if (isDuplex(first)) {
    const duplex = first;
    first = () => duplex.source;
  } else if (isIterable(first)) {
    const source = first;
    first = () => source;
  }
  const fns = [first, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex(fns[i])) {
        fns[i] = duplexPipelineFn(fns[i]);
      }
    }
  }
  return rawPipe(...fns);
}
var import_it_merge, rawPipe, isIterable, isDuplex, duplexPipelineFn;
var init_src8 = __esm({
  "node_modules/it-pipe/dist/src/index.js"() {
    init_src7();
    import_it_merge = __toESM(require_it_merge(), 1);
    rawPipe = (...fns) => {
      let res;
      while (fns.length > 0) {
        res = fns.shift()(res);
      }
      return res;
    };
    isIterable = (obj) => {
      return obj != null && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
    };
    isDuplex = (obj) => {
      return obj != null && typeof obj.sink === "function" && isIterable(obj.source);
    };
    duplexPipelineFn = (duplex) => {
      return (source) => {
        const p = duplex.sink(source);
        if (p.then != null) {
          const stream = pushable({
            objectMode: true
          });
          p.then(() => {
            stream.end();
          }, (err) => {
            stream.end(err);
          });
          const sourceWrap = async function* () {
            yield* duplex.source;
            stream.end();
          };
          return (0, import_it_merge.default)(stream, sourceWrap());
        }
        return duplex.source;
      };
    };
  }
});

// node_modules/p-defer/index.js
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}
var init_p_defer = __esm({
  "node_modules/p-defer/index.js"() {
  }
});

// node_modules/it-pair/dist/src/index.js
function pair() {
  const deferred = pDefer();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}
var init_src9 = __esm({
  "node_modules/it-pair/dist/src/index.js"() {
    init_p_defer();
  }
});

// node_modules/it-pair/dist/src/duplex.js
function duplexPair() {
  const a = pair();
  const b = pair();
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ];
}
var init_duplex = __esm({
  "node_modules/it-pair/dist/src/duplex.js"() {
    init_src9();
  }
});

// node_modules/@libp2p/crypto/dist/src/aes/ciphers.js
var import_crypto6, createCipheriv, createDecipheriv;
var init_ciphers = __esm({
  "node_modules/@libp2p/crypto/dist/src/aes/ciphers.js"() {
    import_crypto6 = __toESM(require("crypto"), 1);
    createCipheriv = import_crypto6.default.createCipheriv;
    createDecipheriv = import_crypto6.default.createDecipheriv;
  }
});

// node_modules/@libp2p/crypto/dist/src/aes/cipher-mode.js
var import_err_code12;
var init_cipher_mode = __esm({
  "node_modules/@libp2p/crypto/dist/src/aes/cipher-mode.js"() {
    import_err_code12 = __toESM(require_err_code(), 1);
  }
});

// node_modules/@libp2p/crypto/dist/src/aes/index.js
var init_aes = __esm({
  "node_modules/@libp2p/crypto/dist/src/aes/index.js"() {
    init_ciphers();
    init_cipher_mode();
  }
});

// node_modules/@libp2p/crypto/dist/src/pbkdf2.js
var import_pbkdf2, import_util4, import_err_code13;
var init_pbkdf2 = __esm({
  "node_modules/@libp2p/crypto/dist/src/pbkdf2.js"() {
    import_pbkdf2 = __toESM(require_pbkdf2(), 1);
    import_util4 = __toESM(require_util2(), 1);
    import_err_code13 = __toESM(require_err_code(), 1);
  }
});

// node_modules/@libp2p/crypto/dist/src/index.js
var init_src10 = __esm({
  "node_modules/@libp2p/crypto/dist/src/index.js"() {
    init_hmac();
    init_aes();
    init_keys2();
    init_random_bytes();
    init_pbkdf2();
  }
});

// node_modules/libp2p/dist/src/pnet/errors.js
var INVALID_PSK, NO_HANDSHAKE_CONNECTION, STREAM_ENDED;
var init_errors = __esm({
  "node_modules/libp2p/dist/src/pnet/errors.js"() {
    INVALID_PSK = "Your private shared key is invalid";
    NO_HANDSHAKE_CONNECTION = "No connection for the handshake provided";
    STREAM_ENDED = "Stream ended prematurely";
  }
});

// node_modules/libp2p/dist/src/errors.js
var messages, codes;
var init_errors2 = __esm({
  "node_modules/libp2p/dist/src/errors.js"() {
    (function(messages2) {
      messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
      messages2["DHT_DISABLED"] = "DHT is not available";
      messages2["PUBSUB_DISABLED"] = "PubSub is not available";
      messages2["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
      messages2["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
      messages2["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
      messages2["NOT_FOUND"] = "Not found";
    })(messages || (messages = {}));
    (function(codes5) {
      codes5["DHT_DISABLED"] = "ERR_DHT_DISABLED";
      codes5["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
      codes5["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
      codes5["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
      codes5["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
      codes5["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
      codes5["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
      codes5["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
      codes5["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
      codes5["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
      codes5["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
      codes5["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
      codes5["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
      codes5["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
      codes5["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
      codes5["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
      codes5["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
      codes5["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
      codes5["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
      codes5["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
      codes5["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
      codes5["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
      codes5["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
      codes5["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
      codes5["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
      codes5["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
      codes5["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
      codes5["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
      codes5["ERR_TIMEOUT"] = "ERR_TIMEOUT";
      codes5["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
      codes5["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
      codes5["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
      codes5["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
      codes5["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
      codes5["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
      codes5["ERR_FIND_SELF"] = "ERR_FIND_SELF";
      codes5["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
      codes5["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
      codes5["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
      codes5["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
      codes5["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
      codes5["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
      codes5["ERR_NO_KEY"] = "ERR_NO_KEY";
      codes5["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
      codes5["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
      codes5["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
      codes5["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
      codes5["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
      codes5["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
      codes5["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
      codes5["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
      codes5["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
      codes5["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
      codes5["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
      codes5["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
      codes5["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
      codes5["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
      codes5["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
      codes5["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
      codes5["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
      codes5["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
      codes5["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
      codes5["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
      codes5["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
      codes5["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
    })(codes || (codes = {}));
  }
});

// node_modules/xsalsa20/xsalsa20.js
var require_xsalsa20 = __commonJS({
  "node_modules/xsalsa20/xsalsa20.js"(exports2, module2) {
    var __commonJS2 = (cb, mod4) => function __require() {
      return mod4 || (0, cb[Object.keys(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
    };
    var __toBinary = /* @__PURE__ */ (() => {
      var table2 = new Uint8Array(128);
      for (var i = 0; i < 64; i++)
        table2[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
      return (base642) => {
        var n = base642.length, bytes2 = new Uint8Array((n - (base642[n - 1] == "=") - (base642[n - 2] == "=")) * 3 / 4 | 0);
        for (var i2 = 0, j = 0; i2 < n; ) {
          var c0 = table2[base642.charCodeAt(i2++)], c1 = table2[base642.charCodeAt(i2++)];
          var c2 = table2[base642.charCodeAt(i2++)], c3 = table2[base642.charCodeAt(i2++)];
          bytes2[j++] = c0 << 2 | c1 >> 4;
          bytes2[j++] = c1 << 4 | c2 >> 2;
          bytes2[j++] = c2 << 6 | c3;
        }
        return bytes2;
      };
    })();
    var require_xsalsa203 = __commonJS2({
      "wasm-binary:./xsalsa20.wat"(exports22, module22) {
        module22.exports = __toBinary("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");
      }
    });
    var bytes = require_xsalsa203();
    var compiled = new WebAssembly.Module(bytes);
    module2.exports = (imports) => {
      const instance = new WebAssembly.Instance(compiled, imports);
      return instance.exports;
    };
  }
});

// node_modules/xsalsa20/index.js
var require_xsalsa202 = __commonJS({
  "node_modules/xsalsa20/index.js"(exports2, module2) {
    var xsalsa202 = typeof WebAssembly !== "undefined" && require_xsalsa20()();
    var SIGMA = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    var head = 144;
    var top = head;
    var free = [];
    module2.exports = XSalsa20;
    XSalsa20.NONCEBYTES = 24;
    XSalsa20.KEYBYTES = 32;
    XSalsa20.core_hsalsa20 = core_hsalsa20;
    XSalsa20.SIGMA = SIGMA;
    function XSalsa20(nonce, key) {
      if (!(this instanceof XSalsa20))
        return new XSalsa20(nonce, key);
      if (!nonce || nonce.length < 24)
        throw new Error("nonce must be at least 24 bytes");
      if (!key || key.length < 32)
        throw new Error("key must be at least 32 bytes");
      this._xor = xsalsa202 ? new WASM(nonce, key) : new Fallback(nonce, key);
    }
    XSalsa20.prototype.update = function(input, output) {
      if (!input)
        throw new Error("input must be Uint8Array or Buffer");
      if (!output)
        output = new Uint8Array(input.length);
      if (input.length)
        this._xor.update(input, output);
      return output;
    };
    XSalsa20.prototype.final = XSalsa20.prototype.finalize = function() {
      this._xor.finalize();
      this._xor = null;
    };
    function WASM(nonce, key) {
      if (!free.length) {
        free.push(head);
        head += 64;
      }
      this._pointer = free.pop();
      this._nonce = this._pointer + 8;
      this._key = this._nonce + 24;
      this._overflow = 0;
      this._memory = new Uint8Array(xsalsa202.memory.buffer);
      this._memory.fill(0, this._pointer, this._pointer + 8);
      this._memory.set(nonce, this._nonce);
      this._memory.set(key, this._key);
    }
    WASM.prototype.realloc = function(size) {
      xsalsa202.memory.grow(Math.ceil(Math.abs(size - this._memory.length) / 65536));
      this._memory = new Uint8Array(xsalsa202.memory.buffer);
    };
    WASM.prototype.update = function(input, output) {
      var len = this._overflow + input.length;
      var start = head + this._overflow;
      top = head + len;
      if (top >= this._memory.length)
        this.realloc(top);
      this._memory.set(input, start);
      xsalsa202.xsalsa20_xor(this._pointer, head, head, len, this._nonce, this._key);
      output.set(this._memory.subarray(start, head + len));
      this._overflow = len & 63;
    };
    WASM.prototype.finalize = function() {
      this._memory.fill(0, this._pointer, this._key + 32);
      if (top > head) {
        this._memory.fill(0, head, top);
        top = 0;
      }
      free.push(this._pointer);
    };
    function Fallback(nonce, key) {
      this._s = new Uint8Array(32);
      this._z = new Uint8Array(16);
      this._overflow = 0;
      core_hsalsa20(this._s, nonce, key, SIGMA);
      for (var i = 0; i < 8; i++)
        this._z[i] = nonce[i + 16];
    }
    Fallback.prototype.update = function(input, output) {
      var x = new Uint8Array(64);
      var u = 0;
      var i = this._overflow;
      var b = input.length + this._overflow;
      var z = this._z;
      var mpos = -this._overflow;
      var cpos = -this._overflow;
      while (b >= 64) {
        core_salsa20(x, z, this._s, SIGMA);
        for (; i < 64; i++)
          output[cpos + i] = input[mpos + i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u += z[i] & 255 | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
        i = 0;
      }
      if (b > 0) {
        core_salsa20(x, z, this._s, SIGMA);
        for (; i < b; i++)
          output[cpos + i] = input[mpos + i] ^ x[i];
      }
      this._overflow = b & 63;
    };
    Fallback.prototype.finalize = function() {
      this._s.fill(0);
      this._z.fill(0);
    };
    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 25;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 19;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 25;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 19;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 25;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 19;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 25;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 19;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 14;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 25;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 19;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 25;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 19;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 25;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 19;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 25;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 19;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 14;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 25;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 19;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 25;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 19;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 25;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 19;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 25;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 19;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 14;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 25;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 19;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 25;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 19;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 25;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 19;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 25;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 19;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 14;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
  }
});

// node_modules/libp2p/dist/src/pnet/key-generator.js
function generateKey4(bytes) {
  const psk = toString2(randomBytes(KEY_LENGTH), "base16");
  const key = fromString2("/key/swarm/psk/1.0.0/\n/base16/\n" + psk);
  bytes.set(key);
}
var NONCE_LENGTH, KEY_LENGTH;
var init_key_generator = __esm({
  "node_modules/libp2p/dist/src/pnet/key-generator.js"() {
    init_src10();
    init_to_string();
    init_from_string();
    NONCE_LENGTH = 24;
    KEY_LENGTH = 32;
    try {
      if (require.main === module) {
        generate(process.stdout);
      }
    } catch (error) {
    }
  }
});

// node_modules/libp2p/dist/src/pnet/crypto.js
function createBoxStream(nonce, psk) {
  const xor = (0, import_xsalsa20.default)(nonce, psk);
  return (source) => async function* () {
    for await (const chunk of source) {
      yield Uint8Array.from(xor.update(chunk.slice()));
    }
  }();
}
function createUnboxStream(nonce, psk) {
  return (source) => async function* () {
    const xor = (0, import_xsalsa20.default)(nonce, psk);
    log.trace("Decryption enabled");
    for await (const chunk of source) {
      yield Uint8Array.from(xor.update(chunk.slice()));
    }
  }();
}
function decodeV1PSK(pskBuffer) {
  try {
    const metadata = toString2(pskBuffer).split(/(?:\r\n|\r|\n)/g);
    const pskTag = metadata.shift();
    const codec = metadata.shift();
    const pskString = metadata.shift();
    const psk = fromString2(pskString ?? "", "base16");
    if (psk.byteLength !== KEY_LENGTH) {
      throw new Error(INVALID_PSK);
    }
    return {
      tag: pskTag,
      codecName: codec,
      psk
    };
  } catch (err) {
    log.error(err);
    throw new Error(INVALID_PSK);
  }
}
var import_xsalsa20, log;
var init_crypto = __esm({
  "node_modules/libp2p/dist/src/pnet/crypto.js"() {
    init_src6();
    init_errors();
    import_xsalsa20 = __toESM(require_xsalsa202(), 1);
    init_key_generator();
    init_from_string();
    init_to_string();
    log = logger("libp2p:pnet");
  }
});

// node_modules/uint8arraylist/dist/src/index.js
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf of bufs) {
    const bufEnd = offset + buf.byteLength;
    if (index < bufEnd) {
      return {
        buf,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
  return Boolean(value == null ? void 0 : value[symbol2]);
}
var symbol2, Uint8ArrayList;
var init_src11 = __esm({
  "node_modules/uint8arraylist/dist/src/index.js"() {
    init_concat();
    init_equals();
    init_alloc();
    symbol2 = Symbol.for("@achingbrain/uint8arraylist");
    Uint8ArrayList = class {
      constructor(...data) {
        Object.defineProperty(this, symbol2, { value: true });
        this.bufs = [];
        this.length = 0;
        if (data.length > 0) {
          this.appendAll(data);
        }
      }
      *[Symbol.iterator]() {
        yield* this.bufs;
      }
      get byteLength() {
        return this.length;
      }
      append(...bufs) {
        this.appendAll(bufs);
      }
      appendAll(bufs) {
        let length2 = 0;
        for (const buf of bufs) {
          if (buf instanceof Uint8Array) {
            length2 += buf.byteLength;
            this.bufs.push(buf);
          } else if (isUint8ArrayList(buf)) {
            length2 += buf.byteLength;
            this.bufs.push(...buf.bufs);
          } else {
            throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
          }
        }
        this.length += length2;
      }
      prepend(...bufs) {
        this.prependAll(bufs);
      }
      prependAll(bufs) {
        let length2 = 0;
        for (const buf of bufs.reverse()) {
          if (buf instanceof Uint8Array) {
            length2 += buf.byteLength;
            this.bufs.unshift(buf);
          } else if (isUint8ArrayList(buf)) {
            length2 += buf.byteLength;
            this.bufs.unshift(...buf.bufs);
          } else {
            throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
          }
        }
        this.length += length2;
      }
      get(index) {
        const res = findBufAndOffset(this.bufs, index);
        return res.buf[res.index];
      }
      set(index, value) {
        const res = findBufAndOffset(this.bufs, index);
        res.buf[res.index] = value;
      }
      write(buf, offset = 0) {
        if (buf instanceof Uint8Array) {
          for (let i = 0; i < buf.length; i++) {
            this.set(offset + i, buf[i]);
          }
        } else if (isUint8ArrayList(buf)) {
          for (let i = 0; i < buf.length; i++) {
            this.set(offset + i, buf.get(i));
          }
        } else {
          throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      consume(bytes) {
        bytes = Math.trunc(bytes);
        if (Number.isNaN(bytes) || bytes <= 0) {
          return;
        }
        while (this.bufs.length > 0) {
          if (bytes >= this.bufs[0].byteLength) {
            bytes -= this.bufs[0].byteLength;
            this.length -= this.bufs[0].byteLength;
            this.bufs.shift();
          } else {
            this.bufs[0] = this.bufs[0].subarray(bytes);
            this.length -= bytes;
            break;
          }
        }
      }
      slice(beginInclusive, endExclusive) {
        const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
        return concat(bufs, length2);
      }
      subarray(beginInclusive, endExclusive) {
        const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
        if (bufs.length === 1) {
          return bufs[0];
        }
        return concat(bufs, length2);
      }
      sublist(beginInclusive, endExclusive) {
        const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
        const list = new Uint8ArrayList();
        list.length = length2;
        list.bufs = bufs;
        return list;
      }
      _subList(beginInclusive, endExclusive) {
        beginInclusive = beginInclusive ?? 0;
        endExclusive = endExclusive ?? this.length;
        if (beginInclusive < 0) {
          beginInclusive = this.length + beginInclusive;
        }
        if (endExclusive < 0) {
          endExclusive = this.length + endExclusive;
        }
        if (beginInclusive < 0 || endExclusive > this.length) {
          throw new RangeError("index is out of bounds");
        }
        if (beginInclusive === endExclusive) {
          return { bufs: [], length: 0 };
        }
        if (beginInclusive === 0 && endExclusive === this.length) {
          return { bufs: [...this.bufs], length: this.length };
        }
        const bufs = [];
        let offset = 0;
        for (let i = 0; i < this.bufs.length; i++) {
          const buf = this.bufs[i];
          const bufStart = offset;
          const bufEnd = bufStart + buf.byteLength;
          offset = bufEnd;
          if (beginInclusive >= bufEnd) {
            continue;
          }
          const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
          const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
          if (sliceStartInBuf && sliceEndsInBuf) {
            if (beginInclusive === bufStart && endExclusive === bufEnd) {
              bufs.push(buf);
              break;
            }
            const start = beginInclusive - bufStart;
            bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));
            break;
          }
          if (sliceStartInBuf) {
            if (beginInclusive === 0) {
              bufs.push(buf);
              continue;
            }
            bufs.push(buf.subarray(beginInclusive - bufStart));
            continue;
          }
          if (sliceEndsInBuf) {
            if (endExclusive === bufEnd) {
              bufs.push(buf);
              break;
            }
            bufs.push(buf.subarray(0, endExclusive - bufStart));
            break;
          }
          bufs.push(buf);
        }
        return { bufs, length: endExclusive - beginInclusive };
      }
      getInt8(byteOffset) {
        const buf = this.subarray(byteOffset, byteOffset + 1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt8(0);
      }
      setInt8(byteOffset, value) {
        const buf = allocUnsafe(1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt8(0, value);
        this.write(buf, byteOffset);
      }
      getInt16(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt16(0, littleEndian);
      }
      setInt16(byteOffset, value, littleEndian) {
        const buf = alloc(2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt16(0, value, littleEndian);
        this.write(buf, byteOffset);
      }
      getInt32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt32(0, littleEndian);
      }
      setInt32(byteOffset, value, littleEndian) {
        const buf = alloc(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt32(0, value, littleEndian);
        this.write(buf, byteOffset);
      }
      getBigInt64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getBigInt64(0, littleEndian);
      }
      setBigInt64(byteOffset, value, littleEndian) {
        const buf = alloc(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setBigInt64(0, value, littleEndian);
        this.write(buf, byteOffset);
      }
      getUint8(byteOffset) {
        const buf = this.subarray(byteOffset, byteOffset + 1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint8(0);
      }
      setUint8(byteOffset, value) {
        const buf = allocUnsafe(1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint8(0, value);
        this.write(buf, byteOffset);
      }
      getUint16(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint16(0, littleEndian);
      }
      setUint16(byteOffset, value, littleEndian) {
        const buf = alloc(2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint16(0, value, littleEndian);
        this.write(buf, byteOffset);
      }
      getUint32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint32(0, littleEndian);
      }
      setUint32(byteOffset, value, littleEndian) {
        const buf = alloc(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint32(0, value, littleEndian);
        this.write(buf, byteOffset);
      }
      getBigUint64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getBigUint64(0, littleEndian);
      }
      setBigUint64(byteOffset, value, littleEndian) {
        const buf = alloc(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setBigUint64(0, value, littleEndian);
        this.write(buf, byteOffset);
      }
      getFloat32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getFloat32(0, littleEndian);
      }
      setFloat32(byteOffset, value, littleEndian) {
        const buf = alloc(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setFloat32(0, value, littleEndian);
        this.write(buf, byteOffset);
      }
      getFloat64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getFloat64(0, littleEndian);
      }
      setFloat64(byteOffset, value, littleEndian) {
        const buf = alloc(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setFloat64(0, value, littleEndian);
        this.write(buf, byteOffset);
      }
      equals(other) {
        if (other == null) {
          return false;
        }
        if (!(other instanceof Uint8ArrayList)) {
          return false;
        }
        if (other.bufs.length !== this.bufs.length) {
          return false;
        }
        for (let i = 0; i < this.bufs.length; i++) {
          if (!equals3(this.bufs[i], other.bufs[i])) {
            return false;
          }
        }
        return true;
      }
      static fromUint8Arrays(bufs, length2) {
        const list = new Uint8ArrayList();
        list.bufs = bufs;
        if (length2 == null) {
          length2 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
        }
        list.length = length2;
        return list;
      }
    };
  }
});

// node_modules/it-reader/dist/src/index.js
function reader(source) {
  const reader2 = async function* () {
    let bytes = yield;
    let bl = new Uint8ArrayList();
    for await (const chunk of source) {
      if (bytes == null) {
        bl.append(chunk);
        bytes = yield bl;
        bl = new Uint8ArrayList();
        continue;
      }
      bl.append(chunk);
      while (bl.length >= bytes) {
        const data = bl.sublist(0, bytes);
        bl.consume(bytes);
        bytes = yield data;
        if (bytes == null) {
          if (bl.length > 0) {
            bytes = yield bl;
            bl = new Uint8ArrayList();
          }
          break;
        }
      }
    }
    if (bytes != null) {
      throw Object.assign(new Error(`stream ended before ${bytes} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
    }
  }();
  void reader2.next();
  return reader2;
}
var init_src12 = __esm({
  "node_modules/it-reader/dist/src/index.js"() {
    init_src11();
  }
});

// node_modules/it-handshake/dist/src/index.js
function handshake(stream) {
  const writer = pushable();
  const source = reader(stream.source);
  const sourcePromise = pDefer();
  let sinkErr;
  const sinkPromise = stream.sink(async function* () {
    yield* writer;
    const source2 = await sourcePromise.promise;
    yield* source2;
  }());
  sinkPromise.catch((err) => {
    sinkErr = err;
  });
  const rest = {
    sink: async (source2) => {
      if (sinkErr != null) {
        return await Promise.reject(sinkErr);
      }
      sourcePromise.resolve(source2);
      return await sinkPromise;
    },
    source
  };
  return {
    reader: source,
    writer,
    stream: rest,
    rest: () => writer.end(),
    write: writer.push,
    read: async () => {
      const res = await source.next();
      if (res.value != null) {
        return res.value;
      }
    }
  };
}
var init_src13 = __esm({
  "node_modules/it-handshake/dist/src/index.js"() {
    init_src12();
    init_src7();
    init_p_defer();
  }
});

// node_modules/it-map/index.js
var require_it_map = __commonJS({
  "node_modules/it-map/index.js"(exports2, module2) {
    "use strict";
    var map2 = async function* (source, func) {
      for await (const val of source) {
        yield func(val);
      }
    };
    module2.exports = map2;
  }
});

// node_modules/libp2p/dist/src/pnet/index.js
var pnet_exports = {};
__export(pnet_exports, {
  PreSharedKeyConnectionProtector: () => PreSharedKeyConnectionProtector,
  generateKey: () => generateKey4
});
var import_err_code14, import_it_map, log2, PreSharedKeyConnectionProtector;
var init_pnet = __esm({
  "node_modules/libp2p/dist/src/pnet/index.js"() {
    init_src6();
    init_src8();
    import_err_code14 = __toESM(require_err_code(), 1);
    init_duplex();
    init_src10();
    init_errors();
    init_errors2();
    init_crypto();
    init_src13();
    init_key_generator();
    import_it_map = __toESM(require_it_map(), 1);
    init_key_generator();
    log2 = logger("libp2p:pnet");
    PreSharedKeyConnectionProtector = class {
      constructor(init) {
        this.enabled = init.enabled !== false;
        if (this.enabled) {
          const decodedPSK = decodeV1PSK(init.psk);
          this.psk = decodedPSK.psk;
          this.tag = decodedPSK.tag ?? "";
        } else {
          this.psk = new Uint8Array();
          this.tag = "";
        }
      }
      async protect(connection) {
        if (!this.enabled) {
          return connection;
        }
        if (connection == null) {
          throw (0, import_err_code14.default)(new Error(NO_HANDSHAKE_CONNECTION), codes.ERR_INVALID_PARAMETERS);
        }
        log2("protecting the connection");
        const localNonce = randomBytes(NONCE_LENGTH);
        const shake = handshake(connection);
        shake.write(localNonce);
        const result = await shake.reader.next(NONCE_LENGTH);
        if (result.value == null) {
          throw (0, import_err_code14.default)(new Error(STREAM_ENDED), codes.ERR_INVALID_PARAMETERS);
        }
        const remoteNonce = result.value.slice();
        shake.rest();
        log2("exchanged nonces");
        const [internal, external] = duplexPair();
        pipe(
          external,
          createBoxStream(localNonce, this.psk),
          shake.stream,
          (source) => (0, import_it_map.default)(source, (buf) => buf.subarray()),
          createUnboxStream(remoteNonce, this.psk),
          external
        ).catch(log2.error);
        return {
          ...connection,
          ...internal
        };
      }
    };
  }
});

// node_modules/@libp2p/peer-record/dist/src/errors.js
var codes2;
var init_errors3 = __esm({
  "node_modules/@libp2p/peer-record/dist/src/errors.js"() {
    codes2 = {
      ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
    };
  }
});

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
var init_envelope = __esm({
  "node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js"() {
    init_src2();
    (function(Envelope2) {
      let _codec;
      Envelope2.codec = () => {
        if (_codec == null) {
          _codec = message((obj, writer, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              writer.fork();
            }
            if (obj.publicKey != null) {
              writer.uint32(10);
              writer.bytes(obj.publicKey);
            } else {
              throw new Error('Protocol error: required field "publicKey" was not found in object');
            }
            if (obj.payloadType != null) {
              writer.uint32(18);
              writer.bytes(obj.payloadType);
            } else {
              throw new Error('Protocol error: required field "payloadType" was not found in object');
            }
            if (obj.payload != null) {
              writer.uint32(26);
              writer.bytes(obj.payload);
            } else {
              throw new Error('Protocol error: required field "payload" was not found in object');
            }
            if (obj.signature != null) {
              writer.uint32(42);
              writer.bytes(obj.signature);
            } else {
              throw new Error('Protocol error: required field "signature" was not found in object');
            }
            if (opts.lengthDelimited !== false) {
              writer.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              publicKey: new Uint8Array(0),
              payloadType: new Uint8Array(0),
              payload: new Uint8Array(0),
              signature: new Uint8Array(0)
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.publicKey = reader2.bytes();
                  break;
                case 2:
                  obj.payloadType = reader2.bytes();
                  break;
                case 3:
                  obj.payload = reader2.bytes();
                  break;
                case 5:
                  obj.signature = reader2.bytes();
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            if (obj.publicKey == null) {
              throw new Error('Protocol error: value for required field "publicKey" was not found in protobuf');
            }
            if (obj.payloadType == null) {
              throw new Error('Protocol error: value for required field "payloadType" was not found in protobuf');
            }
            if (obj.payload == null) {
              throw new Error('Protocol error: value for required field "payload" was not found in protobuf');
            }
            if (obj.signature == null) {
              throw new Error('Protocol error: value for required field "signature" was not found in protobuf');
            }
            return obj;
          });
        }
        return _codec;
      };
      Envelope2.encode = (obj) => {
        return encodeMessage(obj, Envelope2.codec());
      };
      Envelope2.decode = (buf) => {
        return decodeMessage(buf, Envelope2.codec());
      };
    })(Envelope || (Envelope = {}));
  }
});

// node_modules/byte-access/dist/src/index.js
function accessor(buf) {
  if (buf instanceof Uint8Array) {
    return {
      get(index) {
        return buf[index];
      },
      set(index, value) {
        buf[index] = value;
      }
    };
  }
  return {
    get(index) {
      return buf.get(index);
    },
    set(index, value) {
      buf.set(index, value);
    }
  };
}
var init_src14 = __esm({
  "node_modules/byte-access/dist/src/index.js"() {
  }
});

// node_modules/longbits/dist/src/index.js
var TWO_32, LongBits;
var init_src15 = __esm({
  "node_modules/longbits/dist/src/index.js"() {
    init_src14();
    TWO_32 = 4294967296;
    LongBits = class {
      constructor(hi = 0, lo = 0) {
        this.hi = hi;
        this.lo = lo;
      }
      toBigInt(unsigned2) {
        if (unsigned2 === true) {
          return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
        }
        if (this.hi >>> 31 !== 0) {
          const lo = ~this.lo + 1 >>> 0;
          let hi = ~this.hi >>> 0;
          if (lo === 0) {
            hi = hi + 1 >>> 0;
          }
          return -(BigInt(lo) + (BigInt(hi) << 32n));
        }
        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
      }
      toNumber(unsigned2) {
        return Number(this.toBigInt(unsigned2));
      }
      zzDecode() {
        const mask = -(this.lo & 1);
        const lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        const hi = (this.hi >>> 1 ^ mask) >>> 0;
        return new LongBits(hi, lo);
      }
      zzEncode() {
        const mask = this.hi >> 31;
        const hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        const lo = (this.lo << 1 ^ mask) >>> 0;
        return new LongBits(hi, lo);
      }
      toBytes(buf, offset = 0) {
        const access = accessor(buf);
        while (this.hi > 0) {
          access.set(offset++, this.lo & 127 | 128);
          this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0;
          this.hi >>>= 7;
        }
        while (this.lo > 127) {
          access.set(offset++, this.lo & 127 | 128);
          this.lo = this.lo >>> 7;
        }
        access.set(offset++, this.lo);
      }
      static fromBigInt(value) {
        if (value === 0n) {
          return new LongBits();
        }
        const negative = value < 0;
        if (negative) {
          value = -value;
        }
        let hi = Number(value >> 32n) | 0;
        let lo = Number(value - (BigInt(hi) << 32n)) | 0;
        if (negative) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > TWO_32) {
            lo = 0;
            if (++hi > TWO_32) {
              hi = 0;
            }
          }
        }
        return new LongBits(hi, lo);
      }
      static fromNumber(value) {
        if (value === 0) {
          return new LongBits();
        }
        const sign3 = value < 0;
        if (sign3) {
          value = -value;
        }
        let lo = value >>> 0;
        let hi = (value - lo) / 4294967296 >>> 0;
        if (sign3) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295) {
              hi = 0;
            }
          }
        }
        return new LongBits(hi, lo);
      }
      static fromBytes(buf, offset = 0) {
        const access = accessor(buf);
        const bits = new LongBits();
        let i = 0;
        if (buf.length - offset > 4) {
          for (; i < 4; ++i) {
            bits.lo = (bits.lo | (access.get(offset) & 127) << i * 7) >>> 0;
            if (access.get(offset++) < 128) {
              return bits;
            }
          }
          bits.lo = (bits.lo | (access.get(offset) & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (access.get(offset) & 127) >> 4) >>> 0;
          if (access.get(offset++) < 128) {
            return bits;
          }
          i = 0;
        } else {
          for (; i < 4; ++i) {
            if (offset >= buf.length) {
              throw RangeError(`index out of range: ${offset} > ${buf.length}`);
            }
            bits.lo = (bits.lo | (access.get(offset) & 127) << i * 7) >>> 0;
            if (access.get(offset++) < 128) {
              return bits;
            }
          }
        }
        if (buf.length - offset > 4) {
          for (; i < 5; ++i) {
            bits.hi = (bits.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;
            if (access.get(offset++) < 128) {
              return bits;
            }
          }
        } else if (offset < buf.byteLength) {
          for (; i < 5; ++i) {
            if (offset >= buf.length) {
              throw RangeError(`index out of range: ${offset} > ${buf.length}`);
            }
            bits.hi = (bits.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;
            if (access.get(offset++) < 128) {
              return bits;
            }
          }
        }
        throw RangeError("invalid varint encoding");
      }
    };
  }
});

// node_modules/uint8-varint/dist/src/index.js
var N12, N22, N32, N42, N52, N62, N72, N82, N92, unsigned;
var init_src16 = __esm({
  "node_modules/uint8-varint/dist/src/index.js"() {
    init_src15();
    init_alloc();
    N12 = Math.pow(2, 7);
    N22 = Math.pow(2, 14);
    N32 = Math.pow(2, 21);
    N42 = Math.pow(2, 28);
    N52 = Math.pow(2, 35);
    N62 = Math.pow(2, 42);
    N72 = Math.pow(2, 49);
    N82 = Math.pow(2, 56);
    N92 = Math.pow(2, 63);
    unsigned = {
      encodingLength(value) {
        if (value < N12) {
          return 1;
        }
        if (value < N22) {
          return 2;
        }
        if (value < N32) {
          return 3;
        }
        if (value < N42) {
          return 4;
        }
        if (value < N52) {
          return 5;
        }
        if (value < N62) {
          return 6;
        }
        if (value < N72) {
          return 7;
        }
        if (value < N82) {
          return 8;
        }
        if (value < N92) {
          return 9;
        }
        return 10;
      },
      encode(value, buf, offset = 0) {
        if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
          throw new RangeError("Could not encode varint");
        }
        if (buf == null) {
          buf = allocUnsafe(unsigned.encodingLength(value));
        }
        LongBits.fromNumber(value).toBytes(buf, offset);
        return buf;
      },
      decode(buf, offset = 0) {
        return LongBits.fromBytes(buf, offset).toNumber(true);
      }
    };
  }
});

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var import_err_code15, _a, RecordEnvelope, formatSignaturePayload;
var init_envelope2 = __esm({
  "node_modules/@libp2p/peer-record/dist/src/envelope/index.js"() {
    import_err_code15 = __toESM(require_err_code(), 1);
    init_from_string();
    init_equals();
    init_keys2();
    init_errors3();
    init_envelope();
    init_src4();
    init_src11();
    init_src16();
    RecordEnvelope = class {
      constructor(init) {
        const { peerId, payloadType, payload, signature } = init;
        this.peerId = peerId;
        this.payloadType = payloadType;
        this.payload = payload;
        this.signature = signature;
      }
      marshal() {
        if (this.peerId.publicKey == null) {
          throw new Error("Missing public key");
        }
        if (this.marshaled == null) {
          this.marshaled = Envelope.encode({
            publicKey: this.peerId.publicKey,
            payloadType: this.payloadType,
            payload: this.payload.subarray(),
            signature: this.signature
          });
        }
        return this.marshaled;
      }
      equals(other) {
        return equals3(this.marshal(), other.marshal());
      }
      async validate(domain) {
        const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
        if (this.peerId.publicKey == null) {
          throw new Error("Missing public key");
        }
        const key = unmarshalPublicKey(this.peerId.publicKey);
        return await key.verify(signData.subarray(), this.signature);
      }
    };
    _a = RecordEnvelope;
    RecordEnvelope.createFromProtobuf = async (data) => {
      const envelopeData = Envelope.decode(data);
      const peerId = await peerIdFromKeys(envelopeData.publicKey);
      return new RecordEnvelope({
        peerId,
        payloadType: envelopeData.payloadType,
        payload: envelopeData.payload,
        signature: envelopeData.signature
      });
    };
    RecordEnvelope.seal = async (record, peerId) => {
      if (peerId.privateKey == null) {
        throw new Error("Missing private key");
      }
      const domain = record.domain;
      const payloadType = record.codec;
      const payload = record.marshal();
      const signData = formatSignaturePayload(domain, payloadType, payload);
      const key = await unmarshalPrivateKey2(peerId.privateKey);
      const signature = await key.sign(signData.subarray());
      return new RecordEnvelope({
        peerId,
        payloadType,
        payload,
        signature
      });
    };
    RecordEnvelope.openAndCertify = async (data, domain) => {
      const envelope = await RecordEnvelope.createFromProtobuf(data);
      const valid = await envelope.validate(domain);
      if (!valid) {
        throw (0, import_err_code15.default)(new Error("envelope signature is not valid for the given domain"), codes2.ERR_SIGNATURE_NOT_VALID);
      }
      return envelope;
    };
    formatSignaturePayload = (domain, payloadType, payload) => {
      const domainUint8Array = fromString2(domain);
      const domainLength = unsigned.encode(domainUint8Array.byteLength);
      const payloadTypeLength = unsigned.encode(payloadType.length);
      const payloadLength = unsigned.encode(payload.length);
      return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
    };
  }
});

// node_modules/@multiformats/multiaddr/node_modules/ip-regex/index.js
var word, boundry, v4, v6segment, v6, v46Exact, v4exact, v6exact, ipRegex, ip_regex_default;
var init_ip_regex = __esm({
  "node_modules/@multiformats/multiaddr/node_modules/ip-regex/index.js"() {
    word = "[a-fA-F\\d:]";
    boundry = (options2) => options2 && options2.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
    v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    v6segment = "[a-fA-F\\d]{1,4}";
    v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
    v4exact = new RegExp(`^${v4}$`);
    v6exact = new RegExp(`^${v6}$`);
    ipRegex = (options2) => options2 && options2.exact ? v46Exact : new RegExp(`(?:${boundry(options2)}${v4}${boundry(options2)})|(?:${boundry(options2)}${v6}${boundry(options2)})`, "g");
    ipRegex.v4 = (options2) => options2 && options2.exact ? v4exact : new RegExp(`${boundry(options2)}${v4}${boundry(options2)}`, "g");
    ipRegex.v6 = (options2) => options2 && options2.exact ? v6exact : new RegExp(`${boundry(options2)}${v6}${boundry(options2)}`, "g");
    ip_regex_default = ipRegex;
  }
});

// node_modules/function-timeout/index.js
function functionTimeout(function_, { timeout } = {}) {
  const script = new import_node_vm.default.Script("returnValue = function_()");
  const wrappedFunction = (...arguments_) => {
    const context = {
      function_: () => function_(...arguments_)
    };
    script.runInNewContext(context, { timeout });
    return context.returnValue;
  };
  Object.defineProperty(wrappedFunction, "name", {
    value: `functionTimeout(${function_.name || "<anonymous>"})`,
    configurable: true
  });
  return wrappedFunction;
}
function isTimeoutError(error) {
  return (error == null ? void 0 : error.code) === "ERR_SCRIPT_EXECUTION_TIMEOUT";
}
var import_node_vm;
var init_function_timeout = __esm({
  "node_modules/function-timeout/index.js"() {
    import_node_vm = __toESM(require("node:vm"), 1);
  }
});

// node_modules/convert-hrtime/index.js
var init_convert_hrtime = __esm({
  "node_modules/convert-hrtime/index.js"() {
  }
});

// node_modules/time-span/index.js
var init_time_span = __esm({
  "node_modules/time-span/index.js"() {
    init_convert_hrtime();
  }
});

// node_modules/is-regexp/index.js
function isRegexp(value) {
  return toString3.call(value) === "[object RegExp]";
}
var toString3;
var init_is_regexp = __esm({
  "node_modules/is-regexp/index.js"() {
    ({ toString: toString3 } = Object.prototype);
  }
});

// node_modules/clone-regexp/index.js
function clonedRegexp(regexp, options2 = {}) {
  if (!isRegexp(regexp)) {
    throw new TypeError("Expected a RegExp instance");
  }
  const flags = Object.keys(flagMap).map((flag) => (typeof options2[flag] === "boolean" ? options2[flag] : regexp[flag]) ? flagMap[flag] : "").join("");
  const clonedRegexp2 = new RegExp(options2.source || regexp.source, flags);
  clonedRegexp2.lastIndex = typeof options2.lastIndex === "number" ? options2.lastIndex : regexp.lastIndex;
  return clonedRegexp2;
}
var flagMap;
var init_clone_regexp = __esm({
  "node_modules/clone-regexp/index.js"() {
    init_is_regexp();
    flagMap = {
      global: "g",
      ignoreCase: "i",
      multiline: "m",
      dotAll: "s",
      sticky: "y",
      unicode: "u"
    };
  }
});

// node_modules/super-regex/index.js
function isMatch(regex, string2, { timeout } = {}) {
  try {
    return functionTimeout(() => clonedRegexp(regex).test(string2), { timeout })();
  } catch (error) {
    if (isTimeoutError(error)) {
      return false;
    }
    throw error;
  }
}
var init_super_regex = __esm({
  "node_modules/super-regex/index.js"() {
    init_function_timeout();
    init_time_span();
    init_clone_regexp();
  }
});

// node_modules/@multiformats/multiaddr/node_modules/is-ip/index.js
function isIP(string2) {
  return isMatch(ip_regex_default({ exact: true }), string2.slice(0, maxIPv6Length), options);
}
function isIPv6(string2) {
  return isMatch(ip_regex_default.v6({ exact: true }), string2.slice(0, maxIPv6Length), options);
}
function isIPv4(string2) {
  return isMatch(ip_regex_default.v4({ exact: true }), string2.slice(0, maxIPv4Length), options);
}
var maxIPv4Length, maxIPv6Length, options;
var init_is_ip = __esm({
  "node_modules/@multiformats/multiaddr/node_modules/is-ip/index.js"() {
    init_ip_regex();
    init_super_regex();
    maxIPv4Length = 15;
    maxIPv6Length = 45;
    options = {
      timeout: 400
    };
  }
});

// node_modules/@multiformats/multiaddr/dist/src/ip.js
var isV4, isV6, toBytes, toString4;
var init_ip = __esm({
  "node_modules/@multiformats/multiaddr/dist/src/ip.js"() {
    init_is_ip();
    init_to_string();
    init_is_ip();
    isV4 = isIPv4;
    isV6 = isIPv6;
    toBytes = function(ip) {
      let offset = 0;
      let result;
      ip = ip.trim();
      if (isV4(ip)) {
        result = new Uint8Array(offset + 4);
        ip.split(/\./g).forEach((byte) => {
          result[offset++] = parseInt(byte, 10) & 255;
        });
      } else if (isV6(ip)) {
        const sections = ip.split(":", 8);
        let i;
        for (i = 0; i < sections.length; i++) {
          const isv4 = isV4(sections[i]);
          let v4Buffer;
          if (isv4) {
            v4Buffer = toBytes(sections[i]);
            sections[i] = toString2(v4Buffer.slice(0, 2), "base16");
          }
          if (v4Buffer != null && ++i < 8) {
            sections.splice(i, 0, toString2(v4Buffer.slice(2, 4), "base16"));
          }
        }
        if (sections[0] === "") {
          while (sections.length < 8)
            sections.unshift("0");
        } else if (sections[sections.length - 1] === "") {
          while (sections.length < 8)
            sections.push("0");
        } else if (sections.length < 8) {
          for (i = 0; i < sections.length && sections[i] !== ""; i++)
            ;
          const argv = [i, 1];
          for (i = 9 - sections.length; i > 0; i--) {
            argv.push("0");
          }
          sections.splice.apply(sections, argv);
        }
        result = new Uint8Array(offset + 16);
        for (i = 0; i < sections.length; i++) {
          const word2 = parseInt(sections[i], 16);
          result[offset++] = word2 >> 8 & 255;
          result[offset++] = word2 & 255;
        }
      }
      if (result == null) {
        throw new Error(`invalid ip address "${ip}"`);
      }
      return result;
    };
    toString4 = function(buf, offset = 0, length2) {
      offset = ~~offset;
      length2 = length2 ?? buf.length - offset;
      const result = [];
      let string2 = "";
      const view = new DataView(buf.buffer);
      if (length2 === 4) {
        for (let i = 0; i < length2; i++) {
          result.push(buf[offset + i]);
        }
        string2 = result.join(".");
      } else if (length2 === 16) {
        for (let i = 0; i < length2; i += 2) {
          result.push(view.getUint16(offset + i).toString(16));
        }
        string2 = result.join(":");
        string2 = string2.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
        string2 = string2.replace(/:{3,4}/, "::");
      }
      return string2;
    };
  }
});

// node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
function createProtocol(code2, size, name2, resolvable, path2) {
  return {
    code: code2,
    size,
    name: name2,
    resolvable: Boolean(resolvable),
    path: Boolean(path2)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes3[proto] != null) {
      return codes3[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names2[proto] != null) {
      return names2[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}
var V, names2, codes3, table;
var init_protocols_table = __esm({
  "node_modules/@multiformats/multiaddr/dist/src/protocols-table.js"() {
    V = -1;
    names2 = {};
    codes3 = {};
    table = [
      [4, 32, "ip4"],
      [6, 16, "tcp"],
      [33, 16, "dccp"],
      [41, 128, "ip6"],
      [42, V, "ip6zone"],
      [53, V, "dns", true],
      [54, V, "dns4", true],
      [55, V, "dns6", true],
      [56, V, "dnsaddr", true],
      [132, 16, "sctp"],
      [273, 16, "udp"],
      [275, 0, "p2p-webrtc-star"],
      [276, 0, "p2p-webrtc-direct"],
      [277, 0, "p2p-stardust"],
      [280, 0, "webrtc"],
      [290, 0, "p2p-circuit"],
      [301, 0, "udt"],
      [302, 0, "utp"],
      [400, V, "unix", false, true],
      [421, V, "ipfs"],
      [421, V, "p2p"],
      [443, 0, "https"],
      [444, 96, "onion"],
      [445, 296, "onion3"],
      [446, V, "garlic64"],
      [460, 0, "quic"],
      [466, V, "certhash"],
      [477, 0, "ws"],
      [478, 0, "wss"],
      [479, 0, "p2p-websocket-star"],
      [480, 0, "http"],
      [777, V, "memory"]
    ];
    table.forEach((row) => {
      const proto = createProtocol(...row);
      codes3[proto.code] = proto;
      names2[proto.name] = proto;
    });
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode6;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode6(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode6.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode6.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    var N13 = Math.pow(2, 7);
    var N23 = Math.pow(2, 14);
    var N33 = Math.pow(2, 21);
    var N43 = Math.pow(2, 28);
    var N53 = Math.pow(2, 35);
    var N63 = Math.pow(2, 42);
    var N73 = Math.pow(2, 49);
    var N83 = Math.pow(2, 56);
    var N93 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/@multiformats/multiaddr/dist/src/convert.js
function convertToString(proto, buf) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
    case 41:
      return bytes2ip(buf);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return bytes2str(buf);
    case 421:
      return bytes2mh(buf);
    case 444:
      return bytes2onion(buf);
    case 445:
      return bytes2onion(buf);
    case 466:
      return bytes2mb(buf);
    default:
      return toString2(buf, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    default:
      return fromString2(str, "base16");
  }
}
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error(`invalid ip address "${ipString}"`);
  }
  return toBytes(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString4(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error(`invalid ip address "${ipString}"`);
  }
  return ipString;
}
function port2bytes(port) {
  const buf = new ArrayBuffer(2);
  const view = new DataView(buf);
  view.setUint16(0, port);
  return new Uint8Array(buf);
}
function bytes2port(buf) {
  const view = new DataView(buf.buffer);
  return view.getUint16(buf.byteOffset);
}
function str2bytes(str) {
  const buf = fromString2(str);
  const size = Uint8Array.from(import_varint2.default.encode(buf.length));
  return concat([size, buf], size.length + buf.length);
}
function bytes2str(buf) {
  const size = import_varint2.default.decode(buf);
  buf = buf.slice(import_varint2.default.decode.bytes);
  if (buf.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString2(buf);
}
function mh2bytes(hash) {
  let mh;
  if (hash[0] === "Q" || hash[0] === "1") {
    mh = decode5(base58btc.decode(`z${hash}`)).bytes;
  } else {
    mh = CID.parse(hash).multihash.bytes;
  }
  const size = Uint8Array.from(import_varint2.default.encode(mh.length));
  return concat([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(import_varint2.default.encode(mb.length));
  return concat([size, mb], size.length + mb.length);
}
function bytes2mb(buf) {
  const size = import_varint2.default.decode(buf);
  const hash = buf.slice(import_varint2.default.decode.bytes);
  if (hash.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString2(hash, "base64url");
}
function bytes2mh(buf) {
  const size = import_varint2.default.decode(buf);
  const address = buf.slice(import_varint2.default.decode.bytes);
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString2(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf = base32.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf, portBuf], buf.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf, portBuf], buf.length + portBuf.length);
}
function bytes2onion(buf) {
  const addrBytes = buf.slice(0, buf.length - 2);
  const portBytes = buf.slice(buf.length - 2);
  const addr = toString2(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}
var import_varint2, decoders, anybaseDecoder;
var init_convert = __esm({
  "node_modules/@multiformats/multiaddr/dist/src/convert.js"() {
    init_ip();
    init_protocols_table();
    init_cid();
    init_base32();
    init_base58();
    init_basics();
    init_digest();
    import_varint2 = __toESM(require_varint(), 1);
    init_to_string();
    init_from_string();
    init_concat();
    decoders = Object.values(bases).map((c) => c.decoder);
    anybaseDecoder = function() {
      let acc = decoders[0].or(decoders[1]);
      decoders.slice(2).forEach((d) => acc = acc.or(d));
      return acc;
    }();
  }
});

// node_modules/@multiformats/multiaddr/dist/src/codec.js
function stringToStringTuples(str) {
  const tuples = [];
  const parts = str.split("/").slice(1);
  if (parts.length === 1 && parts[0] === "") {
    return [];
  }
  for (let p = 0; p < parts.length; p++) {
    const part = parts[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p++;
    if (p >= parts.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        cleanPath(parts.slice(p).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts[p]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes(concat(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf = Uint8Array.from(import_varint3.default.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf = concat([buf, tup[1]]);
    }
    return buf;
  })));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = import_varint3.default.decode(addr);
    return size + import_varint3.default.decode.bytes;
  }
}
function bytesToTuples(buf) {
  const tuples = [];
  let i = 0;
  while (i < buf.length) {
    const code2 = import_varint3.default.decode(buf, i);
    const n = import_varint3.default.decode.bytes;
    const p = getProtocol(code2);
    const size = sizeForAddr(p, buf.slice(i + n));
    if (size === 0) {
      tuples.push([code2]);
      i += n;
      continue;
    }
    const addr = buf.slice(i + n, i + n + size);
    i += size + n;
    if (i > buf.length) {
      throw ParseError("Invalid address Uint8Array: " + toString2(buf, "base16"));
    }
    tuples.push([code2, addr]);
  }
  return tuples;
}
function bytesToString(buf) {
  const a = bytesToTuples(buf);
  const b = tuplesToStringTuples(a);
  return stringTuplesToString(b);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a = stringToStringTuples(str);
  const b = stringTuplesToTuples(a);
  return tuplesToBytes(b);
}
function fromString3(str) {
  return stringToBytes(str);
}
function fromBytes(buf) {
  const err = validateBytes(buf);
  if (err != null) {
    throw err;
  }
  return Uint8Array.from(buf);
}
function validateBytes(buf) {
  try {
    bytesToTuples(buf);
  } catch (err) {
    return err;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}
var import_varint3;
var init_codec2 = __esm({
  "node_modules/@multiformats/multiaddr/dist/src/codec.js"() {
    init_convert();
    init_protocols_table();
    import_varint3 = __toESM(require_varint(), 1);
    init_concat();
    init_to_string();
  }
});

// node_modules/@multiformats/multiaddr/dist/src/index.js
var import_varint4, import_err_code16, inspect, DNS_CODES, P2P_CODES, resolvers, symbol3, Multiaddr;
var init_src17 = __esm({
  "node_modules/@multiformats/multiaddr/dist/src/index.js"() {
    init_codec2();
    init_protocols_table();
    import_varint4 = __toESM(require_varint(), 1);
    init_cid();
    init_base58();
    import_err_code16 = __toESM(require_err_code(), 1);
    init_to_string();
    init_equals();
    inspect = Symbol.for("nodejs.util.inspect.custom");
    DNS_CODES = [
      getProtocol("dns").code,
      getProtocol("dns4").code,
      getProtocol("dns6").code,
      getProtocol("dnsaddr").code
    ];
    P2P_CODES = [
      getProtocol("p2p").code,
      getProtocol("ipfs").code
    ];
    resolvers = /* @__PURE__ */ new Map();
    symbol3 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
    Multiaddr = class {
      constructor(addr) {
        if (addr == null) {
          addr = "";
        }
        Object.defineProperty(this, symbol3, { value: true });
        if (addr instanceof Uint8Array) {
          this.bytes = fromBytes(addr);
        } else if (typeof addr === "string") {
          if (addr.length > 0 && addr.charAt(0) !== "/") {
            throw new Error(`multiaddr "${addr}" must start with a "/"`);
          }
          this.bytes = fromString3(addr);
        } else if (Multiaddr.isMultiaddr(addr)) {
          this.bytes = fromBytes(addr.bytes);
        } else {
          throw new Error("addr must be a string, Buffer, or another Multiaddr");
        }
      }
      toString() {
        return bytesToString(this.bytes);
      }
      toJSON() {
        return this.toString();
      }
      toOptions() {
        const codes5 = this.protoCodes();
        const parts = this.toString().split("/").slice(1);
        let transport;
        let port;
        if (parts.length > 2) {
          if (DNS_CODES.includes(codes5[0]) && P2P_CODES.includes(codes5[1])) {
            transport = getProtocol("tcp").name;
            port = 443;
          } else {
            transport = getProtocol(parts[2]).name;
            port = parseInt(parts[3]);
          }
        } else if (DNS_CODES.includes(codes5[0])) {
          transport = getProtocol("tcp").name;
          port = 443;
        } else {
          throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
        }
        const opts = {
          family: codes5[0] === 41 || codes5[0] === 55 ? 6 : 4,
          host: parts[1],
          transport,
          port
        };
        return opts;
      }
      protos() {
        return this.protoCodes().map((code2) => Object.assign({}, getProtocol(code2)));
      }
      protoCodes() {
        const codes5 = [];
        const buf = this.bytes;
        let i = 0;
        while (i < buf.length) {
          const code2 = import_varint4.default.decode(buf, i);
          const n = import_varint4.default.decode.bytes;
          const p = getProtocol(code2);
          const size = sizeForAddr(p, buf.slice(i + n));
          i += size + n;
          codes5.push(code2);
        }
        return codes5;
      }
      protoNames() {
        return this.protos().map((proto) => proto.name);
      }
      tuples() {
        return bytesToTuples(this.bytes);
      }
      stringTuples() {
        const t = bytesToTuples(this.bytes);
        return tuplesToStringTuples(t);
      }
      encapsulate(addr) {
        addr = new Multiaddr(addr);
        return new Multiaddr(this.toString() + addr.toString());
      }
      decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
          throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
        }
        return new Multiaddr(s.slice(0, i));
      }
      decapsulateCode(code2) {
        const tuples = this.tuples();
        for (let i = tuples.length - 1; i >= 0; i--) {
          if (tuples[i][0] === code2) {
            return new Multiaddr(tuplesToBytes(tuples.slice(0, i)));
          }
        }
        return this;
      }
      getPeerId() {
        try {
          const tuples = this.stringTuples().filter((tuple2) => {
            if (tuple2[0] === names2.ipfs.code) {
              return true;
            }
            return false;
          });
          const tuple = tuples.pop();
          if ((tuple == null ? void 0 : tuple[1]) != null) {
            const peerIdStr = tuple[1];
            if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
              return toString2(base58btc.decode(`z${peerIdStr}`), "base58btc");
            }
            return toString2(CID.parse(peerIdStr).multihash.bytes, "base58btc");
          }
          return null;
        } catch (e) {
          return null;
        }
      }
      getPath() {
        let path2 = null;
        try {
          path2 = this.stringTuples().filter((tuple) => {
            const proto = getProtocol(tuple[0]);
            if (proto.path === true) {
              return true;
            }
            return false;
          })[0][1];
          if (path2 == null) {
            path2 = null;
          }
        } catch {
          path2 = null;
        }
        return path2;
      }
      equals(addr) {
        return equals3(this.bytes, addr.bytes);
      }
      async resolve(options2) {
        const resolvableProto = this.protos().find((p) => p.resolvable);
        if (resolvableProto == null) {
          return [this];
        }
        const resolver = resolvers.get(resolvableProto.name);
        if (resolver == null) {
          throw (0, import_err_code16.default)(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
        }
        const addresses = await resolver(this, options2);
        return addresses.map((a) => new Multiaddr(a));
      }
      nodeAddress() {
        const options2 = this.toOptions();
        if (options2.transport !== "tcp" && options2.transport !== "udp") {
          throw new Error(`multiaddr must have a valid format - no protocol with name: "${options2.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
        }
        return {
          family: options2.family,
          address: options2.host,
          port: options2.port
        };
      }
      isThinWaistAddress(addr) {
        const protos = (addr ?? this).protos();
        if (protos.length !== 2) {
          return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
          return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
          return false;
        }
        return true;
      }
      static fromNodeAddress(addr, transport) {
        if (addr == null) {
          throw new Error("requires node address object");
        }
        if (transport == null) {
          throw new Error("requires transport protocol");
        }
        let ip;
        switch (addr.family) {
          case 4:
            ip = "ip4";
            break;
          case 6:
            ip = "ip6";
            break;
          default:
            throw Error("Invalid addr family, should be 4 or 6.");
        }
        return new Multiaddr("/" + [ip, addr.address, transport, addr.port].join("/"));
      }
      static isName(addr) {
        if (!Multiaddr.isMultiaddr(addr)) {
          return false;
        }
        return addr.protos().some((proto) => proto.resolvable);
      }
      static isMultiaddr(value) {
        return Boolean(value == null ? void 0 : value[symbol3]);
      }
      [inspect]() {
        return "<Multiaddr " + toString2(this.bytes, "base16") + " - " + bytesToString(this.bytes) + ">";
      }
      inspect() {
        return "<Multiaddr " + toString2(this.bytes, "base16") + " - " + bytesToString(this.bytes) + ">";
      }
    };
    Multiaddr.resolvers = resolvers;
  }
});

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort = (a2, b2) => a2.toString().localeCompare(b2.toString());
  return a.length === b.length && b.sort(sort) && a.sort(sort).every((item, index) => b[index].equals(item));
}
var init_array_equals = __esm({
  "node_modules/@libp2p/utils/dist/src/array-equals.js"() {
  }
});

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
var init_peer_record = __esm({
  "node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js"() {
    init_src2();
    (function(PeerRecord3) {
      let AddressInfo;
      (function(AddressInfo2) {
        let _codec2;
        AddressInfo2.codec = () => {
          if (_codec2 == null) {
            _codec2 = message((obj, writer, opts = {}) => {
              if (opts.lengthDelimited !== false) {
                writer.fork();
              }
              if (obj.multiaddr != null) {
                writer.uint32(10);
                writer.bytes(obj.multiaddr);
              } else {
                throw new Error('Protocol error: required field "multiaddr" was not found in object');
              }
              if (opts.lengthDelimited !== false) {
                writer.ldelim();
              }
            }, (reader2, length2) => {
              const obj = {
                multiaddr: new Uint8Array(0)
              };
              const end = length2 == null ? reader2.len : reader2.pos + length2;
              while (reader2.pos < end) {
                const tag = reader2.uint32();
                switch (tag >>> 3) {
                  case 1:
                    obj.multiaddr = reader2.bytes();
                    break;
                  default:
                    reader2.skipType(tag & 7);
                    break;
                }
              }
              if (obj.multiaddr == null) {
                throw new Error('Protocol error: value for required field "multiaddr" was not found in protobuf');
              }
              return obj;
            });
          }
          return _codec2;
        };
        AddressInfo2.encode = (obj) => {
          return encodeMessage(obj, AddressInfo2.codec());
        };
        AddressInfo2.decode = (buf) => {
          return decodeMessage(buf, AddressInfo2.codec());
        };
      })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
      let _codec;
      PeerRecord3.codec = () => {
        if (_codec == null) {
          _codec = message((obj, writer, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              writer.fork();
            }
            if (obj.peerId != null) {
              writer.uint32(10);
              writer.bytes(obj.peerId);
            } else {
              throw new Error('Protocol error: required field "peerId" was not found in object');
            }
            if (obj.seq != null) {
              writer.uint32(16);
              writer.uint64(obj.seq);
            } else {
              throw new Error('Protocol error: required field "seq" was not found in object');
            }
            if (obj.addresses != null) {
              for (const value of obj.addresses) {
                writer.uint32(26);
                PeerRecord3.AddressInfo.codec().encode(value, writer);
              }
            } else {
              throw new Error('Protocol error: required field "addresses" was not found in object');
            }
            if (opts.lengthDelimited !== false) {
              writer.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              peerId: new Uint8Array(0),
              seq: 0n,
              addresses: []
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.peerId = reader2.bytes();
                  break;
                case 2:
                  obj.seq = reader2.uint64();
                  break;
                case 3:
                  obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader2, reader2.uint32()));
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            if (obj.peerId == null) {
              throw new Error('Protocol error: value for required field "peerId" was not found in protobuf');
            }
            if (obj.seq == null) {
              throw new Error('Protocol error: value for required field "seq" was not found in protobuf');
            }
            return obj;
          });
        }
        return _codec;
      };
      PeerRecord3.encode = (obj) => {
        return encodeMessage(obj, PeerRecord3.codec());
      };
      PeerRecord3.decode = (buf) => {
        return decodeMessage(buf, PeerRecord3.codec());
      };
    })(PeerRecord || (PeerRecord = {}));
  }
});

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD, ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
var init_consts = __esm({
  "node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js"() {
    ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
    ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);
  }
});

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var PeerRecord2;
var init_peer_record2 = __esm({
  "node_modules/@libp2p/peer-record/dist/src/peer-record/index.js"() {
    init_src17();
    init_array_equals();
    init_src4();
    init_peer_record();
    init_consts();
    PeerRecord2 = class {
      constructor(init) {
        this.domain = PeerRecord2.DOMAIN;
        this.codec = PeerRecord2.CODEC;
        const { peerId, multiaddrs, seqNumber } = init;
        this.peerId = peerId;
        this.multiaddrs = multiaddrs ?? [];
        this.seqNumber = seqNumber ?? BigInt(Date.now());
      }
      marshal() {
        if (this.marshaled == null) {
          this.marshaled = PeerRecord.encode({
            peerId: this.peerId.toBytes(),
            seq: BigInt(this.seqNumber),
            addresses: this.multiaddrs.map((m) => ({
              multiaddr: m.bytes
            }))
          });
        }
        return this.marshaled;
      }
      equals(other) {
        if (!(other instanceof PeerRecord2)) {
          return false;
        }
        if (!this.peerId.equals(other.peerId)) {
          return false;
        }
        if (this.seqNumber !== other.seqNumber) {
          return false;
        }
        if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
          return false;
        }
        return true;
      }
    };
    PeerRecord2.createFromProtobuf = (buf) => {
      const peerRecord = PeerRecord.decode(buf);
      const peerId = peerIdFromBytes(peerRecord.peerId);
      const multiaddrs = (peerRecord.addresses ?? []).map((a) => new Multiaddr(a.multiaddr));
      const seqNumber = peerRecord.seq;
      return new PeerRecord2({ peerId, multiaddrs, seqNumber });
    };
    PeerRecord2.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
    PeerRecord2.CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
  }
});

// node_modules/@libp2p/peer-record/dist/src/index.js
var init_src18 = __esm({
  "node_modules/@libp2p/peer-record/dist/src/index.js"() {
    init_envelope2();
    init_peer_record2();
  }
});

// node_modules/@libp2p/interface-registrar/dist/src/index.js
var topologySymbol;
var init_src19 = __esm({
  "node_modules/@libp2p/interface-registrar/dist/src/index.js"() {
    topologySymbol = Symbol.for("@libp2p/topology");
  }
});

// node_modules/@libp2p/topology/dist/src/index.js
function createTopology(init) {
  return new TopologyImpl(init);
}
var noop, TopologyImpl;
var init_src20 = __esm({
  "node_modules/@libp2p/topology/dist/src/index.js"() {
    init_src19();
    noop = () => {
    };
    TopologyImpl = class {
      constructor(init) {
        this.min = init.min ?? 0;
        this.max = init.max ?? Infinity;
        this.peers = /* @__PURE__ */ new Set();
        this.onConnect = init.onConnect ?? noop;
        this.onDisconnect = init.onDisconnect ?? noop;
      }
      get [Symbol.toStringTag]() {
        return topologySymbol.toString();
      }
      get [topologySymbol]() {
        return true;
      }
      async setRegistrar(registrar) {
        this.registrar = registrar;
      }
      disconnect(peerId) {
        this.onDisconnect(peerId);
      }
    };
  }
});

// node_modules/@libp2p/interfaces/dist/src/events.js
var __classPrivateFieldGet, _EventEmitter_listeners, EventEmitter, CustomEventPolyfill, CustomEvent;
var init_events = __esm({
  "node_modules/@libp2p/interfaces/dist/src/events.js"() {
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    EventEmitter = class extends EventTarget {
      constructor() {
        super(...arguments);
        _EventEmitter_listeners.set(this, /* @__PURE__ */ new Map());
      }
      listenerCount(type) {
        const listeners = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
        if (listeners == null) {
          return 0;
        }
        return listeners.length;
      }
      addEventListener(type, listener, options2) {
        super.addEventListener(type, listener, options2);
        let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
        if (list == null) {
          list = [];
          __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(type, list);
        }
        list.push({
          callback: listener,
          once: (options2 !== true && options2 !== false && (options2 == null ? void 0 : options2.once)) ?? false
        });
      }
      removeEventListener(type, listener, options2) {
        super.removeEventListener(type.toString(), listener ?? null, options2);
        let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
        if (list == null) {
          return;
        }
        list = list.filter(({ callback }) => callback !== listener);
        __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(type, list);
      }
      dispatchEvent(event) {
        const result = super.dispatchEvent(event);
        let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(event.type);
        if (list == null) {
          return result;
        }
        list = list.filter(({ once }) => !once);
        __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(event.type, list);
        return result;
      }
    };
    _EventEmitter_listeners = /* @__PURE__ */ new WeakMap();
    CustomEventPolyfill = class extends Event {
      constructor(message2, data) {
        super(message2, data);
        this.detail = data == null ? void 0 : data.detail;
      }
    };
    CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message-cache.js
var MessageCache;
var init_message_cache = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/message-cache.js"() {
    MessageCache = class {
      constructor(gossip, historyCapacity, msgIdToStrFn) {
        this.gossip = gossip;
        this.msgs = /* @__PURE__ */ new Map();
        this.history = [];
        this.msgIdToStrFn = msgIdToStrFn;
        for (let i = 0; i < historyCapacity; i++) {
          this.history[i] = [];
        }
      }
      get size() {
        return this.msgs.size;
      }
      put(messageId, msg, validated = false) {
        const { msgIdStr } = messageId;
        if (this.msgs.has(msgIdStr)) {
          return false;
        }
        this.msgs.set(msgIdStr, {
          message: msg,
          validated,
          originatingPeers: /* @__PURE__ */ new Set(),
          iwantCounts: /* @__PURE__ */ new Map()
        });
        this.history[0].push({ ...messageId, topic: msg.topic });
        return true;
      }
      observeDuplicate(msgId2, fromPeerIdStr) {
        const entry = this.msgs.get(msgId2);
        if (entry && !entry.validated) {
          entry.originatingPeers.add(fromPeerIdStr);
        }
      }
      get(msgId2) {
        var _a2;
        return (_a2 = this.msgs.get(this.msgIdToStrFn(msgId2))) == null ? void 0 : _a2.message;
      }
      getWithIWantCount(msgIdStr, p) {
        const msg = this.msgs.get(msgIdStr);
        if (!msg) {
          return null;
        }
        const count = (msg.iwantCounts.get(p) ?? 0) + 1;
        msg.iwantCounts.set(p, count);
        return { msg: msg.message, count };
      }
      getGossipIDs(topics) {
        const msgIdsByTopic = /* @__PURE__ */ new Map();
        for (let i = 0; i < this.gossip; i++) {
          this.history[i].forEach((entry) => {
            const msg = this.msgs.get(entry.msgIdStr);
            if (msg && msg.validated && topics.has(entry.topic)) {
              let msgIds = msgIdsByTopic.get(entry.topic);
              if (!msgIds) {
                msgIds = [];
                msgIdsByTopic.set(entry.topic, msgIds);
              }
              msgIds.push(entry.msgId);
            }
          });
        }
        return msgIdsByTopic;
      }
      validate(msgId2) {
        const entry = this.msgs.get(msgId2);
        if (!entry) {
          return null;
        }
        const { message: message2, originatingPeers } = entry;
        entry.validated = true;
        entry.originatingPeers = /* @__PURE__ */ new Set();
        return { message: message2, originatingPeers };
      }
      shift() {
        const last = this.history[this.history.length - 1];
        last.forEach((entry) => {
          this.msgs.delete(entry.msgIdStr);
        });
        this.history.pop();
        this.history.unshift([]);
      }
      remove(msgId2) {
        const entry = this.msgs.get(msgId2);
        if (!entry) {
          return null;
        }
        this.msgs.delete(msgId2);
        return entry;
      }
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits2;
    var util = require_minimal2();
    function LongBits2(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits2.zero = new LongBits2(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits2.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign3 = value < 0;
      if (sign3)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign3) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits2(lo, hi);
    };
    LongBits2.from = function from3(value) {
      if (typeof value === "number")
        return LongBits2.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits2.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits2.prototype.toNumber = function toNumber(unsigned2) {
      if (!unsigned2 && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits2.prototype.toLong = function toLong(unsigned2) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits2.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits2(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits2.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits2.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.length = function length2() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits2();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned2) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned2);
      return bits.toNumber(Boolean(unsigned2));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src2[keys[i]];
      return dst;
    }
    util.merge = merge2;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name2;
      } });
      CustomError.prototype.toString = function toString5() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name2)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util = require_minimal2();
    var BufferWriter;
    var LongBits2 = util.LongBits;
    var base642 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create4 = function create5() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create4();
    Writer2.alloc = function alloc2(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer2.alloc = util.pool(Writer2.alloc, util.Array.prototype.subarray);
    Writer2.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits2.fromNumber(value)) : this.uint32(value);
    };
    Writer2.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits2.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits2.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits2.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer2.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer2.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer2.alloc(len = base642.length(value));
        base642.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer2.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create4();
      BufferWriter._configure();
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer2();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util = require_minimal2();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader2;
    var util = require_minimal2();
    var BufferReader;
    var LongBits2 = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader2, writeLength) {
      return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
    }
    function Reader2(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader2(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader2(buffer);
      throw Error("illegal buffer");
    };
    var create4 = function create5() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader2.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader2.create = create4();
    Reader2.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader2.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader2.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader2.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits2(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader2.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader2.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader2.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader2.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader2.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader2.prototype.bytes = function read_bytes() {
      var length2 = this.uint32(), start = this.pos, end = this.pos + length2;
      if (end > this.len)
        throw indexOutOfRange(this, length2);
      this.pos += length2;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader2.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader2.prototype.skip = function skip(length2) {
      if (typeof length2 === "number") {
        if (this.pos + length2 > this.len)
          throw indexOutOfRange(this, length2);
        this.pos += length2;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader2.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader2._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader2.create = create4();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader2.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader2 = require_reader2();
    (BufferReader.prototype = Object.create(Reader2.prototype)).constructor = BufferReader;
    var util = require_minimal2();
    function BufferReader(buffer) {
      Reader2.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc/service.js
var require_service3 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal2();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(true);
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service3();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/roots.js
var require_roots2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal2 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer2();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer2();
    protobuf.util = require_minimal2();
    protobuf.rpc = require_rpc2();
    protobuf.roots = require_roots2();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/minimal.js
var require_minimal3 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal2();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs
var require_rpc3 = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal3());
    })(exports2, function($protobuf) {
      "use strict";
      var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
      var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
      $root.RPC = function() {
        function RPC2(p) {
          this.subscriptions = [];
          this.messages = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        RPC2.prototype.subscriptions = $util.emptyArray;
        RPC2.prototype.messages = $util.emptyArray;
        RPC2.prototype.control = null;
        var $oneOfFields;
        Object.defineProperty(RPC2.prototype, "_control", {
          get: $util.oneOfGetter($oneOfFields = ["control"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        RPC2.encode = function encode6(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.subscriptions != null && m.subscriptions.length) {
            for (var i = 0; i < m.subscriptions.length; ++i)
              $root.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();
          }
          if (m.messages != null && m.messages.length) {
            for (var i = 0; i < m.messages.length; ++i)
              $root.RPC.Message.encode(m.messages[i], w.uint32(18).fork()).ldelim();
          }
          if (m.control != null && Object.hasOwnProperty.call(m, "control"))
            $root.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();
          return w;
        };
        RPC2.decode = function decode7(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.subscriptions && m.subscriptions.length))
                  m.subscriptions = [];
                m.subscriptions.push($root.RPC.SubOpts.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m.messages && m.messages.length))
                  m.messages = [];
                m.messages.push($root.RPC.Message.decode(r, r.uint32()));
                break;
              case 3:
                m.control = $root.RPC.ControlMessage.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        RPC2.fromObject = function fromObject(d) {
          if (d instanceof $root.RPC)
            return d;
          var m = new $root.RPC();
          if (d.subscriptions) {
            if (!Array.isArray(d.subscriptions))
              throw TypeError(".RPC.subscriptions: array expected");
            m.subscriptions = [];
            for (var i = 0; i < d.subscriptions.length; ++i) {
              if (typeof d.subscriptions[i] !== "object")
                throw TypeError(".RPC.subscriptions: object expected");
              m.subscriptions[i] = $root.RPC.SubOpts.fromObject(d.subscriptions[i]);
            }
          }
          if (d.messages) {
            if (!Array.isArray(d.messages))
              throw TypeError(".RPC.messages: array expected");
            m.messages = [];
            for (var i = 0; i < d.messages.length; ++i) {
              if (typeof d.messages[i] !== "object")
                throw TypeError(".RPC.messages: object expected");
              m.messages[i] = $root.RPC.Message.fromObject(d.messages[i]);
            }
          }
          if (d.control != null) {
            if (typeof d.control !== "object")
              throw TypeError(".RPC.control: object expected");
            m.control = $root.RPC.ControlMessage.fromObject(d.control);
          }
          return m;
        };
        RPC2.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.subscriptions = [];
            d.messages = [];
          }
          if (m.subscriptions && m.subscriptions.length) {
            d.subscriptions = [];
            for (var j = 0; j < m.subscriptions.length; ++j) {
              d.subscriptions[j] = $root.RPC.SubOpts.toObject(m.subscriptions[j], o);
            }
          }
          if (m.messages && m.messages.length) {
            d.messages = [];
            for (var j = 0; j < m.messages.length; ++j) {
              d.messages[j] = $root.RPC.Message.toObject(m.messages[j], o);
            }
          }
          if (m.control != null && m.hasOwnProperty("control")) {
            d.control = $root.RPC.ControlMessage.toObject(m.control, o);
            if (o.oneofs)
              d._control = "control";
          }
          return d;
        };
        RPC2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        RPC2.SubOpts = function() {
          function SubOpts(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          SubOpts.prototype.subscribe = null;
          SubOpts.prototype.topic = null;
          var $oneOfFields2;
          Object.defineProperty(SubOpts.prototype, "_subscribe", {
            get: $util.oneOfGetter($oneOfFields2 = ["subscribe"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(SubOpts.prototype, "_topic", {
            get: $util.oneOfGetter($oneOfFields2 = ["topic"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          SubOpts.encode = function encode6(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
              w.uint32(8).bool(m.subscribe);
            if (m.topic != null && Object.hasOwnProperty.call(m, "topic"))
              w.uint32(18).string(m.topic);
            return w;
          };
          SubOpts.decode = function decode7(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.SubOpts();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.subscribe = r.bool();
                  break;
                case 2:
                  m.topic = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          SubOpts.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.SubOpts)
              return d;
            var m = new $root.RPC.SubOpts();
            if (d.subscribe != null) {
              m.subscribe = Boolean(d.subscribe);
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            return m;
          };
          SubOpts.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
              d.subscribe = m.subscribe;
              if (o.oneofs)
                d._subscribe = "subscribe";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
              if (o.oneofs)
                d._topic = "topic";
            }
            return d;
          };
          SubOpts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return SubOpts;
        }();
        RPC2.Message = function() {
          function Message(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Message.prototype.from = null;
          Message.prototype.data = null;
          Message.prototype.seqno = null;
          Message.prototype.topic = "";
          Message.prototype.signature = null;
          Message.prototype.key = null;
          var $oneOfFields2;
          Object.defineProperty(Message.prototype, "_from", {
            get: $util.oneOfGetter($oneOfFields2 = ["from"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_data", {
            get: $util.oneOfGetter($oneOfFields2 = ["data"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_seqno", {
            get: $util.oneOfGetter($oneOfFields2 = ["seqno"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_signature", {
            get: $util.oneOfGetter($oneOfFields2 = ["signature"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_key", {
            get: $util.oneOfGetter($oneOfFields2 = ["key"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Message.encode = function encode6(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.from != null && Object.hasOwnProperty.call(m, "from"))
              w.uint32(10).bytes(m.from);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
              w.uint32(18).bytes(m.data);
            if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
              w.uint32(26).bytes(m.seqno);
            w.uint32(34).string(m.topic);
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
              w.uint32(42).bytes(m.signature);
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
              w.uint32(50).bytes(m.key);
            return w;
          };
          Message.decode = function decode7(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.Message();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.from = r.bytes();
                  break;
                case 2:
                  m.data = r.bytes();
                  break;
                case 3:
                  m.seqno = r.bytes();
                  break;
                case 4:
                  m.topic = r.string();
                  break;
                case 5:
                  m.signature = r.bytes();
                  break;
                case 6:
                  m.key = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            if (!m.hasOwnProperty("topic"))
              throw $util.ProtocolError("missing required 'topic'", { instance: m });
            return m;
          };
          Message.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.Message)
              return d;
            var m = new $root.RPC.Message();
            if (d.from != null) {
              if (typeof d.from === "string")
                $util.base64.decode(d.from, m.from = $util.newBuffer($util.base64.length(d.from)), 0);
              else if (d.from.length)
                m.from = d.from;
            }
            if (d.data != null) {
              if (typeof d.data === "string")
                $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);
              else if (d.data.length)
                m.data = d.data;
            }
            if (d.seqno != null) {
              if (typeof d.seqno === "string")
                $util.base64.decode(d.seqno, m.seqno = $util.newBuffer($util.base64.length(d.seqno)), 0);
              else if (d.seqno.length)
                m.seqno = d.seqno;
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            if (d.signature != null) {
              if (typeof d.signature === "string")
                $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);
              else if (d.signature.length)
                m.signature = d.signature;
            }
            if (d.key != null) {
              if (typeof d.key === "string")
                $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);
              else if (d.key.length)
                m.key = d.key;
            }
            return m;
          };
          Message.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              d.topic = "";
            }
            if (m.from != null && m.hasOwnProperty("from")) {
              d.from = o.bytes === String ? $util.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
              if (o.oneofs)
                d._from = "from";
            }
            if (m.data != null && m.hasOwnProperty("data")) {
              d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
              if (o.oneofs)
                d._data = "data";
            }
            if (m.seqno != null && m.hasOwnProperty("seqno")) {
              d.seqno = o.bytes === String ? $util.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
              if (o.oneofs)
                d._seqno = "seqno";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
            }
            if (m.signature != null && m.hasOwnProperty("signature")) {
              d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
              if (o.oneofs)
                d._signature = "signature";
            }
            if (m.key != null && m.hasOwnProperty("key")) {
              d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
              if (o.oneofs)
                d._key = "key";
            }
            return d;
          };
          Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Message;
        }();
        RPC2.ControlMessage = function() {
          function ControlMessage(p) {
            this.ihave = [];
            this.iwant = [];
            this.graft = [];
            this.prune = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlMessage.prototype.ihave = $util.emptyArray;
          ControlMessage.prototype.iwant = $util.emptyArray;
          ControlMessage.prototype.graft = $util.emptyArray;
          ControlMessage.prototype.prune = $util.emptyArray;
          ControlMessage.encode = function encode6(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.ihave != null && m.ihave.length) {
              for (var i = 0; i < m.ihave.length; ++i)
                $root.RPC.ControlIHave.encode(m.ihave[i], w.uint32(10).fork()).ldelim();
            }
            if (m.iwant != null && m.iwant.length) {
              for (var i = 0; i < m.iwant.length; ++i)
                $root.RPC.ControlIWant.encode(m.iwant[i], w.uint32(18).fork()).ldelim();
            }
            if (m.graft != null && m.graft.length) {
              for (var i = 0; i < m.graft.length; ++i)
                $root.RPC.ControlGraft.encode(m.graft[i], w.uint32(26).fork()).ldelim();
            }
            if (m.prune != null && m.prune.length) {
              for (var i = 0; i < m.prune.length; ++i)
                $root.RPC.ControlPrune.encode(m.prune[i], w.uint32(34).fork()).ldelim();
            }
            return w;
          };
          ControlMessage.decode = function decode7(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlMessage();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.ihave && m.ihave.length))
                    m.ihave = [];
                  m.ihave.push($root.RPC.ControlIHave.decode(r, r.uint32()));
                  break;
                case 2:
                  if (!(m.iwant && m.iwant.length))
                    m.iwant = [];
                  m.iwant.push($root.RPC.ControlIWant.decode(r, r.uint32()));
                  break;
                case 3:
                  if (!(m.graft && m.graft.length))
                    m.graft = [];
                  m.graft.push($root.RPC.ControlGraft.decode(r, r.uint32()));
                  break;
                case 4:
                  if (!(m.prune && m.prune.length))
                    m.prune = [];
                  m.prune.push($root.RPC.ControlPrune.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlMessage.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlMessage)
              return d;
            var m = new $root.RPC.ControlMessage();
            if (d.ihave) {
              if (!Array.isArray(d.ihave))
                throw TypeError(".RPC.ControlMessage.ihave: array expected");
              m.ihave = [];
              for (var i = 0; i < d.ihave.length; ++i) {
                if (typeof d.ihave[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.ihave: object expected");
                m.ihave[i] = $root.RPC.ControlIHave.fromObject(d.ihave[i]);
              }
            }
            if (d.iwant) {
              if (!Array.isArray(d.iwant))
                throw TypeError(".RPC.ControlMessage.iwant: array expected");
              m.iwant = [];
              for (var i = 0; i < d.iwant.length; ++i) {
                if (typeof d.iwant[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.iwant: object expected");
                m.iwant[i] = $root.RPC.ControlIWant.fromObject(d.iwant[i]);
              }
            }
            if (d.graft) {
              if (!Array.isArray(d.graft))
                throw TypeError(".RPC.ControlMessage.graft: array expected");
              m.graft = [];
              for (var i = 0; i < d.graft.length; ++i) {
                if (typeof d.graft[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.graft: object expected");
                m.graft[i] = $root.RPC.ControlGraft.fromObject(d.graft[i]);
              }
            }
            if (d.prune) {
              if (!Array.isArray(d.prune))
                throw TypeError(".RPC.ControlMessage.prune: array expected");
              m.prune = [];
              for (var i = 0; i < d.prune.length; ++i) {
                if (typeof d.prune[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.prune: object expected");
                m.prune[i] = $root.RPC.ControlPrune.fromObject(d.prune[i]);
              }
            }
            return m;
          };
          ControlMessage.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.ihave = [];
              d.iwant = [];
              d.graft = [];
              d.prune = [];
            }
            if (m.ihave && m.ihave.length) {
              d.ihave = [];
              for (var j = 0; j < m.ihave.length; ++j) {
                d.ihave[j] = $root.RPC.ControlIHave.toObject(m.ihave[j], o);
              }
            }
            if (m.iwant && m.iwant.length) {
              d.iwant = [];
              for (var j = 0; j < m.iwant.length; ++j) {
                d.iwant[j] = $root.RPC.ControlIWant.toObject(m.iwant[j], o);
              }
            }
            if (m.graft && m.graft.length) {
              d.graft = [];
              for (var j = 0; j < m.graft.length; ++j) {
                d.graft[j] = $root.RPC.ControlGraft.toObject(m.graft[j], o);
              }
            }
            if (m.prune && m.prune.length) {
              d.prune = [];
              for (var j = 0; j < m.prune.length; ++j) {
                d.prune[j] = $root.RPC.ControlPrune.toObject(m.prune[j], o);
              }
            }
            return d;
          };
          ControlMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlMessage;
        }();
        RPC2.ControlIHave = function() {
          function ControlIHave(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIHave.prototype.topicID = null;
          ControlIHave.prototype.messageIDs = $util.emptyArray;
          var $oneOfFields2;
          Object.defineProperty(ControlIHave.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlIHave.encode = function encode6(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0; i < m.messageIDs.length; ++i)
                w.uint32(18).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIHave.decode = function decode7(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlIHave();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIHave.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlIHave)
              return d;
            var m = new $root.RPC.ControlIHave();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0; i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIHave.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIHave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlIHave;
        }();
        RPC2.ControlIWant = function() {
          function ControlIWant(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIWant.prototype.messageIDs = $util.emptyArray;
          ControlIWant.encode = function encode6(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0; i < m.messageIDs.length; ++i)
                w.uint32(10).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIWant.decode = function decode7(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlIWant();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIWant.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlIWant)
              return d;
            var m = new $root.RPC.ControlIWant();
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0; i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIWant.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIWant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlIWant;
        }();
        RPC2.ControlGraft = function() {
          function ControlGraft(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlGraft.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(ControlGraft.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlGraft.encode = function encode6(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            return w;
          };
          ControlGraft.decode = function decode7(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlGraft();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlGraft.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlGraft)
              return d;
            var m = new $root.RPC.ControlGraft();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          ControlGraft.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          ControlGraft.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlGraft;
        }();
        RPC2.ControlPrune = function() {
          function ControlPrune(p) {
            this.peers = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlPrune.prototype.topicID = null;
          ControlPrune.prototype.peers = $util.emptyArray;
          ControlPrune.prototype.backoff = null;
          var $oneOfFields2;
          Object.defineProperty(ControlPrune.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(ControlPrune.prototype, "_backoff", {
            get: $util.oneOfGetter($oneOfFields2 = ["backoff"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlPrune.encode = function encode6(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.peers != null && m.peers.length) {
              for (var i = 0; i < m.peers.length; ++i)
                $root.RPC.PeerInfo.encode(m.peers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.backoff != null && Object.hasOwnProperty.call(m, "backoff"))
              w.uint32(24).uint64(m.backoff);
            return w;
          };
          ControlPrune.decode = function decode7(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlPrune();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.peers && m.peers.length))
                    m.peers = [];
                  m.peers.push($root.RPC.PeerInfo.decode(r, r.uint32()));
                  break;
                case 3:
                  m.backoff = r.uint64();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlPrune.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlPrune)
              return d;
            var m = new $root.RPC.ControlPrune();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.peers) {
              if (!Array.isArray(d.peers))
                throw TypeError(".RPC.ControlPrune.peers: array expected");
              m.peers = [];
              for (var i = 0; i < d.peers.length; ++i) {
                if (typeof d.peers[i] !== "object")
                  throw TypeError(".RPC.ControlPrune.peers: object expected");
                m.peers[i] = $root.RPC.PeerInfo.fromObject(d.peers[i]);
              }
            }
            if (d.backoff != null) {
              if ($util.Long)
                (m.backoff = $util.Long.fromValue(d.backoff)).unsigned = true;
              else if (typeof d.backoff === "string")
                m.backoff = parseInt(d.backoff, 10);
              else if (typeof d.backoff === "number")
                m.backoff = d.backoff;
              else if (typeof d.backoff === "object")
                m.backoff = new $util.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);
            }
            return m;
          };
          ControlPrune.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.peers = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.peers && m.peers.length) {
              d.peers = [];
              for (var j = 0; j < m.peers.length; ++j) {
                d.peers[j] = $root.RPC.PeerInfo.toObject(m.peers[j], o);
              }
            }
            if (m.backoff != null && m.hasOwnProperty("backoff")) {
              if (typeof m.backoff === "number")
                d.backoff = o.longs === String ? String(m.backoff) : m.backoff;
              else
                d.backoff = o.longs === String ? $util.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;
              if (o.oneofs)
                d._backoff = "backoff";
            }
            return d;
          };
          ControlPrune.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlPrune;
        }();
        RPC2.PeerInfo = function() {
          function PeerInfo(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          PeerInfo.prototype.peerID = null;
          PeerInfo.prototype.signedPeerRecord = null;
          var $oneOfFields2;
          Object.defineProperty(PeerInfo.prototype, "_peerID", {
            get: $util.oneOfGetter($oneOfFields2 = ["peerID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(PeerInfo.prototype, "_signedPeerRecord", {
            get: $util.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          PeerInfo.encode = function encode6(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.peerID != null && Object.hasOwnProperty.call(m, "peerID"))
              w.uint32(10).bytes(m.peerID);
            if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
              w.uint32(18).bytes(m.signedPeerRecord);
            return w;
          };
          PeerInfo.decode = function decode7(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.PeerInfo();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.peerID = r.bytes();
                  break;
                case 2:
                  m.signedPeerRecord = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          PeerInfo.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.PeerInfo)
              return d;
            var m = new $root.RPC.PeerInfo();
            if (d.peerID != null) {
              if (typeof d.peerID === "string")
                $util.base64.decode(d.peerID, m.peerID = $util.newBuffer($util.base64.length(d.peerID)), 0);
              else if (d.peerID.length)
                m.peerID = d.peerID;
            }
            if (d.signedPeerRecord != null) {
              if (typeof d.signedPeerRecord === "string")
                $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);
              else if (d.signedPeerRecord.length)
                m.signedPeerRecord = d.signedPeerRecord;
            }
            return m;
          };
          PeerInfo.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.peerID != null && m.hasOwnProperty("peerID")) {
              d.peerID = o.bytes === String ? $util.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;
              if (o.oneofs)
                d._peerID = "peerID";
            }
            if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
              d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
              if (o.oneofs)
                d._signedPeerRecord = "signedPeerRecord";
            }
            return d;
          };
          PeerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return PeerInfo;
        }();
        return RPC2;
      }();
      return $root;
    });
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js
var import_rpc, RPC;
var init_rpc = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js"() {
    import_rpc = __toESM(require_rpc3(), 1);
    ({ RPC } = import_rpc.default);
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/constants.js
var second, minute, FloodsubID, GossipsubIDv10, GossipsubIDv11, GossipsubD, GossipsubDlo, GossipsubDhi, GossipsubDscore, GossipsubDout, GossipsubHistoryLength, GossipsubHistoryGossip, GossipsubDlazy, GossipsubGossipFactor, GossipsubGossipRetransmission, GossipsubHeartbeatInitialDelay, GossipsubHeartbeatInterval, GossipsubFanoutTTL, GossipsubPrunePeers, GossipsubPruneBackoff, GossipsubPruneBackoffTicks, GossipsubConnectionTimeout, GossipsubDirectConnectTicks, GossipsubDirectConnectInitialDelay, GossipsubOpportunisticGraftTicks, GossipsubOpportunisticGraftPeers, GossipsubGraftFloodThreshold, GossipsubMaxIHaveLength, GossipsubMaxIHaveMessages, GossipsubIWantFollowupTime, GossipsubSeenTTL, TimeCacheDuration, ERR_TOPIC_VALIDATOR_REJECT, ERR_TOPIC_VALIDATOR_IGNORE, ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, ACCEPT_FROM_WHITELIST_MAX_MESSAGES, ACCEPT_FROM_WHITELIST_DURATION_MS, DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS;
var init_constants = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/constants.js"() {
    second = 1e3;
    minute = 60 * second;
    FloodsubID = "/floodsub/1.0.0";
    GossipsubIDv10 = "/meshsub/1.0.0";
    GossipsubIDv11 = "/meshsub/1.1.0";
    GossipsubD = 6;
    GossipsubDlo = 4;
    GossipsubDhi = 12;
    GossipsubDscore = 4;
    GossipsubDout = 2;
    GossipsubHistoryLength = 5;
    GossipsubHistoryGossip = 3;
    GossipsubDlazy = 6;
    GossipsubGossipFactor = 0.25;
    GossipsubGossipRetransmission = 3;
    GossipsubHeartbeatInitialDelay = 100;
    GossipsubHeartbeatInterval = second;
    GossipsubFanoutTTL = minute;
    GossipsubPrunePeers = 16;
    GossipsubPruneBackoff = minute;
    GossipsubPruneBackoffTicks = 15;
    GossipsubConnectionTimeout = 30 * second;
    GossipsubDirectConnectTicks = 300;
    GossipsubDirectConnectInitialDelay = second;
    GossipsubOpportunisticGraftTicks = 60;
    GossipsubOpportunisticGraftPeers = 2;
    GossipsubGraftFloodThreshold = 10 * second;
    GossipsubMaxIHaveLength = 5e3;
    GossipsubMaxIHaveMessages = 10;
    GossipsubIWantFollowupTime = 3 * second;
    GossipsubSeenTTL = 2 * minute;
    TimeCacheDuration = 120 * 1e3;
    ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
    ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
    ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
    ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
    ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
    DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/create-gossip-rpc.js
function createGossipRpc(messages2 = [], control) {
  return {
    subscriptions: [],
    messages: messages2,
    control: control ? {
      graft: control.graft || [],
      prune: control.prune || [],
      ihave: control.ihave || [],
      iwant: control.iwant || []
    } : void 0
  };
}
var init_create_gossip_rpc = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/create-gossip-rpc.js"() {
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/shuffle.js
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = () => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  };
  for (let i = 0; i < arr.length; i++) {
    const j = randInt();
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}
var init_shuffle = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/shuffle.js"() {
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/messageIdToString.js
function messageIdToString(msgId2) {
  return toString2(msgId2, "base64");
}
var init_messageIdToString = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/messageIdToString.js"() {
    init_to_string();
  }
});

// node_modules/@libp2p/interface-pubsub/dist/src/index.js
var StrictSign, StrictNoSign;
var init_src21 = __esm({
  "node_modules/@libp2p/interface-pubsub/dist/src/index.js"() {
    StrictSign = "StrictSign";
    StrictNoSign = "StrictNoSign";
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/types.js
function rejectReasonFromAcceptance(acceptance) {
  switch (acceptance) {
    case MessageAcceptance.Ignore:
      return RejectReason.Ignore;
    case MessageAcceptance.Reject:
      return RejectReason.Reject;
  }
}
var SignaturePolicy, PublishConfigType, MessageAcceptance, RejectReason, ValidateError, MessageStatus;
var init_types = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/types.js"() {
    (function(SignaturePolicy2) {
      SignaturePolicy2["StrictSign"] = "StrictSign";
      SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
    })(SignaturePolicy || (SignaturePolicy = {}));
    (function(PublishConfigType2) {
      PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
      PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
    })(PublishConfigType || (PublishConfigType = {}));
    (function(MessageAcceptance2) {
      MessageAcceptance2["Accept"] = "accept";
      MessageAcceptance2["Ignore"] = "ignore";
      MessageAcceptance2["Reject"] = "reject";
    })(MessageAcceptance || (MessageAcceptance = {}));
    (function(RejectReason2) {
      RejectReason2["Error"] = "error";
      RejectReason2["Ignore"] = "ignore";
      RejectReason2["Reject"] = "reject";
      RejectReason2["Blacklisted"] = "blacklisted";
    })(RejectReason || (RejectReason = {}));
    (function(ValidateError2) {
      ValidateError2["InvalidSignature"] = "invalid_signature";
      ValidateError2["InvalidSeqno"] = "invalid_seqno";
      ValidateError2["InvalidPeerId"] = "invalid_peerid";
      ValidateError2["SignaturePresent"] = "signature_present";
      ValidateError2["SeqnoPresent"] = "seqno_present";
      ValidateError2["FromPresent"] = "from_present";
      ValidateError2["TransformFailed"] = "transform_failed";
    })(ValidateError || (ValidateError = {}));
    (function(MessageStatus2) {
      MessageStatus2["duplicate"] = "duplicate";
      MessageStatus2["invalid"] = "invalid";
      MessageStatus2["valid"] = "valid";
    })(MessageStatus || (MessageStatus = {}));
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/publishConfig.js
async function getPublishConfigFromPeerId(signaturePolicy, peerId) {
  switch (signaturePolicy) {
    case StrictSign: {
      if (!peerId) {
        throw Error("Must provide PeerId");
      }
      if (peerId.privateKey == null) {
        throw Error("Cannot sign message, no private key present");
      }
      if (peerId.publicKey == null) {
        throw Error("Cannot sign message, no public key present");
      }
      const privateKey = await unmarshalPrivateKey2(peerId.privateKey);
      return {
        type: PublishConfigType.Signing,
        author: peerId,
        key: peerId.publicKey,
        privateKey
      };
    }
    case StrictNoSign:
      return {
        type: PublishConfigType.Anonymous
      };
    default:
      throw new Error(`Unknown signature policy "${signaturePolicy}"`);
  }
}
var init_publishConfig = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/publishConfig.js"() {
    init_keys2();
    init_src21();
    init_types();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/index.js
var init_utils = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/index.js"() {
    init_create_gossip_rpc();
    init_shuffle();
    init_messageIdToString();
    init_publishConfig();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/constants.js
var ERR_INVALID_PEER_SCORE_PARAMS;
var init_constants2 = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/constants.js"() {
    ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js
function createPeerScoreParams(p = {}) {
  return {
    ...defaultPeerScoreParams,
    ...p,
    topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}
  };
}
function createTopicScoreParams(p = {}) {
  return {
    ...defaultTopicScoreParams,
    ...p
  };
}
function validatePeerScoreParams(p) {
  for (const [topic, params] of Object.entries(p.topics)) {
    try {
      validateTopicScoreParams(params);
    } catch (e) {
      throw (0, import_err_code17.default)(new Error(`invalid score parameters for topic ${topic}: ${e.message}`), ERR_INVALID_PEER_SCORE_PARAMS);
    }
  }
  if (p.topicScoreCap < 0) {
    throw (0, import_err_code17.default)(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
    throw (0, import_err_code17.default)(new Error("missing application specific score function"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight > 0) {
    throw (0, import_err_code17.default)(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
    throw (0, import_err_code17.default)(new Error("invalid IPColocationFactorThreshold; must be at least 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight > 0) {
    throw (0, import_err_code17.default)(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
    throw (0, import_err_code17.default)(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayInterval < 1e3) {
    throw (0, import_err_code17.default)(new Error("invalid DecayInterval; must be at least 1s"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayToZero <= 0 || p.decayToZero >= 1) {
    throw (0, import_err_code17.default)(new Error("invalid DecayToZero; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
function validateTopicScoreParams(p) {
  if (p.topicWeight < 0) {
    throw (0, import_err_code17.default)(new Error("invalid topic weight; must be >= 0"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshQuantum === 0) {
    throw (0, import_err_code17.default)(new Error("invalid TimeInMeshQuantum; must be non zero"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight < 0) {
    throw (0, import_err_code17.default)(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
    throw (0, import_err_code17.default)(new Error("invalid TimeInMeshQuantum; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
    throw (0, import_err_code17.default)(new Error("invalid TimeInMeshCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight < 0) {
    throw (0, import_err_code17.default)(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
    throw (0, import_err_code17.default)(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
    throw (0, import_err_code17.default)(new Error("invalid FirstMessageDeliveriesCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight > 0) {
    throw (0, import_err_code17.default)(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
    throw (0, import_err_code17.default)(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
    throw (0, import_err_code17.default)(new Error("invalid MeshMessageDeliveriesCap; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
    throw (0, import_err_code17.default)(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWindow < 0) {
    throw (0, import_err_code17.default)(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
    throw (0, import_err_code17.default)(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight > 0) {
    throw (0, import_err_code17.default)(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
    throw (0, import_err_code17.default)(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesWeight > 0) {
    throw (0, import_err_code17.default)(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
    throw (0, import_err_code17.default)(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
var import_err_code17, defaultPeerScoreParams, defaultTopicScoreParams;
var init_peer_score_params = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js"() {
    init_constants2();
    import_err_code17 = __toESM(require_err_code(), 1);
    defaultPeerScoreParams = {
      topics: {},
      topicScoreCap: 10,
      appSpecificScore: () => 0,
      appSpecificWeight: 10,
      IPColocationFactorWeight: -5,
      IPColocationFactorThreshold: 10,
      IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
      behaviourPenaltyWeight: -10,
      behaviourPenaltyThreshold: 0,
      behaviourPenaltyDecay: 0.2,
      decayInterval: 1e3,
      decayToZero: 0.1,
      retainScore: 3600 * 1e3
    };
    defaultTopicScoreParams = {
      topicWeight: 0.5,
      timeInMeshWeight: 1,
      timeInMeshQuantum: 1,
      timeInMeshCap: 3600,
      firstMessageDeliveriesWeight: 1,
      firstMessageDeliveriesDecay: 0.5,
      firstMessageDeliveriesCap: 2e3,
      meshMessageDeliveriesWeight: -1,
      meshMessageDeliveriesDecay: 0.5,
      meshMessageDeliveriesCap: 100,
      meshMessageDeliveriesThreshold: 20,
      meshMessageDeliveriesWindow: 10,
      meshMessageDeliveriesActivation: 5e3,
      meshFailurePenaltyWeight: -1,
      meshFailurePenaltyDecay: 0.5,
      invalidMessageDeliveriesWeight: -1,
      invalidMessageDeliveriesDecay: 0.3
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-thresholds.js
function createPeerScoreThresholds(p = {}) {
  return {
    ...defaultPeerScoreThresholds,
    ...p
  };
}
var import_err_code18, defaultPeerScoreThresholds;
var init_peer_score_thresholds = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-thresholds.js"() {
    init_constants2();
    import_err_code18 = __toESM(require_err_code(), 1);
    defaultPeerScoreThresholds = {
      gossipThreshold: -10,
      publishThreshold: -50,
      graylistThreshold: -80,
      acceptPXThreshold: 10,
      opportunisticGraftThreshold: 20
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/compute-score.js
function computeScore(peer, pstats, params, peerIPs) {
  let score = 0;
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScore = 0;
    if (tstats.inMesh) {
      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
      if (p1 > topicParams.timeInMeshCap) {
        p1 = topicParams.timeInMeshCap;
      }
      topicScore += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    topicScore += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += topicScore * topicParams.topicWeight;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
  }
  const p5 = params.appSpecificScore(peer);
  score += p5 * params.appSpecificWeight;
  pstats.ips.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      score += p6 * params.IPColocationFactorWeight;
    }
  });
  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
    const p7 = excess * excess;
    score += p7 * params.behaviourPenaltyWeight;
  }
  return score;
}
var init_compute_score = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/compute-score.js"() {
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    function Denque2(array, options2) {
      var options2 = options2 || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options2.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque2.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque2.prototype.get = function get(i) {
      return this.peekAt(i);
    };
    Denque2.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque2.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque2.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque2.prototype, "length", {
      get: function length2() {
        return this.size();
      }
    });
    Denque2.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque2.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque2.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque2.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque2.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque2.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque2.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque2.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque2.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque2.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque2.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque2.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque2;
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/message-deliveries.js
var import_denque, DeliveryRecordStatus, MessageDeliveries;
var init_message_deliveries = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/message-deliveries.js"() {
    init_constants();
    import_denque = __toESM(require_denque(), 1);
    (function(DeliveryRecordStatus2) {
      DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
      DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
      DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
      DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
    })(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
    MessageDeliveries = class {
      constructor() {
        this.records = /* @__PURE__ */ new Map();
        this.queue = new import_denque.default();
      }
      ensureRecord(msgIdStr) {
        let drec = this.records.get(msgIdStr);
        if (drec) {
          return drec;
        }
        drec = {
          status: DeliveryRecordStatus.unknown,
          firstSeen: Date.now(),
          validated: 0,
          peers: /* @__PURE__ */ new Set()
        };
        this.records.set(msgIdStr, drec);
        const entry = {
          msgId: msgIdStr,
          expire: Date.now() + TimeCacheDuration
        };
        this.queue.push(entry);
        return drec;
      }
      gc() {
        const now = Date.now();
        let head = this.queue.peekFront();
        while (head && head.expire < now) {
          this.records.delete(head.msgId);
          this.queue.shift();
          head = this.queue.peekFront();
        }
      }
      clear() {
        this.records.clear();
        this.queue.clear();
      }
    };
  }
});

// node_modules/@libp2p/interfaces/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
var init_startable = __esm({
  "node_modules/@libp2p/interfaces/dist/src/startable.js"() {
  }
});

// node_modules/@libp2p/components/dist/src/index.js
function isInitializable(obj) {
  return obj != null && typeof obj.init === "function";
}
var import_err_code19, Components;
var init_src22 = __esm({
  "node_modules/@libp2p/components/dist/src/index.js"() {
    import_err_code19 = __toESM(require_err_code(), 1);
    init_startable();
    Components = class {
      constructor(init = {}) {
        this.started = false;
        if (init.peerId != null) {
          this.setPeerId(init.peerId);
        }
        if (init.addressManager != null) {
          this.setAddressManager(init.addressManager);
        }
        if (init.peerStore != null) {
          this.setPeerStore(init.peerStore);
        }
        if (init.upgrader != null) {
          this.setUpgrader(init.upgrader);
        }
        if (init.metrics != null) {
          this.setMetrics(init.metrics);
        }
        if (init.registrar != null) {
          this.setRegistrar(init.registrar);
        }
        if (init.connectionManager != null) {
          this.setConnectionManager(init.connectionManager);
        }
        if (init.transportManager != null) {
          this.setTransportManager(init.transportManager);
        }
        if (init.connectionGater != null) {
          this.setConnectionGater(init.connectionGater);
        }
        if (init.contentRouting != null) {
          this.setContentRouting(init.contentRouting);
        }
        if (init.peerRouting != null) {
          this.setPeerRouting(init.peerRouting);
        }
        if (init.datastore != null) {
          this.setDatastore(init.datastore);
        }
        if (init.connectionProtector != null) {
          this.setConnectionProtector(init.connectionProtector);
        }
        if (init.dht != null) {
          this.setDHT(init.dht);
        }
        if (init.pubsub != null) {
          this.setPubSub(init.pubsub);
        }
      }
      isStarted() {
        return this.started;
      }
      async beforeStart() {
        await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
          if (startable.beforeStart != null) {
            await startable.beforeStart();
          }
        }));
      }
      async start() {
        await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
          await startable.start();
        }));
        this.started = true;
      }
      async afterStart() {
        await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
          if (startable.afterStart != null) {
            await startable.afterStart();
          }
        }));
      }
      async beforeStop() {
        await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
          if (startable.beforeStop != null) {
            await startable.beforeStop();
          }
        }));
      }
      async stop() {
        await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
          await startable.stop();
        }));
        this.started = false;
      }
      async afterStop() {
        await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
          if (startable.afterStop != null) {
            await startable.afterStop();
          }
        }));
      }
      setPeerId(peerId) {
        this.peerId = peerId;
        return peerId;
      }
      getPeerId() {
        if (this.peerId == null) {
          throw (0, import_err_code19.default)(new Error("peerId not set"), "ERR_SERVICE_MISSING");
        }
        return this.peerId;
      }
      setMetrics(metrics) {
        this.metrics = metrics;
        if (isInitializable(metrics)) {
          metrics.init(this);
        }
        return metrics;
      }
      getMetrics() {
        return this.metrics;
      }
      setAddressManager(addressManager) {
        this.addressManager = addressManager;
        if (isInitializable(addressManager)) {
          addressManager.init(this);
        }
        return addressManager;
      }
      getAddressManager() {
        if (this.addressManager == null) {
          throw (0, import_err_code19.default)(new Error("addressManager not set"), "ERR_SERVICE_MISSING");
        }
        return this.addressManager;
      }
      setPeerStore(peerStore) {
        this.peerStore = peerStore;
        if (isInitializable(peerStore)) {
          peerStore.init(this);
        }
        return peerStore;
      }
      getPeerStore() {
        if (this.peerStore == null) {
          throw (0, import_err_code19.default)(new Error("peerStore not set"), "ERR_SERVICE_MISSING");
        }
        return this.peerStore;
      }
      setUpgrader(upgrader) {
        this.upgrader = upgrader;
        if (isInitializable(upgrader)) {
          upgrader.init(this);
        }
        return upgrader;
      }
      getUpgrader() {
        if (this.upgrader == null) {
          throw (0, import_err_code19.default)(new Error("upgrader not set"), "ERR_SERVICE_MISSING");
        }
        return this.upgrader;
      }
      setRegistrar(registrar) {
        this.registrar = registrar;
        if (isInitializable(registrar)) {
          registrar.init(this);
        }
        return registrar;
      }
      getRegistrar() {
        if (this.registrar == null) {
          throw (0, import_err_code19.default)(new Error("registrar not set"), "ERR_SERVICE_MISSING");
        }
        return this.registrar;
      }
      setConnectionManager(connectionManager) {
        this.connectionManager = connectionManager;
        if (isInitializable(connectionManager)) {
          connectionManager.init(this);
        }
        return connectionManager;
      }
      getConnectionManager() {
        if (this.connectionManager == null) {
          throw (0, import_err_code19.default)(new Error("connectionManager not set"), "ERR_SERVICE_MISSING");
        }
        return this.connectionManager;
      }
      setTransportManager(transportManager) {
        this.transportManager = transportManager;
        if (isInitializable(transportManager)) {
          transportManager.init(this);
        }
        return transportManager;
      }
      getTransportManager() {
        if (this.transportManager == null) {
          throw (0, import_err_code19.default)(new Error("transportManager not set"), "ERR_SERVICE_MISSING");
        }
        return this.transportManager;
      }
      setConnectionGater(connectionGater) {
        this.connectionGater = connectionGater;
        if (isInitializable(connectionGater)) {
          connectionGater.init(this);
        }
        return connectionGater;
      }
      getConnectionGater() {
        if (this.connectionGater == null) {
          throw (0, import_err_code19.default)(new Error("connectionGater not set"), "ERR_SERVICE_MISSING");
        }
        return this.connectionGater;
      }
      setContentRouting(contentRouting) {
        this.contentRouting = contentRouting;
        if (isInitializable(contentRouting)) {
          contentRouting.init(this);
        }
        return contentRouting;
      }
      getContentRouting() {
        if (this.contentRouting == null) {
          throw (0, import_err_code19.default)(new Error("contentRouting not set"), "ERR_SERVICE_MISSING");
        }
        return this.contentRouting;
      }
      setPeerRouting(peerRouting) {
        this.peerRouting = peerRouting;
        if (isInitializable(peerRouting)) {
          peerRouting.init(this);
        }
        return peerRouting;
      }
      getPeerRouting() {
        if (this.peerRouting == null) {
          throw (0, import_err_code19.default)(new Error("peerRouting not set"), "ERR_SERVICE_MISSING");
        }
        return this.peerRouting;
      }
      setDatastore(datastore) {
        this.datastore = datastore;
        if (isInitializable(datastore)) {
          datastore.init(this);
        }
        return datastore;
      }
      getDatastore() {
        if (this.datastore == null) {
          throw (0, import_err_code19.default)(new Error("datastore not set"), "ERR_SERVICE_MISSING");
        }
        return this.datastore;
      }
      setConnectionProtector(connectionProtector) {
        this.connectionProtector = connectionProtector;
        if (isInitializable(connectionProtector)) {
          connectionProtector.init(this);
        }
        return connectionProtector;
      }
      getConnectionProtector() {
        return this.connectionProtector;
      }
      setDHT(dht) {
        this.dht = dht;
        if (isInitializable(dht)) {
          dht.init(this);
        }
        return dht;
      }
      getDHT() {
        if (this.dht == null) {
          throw (0, import_err_code19.default)(new Error("dht not set"), "ERR_SERVICE_MISSING");
        }
        return this.dht;
      }
      setPubSub(pubsub) {
        this.pubsub = pubsub;
        if (isInitializable(pubsub)) {
          pubsub.init(this);
        }
        return pubsub;
      }
      getPubSub() {
        if (this.pubsub == null) {
          throw (0, import_err_code19.default)(new Error("pubsub not set"), "ERR_SERVICE_MISSING");
        }
        return this.pubsub;
      }
      setDialer(dialer) {
        this.dialer = dialer;
        if (isInitializable(dialer)) {
          dialer.init(this);
        }
        return dialer;
      }
      getDialer() {
        if (this.dialer == null) {
          throw (0, import_err_code19.default)(new Error("dialer not set"), "ERR_SERVICE_MISSING");
        }
        return this.dialer;
      }
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js
var log3, PeerScore;
var init_peer_score = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js"() {
    init_peer_score_params();
    init_compute_score();
    init_message_deliveries();
    init_src6();
    init_types();
    init_src22();
    init_src4();
    log3 = logger("libp2p:gossipsub:score");
    PeerScore = class {
      constructor(params, metrics, opts) {
        this.params = params;
        this.metrics = metrics;
        this.peerStats = /* @__PURE__ */ new Map();
        this.peerIPs = /* @__PURE__ */ new Map();
        this.scoreCache = /* @__PURE__ */ new Map();
        this.deliveryRecords = new MessageDeliveries();
        this.components = new Components();
        validatePeerScoreParams(params);
        this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
        this.computeScore = opts.computeScore ?? computeScore;
      }
      init(components) {
        this.components = components;
      }
      get size() {
        return this.peerStats.size;
      }
      start() {
        if (this._backgroundInterval) {
          log3("Peer score already running");
          return;
        }
        this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
        log3("started");
      }
      stop() {
        if (!this._backgroundInterval) {
          log3("Peer score already stopped");
          return;
        }
        clearInterval(this._backgroundInterval);
        delete this._backgroundInterval;
        this.peerIPs.clear();
        this.peerStats.clear();
        this.deliveryRecords.clear();
        log3("stopped");
      }
      background() {
        this.refreshScores();
        this.updateIPs();
        this.deliveryRecords.gc();
      }
      dumpPeerScoreStats() {
        return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
      }
      refreshScores() {
        const now = Date.now();
        const decayToZero = this.params.decayToZero;
        this.peerStats.forEach((pstats, id) => {
          if (!pstats.connected) {
            if (now > pstats.expire) {
              this.removeIPs(id, pstats.ips);
              this.peerStats.delete(id);
              this.scoreCache.delete(id);
            }
            return;
          }
          Object.entries(pstats.topics).forEach(([topic, tstats]) => {
            const tparams = this.params.topics[topic];
            if (tparams === void 0) {
              return;
            }
            tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
            if (tstats.firstMessageDeliveries < decayToZero) {
              tstats.firstMessageDeliveries = 0;
            }
            tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
            if (tstats.meshMessageDeliveries < decayToZero) {
              tstats.meshMessageDeliveries = 0;
            }
            tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
            if (tstats.meshFailurePenalty < decayToZero) {
              tstats.meshFailurePenalty = 0;
            }
            tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
            if (tstats.invalidMessageDeliveries < decayToZero) {
              tstats.invalidMessageDeliveries = 0;
            }
            if (tstats.inMesh) {
              tstats.meshTime = now - tstats.graftTime;
              if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
                tstats.meshMessageDeliveriesActive = true;
              }
            }
          });
          pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
          if (pstats.behaviourPenalty < decayToZero) {
            pstats.behaviourPenalty = 0;
          }
        });
      }
      score(id) {
        var _a2, _b, _c;
        (_a2 = this.metrics) == null ? void 0 : _a2.scoreFnCalls.inc();
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return 0;
        }
        const now = Date.now();
        const cacheEntry = this.scoreCache.get(id);
        if (cacheEntry && cacheEntry.cacheUntil > now) {
          return cacheEntry.score;
        }
        (_b = this.metrics) == null ? void 0 : _b.scoreFnRuns.inc();
        const score = this.computeScore(id, pstats, this.params, this.peerIPs);
        const cacheUntil = now + this.scoreCacheValidityMs;
        if (cacheEntry) {
          (_c = this.metrics) == null ? void 0 : _c.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
          cacheEntry.score = score;
          cacheEntry.cacheUntil = cacheUntil;
        } else {
          this.scoreCache.set(id, { score, cacheUntil });
        }
        return score;
      }
      addPenalty(id, penalty, penaltyLabel) {
        var _a2;
        const pstats = this.peerStats.get(id);
        if (pstats) {
          pstats.behaviourPenalty += penalty;
          (_a2 = this.metrics) == null ? void 0 : _a2.onScorePenalty(penaltyLabel);
        }
      }
      addPeer(id) {
        const pstats = {
          connected: true,
          expire: 0,
          topics: {},
          ips: [],
          behaviourPenalty: 0
        };
        this.peerStats.set(id, pstats);
        const ips = this.getIPs(id);
        this.setIPs(id, ips, pstats.ips);
        pstats.ips = ips;
      }
      removePeer(id) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        if (this.score(id) > 0) {
          this.removeIPs(id, pstats.ips);
          this.peerStats.delete(id);
          return;
        }
        Object.entries(pstats.topics).forEach(([topic, tstats]) => {
          tstats.firstMessageDeliveries = 0;
          const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
          if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
            const deficit = threshold - tstats.meshMessageDeliveries;
            tstats.meshFailurePenalty += deficit * deficit;
          }
          tstats.inMesh = false;
          tstats.meshMessageDeliveriesActive = false;
        });
        pstats.connected = false;
        pstats.expire = Date.now() + this.params.retainScore;
      }
      graft(id, topic) {
        const pstats = this.peerStats.get(id);
        if (pstats) {
          const tstats = this.getPtopicStats(pstats, topic);
          if (tstats) {
            tstats.inMesh = true;
            tstats.graftTime = Date.now();
            tstats.meshTime = 0;
            tstats.meshMessageDeliveriesActive = false;
          }
        }
      }
      prune(id, topic) {
        const pstats = this.peerStats.get(id);
        if (pstats) {
          const tstats = this.getPtopicStats(pstats, topic);
          if (tstats) {
            const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
            if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
              const deficit = threshold - tstats.meshMessageDeliveries;
              tstats.meshFailurePenalty += deficit * deficit;
            }
            tstats.meshMessageDeliveriesActive = false;
            tstats.inMesh = false;
          }
        }
      }
      validateMessage(msgIdStr) {
        this.deliveryRecords.ensureRecord(msgIdStr);
      }
      deliverMessage(from3, msgIdStr, topic) {
        this.markFirstMessageDelivery(from3, topic);
        const drec = this.deliveryRecords.ensureRecord(msgIdStr);
        const now = Date.now();
        if (drec.status !== DeliveryRecordStatus.unknown) {
          log3("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from3, now - drec.firstSeen, DeliveryRecordStatus[drec.status]);
          return;
        }
        drec.status = DeliveryRecordStatus.valid;
        drec.validated = now;
        drec.peers.forEach((p) => {
          if (p !== from3.toString()) {
            this.markDuplicateMessageDelivery(p, topic);
          }
        });
      }
      rejectInvalidMessage(from3, topic) {
        this.markInvalidMessageDelivery(from3, topic);
      }
      rejectMessage(from3, msgIdStr, topic, reason) {
        switch (reason) {
          case RejectReason.Error:
            this.markInvalidMessageDelivery(from3, topic);
            return;
          case RejectReason.Blacklisted:
            return;
        }
        const drec = this.deliveryRecords.ensureRecord(msgIdStr);
        if (drec.status !== DeliveryRecordStatus.unknown) {
          log3("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from3, Date.now() - drec.firstSeen, DeliveryRecordStatus[drec.status]);
          return;
        }
        if (reason === RejectReason.Ignore) {
          drec.status = DeliveryRecordStatus.ignored;
          drec.peers.clear();
          return;
        }
        drec.status = DeliveryRecordStatus.invalid;
        this.markInvalidMessageDelivery(from3, topic);
        drec.peers.forEach((p) => {
          this.markInvalidMessageDelivery(p, topic);
        });
        drec.peers.clear();
      }
      duplicateMessage(from3, msgIdStr, topic) {
        const drec = this.deliveryRecords.ensureRecord(msgIdStr);
        if (drec.peers.has(from3)) {
          return;
        }
        switch (drec.status) {
          case DeliveryRecordStatus.unknown:
            drec.peers.add(from3);
            break;
          case DeliveryRecordStatus.valid:
            drec.peers.add(from3);
            this.markDuplicateMessageDelivery(from3, topic, drec.validated);
            break;
          case DeliveryRecordStatus.invalid:
            this.markInvalidMessageDelivery(from3, topic);
            break;
          case DeliveryRecordStatus.ignored:
            break;
        }
      }
      markInvalidMessageDelivery(from3, topic) {
        const pstats = this.peerStats.get(from3);
        if (pstats) {
          const tstats = this.getPtopicStats(pstats, topic);
          if (tstats) {
            tstats.invalidMessageDeliveries += 1;
          }
        }
      }
      markFirstMessageDelivery(from3, topic) {
        const pstats = this.peerStats.get(from3);
        if (pstats) {
          const tstats = this.getPtopicStats(pstats, topic);
          if (tstats) {
            let cap = this.params.topics[topic].firstMessageDeliveriesCap;
            tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
            if (tstats.inMesh) {
              cap = this.params.topics[topic].meshMessageDeliveriesCap;
              tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
            }
          }
        }
      }
      markDuplicateMessageDelivery(from3, topic, validatedTime) {
        var _a2;
        const pstats = this.peerStats.get(from3);
        if (pstats) {
          const now = validatedTime !== void 0 ? Date.now() : 0;
          const tstats = this.getPtopicStats(pstats, topic);
          if (tstats && tstats.inMesh) {
            const tparams = this.params.topics[topic];
            if (validatedTime !== void 0) {
              const deliveryDelayMs = now - validatedTime;
              const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
              (_a2 = this.metrics) == null ? void 0 : _a2.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
              if (isLateDelivery) {
                return;
              }
            }
            const cap = tparams.meshMessageDeliveriesCap;
            tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
          }
        }
      }
      getIPs(id) {
        return this.components.getConnectionManager().getConnections(peerIdFromString(id)).map((c) => c.remoteAddr.toOptions().host);
      }
      setIPs(id, newIPs, oldIPs) {
        addNewIPs:
          for (const ip of newIPs) {
            for (const xip of oldIPs) {
              if (ip === xip) {
                continue addNewIPs;
              }
            }
            let peers = this.peerIPs.get(ip);
            if (!peers) {
              peers = /* @__PURE__ */ new Set();
              this.peerIPs.set(ip, peers);
            }
            peers.add(id);
          }
        removeOldIPs:
          for (const ip of oldIPs) {
            for (const xip of newIPs) {
              if (ip === xip) {
                continue removeOldIPs;
              }
            }
            const peers = this.peerIPs.get(ip);
            if (!peers) {
              continue;
            }
            peers.delete(id);
            if (!peers.size) {
              this.peerIPs.delete(ip);
            }
          }
      }
      removeIPs(id, ips) {
        ips.forEach((ip) => {
          const peers = this.peerIPs.get(ip);
          if (!peers) {
            return;
          }
          peers.delete(id);
          if (!peers.size) {
            this.peerIPs.delete(ip);
          }
        });
      }
      updateIPs() {
        this.peerStats.forEach((pstats, id) => {
          const newIPs = this.getIPs(id);
          this.setIPs(id, newIPs, pstats.ips);
          pstats.ips = newIPs;
        });
      }
      getPtopicStats(pstats, topic) {
        let topicStats = pstats.topics[topic];
        if (topicStats !== void 0) {
          return topicStats;
        }
        if (this.params.topics[topic] !== void 0) {
          topicStats = {
            inMesh: false,
            graftTime: 0,
            meshTime: 0,
            firstMessageDeliveries: 0,
            meshMessageDeliveries: 0,
            meshMessageDeliveriesActive: false,
            meshFailurePenalty: 0,
            invalidMessageDeliveries: 0
          };
          pstats.topics[topic] = topicStats;
          return topicStats;
        }
        return null;
      }
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/index.js
var init_score = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/index.js"() {
    init_peer_score_params();
    init_peer_score_thresholds();
    init_peer_score();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/tracer.js
var IWantTracer;
var init_tracer = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/tracer.js"() {
    init_types();
    IWantTracer = class {
      constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
        this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
        this.msgIdToStrFn = msgIdToStrFn;
        this.metrics = metrics;
        this.promises = /* @__PURE__ */ new Map();
        this.requestMsByMsg = /* @__PURE__ */ new Map();
        this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
      }
      get size() {
        return this.promises.size;
      }
      get requestMsByMsgSize() {
        return this.requestMsByMsg.size;
      }
      addPromise(from3, msgIds) {
        const ix = Math.floor(Math.random() * msgIds.length);
        const msgId2 = msgIds[ix];
        const msgIdStr = this.msgIdToStrFn(msgId2);
        let expireByPeer = this.promises.get(msgIdStr);
        if (!expireByPeer) {
          expireByPeer = /* @__PURE__ */ new Map();
          this.promises.set(msgIdStr, expireByPeer);
        }
        const now = Date.now();
        if (!expireByPeer.has(from3)) {
          expireByPeer.set(from3, now + this.gossipsubIWantFollowupMs);
          if (this.metrics) {
            this.metrics.iwantPromiseStarted.inc(1);
            if (!this.requestMsByMsg.has(msgIdStr)) {
              this.requestMsByMsg.set(msgIdStr, now);
            }
          }
        }
      }
      getBrokenPromises() {
        var _a2;
        const now = Date.now();
        const result = /* @__PURE__ */ new Map();
        let brokenPromises = 0;
        this.promises.forEach((expireByPeer, msgId2) => {
          expireByPeer.forEach((expire, p) => {
            if (expire < now) {
              result.set(p, (result.get(p) ?? 0) + 1);
              expireByPeer.delete(p);
              brokenPromises++;
            }
          });
          if (!expireByPeer.size) {
            this.promises.delete(msgId2);
          }
        });
        (_a2 = this.metrics) == null ? void 0 : _a2.iwantPromiseBroken.inc(brokenPromises);
        return result;
      }
      deliverMessage(msgIdStr) {
        this.trackMessage(msgIdStr);
        const expireByPeer = this.promises.get(msgIdStr);
        if (expireByPeer) {
          this.promises.delete(msgIdStr);
          if (this.metrics) {
            this.metrics.iwantPromiseResolved.inc(1);
            this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
          }
        }
      }
      rejectMessage(msgIdStr, reason) {
        this.trackMessage(msgIdStr);
        switch (reason) {
          case RejectReason.Error:
            return;
        }
        this.promises.delete(msgIdStr);
      }
      clear() {
        this.promises.clear();
      }
      prune() {
        const maxMs = Date.now() - this.requestMsByMsgExpire;
        for (const [k, v] of this.requestMsByMsg.entries()) {
          if (v < maxMs) {
            this.requestMsByMsg.delete(k);
          } else {
            break;
          }
        }
      }
      trackMessage(msgIdStr) {
        if (this.metrics) {
          const requestMs = this.requestMsByMsg.get(msgIdStr);
          if (requestMs !== void 0) {
            this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
            this.requestMsByMsg.delete(msgIdStr);
          }
        }
      }
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/time-cache.js
var SimpleTimeCache;
var init_time_cache = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/time-cache.js"() {
    SimpleTimeCache = class {
      constructor(opts) {
        this.entries = /* @__PURE__ */ new Map();
        this.validityMs = opts.validityMs;
      }
      get size() {
        return this.entries.size;
      }
      put(key, value) {
        this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs });
      }
      prune() {
        const now = Date.now();
        for (const [k, v] of this.entries.entries()) {
          if (v.validUntilMs < now) {
            this.entries.delete(k);
          } else {
            break;
          }
        }
      }
      has(key) {
        return this.entries.has(key);
      }
      get(key) {
        const value = this.entries.get(key);
        return value && value.validUntilMs >= Date.now() ? value.value : void 0;
      }
      clear() {
        this.entries.clear();
      }
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js
function getMetrics(register, topicStrToLabel, opts) {
  return {
    protocolsEnabled: register.gauge({
      name: "gossipsub_protocol",
      help: "Status of enabled protocols",
      labelNames: ["protocol"]
    }),
    topicSubscriptionStatus: register.gauge({
      name: "gossipsub_topic_subscription_status",
      help: "Status of our subscription to this topic",
      labelNames: ["topicStr"]
    }),
    topicPeersCount: register.gauge({
      name: "gossipsub_topic_peer_count",
      help: "Number of peers subscribed to each topic",
      labelNames: ["topicStr"]
    }),
    meshPeerCounts: register.gauge({
      name: "gossipsub_mesh_peer_count",
      help: "Number of peers in our mesh",
      labelNames: ["topicStr"]
    }),
    meshPeerInclusionEvents: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_total",
      help: "Number of times we include peers in a topic mesh for different reasons",
      labelNames: ["topic", "reason"]
    }),
    meshPeerChurnEvents: register.gauge({
      name: "gossipsub_peer_churn_events_total",
      help: "Number of times we remove peers in a topic mesh for different reasons",
      labelNames: ["topic", "reason"]
    }),
    peersPerProtocol: register.gauge({
      name: "gossipsub_peers_per_protocol_count",
      help: "Peers connected for each topic",
      labelNames: ["protocol"]
    }),
    heartbeatDuration: register.histogram({
      name: "gossipsub_heartbeat_duration_seconds",
      help: "The time it takes to complete one iteration of the heartbeat",
      buckets: [0.01, 0.1, 1]
    }),
    heartbeatSkipped: register.gauge({
      name: "gossipsub_heartbeat_skipped",
      help: "Heartbeat run took longer than heartbeat interval so next is skipped"
    }),
    asyncValidationResult: register.gauge({
      name: "gossipsub_async_validation_result_total",
      help: "Message validation result for each topic",
      labelNames: ["topic", "acceptance"]
    }),
    asyncValidationMcacheHit: register.gauge({
      name: "gossipsub_async_validation_mcache_hit_total",
      help: "Async validation result reported by the user layer",
      labelNames: ["hit"]
    }),
    rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
    rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
    rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
    rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
    rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
    rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
    rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
    rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
    rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
    rpcRecvNotAccepted: register.gauge({
      name: "gossipsub_rpc_rcv_not_accepted_total",
      help: "Total count of RPC dropped because acceptFrom() == false"
    }),
    rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
    rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
    rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
    rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
    rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
    rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
    rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
    rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
    rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
    msgPublishCount: register.gauge({
      name: "gossipsub_msg_publish_count_total",
      help: "Total count of msg published by topic",
      labelNames: ["topic"]
    }),
    msgPublishPeers: register.gauge({
      name: "gossipsub_msg_publish_peers_total",
      help: "Total count of peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    msgPublishPeersByGroup: register.gauge({
      name: "gossipsub_msg_publish_peers_by_group",
      help: "Total count of peers (by group) that we publish a msg to",
      labelNames: ["topic", "peerGroup"]
    }),
    msgPublishBytes: register.gauge({
      name: "gossipsub_msg_publish_bytes_total",
      help: "Total count of msg publish data.length bytes",
      labelNames: ["topic"]
    }),
    msgForwardCount: register.gauge({
      name: "gossipsub_msg_forward_count_total",
      help: "Total count of msg forwarded by topic",
      labelNames: ["topic"]
    }),
    msgForwardPeers: register.gauge({
      name: "gossipsub_msg_forward_peers_total",
      help: "Total count of peers that we forward a msg to",
      labelNames: ["topic"]
    }),
    msgReceivedPreValidation: register.gauge({
      name: "gossipsub_msg_received_prevalidation_total",
      help: "Total count of recv msgs before any validation",
      labelNames: ["topic"]
    }),
    msgReceivedStatus: register.gauge({
      name: "gossipsub_msg_received_status_total",
      help: "Tracks distribution of recv msgs by duplicate, invalid, valid",
      labelNames: ["topic", "status"]
    }),
    msgReceivedInvalid: register.gauge({
      name: "gossipsub_msg_received_invalid_total",
      help: "Tracks specific reason of invalid",
      labelNames: ["topic", "error"]
    }),
    duplicateMsgDeliveryDelay: register.histogram({
      name: "gossisub_duplicate_msg_delivery_delay_seconds",
      help: "Time since the 1st duplicated message validated",
      labelNames: ["topic"],
      buckets: [
        0.25 * opts.maxMeshMessageDeliveriesWindowSec,
        0.5 * opts.maxMeshMessageDeliveriesWindowSec,
        1 * opts.maxMeshMessageDeliveriesWindowSec,
        2 * opts.maxMeshMessageDeliveriesWindowSec,
        4 * opts.maxMeshMessageDeliveriesWindowSec
      ]
    }),
    duplicateMsgLateDelivery: register.gauge({
      name: "gossisub_duplicate_msg_late_delivery_total",
      help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
      labelNames: ["topic"]
    }),
    scoreFnCalls: register.gauge({
      name: "gossipsub_score_fn_calls_total",
      help: "Total times score() is called"
    }),
    scoreFnRuns: register.gauge({
      name: "gossipsub_score_fn_runs_total",
      help: "Total times score() call actually computed computeScore(), no cache"
    }),
    scoreCachedDelta: register.histogram({
      name: "gossipsub_score_cache_delta",
      help: "Delta of score between cached values that expired",
      buckets: [10, 100, 1e3]
    }),
    peersByScoreThreshold: register.gauge({
      name: "gossipsub_peers_by_score_threshold_count",
      help: "Current count of peers by score threshold",
      labelNames: ["threshold"]
    }),
    score: register.avgMinMax({
      name: "gossipsub_score",
      help: "Avg min max of gossip scores",
      labelNames: ["topic", "p"]
    }),
    scoreWeights: register.avgMinMax({
      name: "gossipsub_score_weights",
      help: "Separate score weights",
      labelNames: ["topic", "p"]
    }),
    scorePerMesh: register.avgMinMax({
      name: "gossipsub_score_per_mesh",
      help: "Histogram of the scores for each mesh topic",
      labelNames: ["topic"]
    }),
    scoringPenalties: register.gauge({
      name: "gossipsub_scoring_penalties_total",
      help: "A counter of the kind of penalties being applied to peers",
      labelNames: ["penalty"]
    }),
    behaviourPenalty: register.histogram({
      name: "gossipsub_peer_stat_behaviour_penalty",
      help: "Current peer stat behaviour_penalty at each scrape",
      buckets: [
        0.25 * opts.behaviourPenaltyThreshold,
        0.5 * opts.behaviourPenaltyThreshold,
        1 * opts.behaviourPenaltyThreshold,
        2 * opts.behaviourPenaltyThreshold,
        4 * opts.behaviourPenaltyThreshold
      ]
    }),
    ihaveRcvIgnored: register.gauge({
      name: "gossipsub_ihave_rcv_ignored_total",
      help: "Total received IHAVE messages that we ignore for some reason",
      labelNames: ["reason"]
    }),
    ihaveRcvMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_msgids_total",
      help: "Total received IHAVE messages by topic",
      labelNames: ["topic"]
    }),
    ihaveRcvNotSeenMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_not_seen_msgids_total",
      help: "Total messages per topic we do not have, not actual requests",
      labelNames: ["topic"]
    }),
    iwantRcvMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_msgids_total",
      help: "Total received IWANT messages by topic",
      labelNames: ["topic"]
    }),
    iwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_dont_have_msgids_total",
      help: "Total requested messageIDs that we do not have"
    }),
    iwantPromiseStarted: register.gauge({
      name: "gossipsub_iwant_promise_sent_total",
      help: "Total count of started IWANT promises"
    }),
    iwantPromiseResolved: register.gauge({
      name: "gossipsub_iwant_promise_resolved_total",
      help: "Total count of resolved IWANT promises"
    }),
    iwantPromiseResolvedPeers: register.gauge({
      name: "gossipsub_iwant_promise_resolved_peers",
      help: "Total count of peers we have asked IWANT promises that are resolved"
    }),
    iwantPromiseBroken: register.gauge({
      name: "gossipsub_iwant_promise_broken",
      help: "Total count of broken IWANT promises"
    }),
    iwantPromiseDeliveryTime: register.histogram({
      name: "gossipsub_iwant_promise_delivery_seconds",
      help: "Histogram of delivery time of resolved IWANT promises",
      buckets: [
        0.5 * opts.gossipPromiseExpireSec,
        1 * opts.gossipPromiseExpireSec,
        2 * opts.gossipPromiseExpireSec,
        4 * opts.gossipPromiseExpireSec
      ]
    }),
    cacheSize: register.gauge({
      name: "gossipsub_cache_size",
      help: "Unbounded cache sizes",
      labelNames: ["cache"]
    }),
    mcacheSize: register.gauge({
      name: "gossipsub_mcache_size",
      help: "Current mcache msg count"
    }),
    topicStrToLabel,
    toTopic(topicStr) {
      return this.topicStrToLabel.get(topicStr) ?? topicStr;
    },
    onJoin(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 1);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    onLeave(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 0);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    onAddToMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerInclusionEvents.inc({ topic, reason }, count);
    },
    onRemoveFromMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      this.meshPeerChurnEvents.inc({ topic, reason }, count);
    },
    onReportValidationMcacheHit(hit) {
      this.asyncValidationMcacheHit.inc({ hit: hit ? "hit" : "miss" });
    },
    onReportValidation(topicStr, acceptance) {
      const topic = this.toTopic(topicStr);
      this.asyncValidationResult.inc({ topic, acceptance });
    },
    onScorePenalty(penalty) {
      this.scoringPenalties.inc({ penalty }, 1);
    },
    onIhaveRcv(topicStr, ihave, idonthave) {
      const topic = this.toTopic(topicStr);
      this.ihaveRcvMsgids.inc({ topic }, ihave);
      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
    },
    onIwantRcv(iwantByTopic, iwantDonthave) {
      for (const [topicStr, iwant] of iwantByTopic) {
        const topic = this.toTopic(topicStr);
        this.iwantRcvMsgids.inc({ topic }, iwant);
      }
      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
    },
    onForwardMsg(topicStr, tosendCount) {
      const topic = this.toTopic(topicStr);
      this.msgForwardCount.inc({ topic }, 1);
      this.msgForwardPeers.inc({ topic }, tosendCount);
    },
    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen) {
      const topic = this.toTopic(topicStr);
      this.msgPublishCount.inc({ topic }, 1);
      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
      this.msgPublishPeers.inc({ topic }, tosendCount);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "direct" }, tosendGroupCount.direct);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "floodsub" }, tosendGroupCount.floodsub);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "mesh" }, tosendGroupCount.mesh);
      this.msgPublishPeersByGroup.inc({ topic, peerGroup: "fanout" }, tosendGroupCount.fanout);
    },
    onMsgRecvPreValidation(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedPreValidation.inc({ topic }, 1);
    },
    onMsgRecvResult(topicStr, status) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedStatus.inc({ topic, status });
    },
    onMsgRecvInvalid(topicStr, reason) {
      const topic = this.toTopic(topicStr);
      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
      this.msgReceivedInvalid.inc({ topic, error }, 1);
    },
    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1e3);
      if (isLateDelivery) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgLateDelivery.inc({ topic }, 1);
      }
    },
    onRpcRecv(rpc, rpcBytes) {
      this.rpcRecvBytes.inc(rpcBytes);
      this.rpcRecvCount.inc(1);
      if (rpc.subscriptions)
        this.rpcRecvSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcRecvMessage.inc(rpc.messages.length);
      if (rpc.control) {
        this.rpcRecvControl.inc(1);
        if (rpc.control.ihave)
          this.rpcRecvIHave.inc(rpc.control.ihave.length);
        if (rpc.control.iwant)
          this.rpcRecvIWant.inc(rpc.control.iwant.length);
        if (rpc.control.graft)
          this.rpcRecvGraft.inc(rpc.control.graft.length);
        if (rpc.control.prune)
          this.rpcRecvPrune.inc(rpc.control.prune.length);
      }
    },
    onRpcSent(rpc, rpcBytes) {
      var _a2, _b, _c, _d;
      this.rpcSentBytes.inc(rpcBytes);
      this.rpcSentCount.inc(1);
      if (rpc.subscriptions)
        this.rpcSentSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcSentMessage.inc(rpc.messages.length);
      if (rpc.control) {
        const ihave = ((_a2 = rpc.control.ihave) == null ? void 0 : _a2.length) ?? 0;
        const iwant = ((_b = rpc.control.iwant) == null ? void 0 : _b.length) ?? 0;
        const graft = ((_c = rpc.control.graft) == null ? void 0 : _c.length) ?? 0;
        const prune = ((_d = rpc.control.prune) == null ? void 0 : _d.length) ?? 0;
        if (ihave > 0)
          this.rpcSentIHave.inc(ihave);
        if (iwant > 0)
          this.rpcSentIWant.inc(iwant);
        if (graft > 0)
          this.rpcSentGraft.inc(graft);
        if (prune > 0)
          this.rpcSentPrune.inc(prune);
        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0)
          this.rpcSentControl.inc(1);
      }
    },
    registerScores(scores, scoreThresholds) {
      let graylist = 0;
      let publish = 0;
      let gossip = 0;
      let mesh = 0;
      for (const score of scores) {
        if (score >= scoreThresholds.graylistThreshold)
          graylist++;
        if (score >= scoreThresholds.publishThreshold)
          publish++;
        if (score >= scoreThresholds.gossipThreshold)
          gossip++;
        if (score >= 0)
          mesh++;
      }
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
      this.score.set(scores);
    },
    registerScoreWeights(sw) {
      for (const [topic, wsTopic] of sw.byTopic) {
        this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
        this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
        this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
        this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
        this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
      }
      this.scoreWeights.set({ p: "p5" }, sw.p5w);
      this.scoreWeights.set({ p: "p6" }, sw.p6w);
      this.scoreWeights.set({ p: "p7" }, sw.p7w);
    },
    registerScorePerMesh(mesh, scoreByPeer) {
      const peersPerTopicLabel = /* @__PURE__ */ new Map();
      mesh.forEach((peers, topicStr) => {
        const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
        let peersInMesh = peersPerTopicLabel.get(topicLabel);
        if (!peersInMesh) {
          peersInMesh = /* @__PURE__ */ new Set();
          peersPerTopicLabel.set(topicLabel, peersInMesh);
        }
        peers.forEach((p) => peersInMesh == null ? void 0 : peersInMesh.add(p));
      });
      for (const [topic, peers] of peersPerTopicLabel) {
        const meshScores = [];
        peers.forEach((peer) => {
          meshScores.push(scoreByPeer.get(peer) ?? 0);
        });
        this.scorePerMesh.set({ topic }, meshScores);
      }
    }
  };
}
var MessageSource, InclusionReason, ChurnReason, ScorePenalty, IHaveIgnoreReason, ScoreThreshold;
var init_metrics = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js"() {
    init_types();
    (function(MessageSource2) {
      MessageSource2["forward"] = "forward";
      MessageSource2["publish"] = "publish";
    })(MessageSource || (MessageSource = {}));
    (function(InclusionReason2) {
      InclusionReason2["Fanout"] = "fanout";
      InclusionReason2["Random"] = "random";
      InclusionReason2["Subscribed"] = "subscribed";
      InclusionReason2["Outbound"] = "outbound";
      InclusionReason2["NotEnough"] = "not_enough";
      InclusionReason2["Opportunistic"] = "opportunistic";
    })(InclusionReason || (InclusionReason = {}));
    (function(ChurnReason2) {
      ChurnReason2["Dc"] = "disconnected";
      ChurnReason2["BadScore"] = "bad_score";
      ChurnReason2["Prune"] = "prune";
      ChurnReason2["Unsub"] = "unsubscribed";
      ChurnReason2["Excess"] = "excess";
    })(ChurnReason || (ChurnReason = {}));
    (function(ScorePenalty2) {
      ScorePenalty2["GraftBackoff"] = "graft_backoff";
      ScorePenalty2["BrokenPromise"] = "broken_promise";
      ScorePenalty2["MessageDeficit"] = "message_deficit";
      ScorePenalty2["IPColocation"] = "IP_colocation";
    })(ScorePenalty || (ScorePenalty = {}));
    (function(IHaveIgnoreReason2) {
      IHaveIgnoreReason2["LowScore"] = "low_score";
      IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
      IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
    })(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
    (function(ScoreThreshold2) {
      ScoreThreshold2["graylist"] = "graylist";
      ScoreThreshold2["publish"] = "publish";
      ScoreThreshold2["gossip"] = "gossip";
      ScoreThreshold2["mesh"] = "mesh";
    })(ScoreThreshold || (ScoreThreshold = {}));
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js
async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
  switch (publishConfig.type) {
    case PublishConfigType.Signing: {
      const rpcMsg = {
        from: publishConfig.author.toBytes(),
        data: transformedData,
        seqno: randomBytes(8),
        topic,
        signature: void 0,
        key: void 0
      };
      const bytes = concat([SignPrefix, RPC.Message.encode(rpcMsg).finish()]);
      rpcMsg.signature = await publishConfig.privateKey.sign(bytes);
      rpcMsg.key = publishConfig.key;
      const msg = {
        type: "signed",
        from: publishConfig.author,
        data: originalData,
        sequenceNumber: BigInt(`0x${toString2(rpcMsg.seqno, "base16")}`),
        topic,
        signature: rpcMsg.signature,
        key: rpcMsg.key
      };
      return {
        raw: rpcMsg,
        msg
      };
    }
    case PublishConfigType.Anonymous: {
      return {
        raw: {
          from: void 0,
          data: transformedData,
          seqno: void 0,
          topic,
          signature: void 0,
          key: void 0
        },
        msg: {
          type: "unsigned",
          data: originalData,
          topic
        }
      };
    }
  }
}
async function validateToRawMessage(signaturePolicy, msg) {
  switch (signaturePolicy) {
    case StrictNoSign:
      if (msg.signature != null)
        return { valid: false, error: ValidateError.SignaturePresent };
      if (msg.seqno != null)
        return { valid: false, error: ValidateError.SeqnoPresent };
      if (msg.key != null)
        return { valid: false, error: ValidateError.FromPresent };
      return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
    case StrictSign: {
      if (msg.seqno == null)
        return { valid: false, error: ValidateError.InvalidSeqno };
      if (msg.seqno.length !== 8) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.signature == null)
        return { valid: false, error: ValidateError.InvalidSignature };
      if (msg.from == null)
        return { valid: false, error: ValidateError.InvalidPeerId };
      let fromPeerId;
      try {
        fromPeerId = peerIdFromBytes(msg.from);
      } catch (e) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let publicKey;
      if (msg.key) {
        publicKey = unmarshalPublicKey(msg.key);
        if (fromPeerId.publicKey !== void 0 && !equals3(publicKey.bytes, fromPeerId.publicKey)) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
      } else {
        if (fromPeerId.publicKey == null) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        publicKey = unmarshalPublicKey(fromPeerId.publicKey);
      }
      const rpcMsgPreSign = {
        from: msg.from,
        data: msg.data,
        seqno: msg.seqno,
        topic: msg.topic,
        signature: void 0,
        key: void 0
      };
      const bytes = concat([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()]);
      if (!await publicKey.verify(bytes, msg.signature)) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      return {
        valid: true,
        message: {
          type: "signed",
          from: fromPeerId,
          data: msg.data ?? new Uint8Array(0),
          sequenceNumber: BigInt(`0x${toString2(msg.seqno, "base16")}`),
          topic: msg.topic,
          signature: msg.signature,
          key: msg.key ?? marshalPublicKey(publicKey)
        }
      };
    }
  }
}
var SignPrefix;
var init_buildRawMessage = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js"() {
    init_concat();
    init_from_string();
    init_keys2();
    init_src10();
    init_src4();
    init_equals();
    init_rpc();
    init_types();
    init_src21();
    init_to_string();
    SignPrefix = fromString2("libp2p-pubsub:");
  }
});

// node_modules/@libp2p/pubsub/dist/src/errors.js
var init_errors4 = __esm({
  "node_modules/@libp2p/pubsub/dist/src/errors.js"() {
  }
});

// node_modules/@libp2p/pubsub/dist/src/utils.js
var import_err_code20, msgId;
var init_utils2 = __esm({
  "node_modules/@libp2p/pubsub/dist/src/utils.js"() {
    init_src10();
    init_from_string();
    init_to_string();
    init_sha2();
    init_src4();
    init_errors4();
    import_err_code20 = __toESM(require_err_code(), 1);
    msgId = (key, seqno) => {
      const seqnoBytes = fromString2(seqno.toString(16).padStart(16, "0"), "base16");
      const msgId2 = new Uint8Array(key.length + seqnoBytes.length);
      msgId2.set(key, 0);
      msgId2.set(seqnoBytes, key.length);
      return msgId2;
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/msgIdFn.js
function msgIdFnStrictSign(msg) {
  if (msg.type !== "signed") {
    throw new Error("expected signed message type");
  }
  if (msg.sequenceNumber == null)
    throw Error("missing seqno field");
  return msgId(msg.from.toBytes(), msg.sequenceNumber);
}
async function msgIdFnStrictNoSign(msg) {
  return await sha256.encode(msg.data);
}
var init_msgIdFn = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/msgIdFn.js"() {
    init_sha2();
    init_utils2();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/scoreMetrics.js
function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
  let score = 0;
  const byTopic = /* @__PURE__ */ new Map();
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScores = byTopic.get(topicLabel);
    if (!topicScores) {
      topicScores = {
        p1w: 0,
        p2w: 0,
        p3w: 0,
        p3bw: 0,
        p4w: 0
      };
      byTopic.set(topicLabel, topicScores);
    }
    let p1w = 0;
    let p2w = 0;
    let p3w = 0;
    let p3bw = 0;
    let p4w = 0;
    if (tstats.inMesh) {
      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
      p1w += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    p2w += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      p3w += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    p3bw += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
    topicScores.p1w += p1w;
    topicScores.p2w += p2w;
    topicScores.p3w += p3w;
    topicScores.p3bw += p3bw;
    topicScores.p4w += p4w;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
    const capF = params.topicScoreCap / score;
    for (const ws of byTopic.values()) {
      ws.p1w *= capF;
      ws.p2w *= capF;
      ws.p3w *= capF;
      ws.p3bw *= capF;
      ws.p4w *= capF;
    }
  }
  let p5w = 0;
  let p6w = 0;
  let p7w = 0;
  const p5 = params.appSpecificScore(peer);
  p5w += p5 * params.appSpecificWeight;
  pstats.ips.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      p6w += p6 * params.IPColocationFactorWeight;
    }
  });
  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
  p7w += p7 * params.behaviourPenaltyWeight;
  score += p5w + p6w + p7w;
  return {
    byTopic,
    p5w,
    p6w,
    p7w,
    score
  };
}
function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
  const sw = {
    byTopic: /* @__PURE__ */ new Map(),
    p5w: [],
    p6w: [],
    p7w: [],
    score: []
  };
  for (const peerIdStr of peerIdStrs) {
    const pstats = peerStats.get(peerIdStr);
    if (pstats) {
      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
      for (const [topic, swPeerTopic] of swPeer.byTopic) {
        let swTopic = sw.byTopic.get(topic);
        if (!swTopic) {
          swTopic = {
            p1w: [],
            p2w: [],
            p3w: [],
            p3bw: [],
            p4w: []
          };
          sw.byTopic.set(topic, swTopic);
        }
        swTopic.p1w.push(swPeerTopic.p1w);
        swTopic.p2w.push(swPeerTopic.p2w);
        swTopic.p3w.push(swPeerTopic.p3w);
        swTopic.p3bw.push(swPeerTopic.p3bw);
        swTopic.p4w.push(swPeerTopic.p4w);
      }
      sw.p5w.push(swPeer.p5w);
      sw.p6w.push(swPeer.p6w);
      sw.p7w.push(swPeer.p7w);
      sw.score.push(swPeer.score);
    } else {
      sw.p5w.push(0);
      sw.p6w.push(0);
      sw.p7w.push(0);
      sw.score.push(0);
    }
  }
  return sw;
}
var init_scoreMetrics = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/scoreMetrics.js"() {
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/set.js
function removeItemsFromSet(superSet, ineed, cond = () => true) {
  const subset = /* @__PURE__ */ new Set();
  if (ineed <= 0)
    return subset;
  for (const id of superSet) {
    if (subset.size >= ineed)
      break;
    if (cond(id)) {
      subset.add(id);
      superSet.delete(id);
    }
  }
  return subset;
}
function removeFirstNItemsFromSet(superSet, ineed) {
  return removeItemsFromSet(superSet, ineed, () => true);
}
var init_set = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/set.js"() {
  }
});

// node_modules/abortable-iterator/dist/src/abort-error.js
var AbortError;
var init_abort_error = __esm({
  "node_modules/abortable-iterator/dist/src/abort-error.js"() {
    AbortError = class extends Error {
      constructor(message2, code2) {
        super(message2 ?? "The operation was aborted");
        this.type = "aborted";
        this.code = code2 ?? "ABORT_ERR";
      }
    };
  }
});

// node_modules/abortable-iterator/node_modules/get-iterator/dist/src/index.js
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}
var init_src23 = __esm({
  "node_modules/abortable-iterator/node_modules/get-iterator/dist/src/index.js"() {
  }
});

// node_modules/abortable-iterator/dist/src/index.js
function abortableSource(source, signal, options2) {
  const opts = options2 ?? {};
  const iterator = getIterator(source);
  async function* abortable() {
    let nextAbortHandler;
    const abortHandler = () => {
      if (nextAbortHandler != null)
        nextAbortHandler();
    };
    signal.addEventListener("abort", abortHandler);
    while (true) {
      let result;
      try {
        if (signal.aborted) {
          const { abortMessage, abortCode } = opts;
          throw new AbortError(abortMessage, abortCode);
        }
        const abort = new Promise((resolve, reject) => {
          nextAbortHandler = () => {
            const { abortMessage, abortCode } = opts;
            reject(new AbortError(abortMessage, abortCode));
          };
        });
        result = await Promise.race([abort, iterator.next()]);
        nextAbortHandler = null;
      } catch (err) {
        signal.removeEventListener("abort", abortHandler);
        const isKnownAborter = err.type === "aborted" && signal.aborted;
        if (isKnownAborter && opts.onAbort != null) {
          await opts.onAbort(source);
        }
        if (typeof iterator.return === "function") {
          try {
            const p = iterator.return();
            if (p instanceof Promise) {
              p.catch((err2) => {
                if (opts.onReturnError != null) {
                  opts.onReturnError(err2);
                }
              });
            }
          } catch (err2) {
            if (opts.onReturnError != null) {
              opts.onReturnError(err2);
            }
          }
        }
        if (isKnownAborter && opts.returnOnAbort === true) {
          return;
        }
        throw err;
      }
      if (result.done === true) {
        break;
      }
      yield result.value;
    }
    signal.removeEventListener("abort", abortHandler);
  }
  return abortable();
}
var init_src24 = __esm({
  "node_modules/abortable-iterator/dist/src/index.js"() {
    init_abort_error();
    init_src23();
  }
});

// node_modules/it-length-prefixed/dist/src/alloc.js
function allocUnsafe2(len) {
  var _a2;
  if (((_a2 = globalThis == null ? void 0 : globalThis.Buffer) == null ? void 0 : _a2.allocUnsafe) != null) {
    return globalThis.Buffer.allocUnsafe(len);
  }
  return new Uint8Array(len);
}
var init_alloc2 = __esm({
  "node_modules/it-length-prefixed/dist/src/alloc.js"() {
  }
});

// node_modules/it-length-prefixed/dist/src/encode.js
function encode5(options2) {
  options2 = options2 ?? {};
  const encodeLength = options2.lengthEncoder ?? defaultEncoder;
  const encoder = async function* (source) {
    for await (const chunk of source) {
      const length2 = encodeLength(chunk.byteLength);
      if (length2 instanceof Uint8Array) {
        yield length2;
      } else {
        yield* length2;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
  };
  return encoder;
}
var defaultEncoder;
var init_encode2 = __esm({
  "node_modules/it-length-prefixed/dist/src/encode.js"() {
    init_src11();
    init_src16();
    init_alloc2();
    defaultEncoder = (length2) => {
      const lengthLength = unsigned.encodingLength(length2);
      const lengthBuf = allocUnsafe2(lengthLength);
      unsigned.encode(length2, lengthBuf);
      defaultEncoder.bytes = lengthLength;
      return lengthBuf;
    };
    defaultEncoder.bytes = 0;
    encode5.single = (chunk, options2) => {
      options2 = options2 ?? {};
      const encodeLength = options2.lengthEncoder ?? defaultEncoder;
      return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
    };
  }
});

// node_modules/it-length-prefixed/dist/src/decode.js
function decode6(options2) {
  const decoder = async function* (source) {
    const buffer = new Uint8ArrayList();
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = (options2 == null ? void 0 : options2.lengthDecoder) ?? defaultDecoder;
    const maxLengthLength = (options2 == null ? void 0 : options2.maxLengthLength) ?? MAX_LENGTH_LENGTH;
    const maxDataLength = (options2 == null ? void 0 : options2.maxDataLength) ?? MAX_DATA_LENGTH;
    for await (const buf of source) {
      buffer.append(buf);
      while (buffer.byteLength > 0) {
        if (mode === ReadMode.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer);
            if (dataLength < 0) {
              throw (0, import_err_code21.default)(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
            }
            if (dataLength > maxDataLength) {
              throw (0, import_err_code21.default)(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer.consume(dataLengthLength);
            if ((options2 == null ? void 0 : options2.onLength) != null) {
              options2.onLength(dataLength);
            }
            mode = ReadMode.DATA;
          } catch (err) {
            if (err instanceof RangeError) {
              if (buffer.byteLength > maxLengthLength) {
                throw (0, import_err_code21.default)(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
              }
              break;
            }
            throw err;
          }
        }
        if (mode === ReadMode.DATA) {
          if (buffer.byteLength < dataLength) {
            break;
          }
          const data = buffer.sublist(0, dataLength);
          buffer.consume(dataLength);
          if ((options2 == null ? void 0 : options2.onData) != null) {
            options2.onData(data);
          }
          yield data;
          mode = ReadMode.LENGTH;
        }
      }
    }
    if (buffer.byteLength > 0) {
      throw (0, import_err_code21.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
    }
  };
  return decoder;
}
var import_err_code21, MAX_LENGTH_LENGTH, MAX_DATA_LENGTH, ReadMode, defaultDecoder;
var init_decode2 = __esm({
  "node_modules/it-length-prefixed/dist/src/decode.js"() {
    init_src11();
    init_src16();
    import_err_code21 = __toESM(require_err_code(), 1);
    MAX_LENGTH_LENGTH = 8;
    MAX_DATA_LENGTH = 1024 * 1024 * 4;
    (function(ReadMode2) {
      ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
      ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
    })(ReadMode || (ReadMode = {}));
    defaultDecoder = (buf) => {
      const length2 = unsigned.decode(buf);
      defaultDecoder.bytes = unsigned.encodingLength(length2);
      return length2;
    };
    defaultDecoder.bytes = 0;
    decode6.fromReader = (reader2, options2) => {
      let byteLength = 1;
      const varByteSource = async function* () {
        while (true) {
          try {
            const { done, value } = await reader2.next(byteLength);
            if (done === true) {
              return;
            }
            if (value != null) {
              yield value;
            }
          } catch (err) {
            if (err.code === "ERR_UNDER_READ") {
              return { done: true, value: null };
            }
            throw err;
          } finally {
            byteLength = 1;
          }
        }
      }();
      const onLength = (l) => {
        byteLength = l;
      };
      return decode6({
        ...options2 ?? {},
        onLength
      })(varByteSource);
    };
  }
});

// node_modules/it-length-prefixed/dist/src/index.js
var init_src25 = __esm({
  "node_modules/it-length-prefixed/dist/src/index.js"() {
    init_encode2();
    init_decode2();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/stream.js
var OutboundStream, InboundStream;
var init_stream = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/stream.js"() {
    init_src24();
    init_src8();
    init_src7();
    init_src25();
    OutboundStream = class {
      constructor(rawStream, errCallback, opts) {
        this.rawStream = rawStream;
        this.pushable = pushable({ objectMode: false });
        this.closeController = new AbortController();
        this.maxBufferSize = opts.maxBufferSize ?? Infinity;
        pipe(abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }), encode5(), this.rawStream).catch(errCallback);
      }
      get protocol() {
        return this.rawStream.stat.protocol;
      }
      push(data) {
        if (this.pushable.readableLength > this.maxBufferSize) {
          throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
        }
        this.pushable.push(data);
      }
      close() {
        this.closeController.abort();
        this.pushable.return();
        this.rawStream.close();
      }
    };
    InboundStream = class {
      constructor(rawStream) {
        this.rawStream = rawStream;
        this.closeController = new AbortController();
        this.source = abortableSource(pipe(this.rawStream, decode6()), this.closeController.signal, { returnOnAbort: true });
      }
      close() {
        this.closeController.abort();
        this.rawStream.close();
      }
    };
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  GossipSub: () => GossipSub,
  multicodec: () => multicodec
});
var multicodec, GossipStatusCode, GossipSub;
var init_src26 = __esm({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js"() {
    init_src8();
    init_src18();
    init_src4();
    init_src6();
    init_src20();
    init_events();
    init_message_cache();
    init_rpc();
    init_constants();
    init_utils();
    init_score();
    init_tracer();
    init_time_cache();
    init_constants();
    init_metrics();
    init_types();
    init_buildRawMessage();
    init_msgIdFn();
    init_scoreMetrics();
    init_publishConfig();
    init_src22();
    init_src21();
    init_set();
    init_src7();
    init_stream();
    multicodec = GossipsubIDv11;
    (function(GossipStatusCode2) {
      GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
      GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
    })(GossipStatusCode || (GossipStatusCode = {}));
    GossipSub = class extends EventEmitter {
      constructor(options2 = {}) {
        super();
        this.multicodecs = [GossipsubIDv11, GossipsubIDv10];
        this.peers = /* @__PURE__ */ new Set();
        this.streamsInbound = /* @__PURE__ */ new Map();
        this.streamsOutbound = /* @__PURE__ */ new Map();
        this.outboundInflightQueue = pushable({ objectMode: true });
        this.direct = /* @__PURE__ */ new Set();
        this.floodsubPeers = /* @__PURE__ */ new Set();
        this.acceptFromWhitelist = /* @__PURE__ */ new Map();
        this.topics = /* @__PURE__ */ new Map();
        this.subscriptions = /* @__PURE__ */ new Set();
        this.mesh = /* @__PURE__ */ new Map();
        this.fanout = /* @__PURE__ */ new Map();
        this.fanoutLastpub = /* @__PURE__ */ new Map();
        this.gossip = /* @__PURE__ */ new Map();
        this.control = /* @__PURE__ */ new Map();
        this.peerhave = /* @__PURE__ */ new Map();
        this.iasked = /* @__PURE__ */ new Map();
        this.backoff = /* @__PURE__ */ new Map();
        this.outbound = /* @__PURE__ */ new Map();
        this.topicValidators = /* @__PURE__ */ new Map();
        this.heartbeatTicks = 0;
        this.components = new Components();
        this.directPeerInitial = null;
        this.status = { code: GossipStatusCode.stopped };
        this.heartbeatTimer = null;
        this.runHeartbeat = () => {
          var _a2;
          const timer = (_a2 = this.metrics) == null ? void 0 : _a2.heartbeatDuration.startTimer();
          this.heartbeat().catch((err) => {
            this.log("Error running heartbeat", err);
          }).finally(() => {
            var _a3;
            if (timer != null) {
              timer();
            }
            if (this.status.code === GossipStatusCode.started) {
              clearTimeout(this.status.heartbeatTimeout);
              let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
              if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
                msToNextHeartbeat += this.opts.heartbeatInterval;
                (_a3 = this.metrics) == null ? void 0 : _a3.heartbeatSkipped.inc();
              }
              this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
            }
          });
        };
        const opts = {
          fallbackToFloodsub: true,
          floodPublish: true,
          doPX: false,
          directPeers: [],
          D: GossipsubD,
          Dlo: GossipsubDlo,
          Dhi: GossipsubDhi,
          Dscore: GossipsubDscore,
          Dout: GossipsubDout,
          Dlazy: GossipsubDlazy,
          heartbeatInterval: GossipsubHeartbeatInterval,
          fanoutTTL: GossipsubFanoutTTL,
          mcacheLength: GossipsubHistoryLength,
          mcacheGossip: GossipsubHistoryGossip,
          seenTTL: GossipsubSeenTTL,
          gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
          prunePeers: GossipsubPrunePeers,
          pruneBackoff: GossipsubPruneBackoff,
          graftFloodThreshold: GossipsubGraftFloodThreshold,
          opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
          opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
          directConnectTicks: GossipsubDirectConnectTicks,
          ...options2,
          scoreParams: createPeerScoreParams(options2.scoreParams),
          scoreThresholds: createPeerScoreThresholds(options2.scoreThresholds)
        };
        this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
        if (opts.fallbackToFloodsub) {
          this.multicodecs.push(FloodsubID);
        }
        this.log = logger(opts.debugName ?? "libp2p:gossipsub");
        this.opts = opts;
        this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));
        this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
        this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
        if (options2.msgIdFn) {
          this.msgIdFn = options2.msgIdFn;
        } else {
          switch (this.globalSignaturePolicy) {
            case StrictSign:
              this.msgIdFn = msgIdFnStrictSign;
              break;
            case StrictNoSign:
              this.msgIdFn = msgIdFnStrictNoSign;
              break;
          }
        }
        if (options2.fastMsgIdFn) {
          this.fastMsgIdFn = options2.fastMsgIdFn;
          this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
        }
        this.msgIdToStrFn = options2.msgIdToStrFn ?? messageIdToString;
        this.mcache = options2.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
        if (options2.dataTransform) {
          this.dataTransform = options2.dataTransform;
        }
        if (options2.metricsRegister) {
          if (!options2.metricsTopicStrToLabel) {
            throw Error("Must set metricsTopicStrToLabel with metrics");
          }
          const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
          const metrics = getMetrics(options2.metricsRegister, options2.metricsTopicStrToLabel, {
            gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
            behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
            maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
          });
          metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));
          for (const protocol of this.multicodecs) {
            metrics.protocolsEnabled.set({ protocol }, 1);
          }
          this.metrics = metrics;
        } else {
          this.metrics = null;
        }
        this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
        this.score = new PeerScore(this.opts.scoreParams, this.metrics, {
          scoreCacheValidityMs: opts.heartbeatInterval
        });
        this.maxInboundStreams = options2.maxInboundStreams;
        this.maxOutboundStreams = options2.maxOutboundStreams;
      }
      getPeers() {
        return [...this.peers.keys()].map((str) => peerIdFromString(str));
      }
      isStarted() {
        return this.status.code === GossipStatusCode.started;
      }
      async init(components) {
        this.components = components;
        this.score.init(components);
      }
      async start() {
        if (this.isStarted()) {
          return;
        }
        this.log("starting");
        this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.getPeerId());
        this.outboundInflightQueue = pushable({ objectMode: true });
        pipe(this.outboundInflightQueue, async (source) => {
          for await (const { peerId, connection } of source) {
            await this.createOutboundStream(peerId, connection);
          }
        }).catch((e) => this.log.error("outbound inflight queue error", e));
        await Promise.all(this.opts.directPeers.map(async (p) => {
          await this.components.getPeerStore().addressBook.add(p.id, p.addrs);
        }));
        const registrar = this.components.getRegistrar();
        await Promise.all(this.multicodecs.map((multicodec2) => registrar.handle(multicodec2, this.onIncomingStream.bind(this), {
          maxInboundStreams: this.maxInboundStreams,
          maxOutboundStreams: this.maxOutboundStreams
        })));
        const topology = createTopology({
          onConnect: this.onPeerConnected.bind(this),
          onDisconnect: this.onPeerDisconnected.bind(this)
        });
        const registrarTopologyIds = await Promise.all(this.multicodecs.map((multicodec2) => registrar.register(multicodec2, topology)));
        const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
        this.status = {
          code: GossipStatusCode.started,
          registrarTopologyIds,
          heartbeatTimeout,
          hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
        };
        this.score.start();
        this.directPeerInitial = setTimeout(() => {
          Promise.resolve().then(async () => {
            await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)));
          }).catch((err) => {
            this.log(err);
          });
        }, GossipsubDirectConnectInitialDelay);
        this.log("started");
      }
      async stop() {
        this.log("stopping");
        if (this.status.code !== GossipStatusCode.started) {
          return;
        }
        const { registrarTopologyIds } = this.status;
        this.status = { code: GossipStatusCode.stopped };
        const registrar = this.components.getRegistrar();
        registrarTopologyIds.forEach((id) => registrar.unregister(id));
        this.outboundInflightQueue.end();
        for (const outboundStream of this.streamsOutbound.values()) {
          outboundStream.close();
        }
        this.streamsOutbound.clear();
        for (const inboundStream of this.streamsInbound.values()) {
          inboundStream.close();
        }
        this.streamsInbound.clear();
        this.peers.clear();
        this.subscriptions.clear();
        if (this.heartbeatTimer) {
          this.heartbeatTimer.cancel();
          this.heartbeatTimer = null;
        }
        this.score.stop();
        this.mesh.clear();
        this.fanout.clear();
        this.fanoutLastpub.clear();
        this.gossip.clear();
        this.control.clear();
        this.peerhave.clear();
        this.iasked.clear();
        this.backoff.clear();
        this.outbound.clear();
        this.gossipTracer.clear();
        this.seenCache.clear();
        if (this.fastMsgIdCache)
          this.fastMsgIdCache.clear();
        if (this.directPeerInitial)
          clearTimeout(this.directPeerInitial);
        this.log("stopped");
      }
      dumpPeerScoreStats() {
        return this.score.dumpPeerScoreStats();
      }
      onIncomingStream({ stream, connection }) {
        if (!this.isStarted()) {
          return;
        }
        const peerId = connection.remotePeer;
        this.addPeer(peerId, connection.stat.direction);
        this.createInboundStream(peerId, stream);
        this.outboundInflightQueue.push({ peerId, connection });
      }
      onPeerConnected(peerId, connection) {
        if (!this.isStarted()) {
          return;
        }
        this.addPeer(peerId, connection.stat.direction);
        this.outboundInflightQueue.push({ peerId, connection });
      }
      onPeerDisconnected(peerId) {
        this.log("connection ended %p", peerId);
        this.removePeer(peerId);
      }
      async createOutboundStream(peerId, connection) {
        var _a2;
        if (!this.isStarted()) {
          return;
        }
        const id = peerId.toString();
        if (!this.peers.has(id)) {
          return;
        }
        if (this.streamsOutbound.has(id)) {
          return;
        }
        try {
          const stream = new OutboundStream(await connection.newStream(this.multicodecs), (e) => this.log.error("outbound pipe error", e), { maxBufferSize: this.opts.maxOutboundBufferSize });
          this.log("create outbound stream %p", peerId);
          this.streamsOutbound.set(id, stream);
          const protocol = stream.protocol;
          if (protocol === FloodsubID) {
            this.floodsubPeers.add(id);
          }
          (_a2 = this.metrics) == null ? void 0 : _a2.peersPerProtocol.inc({ protocol }, 1);
          if (this.subscriptions.size > 0) {
            this.log("send subscriptions to", id);
            this.sendSubscriptions(id, Array.from(this.subscriptions), true);
          }
        } catch (e) {
          this.log.error("createOutboundStream error", e);
        }
      }
      async createInboundStream(peerId, stream) {
        if (!this.isStarted()) {
          return;
        }
        const id = peerId.toString();
        if (!this.peers.has(id)) {
          return;
        }
        const priorInboundStream = this.streamsInbound.get(id);
        if (priorInboundStream !== void 0) {
          this.log("replacing existing inbound steam %s", id);
          priorInboundStream.close();
        }
        this.log("create inbound stream %s", id);
        const inboundStream = new InboundStream(stream);
        this.streamsInbound.set(id, inboundStream);
        this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => this.log(err));
      }
      addPeer(peerId, direction) {
        const id = peerId.toString();
        if (!this.peers.has(id)) {
          this.log("new peer %p", peerId);
          this.peers.add(id);
          this.score.addPeer(id);
          if (!this.outbound.has(id)) {
            this.outbound.set(id, direction === "outbound");
          }
        }
      }
      removePeer(peerId) {
        var _a2, _b;
        const id = peerId.toString();
        if (!this.peers.has(id)) {
          return;
        }
        this.log("delete peer %p", peerId);
        this.peers.delete(id);
        const outboundStream = this.streamsOutbound.get(id);
        const inboundStream = this.streamsInbound.get(id);
        if (outboundStream) {
          (_a2 = this.metrics) == null ? void 0 : _a2.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
        }
        outboundStream == null ? void 0 : outboundStream.close();
        inboundStream == null ? void 0 : inboundStream.close();
        this.streamsOutbound.delete(id);
        this.streamsInbound.delete(id);
        for (const peers of this.topics.values()) {
          peers.delete(id);
        }
        for (const [topicStr, peers] of this.mesh) {
          if (peers.delete(id) === true) {
            (_b = this.metrics) == null ? void 0 : _b.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
          }
        }
        for (const peers of this.fanout.values()) {
          peers.delete(id);
        }
        this.floodsubPeers.delete(id);
        this.gossip.delete(id);
        this.control.delete(id);
        this.outbound.delete(id);
        this.score.removePeer(id);
        this.acceptFromWhitelist.delete(id);
      }
      get started() {
        return this.status.code === GossipStatusCode.started;
      }
      getMeshPeers(topic) {
        const peersInTopic = this.mesh.get(topic);
        return peersInTopic ? Array.from(peersInTopic) : [];
      }
      getSubscribers(topic) {
        const peersInTopic = this.topics.get(topic);
        return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str));
      }
      getTopics() {
        return Array.from(this.subscriptions);
      }
      async pipePeerReadStream(peerId, stream) {
        try {
          await pipe(stream, async (source) => {
            var _a2;
            for await (const data of source) {
              try {
                const rpcBytes = data.subarray();
                const rpc = RPC.decode(rpcBytes);
                (_a2 = this.metrics) == null ? void 0 : _a2.onRpcRecv(rpc, rpcBytes.length);
                if (this.opts.awaitRpcHandler) {
                  await this.handleReceivedRpc(peerId, rpc);
                } else {
                  this.handleReceivedRpc(peerId, rpc).catch((err) => this.log(err));
                }
              } catch (e) {
                this.log(e);
              }
            }
          });
        } catch (err) {
          this.log.error(err);
          this.onPeerDisconnected(peerId);
        }
      }
      async handleReceivedRpc(from3, rpc) {
        var _a2;
        if (!this.acceptFrom(from3.toString())) {
          this.log("received message from unacceptable peer %p", from3);
          (_a2 = this.metrics) == null ? void 0 : _a2.rpcRecvNotAccepted.inc();
          return;
        }
        this.log("rpc from %p", from3);
        if (rpc.subscriptions && rpc.subscriptions.length > 0) {
          rpc.subscriptions.forEach((subOpt) => {
            this.handleReceivedSubscription(from3, subOpt);
          });
          this.dispatchEvent(new CustomEvent("subscription-change", {
            detail: {
              peerId: from3,
              subscriptions: rpc.subscriptions.filter((sub) => sub.topic !== null).map((sub) => {
                return {
                  topic: sub.topic ?? "",
                  subscribe: Boolean(sub.subscribe)
                };
              })
            }
          }));
        }
        if (rpc.messages) {
          for (const message2 of rpc.messages) {
            const handleReceivedMessagePromise = this.handleReceivedMessage(from3, message2).catch((err) => this.log(err));
            if (this.opts.awaitRpcMessageHandler) {
              await handleReceivedMessagePromise;
            }
          }
        }
        if (rpc.control) {
          await this.handleControlMessage(from3.toString(), rpc.control);
        }
      }
      handleReceivedSubscription(from3, subOpt) {
        if (subOpt.topic == null) {
          return;
        }
        this.log("subscription update from %p topic %s", from3, subOpt.topic);
        let topicSet = this.topics.get(subOpt.topic);
        if (topicSet == null) {
          topicSet = /* @__PURE__ */ new Set();
          this.topics.set(subOpt.topic, topicSet);
        }
        if (subOpt.subscribe) {
          topicSet.add(from3.toString());
        } else {
          topicSet.delete(from3.toString());
        }
      }
      async handleReceivedMessage(from3, rpcMsg) {
        var _a2, _b, _c;
        (_a2 = this.metrics) == null ? void 0 : _a2.onMsgRecvPreValidation(rpcMsg.topic);
        const validationResult = await this.validateReceivedMessage(from3, rpcMsg);
        (_b = this.metrics) == null ? void 0 : _b.onMsgRecvResult(rpcMsg.topic, validationResult.code);
        switch (validationResult.code) {
          case MessageStatus.duplicate:
            this.score.duplicateMessage(from3.toString(), validationResult.msgIdStr, rpcMsg.topic);
            this.mcache.observeDuplicate(validationResult.msgIdStr, from3.toString());
            return;
          case MessageStatus.invalid:
            if (validationResult.msgIdStr) {
              const msgIdStr = validationResult.msgIdStr;
              this.score.rejectMessage(from3.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
              this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
            } else {
              this.score.rejectInvalidMessage(from3.toString(), rpcMsg.topic);
            }
            (_c = this.metrics) == null ? void 0 : _c.onMsgRecvInvalid(rpcMsg.topic, validationResult);
            return;
          case MessageStatus.valid:
            this.score.validateMessage(validationResult.messageId.msgIdStr);
            this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
            this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
            if (this.subscriptions.has(rpcMsg.topic)) {
              const isFromSelf = this.components.getPeerId().equals(from3);
              if (!isFromSelf || this.opts.emitSelf) {
                super.dispatchEvent(new CustomEvent("gossipsub:message", {
                  detail: {
                    propagationSource: from3,
                    msgId: validationResult.messageId.msgIdStr,
                    msg: validationResult.msg
                  }
                }));
                super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
              }
            }
            if (!this.opts.asyncValidation) {
              this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from3.toString());
            }
        }
      }
      async validateReceivedMessage(propagationSource, rpcMsg) {
        var _a2, _b, _c;
        const fastMsgIdStr = (_a2 = this.fastMsgIdFn) == null ? void 0 : _a2.call(this, rpcMsg);
        const msgIdCached = fastMsgIdStr ? (_b = this.fastMsgIdCache) == null ? void 0 : _b.get(fastMsgIdStr) : void 0;
        if (msgIdCached) {
          return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
        }
        const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
        if (!validationResult.valid) {
          return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
        }
        const msg = validationResult.message;
        try {
          if (this.dataTransform) {
            msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
          }
        } catch (e) {
          this.log("Invalid message, transform failed", e);
          return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
        }
        const msgId2 = await this.msgIdFn(msg);
        const msgIdStr = this.msgIdToStrFn(msgId2);
        const messageId = { msgId: msgId2, msgIdStr };
        if (fastMsgIdStr)
          (_c = this.fastMsgIdCache) == null ? void 0 : _c.put(fastMsgIdStr, msgIdStr);
        if (this.seenCache.has(msgIdStr)) {
          return { code: MessageStatus.duplicate, msgIdStr };
        } else {
          this.seenCache.put(msgIdStr);
        }
        const topicValidator = this.topicValidators.get(rpcMsg.topic);
        if (topicValidator != null) {
          let acceptance;
          try {
            acceptance = await topicValidator(msg.topic, msg, propagationSource);
          } catch (e) {
            const errCode6 = e.code;
            if (errCode6 === ERR_TOPIC_VALIDATOR_IGNORE)
              acceptance = MessageAcceptance.Ignore;
            if (errCode6 === ERR_TOPIC_VALIDATOR_REJECT)
              acceptance = MessageAcceptance.Reject;
            else
              acceptance = MessageAcceptance.Ignore;
          }
          if (acceptance !== MessageAcceptance.Accept) {
            return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
          }
        }
        return { code: MessageStatus.valid, messageId, msg };
      }
      getScore(peerId) {
        return this.score.score(peerId);
      }
      sendSubscriptions(toPeer, topics, subscribe) {
        this.sendRpc(toPeer, {
          subscriptions: topics.map((topic) => ({ topic, subscribe })),
          messages: []
        });
      }
      async handleControlMessage(id, controlMsg) {
        if (controlMsg === void 0) {
          return;
        }
        const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];
        const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];
        const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];
        controlMsg.prune && await this.handlePrune(id, controlMsg.prune);
        if (!iwant.length && !ihave.length && !prune.length) {
          return;
        }
        this.sendRpc(id, createGossipRpc(ihave, { iwant, prune }));
      }
      acceptFrom(id) {
        if (this.direct.has(id)) {
          return true;
        }
        const now = Date.now();
        const entry = this.acceptFromWhitelist.get(id);
        if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
          entry.messagesAccepted += 1;
          return true;
        }
        const score = this.score.score(id);
        if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
          this.acceptFromWhitelist.set(id, {
            messagesAccepted: 0,
            acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
          });
        } else {
          this.acceptFromWhitelist.delete(id);
        }
        return score >= this.opts.scoreThresholds.graylistThreshold;
      }
      handleIHave(id, ihave) {
        var _a2, _b, _c;
        if (!ihave.length) {
          return [];
        }
        const score = this.score.score(id);
        if (score < this.opts.scoreThresholds.gossipThreshold) {
          this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
          (_a2 = this.metrics) == null ? void 0 : _a2.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
          return [];
        }
        const peerhave = (this.peerhave.get(id) ?? 0) + 1;
        this.peerhave.set(id, peerhave);
        if (peerhave > GossipsubMaxIHaveMessages) {
          this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
          (_b = this.metrics) == null ? void 0 : _b.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
          return [];
        }
        const iasked = this.iasked.get(id) ?? 0;
        if (iasked >= GossipsubMaxIHaveLength) {
          this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
          (_c = this.metrics) == null ? void 0 : _c.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
          return [];
        }
        const iwant = /* @__PURE__ */ new Map();
        ihave.forEach(({ topicID, messageIDs }) => {
          var _a3;
          if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
            return;
          }
          let idonthave = 0;
          messageIDs.forEach((msgId2) => {
            const msgIdStr = this.msgIdToStrFn(msgId2);
            if (!this.seenCache.has(msgIdStr)) {
              iwant.set(msgIdStr, msgId2);
              idonthave++;
            }
          });
          (_a3 = this.metrics) == null ? void 0 : _a3.onIhaveRcv(topicID, messageIDs.length, idonthave);
        });
        if (!iwant.size) {
          return [];
        }
        let iask = iwant.size;
        if (iask + iasked > GossipsubMaxIHaveLength) {
          iask = GossipsubMaxIHaveLength - iasked;
        }
        this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
        let iwantList = Array.from(iwant.values());
        shuffle(iwantList);
        iwantList = iwantList.slice(0, iask);
        this.iasked.set(id, iasked + iask);
        this.gossipTracer.addPromise(id, iwantList);
        return [
          {
            messageIDs: iwantList
          }
        ];
      }
      handleIWant(id, iwant) {
        var _a2;
        if (!iwant.length) {
          return [];
        }
        const score = this.score.score(id);
        if (score < this.opts.scoreThresholds.gossipThreshold) {
          this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
          return [];
        }
        const ihave = /* @__PURE__ */ new Map();
        const iwantByTopic = /* @__PURE__ */ new Map();
        let iwantDonthave = 0;
        iwant.forEach(({ messageIDs }) => {
          messageIDs && messageIDs.forEach((msgId2) => {
            const msgIdStr = this.msgIdToStrFn(msgId2);
            const entry = this.mcache.getWithIWantCount(msgIdStr, id);
            if (entry == null) {
              iwantDonthave++;
              return;
            }
            iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
            if (entry.count > GossipsubGossipRetransmission) {
              this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
              return;
            }
            ihave.set(msgIdStr, entry.msg);
          });
        });
        (_a2 = this.metrics) == null ? void 0 : _a2.onIwantRcv(iwantByTopic, iwantDonthave);
        if (!ihave.size) {
          this.log("IWANT: Could not provide any wanted messages to %s", id);
          return [];
        }
        this.log("IWANT: Sending %d messages to %s", ihave.size, id);
        return Array.from(ihave.values());
      }
      async handleGraft(id, graft) {
        const prune = [];
        const score = this.score.score(id);
        const now = Date.now();
        let doPX = this.opts.doPX;
        graft.forEach(({ topicID }) => {
          var _a2, _b;
          if (!topicID) {
            return;
          }
          const peersInMesh = this.mesh.get(topicID);
          if (!peersInMesh) {
            doPX = false;
            return;
          }
          if (peersInMesh.has(id)) {
            return;
          }
          if (this.direct.has(id)) {
            this.log("GRAFT: ignoring request from direct peer %s", id);
            prune.push(topicID);
            doPX = false;
            return;
          }
          const expire = (_a2 = this.backoff.get(topicID)) == null ? void 0 : _a2.get(id);
          if (typeof expire === "number" && now < expire) {
            this.log("GRAFT: ignoring backed off peer %s", id);
            this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
            doPX = false;
            const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
            if (now < floodCutoff) {
              this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
            }
            this.addBackoff(id, topicID);
            prune.push(topicID);
            return;
          }
          if (score < 0) {
            this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
            prune.push(topicID);
            doPX = false;
            this.addBackoff(id, topicID);
            return;
          }
          if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {
            prune.push(topicID);
            this.addBackoff(id, topicID);
            return;
          }
          this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
          this.score.graft(id, topicID);
          peersInMesh.add(id);
          (_b = this.metrics) == null ? void 0 : _b.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
        });
        if (!prune.length) {
          return [];
        }
        return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX)));
      }
      async handlePrune(id, prune) {
        var _a2;
        const score = this.score.score(id);
        for (const { topicID, backoff, peers } of prune) {
          if (topicID == null) {
            continue;
          }
          const peersInMesh = this.mesh.get(topicID);
          if (!peersInMesh) {
            return;
          }
          this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
          this.score.prune(id, topicID);
          if (peersInMesh.has(id)) {
            peersInMesh.delete(id);
            (_a2 = this.metrics) == null ? void 0 : _a2.onRemoveFromMesh(topicID, ChurnReason.Unsub, 1);
          }
          if (typeof backoff === "number" && backoff > 0) {
            this.doAddBackoff(id, topicID, backoff * 1e3);
          } else {
            this.addBackoff(id, topicID);
          }
          if (peers && peers.length) {
            if (score < this.opts.scoreThresholds.acceptPXThreshold) {
              this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
              continue;
            }
            await this.pxConnect(peers);
          }
        }
      }
      addBackoff(id, topic) {
        this.doAddBackoff(id, topic, this.opts.pruneBackoff);
      }
      doAddBackoff(id, topic, interval) {
        let backoff = this.backoff.get(topic);
        if (!backoff) {
          backoff = /* @__PURE__ */ new Map();
          this.backoff.set(topic, backoff);
        }
        const expire = Date.now() + interval;
        const existingExpire = backoff.get(id) ?? 0;
        if (existingExpire < expire) {
          backoff.set(id, expire);
        }
      }
      applyIwantPenalties() {
        this.gossipTracer.getBrokenPromises().forEach((count, p) => {
          this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
          this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);
        });
      }
      clearBackoff() {
        if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
          return;
        }
        const now = Date.now();
        this.backoff.forEach((backoff, topic) => {
          backoff.forEach((expire, id) => {
            if (expire < now) {
              backoff.delete(id);
            }
          });
          if (backoff.size === 0) {
            this.backoff.delete(topic);
          }
        });
      }
      async directConnect() {
        const toconnect = [];
        this.direct.forEach((id) => {
          if (!this.streamsOutbound.has(id)) {
            toconnect.push(id);
          }
        });
        await Promise.all(toconnect.map(async (id) => await this.connect(id)));
      }
      async pxConnect(peers) {
        if (peers.length > this.opts.prunePeers) {
          shuffle(peers);
          peers = peers.slice(0, this.opts.prunePeers);
        }
        const toconnect = [];
        await Promise.all(peers.map(async (pi) => {
          if (!pi.peerID) {
            return;
          }
          const p = peerIdFromBytes(pi.peerID).toString();
          if (this.peers.has(p)) {
            return;
          }
          if (!pi.signedPeerRecord) {
            toconnect.push(p);
            return;
          }
          try {
            const envelope = await RecordEnvelope.openAndCertify(pi.signedPeerRecord, "libp2p-peer-record");
            const eid = envelope.peerId;
            if (!envelope.peerId.equals(p)) {
              this.log("bogus peer record obtained through px: peer ID %p doesn't match expected peer %p", eid, p);
              return;
            }
            if (!await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {
              this.log("bogus peer record obtained through px: could not add peer record to address book");
              return;
            }
            toconnect.push(p);
          } catch (e) {
            this.log("bogus peer record obtained through px: invalid signature or not a peer record");
          }
        }));
        if (!toconnect.length) {
          return;
        }
        await Promise.all(toconnect.map(async (id) => await this.connect(id)));
      }
      async connect(id) {
        this.log("Initiating connection with %s", id);
        const peerId = peerIdFromString(id);
        const connection = await this.components.getConnectionManager().openConnection(peerId);
        for (const multicodec2 of this.multicodecs) {
          for (const topology of this.components.getRegistrar().getTopologies(multicodec2)) {
            topology.onConnect(peerId, connection);
          }
        }
      }
      subscribe(topic) {
        if (this.status.code !== GossipStatusCode.started) {
          throw new Error("Pubsub has not started");
        }
        if (!this.subscriptions.has(topic)) {
          this.subscriptions.add(topic);
          for (const peerId of this.peers.keys()) {
            this.sendSubscriptions(peerId, [topic], true);
          }
        }
        this.join(topic);
      }
      unsubscribe(topic) {
        if (this.status.code !== GossipStatusCode.started) {
          throw new Error("Pubsub is not started");
        }
        const wasSubscribed = this.subscriptions.delete(topic);
        this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
        if (wasSubscribed) {
          for (const peerId of this.peers.keys()) {
            this.sendSubscriptions(peerId, [topic], false);
          }
        }
        this.leave(topic).catch((err) => {
          this.log(err);
        });
      }
      join(topic) {
        var _a2, _b, _c;
        if (this.status.code !== GossipStatusCode.started) {
          throw new Error("Gossipsub has not started");
        }
        if (this.mesh.has(topic)) {
          return;
        }
        this.log("JOIN %s", topic);
        (_a2 = this.metrics) == null ? void 0 : _a2.onJoin(topic);
        const toAdd = /* @__PURE__ */ new Set();
        const fanoutPeers = this.fanout.get(topic);
        if (fanoutPeers) {
          this.fanout.delete(topic);
          this.fanoutLastpub.delete(topic);
          fanoutPeers.forEach((id) => {
            if (!this.direct.has(id) && this.score.score(id) >= 0) {
              toAdd.add(id);
            }
          });
          (_b = this.metrics) == null ? void 0 : _b.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
        }
        if (toAdd.size < this.opts.D) {
          const fanoutCount = toAdd.size;
          const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0);
          newPeers.forEach((peer) => {
            toAdd.add(peer);
          });
          (_c = this.metrics) == null ? void 0 : _c.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
        }
        this.mesh.set(topic, toAdd);
        toAdd.forEach((id) => {
          this.log("JOIN: Add mesh link to %s in %s", id, topic);
          this.sendGraft(id, topic);
        });
      }
      async leave(topic) {
        var _a2;
        if (this.status.code !== GossipStatusCode.started) {
          throw new Error("Gossipsub has not started");
        }
        this.log("LEAVE %s", topic);
        (_a2 = this.metrics) == null ? void 0 : _a2.onLeave(topic);
        const meshPeers = this.mesh.get(topic);
        if (meshPeers) {
          await Promise.all(Array.from(meshPeers).map(async (id) => {
            this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
            return await this.sendPrune(id, topic);
          }));
          this.mesh.delete(topic);
        }
      }
      selectPeersToForward(topic, propagationSource, excludePeers) {
        const tosend = /* @__PURE__ */ new Set();
        const peersInTopic = this.topics.get(topic);
        if (peersInTopic) {
          this.direct.forEach((peer) => {
            if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers == null ? void 0 : excludePeers.has(peer))) {
              tosend.add(peer);
            }
          });
          this.floodsubPeers.forEach((peer) => {
            if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers == null ? void 0 : excludePeers.has(peer)) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
              tosend.add(peer);
            }
          });
        }
        const meshPeers = this.mesh.get(topic);
        if (meshPeers && meshPeers.size > 0) {
          meshPeers.forEach((peer) => {
            if (propagationSource !== peer && !(excludePeers == null ? void 0 : excludePeers.has(peer))) {
              tosend.add(peer);
            }
          });
        }
        return tosend;
      }
      selectPeersToPublish(topic) {
        const tosend = /* @__PURE__ */ new Set();
        const tosendCount = {
          direct: 0,
          floodsub: 0,
          mesh: 0,
          fanout: 0
        };
        const peersInTopic = this.topics.get(topic);
        if (peersInTopic) {
          if (this.opts.floodPublish) {
            peersInTopic.forEach((id) => {
              if (this.direct.has(id)) {
                tosend.add(id);
                tosendCount.direct++;
              } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
                tosend.add(id);
                tosendCount.floodsub++;
              }
            });
          } else {
            this.direct.forEach((id) => {
              if (peersInTopic.has(id)) {
                tosend.add(id);
                tosendCount.direct++;
              }
            });
            this.floodsubPeers.forEach((id) => {
              if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
                tosend.add(id);
                tosendCount.floodsub++;
              }
            });
            const meshPeers = this.mesh.get(topic);
            if (meshPeers && meshPeers.size > 0) {
              meshPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.mesh++;
              });
            } else {
              const fanoutPeers = this.fanout.get(topic);
              if (fanoutPeers && fanoutPeers.size > 0) {
                fanoutPeers.forEach((peer) => {
                  tosend.add(peer);
                  tosendCount.fanout++;
                });
              } else {
                const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
                  return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
                });
                if (newFanoutPeers.size > 0) {
                  this.fanout.set(topic, newFanoutPeers);
                  newFanoutPeers.forEach((peer) => {
                    tosend.add(peer);
                    tosendCount.fanout++;
                  });
                }
              }
              this.fanoutLastpub.set(topic, Date.now());
            }
          }
        }
        return { tosend, tosendCount };
      }
      forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
        var _a2;
        if (propagationSource) {
          this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
        }
        const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
        const rpc = createGossipRpc([rawMsg]);
        tosend.forEach((id) => {
          this.sendRpc(id, rpc);
        });
        (_a2 = this.metrics) == null ? void 0 : _a2.onForwardMsg(rawMsg.topic, tosend.size);
      }
      async publish(topic, data) {
        var _a2;
        const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;
        if (this.publishConfig == null) {
          throw Error("PublishError.Uninitialized");
        }
        const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
        const msgId2 = await this.msgIdFn(msg);
        const msgIdStr = this.msgIdToStrFn(msgId2);
        if (this.seenCache.has(msgIdStr)) {
          throw Error("PublishError.Duplicate");
        }
        const { tosend, tosendCount } = this.selectPeersToPublish(topic);
        const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic);
        if (tosend.size === 0 && !this.opts.allowPublishToZeroPeers && !willSendToSelf) {
          throw Error("PublishError.InsufficientPeers");
        }
        this.seenCache.put(msgIdStr);
        this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
        this.publishedMessageIds.put(msgIdStr);
        const rpc = createGossipRpc([rawMsg]);
        for (const id of tosend) {
          const sent = this.sendRpc(id, rpc);
          if (!sent) {
            tosend.delete(id);
          }
        }
        (_a2 = this.metrics) == null ? void 0 : _a2.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0);
        if (willSendToSelf) {
          tosend.add(this.components.getPeerId().toString());
          super.dispatchEvent(new CustomEvent("gossipsub:message", {
            detail: {
              propagationSource: this.components.getPeerId(),
              msgId: msgIdStr,
              msg
            }
          }));
          super.dispatchEvent(new CustomEvent("message", { detail: msg }));
        }
        return {
          recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))
        };
      }
      reportMessageValidationResult(msgId2, propagationSource, acceptance) {
        var _a2, _b, _c, _d;
        if (acceptance === MessageAcceptance.Accept) {
          const cacheEntry = this.mcache.validate(msgId2);
          (_a2 = this.metrics) == null ? void 0 : _a2.onReportValidationMcacheHit(cacheEntry !== null);
          if (cacheEntry != null) {
            const { message: rawMsg, originatingPeers } = cacheEntry;
            this.score.deliverMessage(propagationSource.toString(), msgId2, rawMsg.topic);
            this.forwardMessage(msgId2, cacheEntry.message, propagationSource.toString(), originatingPeers);
            (_b = this.metrics) == null ? void 0 : _b.onReportValidation(rawMsg.topic, acceptance);
          }
        } else {
          const cacheEntry = this.mcache.remove(msgId2);
          (_c = this.metrics) == null ? void 0 : _c.onReportValidationMcacheHit(cacheEntry !== null);
          if (cacheEntry) {
            const rejectReason = rejectReasonFromAcceptance(acceptance);
            const { message: rawMsg, originatingPeers } = cacheEntry;
            this.score.rejectMessage(propagationSource.toString(), msgId2, rawMsg.topic, rejectReason);
            for (const peer of originatingPeers) {
              this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
            }
            (_d = this.metrics) == null ? void 0 : _d.onReportValidation(rawMsg.topic, acceptance);
          }
        }
      }
      sendGraft(id, topic) {
        const graft = [
          {
            topicID: topic
          }
        ];
        const out = createGossipRpc([], { graft });
        this.sendRpc(id, out);
      }
      async sendPrune(id, topic) {
        const prune = [await this.makePrune(id, topic, this.opts.doPX)];
        const out = createGossipRpc([], { prune });
        this.sendRpc(id, out);
      }
      sendRpc(id, rpc) {
        var _a2;
        const outboundStream = this.streamsOutbound.get(id);
        if (!outboundStream) {
          this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
          return false;
        }
        const ctrl = this.control.get(id);
        if (ctrl) {
          this.piggybackControl(id, rpc, ctrl);
          this.control.delete(id);
        }
        const ihave = this.gossip.get(id);
        if (ihave) {
          this.piggybackGossip(id, rpc, ihave);
          this.gossip.delete(id);
        }
        const rpcBytes = RPC.encode(rpc).finish();
        try {
          outboundStream.push(rpcBytes);
        } catch (e) {
          this.log.error(`Cannot send rpc to ${id}`, e);
          if (ctrl) {
            this.control.set(id, ctrl);
          }
          if (ihave) {
            this.gossip.set(id, ihave);
          }
          return false;
        }
        (_a2 = this.metrics) == null ? void 0 : _a2.onRpcSent(rpc, rpcBytes.length);
        return true;
      }
      piggybackControl(id, outRpc, ctrl) {
        const tograft = (ctrl.graft || []).filter(({ topicID }) => (topicID && this.mesh.get(topicID) || /* @__PURE__ */ new Set()).has(id));
        const toprune = (ctrl.prune || []).filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || /* @__PURE__ */ new Set()).has(id));
        if (!tograft.length && !toprune.length) {
          return;
        }
        if (outRpc.control) {
          outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);
          outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);
        } else {
          outRpc.control = { graft: tograft, prune: toprune, ihave: [], iwant: [] };
        }
      }
      piggybackGossip(id, outRpc, ihave) {
        if (!outRpc.control) {
          outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };
        }
        outRpc.control.ihave = ihave;
      }
      async sendGraftPrune(tograft, toprune, noPX) {
        const doPX = this.opts.doPX;
        for (const [id, topics] of tograft) {
          const graft = topics.map((topicID) => ({ topicID }));
          let prune = [];
          const pruning = toprune.get(id);
          if (pruning) {
            prune = await Promise.all(pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
            toprune.delete(id);
          }
          const outRpc = createGossipRpc([], { graft, prune });
          this.sendRpc(id, outRpc);
        }
        for (const [id, topics] of toprune) {
          const prune = await Promise.all(topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false))));
          const outRpc = createGossipRpc([], { prune });
          this.sendRpc(id, outRpc);
        }
      }
      emitGossip(peersToGossipByTopic) {
        const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
        for (const [topic, peersToGossip] of peersToGossipByTopic) {
          this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
        }
      }
      doEmitGossip(topic, candidateToGossip, messageIDs) {
        if (!messageIDs.length) {
          return;
        }
        shuffle(messageIDs);
        if (messageIDs.length > GossipsubMaxIHaveLength) {
          this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
        }
        if (!candidateToGossip.size)
          return;
        let target = this.opts.Dlazy;
        const factor = GossipsubGossipFactor * candidateToGossip.size;
        let peersToGossip = candidateToGossip;
        if (factor > target) {
          target = factor;
        }
        if (target > peersToGossip.size) {
          target = peersToGossip.size;
        } else {
          peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
        }
        peersToGossip.forEach((id) => {
          let peerMessageIDs = messageIDs;
          if (messageIDs.length > GossipsubMaxIHaveLength) {
            peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
          }
          this.pushGossip(id, {
            topicID: topic,
            messageIDs: peerMessageIDs
          });
        });
      }
      flush() {
        for (const [peer, ihave] of this.gossip.entries()) {
          this.gossip.delete(peer);
          this.sendRpc(peer, createGossipRpc([], { ihave }));
        }
        for (const [peer, control] of this.control.entries()) {
          this.control.delete(peer);
          this.sendRpc(peer, createGossipRpc([], { graft: control.graft, prune: control.prune }));
        }
      }
      pushGossip(id, controlIHaveMsgs) {
        this.log("Add gossip to %s", id);
        const gossip = this.gossip.get(id) || [];
        this.gossip.set(id, gossip.concat(controlIHaveMsgs));
      }
      async makePrune(id, topic, doPX) {
        this.score.prune(id, topic);
        if (this.streamsOutbound.get(id).protocol === GossipsubIDv10) {
          return {
            topicID: topic,
            peers: []
          };
        }
        const backoff = this.opts.pruneBackoff / 1e3;
        if (!doPX) {
          return {
            topicID: topic,
            peers: [],
            backoff
          };
        }
        const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
          return xid !== id && this.score.score(xid) >= 0;
        });
        const px = await Promise.all(Array.from(peers).map(async (peerId) => {
          const id2 = peerIdFromString(peerId);
          return {
            peerID: id2.toBytes(),
            signedPeerRecord: await this.components.getPeerStore().addressBook.getRawEnvelope(id2)
          };
        }));
        return {
          topicID: topic,
          peers: px,
          backoff
        };
      }
      async heartbeat() {
        var _a2, _b;
        const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
        this.heartbeatTicks++;
        const scores = /* @__PURE__ */ new Map();
        const getScore = (id) => {
          let s = scores.get(id);
          if (s === void 0) {
            s = this.score.score(id);
            scores.set(id, s);
          }
          return s;
        };
        const tograft = /* @__PURE__ */ new Map();
        const toprune = /* @__PURE__ */ new Map();
        const noPX = /* @__PURE__ */ new Map();
        this.clearBackoff();
        this.peerhave.clear();
        (_a2 = this.metrics) == null ? void 0 : _a2.cacheSize.set({ cache: "iasked" }, this.iasked.size);
        this.iasked.clear();
        this.applyIwantPenalties();
        if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
          await this.directConnect();
        }
        (_b = this.fastMsgIdCache) == null ? void 0 : _b.prune();
        this.seenCache.prune();
        this.gossipTracer.prune();
        this.publishedMessageIds.prune();
        const peersToGossipByTopic = /* @__PURE__ */ new Map();
        this.mesh.forEach((peers, topic) => {
          const peersInTopic = this.topics.get(topic);
          const candidateMeshPeers = /* @__PURE__ */ new Set();
          const peersToGossip = /* @__PURE__ */ new Set();
          peersToGossipByTopic.set(topic, peersToGossip);
          if (peersInTopic) {
            const shuffledPeers = shuffle(Array.from(peersInTopic));
            const backoff = this.backoff.get(topic);
            for (const id of shuffledPeers) {
              const peerStreams = this.streamsOutbound.get(id);
              if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
                const score = getScore(id);
                if ((!backoff || !backoff.has(id)) && score >= 0)
                  candidateMeshPeers.add(id);
                if (score >= this.opts.scoreThresholds.gossipThreshold)
                  peersToGossip.add(id);
              }
            }
          }
          const prunePeer = (id, reason) => {
            var _a3;
            this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
            this.addBackoff(id, topic);
            peers.delete(id);
            if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
            (_a3 = this.metrics) == null ? void 0 : _a3.onRemoveFromMesh(topic, reason, 1);
            const topics = toprune.get(id);
            if (!topics) {
              toprune.set(id, [topic]);
            } else {
              topics.push(topic);
            }
          };
          const graftPeer = (id, reason) => {
            var _a3;
            this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
            this.score.graft(id, topic);
            peers.add(id);
            peersToGossip.delete(id);
            (_a3 = this.metrics) == null ? void 0 : _a3.onAddToMesh(topic, reason, 1);
            const topics = tograft.get(id);
            if (!topics) {
              tograft.set(id, [topic]);
            } else {
              topics.push(topic);
            }
          };
          peers.forEach((id) => {
            const score = getScore(id);
            if (score < 0) {
              this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
              prunePeer(id, ChurnReason.BadScore);
              noPX.set(id, true);
            }
          });
          if (peers.size < Dlo) {
            const ineed = D - peers.size;
            const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
            newMeshPeers.forEach((p) => {
              graftPeer(p, InclusionReason.NotEnough);
            });
          }
          if (peers.size > Dhi) {
            let peersArray = Array.from(peers);
            peersArray.sort((a, b) => getScore(b) - getScore(a));
            peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
            let outbound = 0;
            peersArray.slice(0, D).forEach((p) => {
              if (this.outbound.get(p)) {
                outbound++;
              }
            });
            if (outbound < Dout) {
              const rotate = (i) => {
                const p = peersArray[i];
                for (let j = i; j > 0; j--) {
                  peersArray[j] = peersArray[j - 1];
                }
                peersArray[0] = p;
              };
              if (outbound > 0) {
                let ihave = outbound;
                for (let i = 1; i < D && ihave > 0; i++) {
                  if (this.outbound.get(peersArray[i])) {
                    rotate(i);
                    ihave--;
                  }
                }
              }
              let ineed = D - outbound;
              for (let i = D; i < peersArray.length && ineed > 0; i++) {
                if (this.outbound.get(peersArray[i])) {
                  rotate(i);
                  ineed--;
                }
              }
            }
            peersArray.slice(D).forEach((p) => {
              prunePeer(p, ChurnReason.Excess);
            });
          }
          if (peers.size >= Dlo) {
            let outbound = 0;
            peers.forEach((p) => {
              if (this.outbound.get(p)) {
                outbound++;
              }
            });
            if (outbound < Dout) {
              const ineed = Dout - outbound;
              const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
              newMeshPeers.forEach((p) => {
                graftPeer(p, InclusionReason.Outbound);
              });
            }
          }
          if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
            const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
            const medianIndex = Math.floor(peers.size / 2);
            const medianScore = getScore(peersList[medianIndex]);
            if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
              const ineed = this.opts.opportunisticGraftPeers;
              const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
              for (const id of newMeshPeers) {
                this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
                graftPeer(id, InclusionReason.Opportunistic);
              }
            }
          }
        });
        const now = Date.now();
        this.fanoutLastpub.forEach((lastpb, topic) => {
          if (lastpb + fanoutTTL < now) {
            this.fanout.delete(topic);
            this.fanoutLastpub.delete(topic);
          }
        });
        this.fanout.forEach((fanoutPeers, topic) => {
          const topicPeers = this.topics.get(topic);
          fanoutPeers.forEach((id) => {
            if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
              fanoutPeers.delete(id);
            }
          });
          const peersInTopic = this.topics.get(topic);
          const candidateFanoutPeers = [];
          const peersToGossip = /* @__PURE__ */ new Set();
          peersToGossipByTopic.set(topic, peersToGossip);
          if (peersInTopic) {
            const shuffledPeers = shuffle(Array.from(peersInTopic));
            for (const id of shuffledPeers) {
              const peerStreams = this.streamsOutbound.get(id);
              if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
                const score = getScore(id);
                if (score >= this.opts.scoreThresholds.publishThreshold)
                  candidateFanoutPeers.push(id);
                if (score >= this.opts.scoreThresholds.gossipThreshold)
                  peersToGossip.add(id);
              }
            }
          }
          if (fanoutPeers.size < D) {
            const ineed = D - fanoutPeers.size;
            candidateFanoutPeers.slice(0, ineed).forEach((id) => {
              fanoutPeers.add(id);
              peersToGossip == null ? void 0 : peersToGossip.delete(id);
            });
          }
        });
        this.emitGossip(peersToGossipByTopic);
        await this.sendGraftPrune(tograft, toprune, noPX);
        this.flush();
        this.mcache.shift();
        this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
      }
      getRandomGossipPeers(topic, count, filter = () => true) {
        const peersInTopic = this.topics.get(topic);
        if (!peersInTopic) {
          return /* @__PURE__ */ new Set();
        }
        let peers = [];
        peersInTopic.forEach((id) => {
          const peerStreams = this.streamsOutbound.get(id);
          if (!peerStreams) {
            return;
          }
          if (this.multicodecs.includes(peerStreams.protocol) && filter(id)) {
            peers.push(id);
          }
        });
        peers = shuffle(peers);
        if (count > 0 && peers.length > count) {
          peers = peers.slice(0, count);
        }
        return new Set(peers);
      }
      onScrapeMetrics(metrics) {
        var _a2, _b;
        metrics.mcacheSize.set(this.mcache.size);
        metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
        metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
        metrics.cacheSize.set({ cache: "fastMsgIdCache" }, ((_a2 = this.fastMsgIdCache) == null ? void 0 : _a2.size) ?? 0);
        metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
        metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
        metrics.cacheSize.set({ cache: "score" }, this.score.size);
        metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
        metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
        metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
        metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
        metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
        metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
        metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
        metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
        metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
        metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
        metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
        metrics.cacheSize.set({ cache: "control" }, this.control.size);
        metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
        metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
        let backoffSize = 0;
        for (const backoff of this.backoff.values()) {
          backoffSize += backoff.size;
        }
        metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
        for (const [topicStr, peers] of this.topics) {
          metrics.topicPeersCount.set({ topicStr }, peers.size);
        }
        for (const [topicStr, peers] of this.mesh) {
          metrics.meshPeerCounts.set({ topicStr }, peers.size);
        }
        const scores = [];
        const scoreByPeer = /* @__PURE__ */ new Map();
        metrics.behaviourPenalty.reset();
        for (const peerIdStr of this.peers.keys()) {
          const score = this.score.score(peerIdStr);
          scores.push(score);
          scoreByPeer.set(peerIdStr, score);
          metrics.behaviourPenalty.observe(((_b = this.score.peerStats.get(peerIdStr)) == null ? void 0 : _b.behaviourPenalty) ?? 0);
        }
        metrics.registerScores(scores, this.opts.scoreThresholds);
        metrics.registerScorePerMesh(this.mesh, scoreByPeer);
        const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
        metrics.registerScoreWeights(sw);
      }
    };
    GossipSub.multicodec = GossipsubIDv11;
  }
});

// src-electron/electron-main.js
var import_electron = require("electron");
init_to_string();
init_concat();
init_cid();
var import_path = __toESM(require("path"));
var import_os = __toESM(require("os"));
var platform = process.platform || import_os.default.platform();
try {
  if (platform === "win32" && import_electron.nativeTheme.shouldUseDarkColors === true) {
    require("fs").unlinkSync(import_path.default.join(import_electron.app.getPath("userData"), "DevTools Extensions"));
  }
} catch (_) {
}
var mainWindow;
async function startIpfs() {
  const { createEd25519PeerId: createEd25519PeerId2 } = await Promise.resolve().then(() => (init_src5(), src_exports));
  const { PreSharedKeyConnectionProtector: PreSharedKeyConnectionProtector2 } = await Promise.resolve().then(() => (init_pnet(), pnet_exports));
  const { GossipSub: GossipSub2 } = await Promise.resolve().then(() => (init_src26(), src_exports2));
  const { createFromPrivKey: createFromPrivKey2 } = await Promise.resolve().then(() => (init_src5(), src_exports));
  const { unmarshalPrivateKey: unmarshalPrivateKey3 } = await Promise.resolve().then(() => (init_keys2(), keys_exports2));
  const createIpfs = (await import("ipfs")).create;
  const privkeyC = "CAESQFtFT7hyKfs6YL0v9Yw+GzlvoGymxiQPb8MYGTMvWqykbmFnrir2XblTT5NnMS+FqFNHnOYCOgspxI/bmR9FCFY=";
  const privkeyJ = "CAESQCinZzMaWWhwmbYfp1t6WRfG+xvoU98nMHwioM3wYVIqL8mPg7EOqjgkT+aITabiReIZo4lUyLo+kI0fWFDxIz4=";
  const privkeyM = "CAESQKaSEkS9k36q1M59NxlncioI4t6BLEqIs2E0fQwJZlXyXoP3JVfj9lz31CXPIUZKE7U2efgYW13yqeGvNWKmnKg=";
  const privkeyO = "CAESQPHWqKGMjLXlHyoYYEfdHznhYXwmxi2dUPcUCiM4pinDMzAc8OmstdPJ4DPqzdv/y3QFS9yI0SOFijO43J919gw=";
  const bootstrap = [];
  const privKey = Buffer.from(privkeyO, "base64");
  const PK = await unmarshalPrivateKey3(new Uint8Array(privKey));
  const myPeerId = await createFromPrivKey2(PK);
  console.log("my peerId:", myPeerId.toString());
  const swarmKey = "L2tleS9zd2FybS9wc2svMS4wLjAvCi9iYXNlMTYvCjZkMDBmNjA3MDc2ZTE3NTM0NzZhMDk3MWQ3NDAzNmViZDU5YTI4NDQ4YjNkZGFmOTAwZTYzYjJhZDc4MjgzOGI";
  const p2pOptions = {
    peerId: myPeerId,
    pubsub: new GossipSub2({
      allowPublishToZeroPeers: true,
      fallbackToFloodsub: true,
      emitSelf: false,
      maxInboundStreams: 64,
      maxOutboundStreams: 128
    }),
    connectionProtector: new PreSharedKeyConnectionProtector2({
      psk: new Uint8Array(Buffer.from(swarmKey, "base64"))
    }),
    nat: {
      enabled: false
    }
  };
  ipfs = await createIpfs({
    libp2p: p2pOptions,
    repo: import_path.default.join(import_os.default.homedir(), ".ipfs-" + myPeerId.toString()),
    config: {
      Bootstrap: bootstrap
    }
  });
  const libp2p = ipfs.libp2p;
  libp2p.connectionManager.addEventListener("peer:connect", async (evt) => {
    const { detail: connection } = evt;
    const { remotePeer } = connection;
    console.log("peer:connect", remotePeer.toString());
  });
  libp2p.connectionManager.addEventListener("peer:disconnect", async (evt) => {
    const { detail: connection } = evt;
    const { remotePeer } = connection;
    console.log("peer:disconnect", remotePeer.toString());
  });
  await ipfs.pubsub.subscribe("ipfsfilemsg", async (msg) => {
    console.log("got file message : ", msg.from.toString(), toString2(msg.data));
    const cid = CID.parse(toString2(msg.data));
    const chunks = [];
    for await (const chunk of ipfs.cat(cid)) {
      chunks.push(chunk);
    }
    const content = toString2(concat(chunks));
    console.log("got file : ", content);
  });
  await ipfs.pubsub.subscribe("ipfsdagmsg", async (msg) => {
    console.log("got dag message : %o", msg.from.toString(), toString2(msg.data));
    const cid = CID.parse(toString2(msg.data));
    const result = await ipfs.dag.get(cid);
    console.log("got dag : ", result.value);
  });
  let nfile = 0;
  setInterval(async () => {
    const peers = await ipfs.pubsub.peers("ipfsfilemsg");
    peers.forEach((p) => console.log("peer : ", p.toString()));
    const resfile = await ipfs.add(myPeerId.toString() + " ipfs file #" + nfile);
    console.log("save ipfs : ", resfile.path);
    await ipfs.pubsub.publish("ipfsfilemsg", new TextEncoder().encode(resfile.path));
    const resdag = await ipfs.dag.put({
      content: myPeerId.toString() + " ipfs dag #" + nfile
    }, { storeCodec: "dag-cbor", hashAlg: "sha2-256" });
    console.log("save dag : ", resdag.toString());
    await ipfs.pubsub.publish("ipfsdagmsg", new TextEncoder().encode(resdag.toString()));
    nfile++;
  }, 1e4);
  console.log(await ipfs.bootstrap.list());
}
function createWindow() {
  mainWindow = new import_electron.BrowserWindow({
    icon: import_path.default.resolve(__dirname, "icons/icon.png"),
    width: 1e3,
    height: 600,
    useContentSize: true,
    webPreferences: {
      contextIsolation: true,
      preload: import_path.default.resolve(__dirname, "/Users/admin/Code/ipfs-electron/.quasar/electron/electron-preload.js")
    }
  });
  mainWindow.loadURL("http://localhost:9300");
  if (true) {
    mainWindow.webContents.openDevTools();
  } else {
    mainWindow.webContents.on("devtools-opened", () => {
      mainWindow.webContents.closeDevTools();
    });
  }
  startIpfs();
  mainWindow.on("closed", () => {
    mainWindow = null;
  });
}
import_electron.app.whenReady().then(createWindow);
import_electron.app.on("window-all-closed", () => {
  if (platform !== "darwin") {
    import_electron.app.quit();
  }
});
import_electron.app.on("activate", () => {
  if (mainWindow === null) {
    createWindow();
  }
});
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vdmVuZG9yL2Jhc2UteC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYnl0ZXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2lkZW50aXR5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UxMC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTE2LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMzIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UzNi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTU4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlNjQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS92ZW5kb3IvdmFyaW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy92YXJpbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9kaWdlc3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9oYXNoZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9zaGEyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9oYXNoZXMvaWRlbnRpdHkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NvZGVjcy9yYXcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NvZGVjcy9qc29uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9jaWQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNpY3MuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvYWxsb2MuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvdXRpbC9iYXNlcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy90by1zdHJpbmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvY29uY2F0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9hc3Byb21pc2UvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Jhc2U2NC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mbG9hdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvaW5xdWlyZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvdXRmOC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvcG9vbC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2NvZGVnZW4vaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2ZldGNoL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wYXRoL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZmllbGQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29uZW9mLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9uYW1lc3BhY2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21hcGZpZWxkLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tZXRob2QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3NlcnZpY2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21lc3NhZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2RlY29kZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3ZlcmlmaWVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9jb252ZXJ0ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyYXBwZXJzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9vYmplY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VudW0uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VuY29kZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LWxpZ2h0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90b2tlbml6ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcGFyc2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbW1vbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvbnMtcnVudGltZS9zcmMvZGVjb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b25zLXJ1bnRpbWUvc3JjL2VuY29kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9ucy1ydW50aW1lL3NyYy9jb2RlYy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9ucy1ydW50aW1lL3NyYy9jb2RlY3MvZW51bS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9ucy1ydW50aW1lL3NyYy9jb2RlY3MvbWVzc2FnZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9ucy1ydW50aW1lL3NyYy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL2tleXMva2V5cy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvZm9yZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Jhc2VOLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi91dGlsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9vaWRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9hc24xLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9jaXBoZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2NpcGhlck1vZGVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9hZXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Rlcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2htYWMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3Bia2RmMi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGVtLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9zaGEyNTYuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BybmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JhbmRvbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcmMyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9qc2JuLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9zaGExLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wa2NzMS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJpbWUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JzYS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGJlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9lcnItY29kZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy9mcm9tLXN0cmluZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL2htYWMvbGVuZ3Rocy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL2htYWMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY3J5cHRvL3NyYy9rZXlzL2tleS1zdHJldGNoZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY3J5cHRvL3NyYy9rZXlzL2VjZGgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY3J5cHRvL3NyYy9rZXlzL2VwaGVtZXJhbC1rZXlzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL2NyeXB0by9zcmMvY2lwaGVycy9hZXMtZ2NtLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL2NyeXB0by9zcmMva2V5cy9pbXBvcnRlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy9lcXVhbHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTUxMi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9saWIvZXNtL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL2NyeXB0by9zcmMvcmFuZG9tLWJ5dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL2NyeXB0by9zcmMvdXRpbC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL2tleXMvcnNhLXV0aWxzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL2NyeXB0by9zcmMva2V5cy9yc2EudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY3J5cHRvL3NyYy9rZXlzL2V4cG9ydGVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL2NyeXB0by9zcmMva2V5cy9yc2EtY2xhc3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9lZDI1NTE5L2xpYi9lc20vaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY3J5cHRvL3NyYy9rZXlzL2VkMjU1MTkudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY3J5cHRvL3NyYy9rZXlzL2VkMjU1MTktY2xhc3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY3J5cHRvL3NyYy9rZXlzL3NlY3AyNTZrMS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL2tleXMvc2VjcDI1NmsxLWNsYXNzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL2NyeXB0by9zcmMva2V5cy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9pbnRlcmZhY2UtcGVlci1pZC9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1pZC1mYWN0b3J5L3NyYy9wcm90by50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLWlkLWZhY3Rvcnkvc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9oYXMtZmxhZy9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvbG9nZ2VyL3NyYy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvaXQtcHVzaGFibGUvc3JjL2ZpZm8udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2l0LXB1c2hhYmxlL3NyYy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvZmFzdC1maWZvL2ZpeGVkLXNpemUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZmlmby9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvaXQtbWVyZ2Uvbm9kZV9tb2R1bGVzL2l0LXB1c2hhYmxlL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pdC1tZXJnZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvaXQtcGlwZS9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3AtZGVmZXIvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2l0LXBhaXIvc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pdC1wYWlyL3NyYy9kdXBsZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY3J5cHRvL3NyYy9hZXMvY2lwaGVycy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL2Flcy9jaXBoZXItbW9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL2Flcy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL3Bia2RmMi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9jcnlwdG8vc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9saWJwMnAvc3JjL3BuZXQvZXJyb3JzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9saWJwMnAvc3JjL2Vycm9ycy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMveHNhbHNhMjAveHNhbHNhMjAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3hzYWxzYTIwL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9saWJwMnAvc3JjL3BuZXQva2V5LWdlbmVyYXRvci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGlicDJwL3NyYy9wbmV0L2NyeXB0by50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdWludDhhcnJheWxpc3Qvc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pdC1yZWFkZXIvc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pdC1oYW5kc2hha2Uvc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pdC1tYXAvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xpYnAycC9zcmMvcG5ldC9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wZWVyLXJlY29yZC9zcmMvZXJyb3JzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItcmVjb3JkL3NyYy9lbnZlbG9wZS9lbnZlbG9wZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvYnl0ZS1hY2Nlc3Mvc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sb25nYml0cy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3VpbnQ4LXZhcmludC9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1yZWNvcmQvc3JjL2VudmVsb3BlL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9ub2RlX21vZHVsZXMvaXAtcmVnZXgvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLXRpbWVvdXQvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbnZlcnQtaHJ0aW1lL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aW1lLXNwYW4vaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2lzLXJlZ2V4cC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY2xvbmUtcmVnZXhwL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdXBlci1yZWdleC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvbm9kZV9tb2R1bGVzL2lzLWlwL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211bHRpYWRkci9zcmMvaXAudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL3NyYy9wcm90b2NvbHMtdGFibGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3ZhcmludC9lbmNvZGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3ZhcmludC9sZW5ndGguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3ZhcmludC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvc3JjL2NvbnZlcnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVsdGlhZGRyL3NyYy9jb2RlYy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdWx0aWFkZHIvc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL3V0aWxzL3NyYy9hcnJheS1lcXVhbHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1yZWNvcmQvc3JjL3BlZXItcmVjb3JkL3BlZXItcmVjb3JkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItcmVjb3JkL3NyYy9wZWVyLXJlY29yZC9jb25zdHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvcGVlci1yZWNvcmQvc3JjL3BlZXItcmVjb3JkL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AbGlicDJwL3BlZXItcmVjb3JkL3NyYy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9pbnRlcmZhY2UtcmVnaXN0cmFyL3NyYy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC90b3BvbG9neS9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvaW50ZXJmYWNlcy9zcmMvZXZlbnRzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL21lc3NhZ2UtY2FjaGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9taW5pbWFsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL21lc3NhZ2UvcnBjLmNqcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy9tZXNzYWdlL3JwYy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy9jb25zdGFudHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9zcmMvdXRpbHMvY3JlYXRlLWdvc3NpcC1ycGMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9zcmMvdXRpbHMvc2h1ZmZsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy91dGlscy9tZXNzYWdlSWRUb1N0cmluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9pbnRlcmZhY2UtcHVic3ViL3NyYy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy90eXBlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy91dGlscy9wdWJsaXNoQ29uZmlnLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL3V0aWxzL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL3Njb3JlL2NvbnN0YW50cy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy9zY29yZS9wZWVyLXNjb3JlLXBhcmFtcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy9zY29yZS9wZWVyLXNjb3JlLXRocmVzaG9sZHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9zcmMvc2NvcmUvY29tcHV0ZS1zY29yZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvZGVucXVlL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL3Njb3JlL21lc3NhZ2UtZGVsaXZlcmllcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9pbnRlcmZhY2VzL3NyYy9zdGFydGFibGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BsaWJwMnAvY29tcG9uZW50cy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9zcmMvc2NvcmUvcGVlci1zY29yZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy9zY29yZS9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy90cmFjZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9zcmMvdXRpbHMvdGltZS1jYWNoZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9saWJwMnAtZ29zc2lwc3ViL3NyYy9tZXRyaWNzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL3V0aWxzL2J1aWxkUmF3TWVzc2FnZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wdWJzdWIvc3JjL2Vycm9ycy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQGxpYnAycC9wdWJzdWIvc3JjL3V0aWxzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL3V0aWxzL21zZ0lkRm4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9zcmMvc2NvcmUvc2NvcmVNZXRyaWNzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL3V0aWxzL3NldC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLWl0ZXJhdG9yL3NyYy9hYm9ydC1lcnJvci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLWl0ZXJhdG9yL25vZGVfbW9kdWxlcy9nZXQtaXRlcmF0b3Ivc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9hYm9ydGFibGUtaXRlcmF0b3Ivc3JjL2luZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pdC1sZW5ndGgtcHJlZml4ZWQvc3JjL2FsbG9jLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pdC1sZW5ndGgtcHJlZml4ZWQvc3JjL2VuY29kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvaXQtbGVuZ3RoLXByZWZpeGVkL3NyYy9kZWNvZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2l0LWxlbmd0aC1wcmVmaXhlZC9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvbGlicDJwLWdvc3NpcHN1Yi9zcmMvc3RyZWFtLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWIvc3JjL2luZGV4LnRzIiwgIi4uLy4uL3NyYy1lbGVjdHJvbi9lbGVjdHJvbi1tYWluLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJmdW5jdGlvbiBiYXNlKEFMUEhBQkVULCBuYW1lKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKTtcbiAgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpO1xuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJyk7XG4gICAgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGk7XG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGg7XG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMCk7XG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1Nik7XG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpO1xuICBmdW5jdGlvbiBlbmNvZGUoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBVaW50OEFycmF5LmZyb20oc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIHBiZWdpbiA9IDA7XG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrO1xuICAgICAgemVyb2VzKys7XG4gICAgfVxuICAgIHZhciBzaXplID0gKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEgPj4+IDA7XG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiBpdDEgIT09IC0xOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IDI1NiAqIGI1OFtpdDFdID4+PiAwO1xuICAgICAgICBiNThbaXQxXSA9IGNhcnJ5ICUgQkFTRSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSBjYXJyeSAvIEJBU0UgPj4+IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIHBiZWdpbisrO1xuICAgIH1cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aDtcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrKztcbiAgICB9XG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKTtcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHtcbiAgICAgIHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZShzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgIHZhciBwc3ogPSAwO1xuICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrKztcbiAgICAgIHBzeisrO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUiArIDEgPj4+IDA7XG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildO1xuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiBpdDMgIT09IC0xOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IEJBU0UgKiBiMjU2W2l0M10gPj4+IDA7XG4gICAgICAgIGIyNTZbaXQzXSA9IGNhcnJ5ICUgMjU2ID4+PiAwO1xuICAgICAgICBjYXJyeSA9IGNhcnJ5IC8gMjU2ID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwc3orKztcbiAgICB9XG4gICAgaWYgKHNvdXJjZVtwc3pdID09PSAnICcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrO1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKTtcbiAgICB2YXIgaiA9IHplcm9lcztcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdO1xuICAgIH1cbiAgICByZXR1cm4gdmNoO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZShzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb24tJHsgbmFtZSB9IGNoYXJhY3RlcmApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfTtcbn1cbnZhciBzcmMgPSBiYXNlO1xudmFyIF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVggPSBzcmM7XG5leHBvcnQgZGVmYXVsdCBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYOyIsICJjb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KDApO1xuY29uc3QgdG9IZXggPSBkID0+IGQucmVkdWNlKChoZXgsIGJ5dGUpID0+IGhleCArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksICcnKTtcbmNvbnN0IGZyb21IZXggPSBoZXggPT4ge1xuICBjb25zdCBoZXhlcyA9IGhleC5tYXRjaCgvLi4vZyk7XG4gIHJldHVybiBoZXhlcyA/IG5ldyBVaW50OEFycmF5KGhleGVzLm1hcChiID0+IHBhcnNlSW50KGIsIDE2KSkpIDogZW1wdHk7XG59O1xuY29uc3QgZXF1YWxzID0gKGFhLCBiYikgPT4ge1xuICBpZiAoYWEgPT09IGJiKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoYWEuYnl0ZUxlbmd0aCAhPT0gYmIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYWEuYnl0ZUxlbmd0aDsgaWkrKykge1xuICAgIGlmIChhYVtpaV0gIT09IGJiW2lpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBjb2VyY2UgPSBvID0+IHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG8uY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKVxuICAgIHJldHVybiBvO1xuICBpZiAobyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvKTtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvLmJ1ZmZlciwgby5ieXRlT2Zmc2V0LCBvLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG59O1xuY29uc3QgaXNCaW5hcnkgPSBvID0+IG8gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcobyk7XG5jb25zdCBmcm9tU3RyaW5nID0gc3RyID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuY29uc3QgdG9TdHJpbmcgPSBiID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShiKTtcbmV4cG9ydCB7XG4gIGVxdWFscyxcbiAgY29lcmNlLFxuICBpc0JpbmFyeSxcbiAgZnJvbUhleCxcbiAgdG9IZXgsXG4gIGZyb21TdHJpbmcsXG4gIHRvU3RyaW5nLFxuICBlbXB0eVxufTsiLCAiaW1wb3J0IGJhc2V4IGZyb20gJy4uLy4uL3ZlbmRvci9iYXNlLXguanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbiAgfVxuICBlbmNvZGUoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gYCR7IHRoaXMucHJlZml4IH0keyB0aGlzLmJhc2VFbmNvZGUoYnl0ZXMpIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgcHJlZml4LCBiYXNlRGVjb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICBpZiAocHJlZml4LmNvZGVQb2ludEF0KDApID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyJyk7XG4gICAgfVxuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gcHJlZml4LmNvZGVQb2ludEF0KDApO1xuICAgIHRoaXMuYmFzZURlY29kZSA9IGJhc2VEZWNvZGU7XG4gIH1cbiAgZGVjb2RlKHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodGV4dC5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAkeyBKU09OLnN0cmluZ2lmeSh0ZXh0KSB9LCAkeyB0aGlzLm5hbWUgfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHsgdGhpcy5wcmVmaXggfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYmFzZURlY29kZSh0ZXh0LnNsaWNlKHRoaXMucHJlZml4Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzJyk7XG4gICAgfVxuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gIH1cbn1cbmNsYXNzIENvbXBvc2VkRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGRlY29kZXJzKSB7XG4gICAgdGhpcy5kZWNvZGVycyA9IGRlY29kZXJzO1xuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gIH1cbiAgZGVjb2RlKGlucHV0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gaW5wdXRbMF07XG4gICAgY29uc3QgZGVjb2RlciA9IHRoaXMuZGVjb2RlcnNbcHJlZml4XTtcbiAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7IEpTT04uc3RyaW5naWZ5KGlucHV0KSB9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7IE9iamVjdC5rZXlzKHRoaXMuZGVjb2RlcnMpIH0gYXJlIHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGNvbnN0IG9yID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgQ29tcG9zZWREZWNvZGVyKHtcbiAgLi4ubGVmdC5kZWNvZGVycyB8fCB7IFtsZWZ0LnByZWZpeF06IGxlZnQgfSxcbiAgLi4ucmlnaHQuZGVjb2RlcnMgfHwgeyBbcmlnaHQucHJlZml4XTogcmlnaHQgfVxufSk7XG5leHBvcnQgY2xhc3MgQ29kZWMge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUsIGJhc2VEZWNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGU7XG4gICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUpO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSk7XG4gIH1cbiAgZW5jb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICB9XG4gIGRlY29kZShpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IGZyb20gPSAoe25hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGV9KSA9PiBuZXcgQ29kZWMobmFtZSwgcHJlZml4LCBlbmNvZGUsIGRlY29kZSk7XG5leHBvcnQgY29uc3QgYmFzZVggPSAoe3ByZWZpeCwgbmFtZSwgYWxwaGFiZXR9KSA9PiB7XG4gIGNvbnN0IHtlbmNvZGUsIGRlY29kZX0gPSBiYXNleChhbHBoYWJldCwgbmFtZSk7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlOiB0ZXh0ID0+IGNvZXJjZShkZWNvZGUodGV4dCkpXG4gIH0pO1xufTtcbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSkgPT4ge1xuICBjb25zdCBjb2RlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaTtcbiAgfVxuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmQ7XG4gIH1cbiAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kICogYml0c1BlckNoYXIgLyA4IHwgMCk7XG4gIGxldCBiaXRzID0gMDtcbiAgbGV0IGJ1ZmZlciA9IDA7XG4gIGxldCB3cml0dGVuID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHsgbmFtZSB9IGNoYXJhY3RlcmApO1xuICAgIH1cbiAgICBidWZmZXIgPSBidWZmZXIgPDwgYml0c1BlckNoYXIgfCB2YWx1ZTtcbiAgICBiaXRzICs9IGJpdHNQZXJDaGFyO1xuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIGJpdHMgLT0gODtcbiAgICAgIG91dFt3cml0dGVuKytdID0gMjU1ICYgYnVmZmVyID4+IGJpdHM7XG4gICAgfVxuICB9XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDI1NSAmIGJ1ZmZlciA8PCA4IC0gYml0cykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nO1xuICBjb25zdCBtYXNrID0gKDEgPDwgYml0c1BlckNoYXIpIC0gMTtcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgYml0cyA9IDA7XG4gIGxldCBidWZmZXIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXIgPSBidWZmZXIgPDwgOCB8IGRhdGFbaV07XG4gICAgYml0cyArPSA4O1xuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXI7XG4gICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA+PiBiaXRzXTtcbiAgICB9XG4gIH1cbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA8PCBiaXRzUGVyQ2hhciAtIGJpdHNdO1xuICB9XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAqIGJpdHNQZXJDaGFyICYgNykge1xuICAgICAgb3V0ICs9ICc9JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5leHBvcnQgY29uc3QgcmZjNDY0OCA9ICh7bmFtZSwgcHJlZml4LCBiaXRzUGVyQ2hhciwgYWxwaGFiZXR9KSA9PiB7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcik7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSk7XG4gICAgfVxuICB9KTtcbn07IiwgImltcG9ydCB7IGZyb20gfSBmcm9tICcuL2Jhc2UuanMnO1xuaW1wb3J0IHtcbiAgZnJvbVN0cmluZyxcbiAgdG9TdHJpbmdcbn0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gZnJvbSh7XG4gIHByZWZpeDogJ1xcMCcsXG4gIG5hbWU6ICdpZGVudGl0eScsXG4gIGVuY29kZTogYnVmID0+IHRvU3RyaW5nKGJ1ZiksXG4gIGRlY29kZTogc3RyID0+IGZyb21TdHJpbmcoc3RyKVxufSk7IiwgImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJzAnLFxuICBuYW1lOiAnYmFzZTInLFxuICBhbHBoYWJldDogJzAxJyxcbiAgYml0c1BlckNoYXI6IDFcbn0pOyIsICJpbXBvcnQgeyByZmM0NjQ4IH0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCBjb25zdCBiYXNlOCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICc3JyxcbiAgbmFtZTogJ2Jhc2U4JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2NycsXG4gIGJpdHNQZXJDaGFyOiAzXG59KTsiLCAiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UxMCA9IGJhc2VYKHtcbiAgcHJlZml4OiAnOScsXG4gIG5hbWU6ICdiYXNlMTAnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODknXG59KTsiLCAiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTE2ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2YnLFxuICBuYW1lOiAnYmFzZTE2JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgYml0c1BlckNoYXI6IDRcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UxNnVwcGVyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ0YnLFxuICBuYW1lOiAnYmFzZTE2dXBwZXInLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUYnLFxuICBiaXRzUGVyQ2hhcjogNFxufSk7IiwgImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdiJyxcbiAgbmFtZTogJ2Jhc2UzMicsXG4gIGFscGhhYmV0OiAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMydXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnQicsXG4gIG5hbWU6ICdiYXNlMzJ1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMycGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2MnLFxuICBuYW1lOiAnYmFzZTMycGFkJyxcbiAgYWxwaGFiZXQ6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMycGFkdXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnQycsXG4gIG5hbWU6ICdiYXNlMzJwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICd2JyxcbiAgbmFtZTogJ2Jhc2UzMmhleCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4dXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVicsXG4gIG5hbWU6ICdiYXNlMzJoZXh1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4cGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3QnLFxuICBuYW1lOiAnYmFzZTMyaGV4cGFkJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4cGFkdXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVCcsXG4gIG5hbWU6ICdiYXNlMzJoZXhwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMnogPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnaCcsXG4gIG5hbWU6ICdiYXNlMzJ6JyxcbiAgYWxwaGFiZXQ6ICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTsiLCAiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UzNiA9IGJhc2VYKHtcbiAgcHJlZml4OiAnaycsXG4gIG5hbWU6ICdiYXNlMzYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzNnVwcGVyID0gYmFzZVgoe1xuICBwcmVmaXg6ICdLJyxcbiAgbmFtZTogJ2Jhc2UzNnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonXG59KTsiLCAiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGJ0YyA9IGJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGJ0YycsXG4gIHByZWZpeDogJ3onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG59KTtcbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSBiYXNlWCh7XG4gIG5hbWU6ICdiYXNlNThmbGlja3InLFxuICBwcmVmaXg6ICdaJyxcbiAgYWxwaGFiZXQ6ICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ1xufSk7IiwgImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdtJyxcbiAgbmFtZTogJ2Jhc2U2NCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycsXG4gIGJpdHNQZXJDaGFyOiA2XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlNjRwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnTScsXG4gIG5hbWU6ICdiYXNlNjRwYWQnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICd1JyxcbiAgbmFtZTogJ2Jhc2U2NHVybCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycsXG4gIGJpdHNQZXJDaGFyOiA2XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVScsXG4gIG5hbWU6ICdiYXNlNjR1cmxwYWQnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89JyxcbiAgYml0c1BlckNoYXI6IDZcbn0pOyIsICJpbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9iYXNlLmpzJztcbmNvbnN0IGFscGhhYmV0ID0gQXJyYXkuZnJvbSgnXFx1RDgzRFxcdURFODBcXHVEODNFXFx1REU5MFxcdTI2MDRcXHVEODNEXFx1REVGMFxcdUQ4M0NcXHVERjBDXFx1RDgzQ1xcdURGMTFcXHVEODNDXFx1REYxMlxcdUQ4M0NcXHVERjEzXFx1RDgzQ1xcdURGMTRcXHVEODNDXFx1REYxNVxcdUQ4M0NcXHVERjE2XFx1RDgzQ1xcdURGMTdcXHVEODNDXFx1REYxOFxcdUQ4M0NcXHVERjBEXFx1RDgzQ1xcdURGMEZcXHVEODNDXFx1REYwRVxcdUQ4M0RcXHVEQzA5XFx1MjYwMFxcdUQ4M0RcXHVEQ0JCXFx1RDgzRFxcdUREQTVcXHVEODNEXFx1RENCRVxcdUQ4M0RcXHVEQ0JGXFx1RDgzRFxcdURFMDJcXHUyNzY0XFx1RDgzRFxcdURFMERcXHVEODNFXFx1REQyM1xcdUQ4M0RcXHVERTBBXFx1RDgzRFxcdURFNEZcXHVEODNEXFx1REM5NVxcdUQ4M0RcXHVERTJEXFx1RDgzRFxcdURFMThcXHVEODNEXFx1REM0RFxcdUQ4M0RcXHVERTA1XFx1RDgzRFxcdURDNEZcXHVEODNEXFx1REUwMVxcdUQ4M0RcXHVERDI1XFx1RDgzRVxcdURENzBcXHVEODNEXFx1REM5NFxcdUQ4M0RcXHVEQzk2XFx1RDgzRFxcdURDOTlcXHVEODNEXFx1REUyMlxcdUQ4M0VcXHVERDE0XFx1RDgzRFxcdURFMDZcXHVEODNEXFx1REU0NFxcdUQ4M0RcXHVEQ0FBXFx1RDgzRFxcdURFMDlcXHUyNjNBXFx1RDgzRFxcdURDNENcXHVEODNFXFx1REQxN1xcdUQ4M0RcXHVEQzlDXFx1RDgzRFxcdURFMTRcXHVEODNEXFx1REUwRVxcdUQ4M0RcXHVERTA3XFx1RDgzQ1xcdURGMzlcXHVEODNFXFx1REQyNlxcdUQ4M0NcXHVERjg5XFx1RDgzRFxcdURDOUVcXHUyNzBDXFx1MjcyOFxcdUQ4M0VcXHVERDM3XFx1RDgzRFxcdURFMzFcXHVEODNEXFx1REUwQ1xcdUQ4M0NcXHVERjM4XFx1RDgzRFxcdURFNENcXHVEODNEXFx1REUwQlxcdUQ4M0RcXHVEQzk3XFx1RDgzRFxcdURDOUFcXHVEODNEXFx1REUwRlxcdUQ4M0RcXHVEQzlCXFx1RDgzRFxcdURFNDJcXHVEODNEXFx1REM5M1xcdUQ4M0VcXHVERDI5XFx1RDgzRFxcdURFMDRcXHVEODNEXFx1REUwMFxcdUQ4M0RcXHVEREE0XFx1RDgzRFxcdURFMDNcXHVEODNEXFx1RENBRlxcdUQ4M0RcXHVERTQ4XFx1RDgzRFxcdURDNDdcXHVEODNDXFx1REZCNlxcdUQ4M0RcXHVERTEyXFx1RDgzRVxcdUREMkRcXHUyNzYzXFx1RDgzRFxcdURFMUNcXHVEODNEXFx1REM4QlxcdUQ4M0RcXHVEQzQwXFx1RDgzRFxcdURFMkFcXHVEODNEXFx1REUxMVxcdUQ4M0RcXHVEQ0E1XFx1RDgzRFxcdURFNEJcXHVEODNEXFx1REUxRVxcdUQ4M0RcXHVERTI5XFx1RDgzRFxcdURFMjFcXHVEODNFXFx1REQyQVxcdUQ4M0RcXHVEQzRBXFx1RDgzRVxcdURENzNcXHVEODNEXFx1REUyNVxcdUQ4M0VcXHVERDI0XFx1RDgzRFxcdURDNDlcXHVEODNEXFx1REM4M1xcdUQ4M0RcXHVERTMzXFx1MjcwQlxcdUQ4M0RcXHVERTFBXFx1RDgzRFxcdURFMURcXHVEODNEXFx1REUzNFxcdUQ4M0NcXHVERjFGXFx1RDgzRFxcdURFMkNcXHVEODNEXFx1REU0M1xcdUQ4M0NcXHVERjQwXFx1RDgzQ1xcdURGMzdcXHVEODNEXFx1REUzQlxcdUQ4M0RcXHVERTEzXFx1MkI1MFxcdTI3MDVcXHVEODNFXFx1REQ3QVxcdUQ4M0NcXHVERjA4XFx1RDgzRFxcdURFMDhcXHVEODNFXFx1REQxOFxcdUQ4M0RcXHVEQ0E2XFx1MjcxNFxcdUQ4M0RcXHVERTIzXFx1RDgzQ1xcdURGQzNcXHVEODNEXFx1REM5MFxcdTI2MzlcXHVEODNDXFx1REY4QVxcdUQ4M0RcXHVEQzk4XFx1RDgzRFxcdURFMjBcXHUyNjFEXFx1RDgzRFxcdURFMTVcXHVEODNDXFx1REYzQVxcdUQ4M0NcXHVERjgyXFx1RDgzQ1xcdURGM0JcXHVEODNEXFx1REUxMFxcdUQ4M0RcXHVERDk1XFx1RDgzRFxcdURDOURcXHVEODNEXFx1REU0QVxcdUQ4M0RcXHVERTM5XFx1RDgzRFxcdURERTNcXHVEODNEXFx1RENBQlxcdUQ4M0RcXHVEQzgwXFx1RDgzRFxcdURDNTFcXHVEODNDXFx1REZCNVxcdUQ4M0VcXHVERDFFXFx1RDgzRFxcdURFMUJcXHVEODNEXFx1REQzNFxcdUQ4M0RcXHVERTI0XFx1RDgzQ1xcdURGM0NcXHVEODNEXFx1REUyQlxcdTI2QkRcXHVEODNFXFx1REQxOVxcdTI2MTVcXHVEODNDXFx1REZDNlxcdUQ4M0VcXHVERDJCXFx1RDgzRFxcdURDNDhcXHVEODNEXFx1REUyRVxcdUQ4M0RcXHVERTQ2XFx1RDgzQ1xcdURGN0JcXHVEODNDXFx1REY0M1xcdUQ4M0RcXHVEQzM2XFx1RDgzRFxcdURDODFcXHVEODNEXFx1REUzMlxcdUQ4M0NcXHVERjNGXFx1RDgzRVxcdURERTFcXHVEODNDXFx1REY4MVxcdTI2QTFcXHVEODNDXFx1REYxRVxcdUQ4M0NcXHVERjg4XFx1Mjc0Q1xcdTI3MEFcXHVEODNEXFx1REM0QlxcdUQ4M0RcXHVERTMwXFx1RDgzRVxcdUREMjhcXHVEODNEXFx1REUzNlxcdUQ4M0VcXHVERDFEXFx1RDgzRFxcdURFQjZcXHVEODNEXFx1RENCMFxcdUQ4M0NcXHVERjUzXFx1RDgzRFxcdURDQTJcXHVEODNFXFx1REQxRlxcdUQ4M0RcXHVERTQxXFx1RDgzRFxcdURFQThcXHVEODNEXFx1RENBOFxcdUQ4M0VcXHVERDJDXFx1MjcwOFxcdUQ4M0NcXHVERjgwXFx1RDgzQ1xcdURGN0FcXHVEODNFXFx1REQxM1xcdUQ4M0RcXHVERTE5XFx1RDgzRFxcdURDOUZcXHVEODNDXFx1REYzMVxcdUQ4M0RcXHVERTE2XFx1RDgzRFxcdURDNzZcXHVEODNFXFx1REQ3NFxcdTI1QjZcXHUyN0ExXFx1Mjc1M1xcdUQ4M0RcXHVEQzhFXFx1RDgzRFxcdURDQjhcXHUyQjA3XFx1RDgzRFxcdURFMjhcXHVEODNDXFx1REYxQVxcdUQ4M0VcXHVERDhCXFx1RDgzRFxcdURFMzdcXHVEODNEXFx1REQ3QVxcdTI2QTBcXHVEODNEXFx1REU0NVxcdUQ4M0RcXHVERTFGXFx1RDgzRFxcdURFMzVcXHVEODNEXFx1REM0RVxcdUQ4M0VcXHVERDMyXFx1RDgzRVxcdUREMjBcXHVEODNFXFx1REQyN1xcdUQ4M0RcXHVEQ0NDXFx1RDgzRFxcdUREMzVcXHVEODNEXFx1REM4NVxcdUQ4M0VcXHVEREQwXFx1RDgzRFxcdURDM0VcXHVEODNDXFx1REY1MlxcdUQ4M0RcXHVERTE3XFx1RDgzRVxcdUREMTFcXHVEODNDXFx1REYwQVxcdUQ4M0VcXHVERDJGXFx1RDgzRFxcdURDMzdcXHUyNjBFXFx1RDgzRFxcdURDQTdcXHVEODNEXFx1REUyRlxcdUQ4M0RcXHVEQzg2XFx1RDgzRFxcdURDNDZcXHVEODNDXFx1REZBNFxcdUQ4M0RcXHVERTQ3XFx1RDgzQ1xcdURGNTFcXHUyNzQ0XFx1RDgzQ1xcdURGMzRcXHVEODNEXFx1RENBM1xcdUQ4M0RcXHVEQzM4XFx1RDgzRFxcdURDOENcXHVEODNEXFx1RENDRFxcdUQ4M0VcXHVERDQwXFx1RDgzRVxcdUREMjJcXHVEODNEXFx1REM0NVxcdUQ4M0RcXHVEQ0ExXFx1RDgzRFxcdURDQTlcXHVEODNEXFx1REM1MFxcdUQ4M0RcXHVEQ0Y4XFx1RDgzRFxcdURDN0JcXHVEODNFXFx1REQxMFxcdUQ4M0VcXHVERDJFXFx1RDgzQ1xcdURGQkNcXHVEODNFXFx1REQ3NVxcdUQ4M0RcXHVERUE5XFx1RDgzQ1xcdURGNEVcXHVEODNDXFx1REY0QVxcdUQ4M0RcXHVEQzdDXFx1RDgzRFxcdURDOERcXHVEODNEXFx1RENFM1xcdUQ4M0VcXHVERDQyJyk7XG5jb25zdCBhbHBoYWJldEJ5dGVzVG9DaGFycyA9IGFscGhhYmV0LnJlZHVjZSgocCwgYywgaSkgPT4ge1xuICBwW2ldID0gYztcbiAgcmV0dXJuIHA7XG59LCBbXSk7XG5jb25zdCBhbHBoYWJldENoYXJzVG9CeXRlcyA9IGFscGhhYmV0LnJlZHVjZSgocCwgYywgaSkgPT4ge1xuICBwW2MuY29kZVBvaW50QXQoMCldID0gaTtcbiAgcmV0dXJuIHA7XG59LCBbXSk7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICByZXR1cm4gZGF0YS5yZWR1Y2UoKHAsIGMpID0+IHtcbiAgICBwICs9IGFscGhhYmV0Qnl0ZXNUb0NoYXJzW2NdO1xuICAgIHJldHVybiBwO1xuICB9LCAnJyk7XG59XG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIGNvbnN0IGJ5dHMgPSBbXTtcbiAgZm9yIChjb25zdCBjaGFyIG9mIHN0cikge1xuICAgIGNvbnN0IGJ5dCA9IGFscGhhYmV0Q2hhcnNUb0J5dGVzW2NoYXIuY29kZVBvaW50QXQoMCldO1xuICAgIGlmIChieXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24tYmFzZTI1NmVtb2ppIGNoYXJhY3RlcjogJHsgY2hhciB9YCk7XG4gICAgfVxuICAgIGJ5dHMucHVzaChieXQpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRzKTtcbn1cbmV4cG9ydCBjb25zdCBiYXNlMjU2ZW1vamkgPSBmcm9tKHtcbiAgcHJlZml4OiAnXFx1RDgzRFxcdURFODAnLFxuICBuYW1lOiAnYmFzZTI1NmVtb2ppJyxcbiAgZW5jb2RlLFxuICBkZWNvZGVcbn0pOyIsICJ2YXIgZW5jb2RlXzEgPSBlbmNvZGU7XG52YXIgTVNCID0gMTI4LCBSRVNUID0gMTI3LCBNU0JBTEwgPSB+UkVTVCwgSU5UID0gTWF0aC5wb3coMiwgMzEpO1xuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0ID0gb3V0IHx8IFtdO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIG9sZE9mZnNldCA9IG9mZnNldDtcbiAgd2hpbGUgKG51bSA+PSBJTlQpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gbnVtICYgMjU1IHwgTVNCO1xuICAgIG51bSAvPSAxMjg7XG4gIH1cbiAgd2hpbGUgKG51bSAmIE1TQkFMTCkge1xuICAgIG91dFtvZmZzZXQrK10gPSBudW0gJiAyNTUgfCBNU0I7XG4gICAgbnVtID4+Pj0gNztcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDA7XG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDE7XG4gIHJldHVybiBvdXQ7XG59XG52YXIgZGVjb2RlID0gcmVhZDtcbnZhciBNU0IkMSA9IDEyOCwgUkVTVCQxID0gMTI3O1xuZnVuY3Rpb24gcmVhZChidWYsIG9mZnNldCkge1xuICB2YXIgcmVzID0gMCwgb2Zmc2V0ID0gb2Zmc2V0IHx8IDAsIHNoaWZ0ID0gMCwgY291bnRlciA9IG9mZnNldCwgYiwgbCA9IGJ1Zi5sZW5ndGg7XG4gIGRvIHtcbiAgICBpZiAoY291bnRlciA+PSBsKSB7XG4gICAgICByZWFkLmJ5dGVzID0gMDtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHZhcmludCcpO1xuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK107XG4gICAgcmVzICs9IHNoaWZ0IDwgMjggPyAoYiAmIFJFU1QkMSkgPDwgc2hpZnQgOiAoYiAmIFJFU1QkMSkgKiBNYXRoLnBvdygyLCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gNztcbiAgfSB3aGlsZSAoYiA+PSBNU0IkMSk7XG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0O1xuICByZXR1cm4gcmVzO1xufVxudmFyIE4xID0gTWF0aC5wb3coMiwgNyk7XG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNCk7XG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSk7XG52YXIgTjQgPSBNYXRoLnBvdygyLCAyOCk7XG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSk7XG52YXIgTjYgPSBNYXRoLnBvdygyLCA0Mik7XG52YXIgTjcgPSBNYXRoLnBvdygyLCA0OSk7XG52YXIgTjggPSBNYXRoLnBvdygyLCA1Nik7XG52YXIgTjkgPSBNYXRoLnBvdygyLCA2Myk7XG52YXIgbGVuZ3RoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IE4xID8gMSA6IHZhbHVlIDwgTjIgPyAyIDogdmFsdWUgPCBOMyA/IDMgOiB2YWx1ZSA8IE40ID8gNCA6IHZhbHVlIDwgTjUgPyA1IDogdmFsdWUgPCBONiA/IDYgOiB2YWx1ZSA8IE43ID8gNyA6IHZhbHVlIDwgTjggPyA4IDogdmFsdWUgPCBOOSA/IDkgOiAxMDtcbn07XG52YXIgdmFyaW50ID0ge1xuICBlbmNvZGU6IGVuY29kZV8xLFxuICBkZWNvZGU6IGRlY29kZSxcbiAgZW5jb2RpbmdMZW5ndGg6IGxlbmd0aFxufTtcbnZhciBfYnJycF92YXJpbnQgPSB2YXJpbnQ7XG5leHBvcnQgZGVmYXVsdCBfYnJycF92YXJpbnQ7IiwgImltcG9ydCB2YXJpbnQgZnJvbSAnLi4vdmVuZG9yL3ZhcmludC5qcyc7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gZGF0YSA9PiB7XG4gIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGRhdGEpO1xuICByZXR1cm4gW1xuICAgIGNvZGUsXG4gICAgdmFyaW50LmRlY29kZS5ieXRlc1xuICBdO1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUbyA9IChpbnQsIHRhcmdldCwgb2Zmc2V0ID0gMCkgPT4ge1xuICB2YXJpbnQuZW5jb2RlKGludCwgdGFyZ2V0LCBvZmZzZXQpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGluZ0xlbmd0aCA9IGludCA9PiB7XG4gIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoaW50KTtcbn07IiwgImltcG9ydCB7XG4gIGNvZXJjZSxcbiAgZXF1YWxzIGFzIGVxdWFsQnl0ZXNcbn0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4uL3ZhcmludC5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlID0gKGNvZGUsIGRpZ2VzdCkgPT4ge1xuICBjb25zdCBzaXplID0gZGlnZXN0LmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHNpemVPZmZzZXQgPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSk7XG4gIGNvbnN0IGRpZ2VzdE9mZnNldCA9IHNpemVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoc2l6ZSk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGlnZXN0T2Zmc2V0ICsgc2l6ZSk7XG4gIHZhcmludC5lbmNvZGVUbyhjb2RlLCBieXRlcywgMCk7XG4gIHZhcmludC5lbmNvZGVUbyhzaXplLCBieXRlcywgc2l6ZU9mZnNldCk7XG4gIGJ5dGVzLnNldChkaWdlc3QsIGRpZ2VzdE9mZnNldCk7XG4gIHJldHVybiBuZXcgRGlnZXN0KGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBtdWx0aWhhc2ggPT4ge1xuICBjb25zdCBieXRlcyA9IGNvZXJjZShtdWx0aWhhc2gpO1xuICBjb25zdCBbY29kZSwgc2l6ZU9mZnNldF0gPSB2YXJpbnQuZGVjb2RlKGJ5dGVzKTtcbiAgY29uc3QgW3NpemUsIGRpZ2VzdE9mZnNldF0gPSB2YXJpbnQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KHNpemVPZmZzZXQpKTtcbiAgY29uc3QgZGlnZXN0ID0gYnl0ZXMuc3ViYXJyYXkoc2l6ZU9mZnNldCArIGRpZ2VzdE9mZnNldCk7XG4gIGlmIChkaWdlc3QuYnl0ZUxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICB9XG4gIHJldHVybiBuZXcgRGlnZXN0KGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBlcXVhbHMgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhLmNvZGUgPT09IGIuY29kZSAmJiBhLnNpemUgPT09IGIuc2l6ZSAmJiBlcXVhbEJ5dGVzKGEuYnl0ZXMsIGIuYnl0ZXMpO1xuICB9XG59O1xuZXhwb3J0IGNsYXNzIERpZ2VzdCB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5kaWdlc3QgPSBkaWdlc3Q7XG4gICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICB9XG59IiwgImltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2RpZ2VzdC5qcyc7XG5leHBvcnQgY29uc3QgZnJvbSA9ICh7bmFtZSwgY29kZSwgZW5jb2RlfSkgPT4gbmV3IEhhc2hlcihuYW1lLCBjb2RlLCBlbmNvZGUpO1xuZXhwb3J0IGNsYXNzIEhhc2hlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGNvZGUsIGVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmVuY29kZSA9IGVuY29kZTtcbiAgfVxuICBkaWdlc3QoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmVuY29kZShpbnB1dCk7XG4gICAgICByZXR1cm4gcmVzdWx0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IERpZ2VzdC5jcmVhdGUodGhpcy5jb2RlLCByZXN1bHQpIDogcmVzdWx0LnRoZW4oZGlnZXN0ID0+IERpZ2VzdC5jcmVhdGUodGhpcy5jb2RlLCBkaWdlc3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZScpO1xuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9oYXNoZXIuanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IGZyb20oe1xuICBuYW1lOiAnc2hhMi0yNTYnLFxuICBjb2RlOiAxOCxcbiAgZW5jb2RlOiBpbnB1dCA9PiBjb2VyY2UoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShpbnB1dCkuZGlnZXN0KCkpXG59KTtcbmV4cG9ydCBjb25zdCBzaGE1MTIgPSBmcm9tKHtcbiAgbmFtZTogJ3NoYTItNTEyJyxcbiAgY29kZTogMTksXG4gIGVuY29kZTogaW5wdXQgPT4gY29lcmNlKGNyeXB0by5jcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxufSk7IiwgImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2RpZ2VzdC5qcyc7XG5jb25zdCBjb2RlID0gMDtcbmNvbnN0IG5hbWUgPSAnaWRlbnRpdHknO1xuY29uc3QgZW5jb2RlID0gY29lcmNlO1xuY29uc3QgZGlnZXN0ID0gaW5wdXQgPT4gRGlnZXN0LmNyZWF0ZShjb2RlLCBlbmNvZGUoaW5wdXQpKTtcbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9IHtcbiAgY29kZSxcbiAgbmFtZSxcbiAgZW5jb2RlLFxuICBkaWdlc3Rcbn07IiwgImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmV4cG9ydCBjb25zdCBuYW1lID0gJ3Jhdyc7XG5leHBvcnQgY29uc3QgY29kZSA9IDg1O1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IG5vZGUgPT4gY29lcmNlKG5vZGUpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gY29lcmNlKGRhdGEpOyIsICJjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmV4cG9ydCBjb25zdCBuYW1lID0gJ2pzb24nO1xuZXhwb3J0IGNvbnN0IGNvZGUgPSA1MTI7XG5leHBvcnQgY29uc3QgZW5jb2RlID0gbm9kZSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gSlNPTi5wYXJzZSh0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSkpOyIsICJpbXBvcnQgKiBhcyB2YXJpbnQgZnJvbSAnLi92YXJpbnQuanMnO1xuaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJy4vaGFzaGVzL2RpZ2VzdC5qcyc7XG5pbXBvcnQgeyBiYXNlNThidGMgfSBmcm9tICcuL2Jhc2VzL2Jhc2U1OC5qcyc7XG5pbXBvcnQgeyBiYXNlMzIgfSBmcm9tICcuL2Jhc2VzL2Jhc2UzMi5qcyc7XG5pbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuL2J5dGVzLmpzJztcbmV4cG9ydCBjbGFzcyBDSUQge1xuICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gsIGJ5dGVzKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMubXVsdGloYXNoID0gbXVsdGloYXNoO1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICB0aGlzLmJ5dGVPZmZzZXQgPSBieXRlcy5ieXRlT2Zmc2V0O1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5hc0NJRCA9IHRoaXM7XG4gICAgdGhpcy5fYmFzZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGJ5dGVPZmZzZXQ6IGhpZGRlbixcbiAgICAgIGJ5dGVMZW5ndGg6IGhpZGRlbixcbiAgICAgIGNvZGU6IHJlYWRvbmx5LFxuICAgICAgdmVyc2lvbjogcmVhZG9ubHksXG4gICAgICBtdWx0aWhhc2g6IHJlYWRvbmx5LFxuICAgICAgYnl0ZXM6IHJlYWRvbmx5LFxuICAgICAgX2Jhc2VDYWNoZTogaGlkZGVuLFxuICAgICAgYXNDSUQ6IGhpZGRlblxuICAgIH0pO1xuICB9XG4gIHRvVjAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCB7Y29kZSwgbXVsdGloYXNofSA9IHRoaXM7XG4gICAgICAgIGlmIChjb2RlICE9PSBEQUdfUEJfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBub24gZGFnLXBiIENJRCB0byBDSUR2MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aWhhc2guY29kZSAhPT0gU0hBXzI1Nl9DT0RFKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBub24gc2hhMi0yNTYgbXVsdGloYXNoIENJRCB0byBDSUR2MCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDSUQuY3JlYXRlVjAobXVsdGloYXNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdG9WMSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudmVyc2lvbikge1xuICAgIGNhc2UgMDoge1xuICAgICAgICBjb25zdCB7Y29kZSwgZGlnZXN0fSA9IHRoaXMubXVsdGloYXNoO1xuICAgICAgICBjb25zdCBtdWx0aWhhc2ggPSBEaWdlc3QuY3JlYXRlKGNvZGUsIGRpZ2VzdCk7XG4gICAgICAgIHJldHVybiBDSUQuY3JlYXRlVjEodGhpcy5jb2RlLCBtdWx0aWhhc2gpO1xuICAgICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IEVycm9yKGBDYW4gbm90IGNvbnZlcnQgQ0lEIHZlcnNpb24gJHsgdGhpcy52ZXJzaW9uIH0gdG8gdmVyc2lvbiAwLiBUaGlzIGlzIGEgYnVnIHBsZWFzZSByZXBvcnRgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyICYmIHRoaXMuY29kZSA9PT0gb3RoZXIuY29kZSAmJiB0aGlzLnZlcnNpb24gPT09IG90aGVyLnZlcnNpb24gJiYgRGlnZXN0LmVxdWFscyh0aGlzLm11bHRpaGFzaCwgb3RoZXIubXVsdGloYXNoKTtcbiAgfVxuICB0b1N0cmluZyhiYXNlKSB7XG4gICAgY29uc3Qge2J5dGVzLCB2ZXJzaW9uLCBfYmFzZUNhY2hlfSA9IHRoaXM7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHRvU3RyaW5nVjAoYnl0ZXMsIF9iYXNlQ2FjaGUsIGJhc2UgfHwgYmFzZTU4YnRjLmVuY29kZXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdG9TdHJpbmdWMShieXRlcywgX2Jhc2VDYWNoZSwgYmFzZSB8fCBiYXNlMzIuZW5jb2Rlcik7XG4gICAgfVxuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgaGFzaDogdGhpcy5tdWx0aWhhc2guYnl0ZXNcbiAgICB9O1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0NJRCc7XG4gIH1cbiAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgIHJldHVybiAnQ0lEKCcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnKSc7XG4gIH1cbiAgc3RhdGljIGlzQ0lEKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRlKC9eMFxcLjAvLCBJU19DSURfREVQUkVDQVRJT04pO1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiAodmFsdWVbY2lkU3ltYm9sXSB8fCB2YWx1ZS5hc0NJRCA9PT0gdmFsdWUpKTtcbiAgfVxuICBnZXQgdG9CYXNlRW5jb2RlZFN0cmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHJlY2F0ZWQsIHVzZSAudG9TdHJpbmcoKScpO1xuICB9XG4gIGdldCBjb2RlYygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZWNcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLCB1c2UgaW50ZWdlciBcImNvZGVcIiBwcm9wZXJ0eSBpbnN0ZWFkJyk7XG4gIH1cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHJlY2F0ZWQgLmJ1ZmZlciBwcm9wZXJ0eSwgdXNlIC5ieXRlcyB0byBnZXQgVWludDhBcnJheSBpbnN0ZWFkJyk7XG4gIH1cbiAgZ2V0IG11bHRpYmFzZU5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIm11bHRpYmFzZU5hbWVcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkJyk7XG4gIH1cbiAgZ2V0IHByZWZpeCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wicHJlZml4XCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCcpO1xuICB9XG4gIHN0YXRpYyBhc0NJRCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENJRCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5hc0NJRCA9PT0gdmFsdWUpIHtcbiAgICAgIGNvbnN0IHt2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gsIGJ5dGVzfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDSUQodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcyB8fCBlbmNvZGVDSUQodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLmJ5dGVzKSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW2NpZFN5bWJvbF0gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHt2ZXJzaW9uLCBtdWx0aWhhc2gsIGNvZGV9ID0gdmFsdWU7XG4gICAgICBjb25zdCBkaWdlc3QgPSBEaWdlc3QuZGVjb2RlKG11bHRpaGFzaCk7XG4gICAgICByZXR1cm4gQ0lELmNyZWF0ZSh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZSh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QpIHtcbiAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBjb2RlY3MgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICAgIGlmIChjb2RlICE9PSBEQUdfUEJfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyc2lvbiAwIENJRCBtdXN0IHVzZSBkYWctcGIgKGNvZGU6ICR7IERBR19QQl9DT0RFIH0pIGJsb2NrIGVuY29kaW5nYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDSUQodmVyc2lvbiwgY29kZSwgZGlnZXN0LCBkaWdlc3QuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdC5ieXRlcyk7XG4gICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCwgYnl0ZXMpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnNpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVYwKGRpZ2VzdCkge1xuICAgIHJldHVybiBDSUQuY3JlYXRlKDAsIERBR19QQl9DT0RFLCBkaWdlc3QpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVWMShjb2RlLCBkaWdlc3QpIHtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgxLCBjb2RlLCBkaWdlc3QpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGUoYnl0ZXMpIHtcbiAgICBjb25zdCBbY2lkLCByZW1haW5kZXJdID0gQ0lELmRlY29kZUZpcnN0KGJ5dGVzKTtcbiAgICBpZiAocmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgfVxuICAgIHJldHVybiBjaWQ7XG4gIH1cbiAgc3RhdGljIGRlY29kZUZpcnN0KGJ5dGVzKSB7XG4gICAgY29uc3Qgc3BlY3MgPSBDSUQuaW5zcGVjdEJ5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBwcmVmaXhTaXplID0gc3BlY3Muc2l6ZSAtIHNwZWNzLm11bHRpaGFzaFNpemU7XG4gICAgY29uc3QgbXVsdGloYXNoQnl0ZXMgPSBjb2VyY2UoYnl0ZXMuc3ViYXJyYXkocHJlZml4U2l6ZSwgcHJlZml4U2l6ZSArIHNwZWNzLm11bHRpaGFzaFNpemUpKTtcbiAgICBpZiAobXVsdGloYXNoQnl0ZXMuYnl0ZUxlbmd0aCAhPT0gc3BlY3MubXVsdGloYXNoU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgfVxuICAgIGNvbnN0IGRpZ2VzdEJ5dGVzID0gbXVsdGloYXNoQnl0ZXMuc3ViYXJyYXkoc3BlY3MubXVsdGloYXNoU2l6ZSAtIHNwZWNzLmRpZ2VzdFNpemUpO1xuICAgIGNvbnN0IGRpZ2VzdCA9IG5ldyBEaWdlc3QuRGlnZXN0KHNwZWNzLm11bHRpaGFzaENvZGUsIHNwZWNzLmRpZ2VzdFNpemUsIGRpZ2VzdEJ5dGVzLCBtdWx0aWhhc2hCeXRlcyk7XG4gICAgY29uc3QgY2lkID0gc3BlY3MudmVyc2lvbiA9PT0gMCA/IENJRC5jcmVhdGVWMChkaWdlc3QpIDogQ0lELmNyZWF0ZVYxKHNwZWNzLmNvZGVjLCBkaWdlc3QpO1xuICAgIHJldHVybiBbXG4gICAgICBjaWQsXG4gICAgICBieXRlcy5zdWJhcnJheShzcGVjcy5zaXplKVxuICAgIF07XG4gIH1cbiAgc3RhdGljIGluc3BlY3RCeXRlcyhpbml0aWFsQnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgW2ksIGxlbmd0aF0gPSB2YXJpbnQuZGVjb2RlKGluaXRpYWxCeXRlcy5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuICAgIGxldCB2ZXJzaW9uID0gbmV4dCgpO1xuICAgIGxldCBjb2RlYyA9IERBR19QQl9DT0RFO1xuICAgIGlmICh2ZXJzaW9uID09PSAxOCkge1xuICAgICAgdmVyc2lvbiA9IDA7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgY29kZWMgPSBuZXh0KCk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uICE9PSAwICYmIHZlcnNpb24gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIENJRCB2ZXJzaW9uICR7IHZlcnNpb24gfWApO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXhTaXplID0gb2Zmc2V0O1xuICAgIGNvbnN0IG11bHRpaGFzaENvZGUgPSBuZXh0KCk7XG4gICAgY29uc3QgZGlnZXN0U2l6ZSA9IG5leHQoKTtcbiAgICBjb25zdCBzaXplID0gb2Zmc2V0ICsgZGlnZXN0U2l6ZTtcbiAgICBjb25zdCBtdWx0aWhhc2hTaXplID0gc2l6ZSAtIHByZWZpeFNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb24sXG4gICAgICBjb2RlYyxcbiAgICAgIG11bHRpaGFzaENvZGUsXG4gICAgICBkaWdlc3RTaXplLFxuICAgICAgbXVsdGloYXNoU2l6ZSxcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwYXJzZShzb3VyY2UsIGJhc2UpIHtcbiAgICBjb25zdCBbcHJlZml4LCBieXRlc10gPSBwYXJzZUNJRHRvQnl0ZXMoc291cmNlLCBiYXNlKTtcbiAgICBjb25zdCBjaWQgPSBDSUQuZGVjb2RlKGJ5dGVzKTtcbiAgICBjaWQuX2Jhc2VDYWNoZS5zZXQocHJlZml4LCBzb3VyY2UpO1xuICAgIHJldHVybiBjaWQ7XG4gIH1cbn1cbmNvbnN0IHBhcnNlQ0lEdG9CeXRlcyA9IChzb3VyY2UsIGJhc2UpID0+IHtcbiAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgY2FzZSAnUSc6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlIHx8IGJhc2U1OGJ0YztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGJhc2U1OGJ0Yy5wcmVmaXgsXG4gICAgICAgIGRlY29kZXIuZGVjb2RlKGAkeyBiYXNlNThidGMucHJlZml4IH0keyBzb3VyY2UgfWApXG4gICAgICBdO1xuICAgIH1cbiAgY2FzZSBiYXNlNThidGMucHJlZml4OiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlNThidGM7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlNThidGMucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgY2FzZSBiYXNlMzIucHJlZml4OiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlMzI7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlMzIucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgZGVmYXVsdDoge1xuICAgICAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBFcnJvcignVG8gcGFyc2Ugbm9uIGJhc2UzMiBvciBiYXNlNThidGMgZW5jb2RlZCBDSUQgbXVsdGliYXNlIGRlY29kZXIgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc291cmNlWzBdLFxuICAgICAgICBiYXNlLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHRvU3RyaW5nVjAgPSAoYnl0ZXMsIGNhY2hlLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHtwcmVmaXh9ID0gYmFzZTtcbiAgaWYgKHByZWZpeCAhPT0gYmFzZTU4YnRjLnByZWZpeCkge1xuICAgIHRocm93IEVycm9yKGBDYW5ub3Qgc3RyaW5nIGVuY29kZSBWMCBpbiAkeyBiYXNlLm5hbWUgfSBlbmNvZGluZ2ApO1xuICB9XG4gIGNvbnN0IGNpZCA9IGNhY2hlLmdldChwcmVmaXgpO1xuICBpZiAoY2lkID09IG51bGwpIHtcbiAgICBjb25zdCBjaWQgPSBiYXNlLmVuY29kZShieXRlcykuc2xpY2UoMSk7XG4gICAgY2FjaGUuc2V0KHByZWZpeCwgY2lkKTtcbiAgICByZXR1cm4gY2lkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjaWQ7XG4gIH1cbn07XG5jb25zdCB0b1N0cmluZ1YxID0gKGJ5dGVzLCBjYWNoZSwgYmFzZSkgPT4ge1xuICBjb25zdCB7cHJlZml4fSA9IGJhc2U7XG4gIGNvbnN0IGNpZCA9IGNhY2hlLmdldChwcmVmaXgpO1xuICBpZiAoY2lkID09IG51bGwpIHtcbiAgICBjb25zdCBjaWQgPSBiYXNlLmVuY29kZShieXRlcyk7XG4gICAgY2FjaGUuc2V0KHByZWZpeCwgY2lkKTtcbiAgICByZXR1cm4gY2lkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjaWQ7XG4gIH1cbn07XG5jb25zdCBEQUdfUEJfQ09ERSA9IDExMjtcbmNvbnN0IFNIQV8yNTZfQ09ERSA9IDE4O1xuY29uc3QgZW5jb2RlQ0lEID0gKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCkgPT4ge1xuICBjb25zdCBjb2RlT2Zmc2V0ID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKHZlcnNpb24pO1xuICBjb25zdCBoYXNoT2Zmc2V0ID0gY29kZU9mZnNldCArIHZhcmludC5lbmNvZGluZ0xlbmd0aChjb2RlKTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoT2Zmc2V0ICsgbXVsdGloYXNoLmJ5dGVMZW5ndGgpO1xuICB2YXJpbnQuZW5jb2RlVG8odmVyc2lvbiwgYnl0ZXMsIDApO1xuICB2YXJpbnQuZW5jb2RlVG8oY29kZSwgYnl0ZXMsIGNvZGVPZmZzZXQpO1xuICBieXRlcy5zZXQobXVsdGloYXNoLCBoYXNoT2Zmc2V0KTtcbiAgcmV0dXJuIGJ5dGVzO1xufTtcbmNvbnN0IGNpZFN5bWJvbCA9IFN5bWJvbC5mb3IoJ0BpcGxkL2pzLWNpZC9DSUQnKTtcbmNvbnN0IHJlYWRvbmx5ID0ge1xuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWVcbn07XG5jb25zdCBoaWRkZW4gPSB7XG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn07XG5jb25zdCB2ZXJzaW9uID0gJzAuMC4wLWRldic7XG5jb25zdCBkZXByZWNhdGUgPSAocmFuZ2UsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKHJhbmdlLnRlc3QodmVyc2lvbikpIHtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuY29uc3QgSVNfQ0lEX0RFUFJFQ0FUSU9OID0gYENJRC5pc0NJRCh2KSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cbkZvbGxvd2luZyBjb2RlIHBhdHRlcm46XG5cbmlmIChDSUQuaXNDSUQodmFsdWUpKSB7XG4gIGRvU29tZXRoaW5nV2l0aENJRCh2YWx1ZSlcbn1cblxuSXMgcmVwbGFjZWQgd2l0aDpcblxuY29uc3QgY2lkID0gQ0lELmFzQ0lEKHZhbHVlKVxuaWYgKGNpZCkge1xuICAvLyBNYWtlIHN1cmUgdG8gdXNlIGNpZCBpbnN0ZWFkIG9mIHZhbHVlXG4gIGRvU29tZXRoaW5nV2l0aENJRChjaWQpXG59XG5gOyIsICJpbXBvcnQgeyBDSUQgfSBmcm9tICcuL2NpZC5qcyc7XG5pbXBvcnQgKiBhcyB2YXJpbnQgZnJvbSAnLi92YXJpbnQuanMnO1xuaW1wb3J0ICogYXMgYnl0ZXMgZnJvbSAnLi9ieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBoYXNoZXIgZnJvbSAnLi9oYXNoZXMvaGFzaGVyLmpzJztcbmltcG9ydCAqIGFzIGRpZ2VzdCBmcm9tICcuL2hhc2hlcy9kaWdlc3QuanMnO1xuZXhwb3J0IHtcbiAgQ0lELFxuICBoYXNoZXIsXG4gIGRpZ2VzdCxcbiAgdmFyaW50LFxuICBieXRlc1xufTsiLCAiaW1wb3J0ICogYXMgaWRlbnRpdHlCYXNlIGZyb20gJy4vYmFzZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0ICogYXMgYmFzZTIgZnJvbSAnLi9iYXNlcy9iYXNlMi5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlOCBmcm9tICcuL2Jhc2VzL2Jhc2U4LmpzJztcbmltcG9ydCAqIGFzIGJhc2UxMCBmcm9tICcuL2Jhc2VzL2Jhc2UxMC5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMTYgZnJvbSAnLi9iYXNlcy9iYXNlMTYuanMnO1xuaW1wb3J0ICogYXMgYmFzZTMyIGZyb20gJy4vYmFzZXMvYmFzZTMyLmpzJztcbmltcG9ydCAqIGFzIGJhc2UzNiBmcm9tICcuL2Jhc2VzL2Jhc2UzNi5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlNTggZnJvbSAnLi9iYXNlcy9iYXNlNTguanMnO1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJy4vYmFzZXMvYmFzZTY0LmpzJztcbmltcG9ydCAqIGFzIGJhc2UyNTZlbW9qaSBmcm9tICcuL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcyc7XG5pbXBvcnQgKiBhcyBzaGEyIGZyb20gJy4vaGFzaGVzL3NoYTIuanMnO1xuaW1wb3J0ICogYXMgaWRlbnRpdHkgZnJvbSAnLi9oYXNoZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0ICogYXMgcmF3IGZyb20gJy4vY29kZWNzL3Jhdy5qcyc7XG5pbXBvcnQgKiBhcyBqc29uIGZyb20gJy4vY29kZWNzL2pzb24uanMnO1xuaW1wb3J0IHtcbiAgQ0lELFxuICBoYXNoZXIsXG4gIGRpZ2VzdCxcbiAgdmFyaW50LFxuICBieXRlc1xufSBmcm9tICcuL2luZGV4LmpzJztcbmNvbnN0IGJhc2VzID0ge1xuICAuLi5pZGVudGl0eUJhc2UsXG4gIC4uLmJhc2UyLFxuICAuLi5iYXNlOCxcbiAgLi4uYmFzZTEwLFxuICAuLi5iYXNlMTYsXG4gIC4uLmJhc2UzMixcbiAgLi4uYmFzZTM2LFxuICAuLi5iYXNlNTgsXG4gIC4uLmJhc2U2NCxcbiAgLi4uYmFzZTI1NmVtb2ppXG59O1xuY29uc3QgaGFzaGVzID0ge1xuICAuLi5zaGEyLFxuICAuLi5pZGVudGl0eVxufTtcbmNvbnN0IGNvZGVjcyA9IHtcbiAgcmF3LFxuICBqc29uXG59O1xuZXhwb3J0IHtcbiAgQ0lELFxuICBoYXNoZXIsXG4gIGRpZ2VzdCxcbiAgdmFyaW50LFxuICBieXRlcyxcbiAgaGFzaGVzLFxuICBiYXNlcyxcbiAgY29kZWNzXG59OyIsICJleHBvcnQgZnVuY3Rpb24gYWxsb2Moc2l6ZSA9IDApIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2MgIT0gbnVsbCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSA9IDApIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUgIT0gbnVsbCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG59IiwgImltcG9ydCB7IGJhc2VzIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2Jhc2ljcyc7XG5pbXBvcnQgeyBhbGxvY1Vuc2FmZSB9IGZyb20gJy4uL2FsbG9jLmpzJztcbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjKG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHByZWZpeCxcbiAgICBlbmNvZGVyOiB7XG4gICAgICBuYW1lLFxuICAgICAgcHJlZml4LFxuICAgICAgZW5jb2RlXG4gICAgfSxcbiAgICBkZWNvZGVyOiB7IGRlY29kZSB9XG4gIH07XG59XG5jb25zdCBzdHJpbmcgPSBjcmVhdGVDb2RlYygndXRmOCcsICd1JywgYnVmID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICByZXR1cm4gJ3UnICsgZGVjb2Rlci5kZWNvZGUoYnVmKTtcbn0sIHN0ciA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0ci5zdWJzdHJpbmcoMSkpO1xufSk7XG5jb25zdCBhc2NpaSA9IGNyZWF0ZUNvZGVjKCdhc2NpaScsICdhJywgYnVmID0+IHtcbiAgbGV0IHN0cmluZyA9ICdhJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59LCBzdHIgPT4ge1xuICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICBjb25zdCBidWYgPSBhbGxvY1Vuc2FmZShzdHIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufSk7XG5jb25zdCBCQVNFUyA9IHtcbiAgdXRmODogc3RyaW5nLFxuICAndXRmLTgnOiBzdHJpbmcsXG4gIGhleDogYmFzZXMuYmFzZTE2LFxuICBsYXRpbjE6IGFzY2lpLFxuICBhc2NpaTogYXNjaWksXG4gIGJpbmFyeTogYXNjaWksXG4gIC4uLmJhc2VzXG59O1xuZXhwb3J0IGRlZmF1bHQgQkFTRVM7IiwgImltcG9ydCBiYXNlcyBmcm9tICcuL3V0aWwvYmFzZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGFycmF5LCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBjb25zdCBiYXNlID0gYmFzZXNbZW5jb2RpbmddO1xuICBpZiAoIWJhc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHsgZW5jb2RpbmcgfVwiYCk7XG4gIH1cbiAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20gIT0gbnVsbCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gYmFzZS5lbmNvZGVyLmVuY29kZShhcnJheSkuc3Vic3RyaW5nKDEpO1xufSIsICJpbXBvcnQgeyBhbGxvY1Vuc2FmZSB9IGZyb20gJy4vYWxsb2MuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChhcnJheXMsIGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IGFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGFyciBvZiBhcnJheXMpIHtcbiAgICBvdXRwdXQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufSIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBhc1Byb21pc2U7XHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5hc1Byb21pc2V9LlxyXG4gKiBAdHlwZWRlZiBhc1Byb21pc2VDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBBZGRpdGlvbmFsIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmcm9tIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHthc1Byb21pc2VDYWxsYmFja30gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IGN0eCBGdW5jdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gUHJvbWlzaWZpZWQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4LyosIHZhcmFyZ3MgKi8pIHtcclxuICAgIHZhciBwYXJhbXMgID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICBvZmZzZXQgID0gMCxcclxuICAgICAgICBpbmRleCAgID0gMixcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVyci8qLCB2YXJhcmdzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBBIG1pbmltYWwgZXZlbnQgZW1pdHRlci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gTGlzdGVuZXJcclxuICogQHBhcmFtIHsqfSBbY3R4XSBMaXN0ZW5lciBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XHJcbiAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcclxuICAgICAgICBmbiAgOiBmbixcclxuICAgICAgICBjdHggOiBjdHggfHwgdGhpc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIG9yIGFueSBtYXRjaGluZyBsaXN0ZW5lcnMgaWYgYXJndW1lbnRzIGFyZSBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2dF0gRXZlbnQgbmFtZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGlmIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb2YgYGV2dGAgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcclxuICAgIGlmIChldnQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0cyBhbiBldmVudCBieSBjYWxsaW5nIGl0cyBsaXN0ZW5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyAvIHdyaXRlcyBmbG9hdHMgLyBkb3VibGVzIGZyb20gLyB0byBidWZmZXJzLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0XHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2Ygbm9kZS1iYXNlZCB0ZXN0aW5nIGluIG1vZGlmaWVkIGdsb2JhbCBlbnZpcm9ubWVudHNcclxuZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzKSB7XHJcblxyXG4gICAgLy8gZmxvYXQ6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbIC0wIF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzNdID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgIC8vIGZsb2F0OiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gMy40MDI4MjM0NjYzODUyODg2ZSszOCkgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMS4xNzU0OTQzNTA4MjIyODc1ZS0zOCkgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZG91YmxlOiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbN10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbN107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgLy8gZG91YmxlOiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpIHsgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgeyAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLFxyXG4gICAgICAgICAgICAgICAgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NyxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0N1xyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbi8vIHVpbnQgaGVscGVyc1xyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgPj4+IDI0O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXVxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF0gPDwgMjRcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XHJcblxyXG4vKipcclxuICogUmVxdWlyZXMgYSBtb2R1bGUgb25seSBpZiBhdmFpbGFibGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE1vZHVsZSB0byByZXF1aXJlXHJcbiAqIEByZXR1cm5zIHs/T2JqZWN0fSBSZXF1aXJlZCBtb2R1bGUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZW1wdHksIG90aGVyd2lzZSBgbnVsbGBcclxuICovXHJcbmZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxyXG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBVVEY4IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgdXRmOCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVVRGOCBieXRlIGxlbmd0aCBvZiBhIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbnV0ZjgubGVuZ3RoID0gZnVuY3Rpb24gdXRmOF9sZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgbGVuID0gMCxcclxuICAgICAgICBjID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMTtcclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcclxuICAgICAgICAgICAgbGVuICs9IDI7XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGxlbiArPSA0O1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBsZW4gKz0gMztcclxuICAgIH1cclxuICAgIHJldHVybiBsZW47XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgVVRGOCBieXRlcyBhcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxyXG4gKi9cclxudXRmOC5yZWFkID0gZnVuY3Rpb24gdXRmOF9yZWFkKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW10sXHJcbiAgICAgICAgaSA9IDAsIC8vIGNoYXIgb2Zmc2V0XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdCA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBpZiAodCA8IDEyOClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IHQ7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDE5MSAmJiB0IDwgMjI0KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAzMSkgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAyMzkgJiYgdCA8IDM2NSkge1xyXG4gICAgICAgICAgICB0ID0gKCh0ICYgNykgPDwgMTggfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjMpIC0gMHgxMDAwMDtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4RDgwMCArICh0ID4+IDEwKTtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4REMwMCArICh0ICYgMTAyMyk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDE1KSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHN0cmluZyBhcyBVVEY4IGJ5dGVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGVzIHdyaXR0ZW5cclxuICovXHJcbnV0Zjgud3JpdGUgPSBmdW5jdGlvbiB1dGY4X3dyaXRlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICBjMSwgLy8gY2hhcmFjdGVyIDFcclxuICAgICAgICBjMjsgLy8gY2hhcmFjdGVyIDJcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAgICAgIHwgMTkyO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2UgaWYgKChjMSAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoKGMyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICBjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM0ZGKSA8PCAxMCkgKyAoYzIgJiAweDAzRkYpO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxOCAgICAgIHwgMjQwO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAgICAgIHwgMjI0O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXJ9IGhpIEhpZ2ggMzIgYml0cywgdW5zaWduZWRcbiAqL1xuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxuXG4gICAgLyoqXG4gICAgICogTG93IGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG59XG5cbi8qKlxuICogWmVybyBiaXRzLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxuICovXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG5cbnplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuXG4vKipcbiAqIFplcm8gaGFzaC5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge251bWJlcn0gUG9zc2libHkgdW5zYWZlIG51bWJlclxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICByZXR1cm4gdXRpbC5Mb25nXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xufTtcblxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEJpdHNcbiAqL1xuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMFxuICAgICxcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0ICAgICAgLFxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICk7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZW5jb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMubG8gID0gKCB0aGlzLmxvIDw8IDEgICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxuICAgICAgICBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICAgPyBwYXJ0MSA9PT0gMFxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcbiAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0XG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxuICAgICAgICAgICAgIDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDhcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IEN1c3RvbUVycm9yLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gbmFtZTsgfSxcbiAgICAgICAgICAgIHNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAvLyBjb25maWd1cmFibGU6IGZhbHNlIHdvdWxkIGFjY3VyYXRlbHkgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGJ1dCBJJ20gZ3Vlc3NpbmcgdGhhdCB3YXMgbm90IGludGVudGlvbmFsLlxuICAgICAgICAgICAgLy8gRm9yIGFuIGFjdHVhbCBlcnJvciBzdWJjbGFzcywgdGhpcyBwcm9wZXJ0eSB3b3VsZFxuICAgICAgICAgICAgLy8gYmUgY29uZmlndXJhYmxlLlxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB0b1N0cmluZzoge1xuICAgICAgICAgICAgdmFsdWUoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH0sXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuXG4vLyBleHRlbmRzIFJlYWRlclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFJlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXG4gICAgICogQHR5cGUge0J1ZmZlcn1cbiAgICAgKi9cbn1cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZVxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxuICAgICAgICA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxuICovXG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gY29kZWdlbjtcclxuXHJcbi8qKlxyXG4gKiBCZWdpbnMgZ2VuZXJhdGluZyBhIGZ1bmN0aW9uLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmdW5jdGlvblBhcmFtcyBGdW5jdGlvbiBwYXJhbWV0ZXIgbmFtZXNcclxuICogQHBhcmFtIHtzdHJpbmd9IFtmdW5jdGlvbk5hbWVdIEZ1bmN0aW9uIG5hbWUgaWYgbm90IGFub255bW91c1xyXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQXBwZW5kZXIgdGhhdCBhcHBlbmRzIGNvZGUgdG8gdGhlIGZ1bmN0aW9uJ3MgYm9keVxyXG4gKi9cclxuZnVuY3Rpb24gY29kZWdlbihmdW5jdGlvblBhcmFtcywgZnVuY3Rpb25OYW1lKSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodHlwZW9mIGZ1bmN0aW9uUGFyYW1zID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25QYXJhbXM7XHJcbiAgICAgICAgZnVuY3Rpb25QYXJhbXMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJvZHkgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgY29kZSB0byB0aGUgZnVuY3Rpb24ncyBib2R5IG9yIGZpbmlzaGVzIGdlbmVyYXRpb24uXHJcbiAgICAgKiBAdHlwZWRlZiBDb2RlZ2VuXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2Zvcm1hdFN0cmluZ09yU2NvcGVdIEZvcm1hdCBzdHJpbmcgb3IsIHRvIGZpbmlzaCB0aGUgZnVuY3Rpb24sIGFuIG9iamVjdCBvZiBhZGRpdGlvbmFsIHNjb3BlIHZhcmlhYmxlcywgaWYgYW55XHJcbiAgICAgKiBAcGFyYW0gey4uLip9IFtmb3JtYXRQYXJhbXNdIEZvcm1hdCBwYXJhbWV0ZXJzXHJcbiAgICAgKiBAcmV0dXJucyB7Q29kZWdlbnxGdW5jdGlvbn0gSXRzZWxmIG9yIHRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaWYgZmluaXNoZWRcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBmb3JtYXQgcGFyYW1ldGVyIGNvdW50cyBkbyBub3QgbWF0Y2hcclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIENvZGVnZW4oZm9ybWF0U3RyaW5nT3JTY29wZSkge1xyXG4gICAgICAgIC8vIG5vdGUgdGhhdCBleHBsaWNpdCBhcnJheSBoYW5kbGluZyBiZWxvdyBtYWtlcyB0aGlzIH41MCUgZmFzdGVyXHJcblxyXG4gICAgICAgIC8vIGZpbmlzaCB0aGUgZnVuY3Rpb25cclxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdFN0cmluZ09yU2NvcGUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuLnZlcmJvc2UpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvZGVnZW46IFwiICsgc291cmNlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgIHNvdXJjZSA9IFwicmV0dXJuIFwiICsgc291cmNlO1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0U3RyaW5nT3JTY29wZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjb3BlS2V5cyAgID0gT2JqZWN0LmtleXMoZm9ybWF0U3RyaW5nT3JTY29wZSksXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVQYXJhbXMgPSBuZXcgQXJyYXkoc2NvcGVLZXlzLmxlbmd0aCArIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlVmFsdWVzID0gbmV3IEFycmF5KHNjb3BlS2V5cy5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzY29wZU9mZnNldCA8IHNjb3BlS2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZVBhcmFtc1tzY29wZU9mZnNldF0gPSBzY29wZUtleXNbc2NvcGVPZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlVmFsdWVzW3Njb3BlT2Zmc2V0XSA9IGZvcm1hdFN0cmluZ09yU2NvcGVbc2NvcGVLZXlzW3Njb3BlT2Zmc2V0KytdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNjb3BlUGFyYW1zW3Njb3BlT2Zmc2V0XSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5hcHBseShudWxsLCBzY29wZVBhcmFtcykuYXBwbHkobnVsbCwgc2NvcGVWYWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKHNvdXJjZSkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGFwcGVuZCB0byBib2R5XHJcbiAgICAgICAgdmFyIGZvcm1hdFBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgIGZvcm1hdE9mZnNldCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGZvcm1hdE9mZnNldCA8IGZvcm1hdFBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIGZvcm1hdFBhcmFtc1tmb3JtYXRPZmZzZXRdID0gYXJndW1lbnRzWysrZm9ybWF0T2Zmc2V0XTtcclxuICAgICAgICBmb3JtYXRPZmZzZXQgPSAwO1xyXG4gICAgICAgIGZvcm1hdFN0cmluZ09yU2NvcGUgPSBmb3JtYXRTdHJpbmdPclNjb3BlLnJlcGxhY2UoLyUoWyVkZmlqc10pL2csIGZ1bmN0aW9uIHJlcGxhY2UoJDAsICQxKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZvcm1hdFBhcmFtc1tmb3JtYXRPZmZzZXQrK107XHJcbiAgICAgICAgICAgIHN3aXRjaCAoJDEpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJkXCI6IGNhc2UgXCJmXCI6IHJldHVybiBTdHJpbmcoTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaVwiOiByZXR1cm4gU3RyaW5nKE1hdGguZmxvb3IodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJqXCI6IHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic1wiOiByZXR1cm4gU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXCIlXCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGZvcm1hdE9mZnNldCAhPT0gZm9ybWF0UGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXJhbWV0ZXIgY291bnQgbWlzbWF0Y2hcIik7XHJcbiAgICAgICAgYm9keS5wdXNoKGZvcm1hdFN0cmluZ09yU2NvcGUpO1xyXG4gICAgICAgIHJldHVybiBDb2RlZ2VuO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKGZ1bmN0aW9uTmFtZU92ZXJyaWRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb24gXCIgKyAoZnVuY3Rpb25OYW1lT3ZlcnJpZGUgfHwgZnVuY3Rpb25OYW1lIHx8IFwiXCIpICsgXCIoXCIgKyAoZnVuY3Rpb25QYXJhbXMgJiYgZnVuY3Rpb25QYXJhbXMuam9pbihcIixcIikgfHwgXCJcIikgKyBcIil7XFxuICBcIiArIGJvZHkuam9pbihcIlxcbiAgXCIpICsgXCJcXG59XCI7XHJcbiAgICB9XHJcblxyXG4gICAgQ29kZWdlbi50b1N0cmluZyA9IHRvU3RyaW5nO1xyXG4gICAgcmV0dXJuIENvZGVnZW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCZWdpbnMgZ2VuZXJhdGluZyBhIGZ1bmN0aW9uLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb24gY29kZWdlblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2Z1bmN0aW9uTmFtZV0gRnVuY3Rpb24gbmFtZSBpZiBub3QgYW5vbnltb3VzXHJcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBBcHBlbmRlciB0aGF0IGFwcGVuZHMgY29kZSB0byB0aGUgZnVuY3Rpb24ncyBib2R5XHJcbiAqIEB2YXJpYXRpb24gMlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXaGVuIHNldCB0byBgdHJ1ZWAsIGNvZGVnZW4gd2lsbCBsb2cgZ2VuZXJhdGVkIGNvZGUgdG8gY29uc29sZS4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXHJcbiAqIEBuYW1lIHV0aWwuY29kZWdlbi52ZXJib3NlXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKi9cclxuY29kZWdlbi52ZXJib3NlID0gZmFsc2U7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBmZXRjaDtcclxuXHJcbnZhciBhc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpLFxyXG4gICAgaW5xdWlyZSAgID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XHJcblxyXG52YXIgZnMgPSBpbnF1aXJlKFwiZnNcIik7XHJcblxyXG4vKipcclxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLmZldGNofS5cclxuICogQHR5cGVkZWYgRmV0Y2hDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29udGVudHNdIEZpbGUgY29udGVudHMsIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5mZXRjaH0uXHJcbiAqIEB0eXBlZGVmIEZldGNoT3B0aW9uc1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtiaW5hcnk9ZmFsc2VdIFdoZXRoZXIgZXhwZWN0aW5nIGEgYmluYXJ5IHJlc3BvbnNlXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3hocj1mYWxzZV0gSWYgYHRydWVgLCBmb3JjZXMgdGhlIHVzZSBvZiBYTUxIdHRwUmVxdWVzdFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBGZXRjaGVzIHRoZSBjb250ZW50cyBvZiBhIGZpbGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSBGaWxlIHBhdGggb3IgdXJsXHJcbiAqIEBwYXJhbSB7RmV0Y2hPcHRpb25zfSBvcHRpb25zIEZldGNoIG9wdGlvbnNcclxuICogQHBhcmFtIHtGZXRjaENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuZnVuY3Rpb24gZmV0Y2goZmlsZW5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICBpZiAoIWNhbGxiYWNrKVxyXG4gICAgICAgIHJldHVybiBhc1Byb21pc2UoZmV0Y2gsIHRoaXMsIGZpbGVuYW1lLCBvcHRpb25zKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcclxuXHJcbiAgICAvLyBpZiBhIG5vZGUtbGlrZSBmaWxlc3lzdGVtIGlzIHByZXNlbnQsIHRyeSBpdCBmaXJzdCBidXQgZmFsbCBiYWNrIHRvIFhIUiBpZiBub3RoaW5nIGlzIGZvdW5kLlxyXG4gICAgaWYgKCFvcHRpb25zLnhociAmJiBmcyAmJiBmcy5yZWFkRmlsZSlcclxuICAgICAgICByZXR1cm4gZnMucmVhZEZpbGUoZmlsZW5hbWUsIGZ1bmN0aW9uIGZldGNoUmVhZEZpbGVDYWxsYmFjayhlcnIsIGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnIgJiYgdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSBcInVuZGVmaW5lZFwiXHJcbiAgICAgICAgICAgICAgICA/IGZldGNoLnhocihmaWxlbmFtZSwgb3B0aW9ucywgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICA6IGVyclxyXG4gICAgICAgICAgICAgICAgPyBjYWxsYmFjayhlcnIpXHJcbiAgICAgICAgICAgICAgICA6IGNhbGxiYWNrKG51bGwsIG9wdGlvbnMuYmluYXJ5ID8gY29udGVudHMgOiBjb250ZW50cy50b1N0cmluZyhcInV0ZjhcIikpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIC8vIHVzZSB0aGUgWEhSIHZlcnNpb24gb3RoZXJ3aXNlLlxyXG4gICAgcmV0dXJuIGZldGNoLnhocihmaWxlbmFtZSwgb3B0aW9ucywgY2FsbGJhY2spO1xyXG59XHJcblxyXG4vKipcclxuICogRmV0Y2hlcyB0aGUgY29udGVudHMgb2YgYSBmaWxlLlxyXG4gKiBAbmFtZSB1dGlsLmZldGNoXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBGaWxlIHBhdGggb3IgdXJsXHJcbiAqIEBwYXJhbSB7RmV0Y2hDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQHZhcmlhdGlvbiAyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEZldGNoZXMgdGhlIGNvbnRlbnRzIG9mIGEgZmlsZS5cclxuICogQG5hbWUgdXRpbC5mZXRjaFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggRmlsZSBwYXRoIG9yIHVybFxyXG4gKiBAcGFyYW0ge0ZldGNoT3B0aW9uc30gW29wdGlvbnNdIEZldGNoIG9wdGlvbnNcclxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nfFVpbnQ4QXJyYXk+fSBQcm9taXNlXHJcbiAqIEB2YXJpYXRpb24gM1xyXG4gKi9cclxuXHJcbi8qKi9cclxuZmV0Y2gueGhyID0gZnVuY3Rpb24gZmV0Y2hfeGhyKGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSAvKiB3b3JrcyBldmVyeXdoZXJlICovID0gZnVuY3Rpb24gZmV0Y2hPblJlYWR5U3RhdGVDaGFuZ2UoKSB7XHJcblxyXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNClcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gbG9jYWwgY29ycyBzZWN1cml0eSBlcnJvcnMgcmV0dXJuIHN0YXR1cyAwIC8gZW1wdHkgc3RyaW5nLCB0b28uIGFmYWlrIHRoaXMgY2Fubm90IGJlXHJcbiAgICAgICAgLy8gcmVsaWFibHkgZGlzdGluZ3Vpc2hlZCBmcm9tIGFuIGFjdHVhbGx5IGVtcHR5IGZpbGUgZm9yIHNlY3VyaXR5IHJlYXNvbnMuIGZlZWwgZnJlZVxyXG4gICAgICAgIC8vIHRvIHNlbmQgYSBwdWxsIHJlcXVlc3QgaWYgeW91IGFyZSBhd2FyZSBvZiBhIHNvbHV0aW9uLlxyXG4gICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSAwICYmIHhoci5zdGF0dXMgIT09IDIwMClcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yKFwic3RhdHVzIFwiICsgeGhyLnN0YXR1cykpO1xyXG5cclxuICAgICAgICAvLyBpZiBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCwgbWFrZSBzdXJlIHRoYXQgc29tZSBzb3J0IG9mIGFycmF5IGlzIHJldHVybmVkLCBldmVuIGlmXHJcbiAgICAgICAgLy8gQXJyYXlCdWZmZXJzIGFyZSBub3Qgc3VwcG9ydGVkLiB0aGUgYmluYXJ5IHN0cmluZyBmYWxsYmFjaywgaG93ZXZlciwgaXMgdW5zYWZlLlxyXG4gICAgICAgIGlmIChvcHRpb25zLmJpbmFyeSkge1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0geGhyLnJlc3BvbnNlO1xyXG4gICAgICAgICAgICBpZiAoIWJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhoci5yZXNwb25zZVRleHQubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goeGhyLnJlc3BvbnNlVGV4dC5jaGFyQ29kZUF0KGkpICYgMjU1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgVWludDhBcnJheShidWZmZXIpIDogYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5iaW5hcnkpIHtcclxuICAgICAgICAvLyByZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9TZW5kaW5nX2FuZF9SZWNlaXZpbmdfQmluYXJ5X0RhdGEjUmVjZWl2aW5nX2JpbmFyeV9kYXRhX2luX29sZGVyX2Jyb3dzZXJzXHJcbiAgICAgICAgaWYgKFwib3ZlcnJpZGVNaW1lVHlwZVwiIGluIHhocilcclxuICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIpO1xyXG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcbiAgICB9XHJcblxyXG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgZmlsZW5hbWUpO1xyXG4gICAgeGhyLnNlbmQoKTtcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBwYXRoIG1vZHVsZSB0byByZXNvbHZlIFVuaXgsIFdpbmRvd3MgYW5kIFVSTCBwYXRocyBhbGlrZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHBhdGggPSBleHBvcnRzO1xyXG5cclxudmFyIGlzQWJzb2x1dGUgPVxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBwYXRoIGlzIGFic29sdXRlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBwYXRoIGlzIGFic29sdXRlXHJcbiAqL1xyXG5wYXRoLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcclxuICAgIHJldHVybiAvXig/OlxcL3xcXHcrOikvLnRlc3QocGF0aCk7XHJcbn07XHJcblxyXG52YXIgbm9ybWFsaXplID1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBOb3JtYWxpemVkIHBhdGhcclxuICovXHJcbnBhdGgubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcclxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXHJcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcclxuICAgIHZhciBwYXJ0cyAgICA9IHBhdGguc3BsaXQoXCIvXCIpLFxyXG4gICAgICAgIGFic29sdXRlID0gaXNBYnNvbHV0ZShwYXRoKSxcclxuICAgICAgICBwcmVmaXggICA9IFwiXCI7XHJcbiAgICBpZiAoYWJzb2x1dGUpXHJcbiAgICAgICAgcHJlZml4ID0gcGFydHMuc2hpZnQoKSArIFwiL1wiO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7KSB7XHJcbiAgICAgICAgaWYgKHBhcnRzW2ldID09PSBcIi4uXCIpIHtcclxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHBhcnRzW2kgLSAxXSAhPT0gXCIuLlwiKVxyXG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKC0taSwgMik7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFic29sdXRlKVxyXG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXSA9PT0gXCIuXCIpXHJcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICsraTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcmVmaXggKyBwYXJ0cy5qb2luKFwiL1wiKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlcyB0aGUgc3BlY2lmaWVkIGluY2x1ZGUgcGF0aCBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgb3JpZ2luIHBhdGguXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5QYXRoIFBhdGggdG8gdGhlIG9yaWdpbiBmaWxlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmNsdWRlUGF0aCBJbmNsdWRlIHBhdGggcmVsYXRpdmUgdG8gb3JpZ2luIHBhdGhcclxuICogQHBhcmFtIHtib29sZWFufSBbYWxyZWFkeU5vcm1hbGl6ZWQ9ZmFsc2VdIGB0cnVlYCBpZiBib3RoIHBhdGhzIGFyZSBhbHJlYWR5IGtub3duIHRvIGJlIG5vcm1hbGl6ZWRcclxuICogQHJldHVybnMge3N0cmluZ30gUGF0aCB0byB0aGUgaW5jbHVkZSBmaWxlXHJcbiAqL1xyXG5wYXRoLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKG9yaWdpblBhdGgsIGluY2x1ZGVQYXRoLCBhbHJlYWR5Tm9ybWFsaXplZCkge1xyXG4gICAgaWYgKCFhbHJlYWR5Tm9ybWFsaXplZClcclxuICAgICAgICBpbmNsdWRlUGF0aCA9IG5vcm1hbGl6ZShpbmNsdWRlUGF0aCk7XHJcbiAgICBpZiAoaXNBYnNvbHV0ZShpbmNsdWRlUGF0aCkpXHJcbiAgICAgICAgcmV0dXJuIGluY2x1ZGVQYXRoO1xyXG4gICAgaWYgKCFhbHJlYWR5Tm9ybWFsaXplZClcclxuICAgICAgICBvcmlnaW5QYXRoID0gbm9ybWFsaXplKG9yaWdpblBhdGgpO1xyXG4gICAgcmV0dXJuIChvcmlnaW5QYXRoID0gb3JpZ2luUGF0aC5yZXBsYWNlKC8oPzpcXC98XilbXi9dKyQvLCBcIlwiKSkubGVuZ3RoID8gbm9ybWFsaXplKG9yaWdpblBhdGggKyBcIi9cIiArIGluY2x1ZGVQYXRoKSA6IGluY2x1ZGVQYXRoO1xyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29tbW9uIHR5cGUgY29uc3RhbnRzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgdHlwZXMgPSBleHBvcnRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBzID0gW1xuICAgIFwiZG91YmxlXCIsICAgLy8gMFxuICAgIFwiZmxvYXRcIiwgICAgLy8gMVxuICAgIFwiaW50MzJcIiwgICAgLy8gMlxuICAgIFwidWludDMyXCIsICAgLy8gM1xuICAgIFwic2ludDMyXCIsICAgLy8gNFxuICAgIFwiZml4ZWQzMlwiLCAgLy8gNVxuICAgIFwic2ZpeGVkMzJcIiwgLy8gNlxuICAgIFwiaW50NjRcIiwgICAgLy8gN1xuICAgIFwidWludDY0XCIsICAgLy8gOFxuICAgIFwic2ludDY0XCIsICAgLy8gOVxuICAgIFwiZml4ZWQ2NFwiLCAgLy8gMTBcbiAgICBcInNmaXhlZDY0XCIsIC8vIDExXG4gICAgXCJib29sXCIsICAgICAvLyAxMlxuICAgIFwic3RyaW5nXCIsICAgLy8gMTNcbiAgICBcImJ5dGVzXCIgICAgIC8vIDE0XG5dO1xuXG5mdW5jdGlvbiBiYWtlKHZhbHVlcywgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSAwLCBvID0ge307XG4gICAgb2Zmc2V0IHw9IDA7XG4gICAgd2hpbGUgKGkgPCB2YWx1ZXMubGVuZ3RoKSBvW3NbaSArIG9mZnNldF1dID0gdmFsdWVzW2krK107XG4gICAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogQmFzaWMgdHlwZSB3aXJlIHR5cGVzLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cmluZz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBieXRlcz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqL1xudHlwZXMuYmFzaWMgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAxLFxuICAgIC8qIGZsb2F0ICAgICovIDUsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwLFxuICAgIC8qIHN0cmluZyAgICovIDIsXG4gICAgLyogYnl0ZXMgICAgKi8gMlxuXSk7XG5cbi8qKlxuICogQmFzaWMgdHlwZSBkZWZhdWx0cy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRvdWJsZT0wIERvdWJsZSBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZmxvYXQ9MCBGbG9hdCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBJbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVWludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBTaW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9MCBGaXhlZDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj0wIFNmaXhlZDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIEludDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBVaW50NjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFNpbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0wIEZpeGVkNjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTAgU2ZpeGVkNjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBib29sPWZhbHNlIEJvb2wgZGVmYXVsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0cmluZz1cIlwiIFN0cmluZyBkZWZhdWx0XG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBieXRlcz1BcnJheSgwKSBCeXRlcyBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bGx9IG1lc3NhZ2U9bnVsbCBNZXNzYWdlIGRlZmF1bHRcbiAqL1xudHlwZXMuZGVmYXVsdHMgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAwLFxuICAgIC8qIGZsb2F0ICAgICovIDAsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gMCxcbiAgICAvKiBzZml4ZWQzMiAqLyAwLFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDAsXG4gICAgLyogc2ZpeGVkNjQgKi8gMCxcbiAgICAvKiBib29sICAgICAqLyBmYWxzZSxcbiAgICAvKiBzdHJpbmcgICAqLyBcIlwiLFxuICAgIC8qIGJ5dGVzICAgICovIHV0aWwuZW1wdHlBcnJheSxcbiAgICAvKiBtZXNzYWdlICAqLyBudWxsXG5dKTtcblxuLyoqXG4gKiBCYXNpYyBsb25nIHR5cGUgd2lyZSB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKi9cbnR5cGVzLmxvbmcgPSBiYWtlKFtcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDFcbl0sIDcpO1xuXG4vKipcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIG1hcCBrZXlzIHdpdGggdGhlaXIgYXNzb2NpYXRlZCB3aXJlIHR5cGUuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvb2w9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RyaW5nPTIgTGRlbGltIHdpcmUgdHlwZVxuICovXG50eXBlcy5tYXBLZXkgPSBiYWtlKFtcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxuICAgIC8qIHVpbnQzMiAgICovIDAsXG4gICAgLyogc2ludDMyICAgKi8gMCxcbiAgICAvKiBmaXhlZDMyICAqLyA1LFxuICAgIC8qIHNmaXhlZDMyICovIDUsXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxLFxuICAgIC8qIGJvb2wgICAgICovIDAsXG4gICAgLyogc3RyaW5nICAgKi8gMlxuXSwgMik7XG5cbi8qKlxuICogQWxsb3dlZCB0eXBlcyBmb3IgcGFja2VkIHJlcGVhdGVkIGZpZWxkcyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd2lyZSB0eXBlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICovXG50eXBlcy5wYWNrZWQgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAxLFxuICAgIC8qIGZsb2F0ICAgICovIDUsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwXG5dKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gRmllbGQ7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEZpZWxkKS5jbGFzc05hbWUgPSBcIkZpZWxkXCI7XG5cbnZhciBFbnVtICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBUeXBlOyAvLyBjeWNsaWNcblxudmFyIHJ1bGVSZSA9IC9ecmVxdWlyZWR8b3B0aW9uYWx8cmVwZWF0ZWQkLztcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc3NhZ2UgZmllbGQgaW5zdGFuY2UuIE5vdGUgdGhhdCB7QGxpbmsgTWFwRmllbGR8bWFwIGZpZWxkc30gaGF2ZSB0aGVpciBvd24gY2xhc3MuXG4gKiBAbmFtZSBGaWVsZFxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWVzc2FnZSBmaWVsZC5cbiAqIEBleHRlbmRzIEZpZWxkQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBpZCB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtydWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtleHRlbmRdIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZpZWxkIGZyb20gYSBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICogQHBhcmFtIHtJRmllbGR9IGpzb24gRmllbGQgZGVzY3JpcHRvclxuICogQHJldHVybnMge0ZpZWxkfSBDcmVhdGVkIGZpZWxkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5GaWVsZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEZpZWxkKG5hbWUsIGpzb24uaWQsIGpzb24udHlwZSwganNvbi5ydWxlLCBqc29uLmV4dGVuZCwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGNvbnN0cnVjdG9yLiBVc2Uge0BsaW5rIEZpZWxkfSBpbnN0ZWFkLlxuICogQGNsYXNzZGVzYyBCYXNlIGNsYXNzIG9mIGFsbCByZWZsZWN0ZWQgbWVzc2FnZSBmaWVsZHMuIFRoaXMgaXMgbm90IGFuIGFjdHVhbCBjbGFzcyBidXQgaGVyZSBmb3IgdGhlIHNha2Ugb2YgaGF2aW5nIGNvbnNpc3RlbnQgdHlwZSBkZWZpbml0aW9ucy5cbiAqIEBleHBvcnRzIEZpZWxkQmFzZVxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBpZCB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtydWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtleHRlbmRdIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIEZpZWxkKG5hbWUsIGlkLCB0eXBlLCBydWxlLCBleHRlbmQsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIGlmICh1dGlsLmlzT2JqZWN0KHJ1bGUpKSB7XG4gICAgICAgIGNvbW1lbnQgPSBleHRlbmQ7XG4gICAgICAgIG9wdGlvbnMgPSBydWxlO1xuICAgICAgICBydWxlID0gZXh0ZW5kID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc09iamVjdChleHRlbmQpKSB7XG4gICAgICAgIGNvbW1lbnQgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kO1xuICAgICAgICBleHRlbmQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpZCkgfHwgaWQgPCAwKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJpZCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXJcIik7XG5cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcodHlwZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIGlmIChydWxlICE9PSB1bmRlZmluZWQgJiYgIXJ1bGVSZS50ZXN0KHJ1bGUgPSBydWxlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJ1bGUgbXVzdCBiZSBhIHN0cmluZyBydWxlXCIpO1xuXG4gICAgaWYgKGV4dGVuZCAhPT0gdW5kZWZpbmVkICYmICF1dGlsLmlzU3RyaW5nKGV4dGVuZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImV4dGVuZCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogRmllbGQgcnVsZSwgaWYgYW55LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGlmIChydWxlID09PSBcInByb3RvM19vcHRpb25hbFwiKSB7XG4gICAgICAgIHJ1bGUgPSBcIm9wdGlvbmFsXCI7XG4gICAgfVxuICAgIHRoaXMucnVsZSA9IHJ1bGUgJiYgcnVsZSAhPT0gXCJvcHRpb25hbFwiID8gcnVsZSA6IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBVbmlxdWUgZmllbGQgaWQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gaWQ7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmRlZCB0eXBlIGlmIGRpZmZlcmVudCBmcm9tIHBhcmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuZCA9IGV4dGVuZCB8fCB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkIGlzIHJlcXVpcmVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWlyZWQgPSBydWxlID09PSBcInJlcXVpcmVkXCI7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgb3B0aW9uYWwuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25hbCA9ICF0aGlzLnJlcXVpcmVkO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkIGlzIHJlcGVhdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVwZWF0ZWQgPSBydWxlID09PSBcInJlcGVhdGVkXCI7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgYSBtYXAgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIHRoaXMgZmllbGQgYmVsb25ncyB0by5cbiAgICAgKiBAdHlwZSB7VHlwZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBPbmVPZiB0aGlzIGZpZWxkIGJlbG9uZ3MgdG8sIGlmIGFueSxcbiAgICAgKiBAdHlwZSB7T25lT2Z8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcnRPZiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgdHlwZSdzIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy50eXBlRGVmYXVsdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQncyBkZWZhdWx0IHZhbHVlIG9uIHByb3RvdHlwZXMuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkJ3MgdmFsdWUgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBsb25nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9uZyA9IHV0aWwuTG9uZyA/IHR5cGVzLmxvbmdbdHlwZV0gIT09IHVuZGVmaW5lZCA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkJ3MgdmFsdWUgaXMgYSBidWZmZXIuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5ieXRlcyA9IHR5cGUgPT09IFwiYnl0ZXNcIjtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHR5cGUgaWYgbm90IGEgYmFzaWMgdHlwZS5cbiAgICAgKiBAdHlwZSB7VHlwZXxFbnVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZFR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2lzdGVyLWZpZWxkIHdpdGhpbiB0aGUgZXh0ZW5kZWQgdHlwZSBpZiBhIGRlY2xhcmluZyBleHRlbnNpb24gZmllbGQuXG4gICAgICogQHR5cGUge0ZpZWxkfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnNpb25GaWVsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaXN0ZXItZmllbGQgd2l0aGluIHRoZSBkZWNsYXJpbmcgbmFtZXNwYWNlIGlmIGFuIGV4dGVuZGVkIGZpZWxkLlxuICAgICAqIEB0eXBlIHtGaWVsZHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbGFyaW5nRmllbGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSByZW1lbWJlcnMgd2hldGhlciB0aGlzIGZpZWxkIGlzIHBhY2tlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFja2VkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgZmllbGQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgZmllbGQgaXMgcGFja2VkLiBPbmx5IHJlbGV2YW50IHdoZW4gcmVwZWF0ZWQgYW5kIHdvcmtpbmcgd2l0aCBwcm90bzIuXG4gKiBAbmFtZSBGaWVsZCNwYWNrZWRcbiAqIEB0eXBlIHtib29sZWFufVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaWVsZC5wcm90b3R5cGUsIFwicGFja2VkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZSBpZiBub3QgZXhwbGljaXR5IHNldCB0byBmYWxzZVxuICAgICAgICBpZiAodGhpcy5fcGFja2VkID09PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcGFja2VkID0gdGhpcy5nZXRPcHRpb24oXCJwYWNrZWRcIikgIT09IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFja2VkO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5GaWVsZC5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gc2V0T3B0aW9uKG5hbWUsIHZhbHVlLCBpZk5vdFNldCkge1xuICAgIGlmIChuYW1lID09PSBcInBhY2tlZFwiKSAvLyBjbGVhciBjYWNoZWQgYmVmb3JlIHNldHRpbmdcbiAgICAgICAgdGhpcy5fcGFja2VkID0gbnVsbDtcbiAgICByZXR1cm4gUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9uLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIGlmTm90U2V0KTtcbn07XG5cbi8qKlxuICogRmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUZpZWxkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBGaWVsZCB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWQgRmllbGQgaWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBGaWVsZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBFeHRlbnNpb24gZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUV4dGVuc2lvbkZpZWxkXG4gKiBAZXh0ZW5kcyBJRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHRlbmQgRXh0ZW5kZWQgdHlwZVxuICovXG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBmaWVsZCB0byBhIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJRmllbGR9IEZpZWxkIGRlc2NyaXB0b3JcbiAqL1xuRmllbGQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJydWxlXCIgICAgLCB0aGlzLnJ1bGUgIT09IFwib3B0aW9uYWxcIiAmJiB0aGlzLnJ1bGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcInR5cGVcIiAgICAsIHRoaXMudHlwZSxcbiAgICAgICAgXCJpZFwiICAgICAgLCB0aGlzLmlkLFxuICAgICAgICBcImV4dGVuZFwiICAsIHRoaXMuZXh0ZW5kLFxuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBmaWVsZCdzIHR5cGUgcmVmZXJlbmNlcy5cbiAqIEByZXR1cm5zIHtGaWVsZH0gYHRoaXNgXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IHJlZmVyZW5jZSBjYW5ub3QgYmUgcmVzb2x2ZWRcbiAqL1xuRmllbGQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuXG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCh0aGlzLnR5cGVEZWZhdWx0ID0gdHlwZXMuZGVmYXVsdHNbdGhpcy50eXBlXSkgPT09IHVuZGVmaW5lZCkgeyAvLyBpZiBub3QgYSBiYXNpYyB0eXBlLCByZXNvbHZlIGl0XG4gICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlID0gKHRoaXMuZGVjbGFyaW5nRmllbGQgPyB0aGlzLmRlY2xhcmluZ0ZpZWxkLnBhcmVudCA6IHRoaXMucGFyZW50KS5sb29rdXBUeXBlT3JFbnVtKHRoaXMudHlwZSk7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcbiAgICAgICAgZWxzZSAvLyBpbnN0YW5jZW9mIEVudW1cbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbT2JqZWN0LmtleXModGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzKVswXV07IC8vIGZpcnN0IGRlZmluZWRcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucHJvdG8zX29wdGlvbmFsKSB7XG4gICAgICAgIC8vIHByb3RvMyBzY2FsYXIgdmFsdWUgbWFya2VkIG9wdGlvbmFsOyBzaG91bGQgZGVmYXVsdCB0byBudWxsXG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHVzZSBleHBsaWNpdGx5IHNldCBkZWZhdWx0IHZhbHVlIGlmIHByZXNlbnRcbiAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5vcHRpb25zW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSAmJiB0eXBlb2YgdGhpcy50eXBlRGVmYXVsdCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbdGhpcy50eXBlRGVmYXVsdF07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IG9wdGlvbnNcbiAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFja2VkID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5wYWNrZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJlc29sdmVkVHlwZSAmJiAhKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnBhY2tlZDtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIGludGVybmFsIGRhdGEgdHlwZSBpZiBuZWNlc3NzYXJ5XG4gICAgaWYgKHRoaXMubG9uZykge1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdXRpbC5Mb25nLmZyb21OdW1iZXIodGhpcy50eXBlRGVmYXVsdCwgdGhpcy50eXBlLmNoYXJBdCgwKSA9PT0gXCJ1XCIpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChPYmplY3QuZnJlZXplKVxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLnR5cGVEZWZhdWx0KTsgLy8gbG9uZyBpbnN0YW5jZXMgYXJlIG1lYW50IHRvIGJlIGltbXV0YWJsZSBhbnl3YXkgKGkuZS4gdXNlIHNtYWxsIGludCBjYWNoZSB0aGF0IGV2ZW4gcmVxdWlyZXMgaXQpXG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXMgJiYgdHlwZW9mIHRoaXMudHlwZURlZmF1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgaWYgKHV0aWwuYmFzZTY0LnRlc3QodGhpcy50eXBlRGVmYXVsdCkpXG4gICAgICAgICAgICB1dGlsLmJhc2U2NC5kZWNvZGUodGhpcy50eXBlRGVmYXVsdCwgYnVmID0gdXRpbC5uZXdCdWZmZXIodXRpbC5iYXNlNjQubGVuZ3RoKHRoaXMudHlwZURlZmF1bHQpKSwgMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHV0aWwudXRmOC53cml0ZSh0aGlzLnR5cGVEZWZhdWx0LCBidWYgPSB1dGlsLm5ld0J1ZmZlcih1dGlsLnV0ZjgubGVuZ3RoKHRoaXMudHlwZURlZmF1bHQpKSwgMCk7XG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSBidWY7XG4gICAgfVxuXG4gICAgLy8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgbWFwcyBhbmQgcmVwZWF0ZWQgZmllbGRzXG4gICAgaWYgKHRoaXMubWFwKVxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHV0aWwuZW1wdHlPYmplY3Q7XG4gICAgZWxzZSBpZiAodGhpcy5yZXBlYXRlZClcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB1dGlsLmVtcHR5QXJyYXk7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMudHlwZURlZmF1bHQ7XG5cbiAgICAvLyBlbnN1cmUgcHJvcGVyIHZhbHVlIG9uIHByb3RvdHlwZVxuICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgIHRoaXMucGFyZW50LmN0b3IucHJvdG90eXBlW3RoaXMubmFtZV0gPSB0aGlzLmRlZmF1bHRWYWx1ZTtcblxuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiBhcyByZXR1cm5lZCBieSB7QGxpbmsgRmllbGQuZH0gYW5kIHtAbGluayBNYXBGaWVsZC5kfSAoVHlwZVNjcmlwdCkuXG4gKiBAdHlwZWRlZiBGaWVsZERlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgcHJvdG90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBGaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtcImRvdWJsZVwifFwiZmxvYXRcInxcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcInN0cmluZ1wifFwiYm9vbFwifFwiYnl0ZXNcInxPYmplY3R9IGZpZWxkVHlwZSBGaWVsZCB0eXBlXG4gKiBAcGFyYW0ge1wib3B0aW9uYWxcInxcInJlcXVpcmVkXCJ8XCJyZXBlYXRlZFwifSBbZmllbGRSdWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHBhcmFtIHtUfSBbZGVmYXVsdFZhbHVlXSBEZWZhdWx0IHZhbHVlXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBudW1iZXIgfCBudW1iZXJbXSB8IExvbmcgfCBMb25nW10gfCBzdHJpbmcgfCBzdHJpbmdbXSB8IGJvb2xlYW4gfCBib29sZWFuW10gfCBVaW50OEFycmF5IHwgVWludDhBcnJheVtdIHwgQnVmZmVyIHwgQnVmZmVyW11cbiAqL1xuRmllbGQuZCA9IGZ1bmN0aW9uIGRlY29yYXRlRmllbGQoZmllbGRJZCwgZmllbGRUeXBlLCBmaWVsZFJ1bGUsIGRlZmF1bHRWYWx1ZSkge1xuXG4gICAgLy8gc3VibWVzc2FnZTogZGVjb3JhdGUgdGhlIHN1Ym1lc3NhZ2UgYW5kIHVzZSBpdHMgbmFtZSBhcyB0aGUgdHlwZVxuICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZpZWxkVHlwZSA9IHV0aWwuZGVjb3JhdGVUeXBlKGZpZWxkVHlwZSkubmFtZTtcblxuICAgIC8vIGVudW0gcmVmZXJlbmNlOiBjcmVhdGUgYSByZWZsZWN0ZWQgY29weSBvZiB0aGUgZW51bSBhbmQga2VlcCByZXVzZWluZyBpdFxuICAgIGVsc2UgaWYgKGZpZWxkVHlwZSAmJiB0eXBlb2YgZmllbGRUeXBlID09PSBcIm9iamVjdFwiKVxuICAgICAgICBmaWVsZFR5cGUgPSB1dGlsLmRlY29yYXRlRW51bShmaWVsZFR5cGUpLm5hbWU7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZmllbGREZWNvcmF0b3IocHJvdG90eXBlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUocHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmFkZChuZXcgRmllbGQoZmllbGROYW1lLCBmaWVsZElkLCBmaWVsZFR5cGUsIGZpZWxkUnVsZSwgeyBcImRlZmF1bHRcIjogZGVmYXVsdFZhbHVlIH0pKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBGaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPnxzdHJpbmd9IGZpZWxkVHlwZSBGaWVsZCB0eXBlXG4gKiBAcGFyYW0ge1wib3B0aW9uYWxcInxcInJlcXVpcmVkXCJ8XCJyZXBlYXRlZFwifSBbZmllbGRSdWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGxpa2UgRmllbGQuZCBidXQgd2l0aG91dCBhIGRlZmF1bHQgdmFsdWVcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5GaWVsZC5fY29uZmlndXJlID0gZnVuY3Rpb24gY29uZmlndXJlKFR5cGVfKSB7XG4gICAgVHlwZSA9IFR5cGVfO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gT25lT2Y7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKE9uZU9mLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE9uZU9mKS5jbGFzc05hbWUgPSBcIk9uZU9mXCI7XG5cbnZhciBGaWVsZCA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIHV0aWwgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG9uZW9mIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgb25lb2YuXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZW9mIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nW118T2JqZWN0LjxzdHJpbmcsKj59IFtmaWVsZE5hbWVzXSBGaWVsZCBuYW1lc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxuICovXG5mdW5jdGlvbiBPbmVPZihuYW1lLCBmaWVsZE5hbWVzLCBvcHRpb25zLCBjb21tZW50KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpZWxkTmFtZXMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBmaWVsZE5hbWVzO1xuICAgICAgICBmaWVsZE5hbWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZE5hbWVzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImZpZWxkTmFtZXMgbXVzdCBiZSBhbiBBcnJheVwiKTtcblxuICAgIC8qKlxuICAgICAqIEZpZWxkIG5hbWVzIHRoYXQgYmVsb25nIHRvIHRoaXMgb25lb2YuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMub25lb2YgPSBmaWVsZE5hbWVzIHx8IFtdOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogRmllbGRzIHRoYXQgYmVsb25nIHRvIHRoaXMgb25lb2YgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkc0FycmF5ID0gW107IC8vIGRlY2xhcmVkIHJlYWRvbmx5IGZvciBjb25mb3JtYW5jZSwgcG9zc2libHkgbm90IHlldCBhZGRlZCB0byBwYXJlbnRcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgZmllbGQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG59XG5cbi8qKlxuICogT25lb2YgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU9uZU9mXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBvbmVvZiBPbmVvZiBmaWVsZCBuYW1lc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE9uZW9mIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBvbmVvZiBmcm9tIGEgb25lb2YgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZW9mIG5hbWVcbiAqIEBwYXJhbSB7SU9uZU9mfSBqc29uIE9uZW9mIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtPbmVPZn0gQ3JlYXRlZCBvbmVvZlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuT25lT2YuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBPbmVPZihuYW1lLCBqc29uLm9uZW9mLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgb25lb2YgdG8gYSBvbmVvZiBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU9uZU9mfSBPbmVvZiBkZXNjcmlwdG9yXG4gKi9cbk9uZU9mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcIm9uZW9mXCIgICAsIHRoaXMub25lb2YsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIGZpZWxkcyBvZiB0aGUgc3BlY2lmaWVkIG9uZW9mIHRvIHRoZSBwYXJlbnQgaWYgbm90IGFscmVhZHkgZG9uZSBzby5cbiAqIEBwYXJhbSB7T25lT2Z9IG9uZW9mIFRoZSBvbmVvZlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBpbm5lclxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBhZGRGaWVsZHNUb1BhcmVudChvbmVvZikge1xuICAgIGlmIChvbmVvZi5wYXJlbnQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25lb2YuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoIW9uZW9mLmZpZWxkc0FycmF5W2ldLnBhcmVudClcbiAgICAgICAgICAgICAgICBvbmVvZi5wYXJlbnQuYWRkKG9uZW9mLmZpZWxkc0FycmF5W2ldKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgZmllbGQgdG8gdGhpcyBvbmVvZiBhbmQgcmVtb3ZlcyBpdCBmcm9tIGl0cyBjdXJyZW50IHBhcmVudCwgaWYgYW55LlxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgRmllbGQgdG8gYWRkXG4gKiBAcmV0dXJucyB7T25lT2Z9IGB0aGlzYFxuICovXG5PbmVPZi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGZpZWxkKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIEZpZWxkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xuXG4gICAgaWYgKGZpZWxkLnBhcmVudCAmJiBmaWVsZC5wYXJlbnQgIT09IHRoaXMucGFyZW50KVxuICAgICAgICBmaWVsZC5wYXJlbnQucmVtb3ZlKGZpZWxkKTtcbiAgICB0aGlzLm9uZW9mLnB1c2goZmllbGQubmFtZSk7XG4gICAgdGhpcy5maWVsZHNBcnJheS5wdXNoKGZpZWxkKTtcbiAgICBmaWVsZC5wYXJ0T2YgPSB0aGlzOyAvLyBmaWVsZC5wYXJlbnQgcmVtYWlucyBudWxsXG4gICAgYWRkRmllbGRzVG9QYXJlbnQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBmaWVsZCBmcm9tIHRoaXMgb25lb2YgYW5kIHB1dHMgaXQgYmFjayB0byB0aGUgb25lb2YncyBwYXJlbnQuXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBGaWVsZCB0byByZW1vdmVcbiAqIEByZXR1cm5zIHtPbmVPZn0gYHRoaXNgXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoZmllbGQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgRmllbGQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZCBtdXN0IGJlIGEgRmllbGRcIik7XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgdGhyb3cgRXJyb3IoZmllbGQgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgIHRoaXMuZmllbGRzQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpbmRleCA9IHRoaXMub25lb2YuaW5kZXhPZihmaWVsZC5uYW1lKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluZGV4ID4gLTEpIC8vIHRoZW9yZXRpY2FsXG4gICAgICAgIHRoaXMub25lb2Yuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGZpZWxkLnBhcnRPZiA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5PbmVPZi5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiBvbkFkZChwYXJlbnQpIHtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIENvbGxlY3QgcHJlc2VudCBmaWVsZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub25lb2YubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gcGFyZW50LmdldCh0aGlzLm9uZW9mW2ldKTtcbiAgICAgICAgaWYgKGZpZWxkICYmICFmaWVsZC5wYXJ0T2YpIHtcbiAgICAgICAgICAgIGZpZWxkLnBhcnRPZiA9IHNlbGY7XG4gICAgICAgICAgICBzZWxmLmZpZWxkc0FycmF5LnB1c2goZmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBub3QgeWV0IHByZXNlbnQgZmllbGRzXG4gICAgYWRkRmllbGRzVG9QYXJlbnQodGhpcyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5PbmVPZi5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiBvblJlbW92ZShwYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoKGZpZWxkID0gdGhpcy5maWVsZHNBcnJheVtpXSkucGFyZW50KVxuICAgICAgICAgICAgZmllbGQucGFyZW50LnJlbW92ZShmaWVsZCk7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBwYXJlbnQpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIE9uZU9mLmR9IChUeXBlU2NyaXB0KS5cbiAqIEB0eXBlZGVmIE9uZU9mRGVjb3JhdG9yXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBwcm90b3R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbmVvZk5hbWUgT25lT2YgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIE9uZU9mIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZEZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBzdHJpbmdcbiAqL1xuT25lT2YuZCA9IGZ1bmN0aW9uIGRlY29yYXRlT25lT2YoKSB7XG4gICAgdmFyIGZpZWxkTmFtZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXG4gICAgICAgIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICBmaWVsZE5hbWVzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25lT2ZEZWNvcmF0b3IocHJvdG90eXBlLCBvbmVvZk5hbWUpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUocHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmFkZChuZXcgT25lT2Yob25lb2ZOYW1lLCBmaWVsZE5hbWVzKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG9uZW9mTmFtZSwge1xuICAgICAgICAgICAgZ2V0OiB1dGlsLm9uZU9mR2V0dGVyKGZpZWxkTmFtZXMpLFxuICAgICAgICAgICAgc2V0OiB1dGlsLm9uZU9mU2V0dGVyKGZpZWxkTmFtZXMpXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBOYW1lc3BhY2U7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKE5hbWVzcGFjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBOYW1lc3BhY2UpLmNsYXNzTmFtZSA9IFwiTmFtZXNwYWNlXCI7XG5cbnZhciBGaWVsZCAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIHV0aWwgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBPbmVPZiAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xuXG52YXIgVHlwZSwgICAgLy8gY3ljbGljXG4gICAgU2VydmljZSxcbiAgICBFbnVtO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbmFtZXNwYWNlIGluc3RhbmNlLlxuICogQG5hbWUgTmFtZXNwYWNlXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBuYW1lc3BhY2UuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5hbWVzcGFjZSBmcm9tIEpTT04uXG4gKiBAbWVtYmVyb2YgTmFtZXNwYWNlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIEpTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBDcmVhdGVkIG5hbWVzcGFjZVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTmFtZXNwYWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTmFtZXNwYWNlKG5hbWUsIGpzb24ub3B0aW9ucykuYWRkSlNPTihqc29uLm5lc3RlZCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHJlZmxlY3Rpb24gb2JqZWN0cyB0byBKU09OLlxuICogQG1lbWJlcm9mIE5hbWVzcGFjZVxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0W119IGFycmF5IE9iamVjdCBhcnJheVxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj58dW5kZWZpbmVkfSBKU09OIG9iamVjdCBvciBgdW5kZWZpbmVkYCB3aGVuIGFycmF5IGlzIGVtcHR5XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9KU09OKGFycmF5LCB0b0pTT05PcHRpb25zKSB7XG4gICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgb2JqW2FycmF5W2ldLm5hbWVdID0gYXJyYXlbaV0udG9KU09OKHRvSlNPTk9wdGlvbnMpO1xuICAgIHJldHVybiBvYmo7XG59XG5cbk5hbWVzcGFjZS5hcnJheVRvSlNPTiA9IGFycmF5VG9KU09OO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fHVuZGVmaW5lZH0gcmVzZXJ2ZWQgQXJyYXkgb2YgcmVzZXJ2ZWQgcmFuZ2VzIGFuZCBuYW1lc1xuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbk5hbWVzcGFjZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQocmVzZXJ2ZWQsIGlkKSB7XG4gICAgaWYgKHJlc2VydmVkKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNlcnZlZFtpXSAhPT0gXCJzdHJpbmdcIiAmJiByZXNlcnZlZFtpXVswXSA8PSBpZCAmJiByZXNlcnZlZFtpXVsxXSA+IGlkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyW118c3RyaW5nPnx1bmRlZmluZWR9IHJlc2VydmVkIEFycmF5IG9mIHJlc2VydmVkIHJhbmdlcyBhbmQgbmFtZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUocmVzZXJ2ZWQsIG5hbWUpIHtcbiAgICBpZiAocmVzZXJ2ZWQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzZXJ2ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRbaV0gPT09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGNvbnN0cnVjdG9yLiBVc2Uge0BsaW5rIE5hbWVzcGFjZX0gaW5zdGVhZC5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGlvbiBvYmplY3RzIGNvbnRhaW5pbmcgbmVzdGVkIG9iamVjdHMuIFRoaXMgaXMgbm90IGFuIGFjdHVhbCBjbGFzcyBidXQgaGVyZSBmb3IgdGhlIHNha2Ugb2YgaGF2aW5nIGNvbnNpc3RlbnQgdHlwZSBkZWZpbml0aW9ucy5cbiAqIEBleHBvcnRzIE5hbWVzcGFjZUJhc2VcbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBhYnN0cmFjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIE5hbWVzcGFjZX1cbiAqL1xuZnVuY3Rpb24gTmFtZXNwYWNlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBOZXN0ZWQgb2JqZWN0cyBieSBuYW1lLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSZWZsZWN0aW9uT2JqZWN0Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXN0ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG5lc3RlZCBvYmplY3RzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0W118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX25lc3RlZEFycmF5ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xlYXJDYWNoZShuYW1lc3BhY2UpIHtcbiAgICBuYW1lc3BhY2UuX25lc3RlZEFycmF5ID0gbnVsbDtcbiAgICByZXR1cm4gbmFtZXNwYWNlO1xufVxuXG4vKipcbiAqIE5lc3RlZCBvYmplY3RzIG9mIHRoaXMgbmFtZXNwYWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gKiBAbmFtZSBOYW1lc3BhY2VCYXNlI25lc3RlZEFycmF5XG4gKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdFtdfVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOYW1lc3BhY2UucHJvdG90eXBlLCBcIm5lc3RlZEFycmF5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmVzdGVkQXJyYXkgfHwgKHRoaXMuX25lc3RlZEFycmF5ID0gdXRpbC50b0FycmF5KHRoaXMubmVzdGVkKSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogTmFtZXNwYWNlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBOYW1lc3BhY2Ugb3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxBbnlOZXN0ZWRPYmplY3Q+fSBbbmVzdGVkXSBOZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzXG4gKi9cblxuLyoqXG4gKiBBbnkgZXh0ZW5zaW9uIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAdHlwZWRlZiBBbnlFeHRlbnNpb25GaWVsZFxuICogQHR5cGUge0lFeHRlbnNpb25GaWVsZHxJRXh0ZW5zaW9uTWFwRmllbGR9XG4gKi9cblxuLyoqXG4gKiBBbnkgbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9yLlxuICogQHR5cGVkZWYgQW55TmVzdGVkT2JqZWN0XG4gKiBAdHlwZSB7SUVudW18SVR5cGV8SVNlcnZpY2V8QW55RXh0ZW5zaW9uRmllbGR8SU5hbWVzcGFjZX1cbiAqL1xuLy8gXiBCRVdBUkU6IFZTQ29kZSBoYW5ncyBmb3JldmVyIHdoZW4gdXNpbmcgbW9yZSB0aGFuIDUgdHlwZXMgKHRoYXQncyB3aHkgQW55RXh0ZW5zaW9uRmllbGQgZXhpc3RzIGluIHRoZSBmaXJzdCBwbGFjZSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG5hbWVzcGFjZSB0byBhIG5hbWVzcGFjZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU5hbWVzcGFjZX0gTmFtZXNwYWNlIGRlc2NyaXB0b3JcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwibmVzdGVkXCIgICwgYXJyYXlUb0pTT04odGhpcy5uZXN0ZWRBcnJheSwgdG9KU09OT3B0aW9ucylcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQWRkcyBuZXN0ZWQgb2JqZWN0cyB0byB0aGlzIG5hbWVzcGFjZSBmcm9tIG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLEFueU5lc3RlZE9iamVjdD59IG5lc3RlZEpzb24gQW55IG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnNcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZEpTT04gPSBmdW5jdGlvbiBhZGRKU09OKG5lc3RlZEpzb24pIHtcbiAgICB2YXIgbnMgPSB0aGlzO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKG5lc3RlZEpzb24pIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhuZXN0ZWRKc29uKSwgaSA9IDAsIG5lc3RlZDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRKc29uW25hbWVzW2ldXTtcbiAgICAgICAgICAgIG5zLmFkZCggLy8gbW9zdCB0byBsZWFzdCBsaWtlbHlcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5maWVsZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gVHlwZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLnZhbHVlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBFbnVtLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQubWV0aG9kcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTZXJ2aWNlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IE5hbWVzcGFjZS5mcm9tSlNPTiApKG5hbWVzW2ldLCBuZXN0ZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuZXN0ZWQgb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5lc3RlZCBvYmplY3QgbmFtZVxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gVGhlIHJlZmxlY3Rpb24gb2JqZWN0IG9yIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV1cbiAgICAgICAgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBuZXN0ZWQge0BsaW5rIEVudW18ZW51bX0gb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICogVGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2dldHxnZXR9IGluIHRoYXQgaXQgcmV0dXJucyBhbiBlbnVtJ3MgdmFsdWVzIGRpcmVjdGx5IGFuZCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmVzdGVkIGVudW0gbmFtZVxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLG51bWJlcj59IEVudW0gdmFsdWVzXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBlbnVtXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0RW51bSA9IGZ1bmN0aW9uIGdldEVudW0obmFtZSkge1xuICAgIGlmICh0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXSBpbnN0YW5jZW9mIEVudW0pXG4gICAgICAgIHJldHVybiB0aGlzLm5lc3RlZFtuYW1lXS52YWx1ZXM7XG4gICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIGVudW06IFwiICsgbmFtZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byBhZGRcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbmVzdGVkIG9iamVjdCB3aXRoIHRoaXMgbmFtZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcblxuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUeXBlICB8fCBvYmplY3QgaW5zdGFuY2VvZiBPbmVPZiB8fCBvYmplY3QgaW5zdGFuY2VvZiBFbnVtIHx8IG9iamVjdCBpbnN0YW5jZW9mIFNlcnZpY2UgfHwgb2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib2JqZWN0IG11c3QgYmUgYSB2YWxpZCBuZXN0ZWQgb2JqZWN0XCIpO1xuXG4gICAgaWYgKCF0aGlzLm5lc3RlZClcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLmdldChvYmplY3QubmFtZSk7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAocHJldiBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiBvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgIShwcmV2IGluc3RhbmNlb2YgVHlwZSB8fCBwcmV2IGluc3RhbmNlb2YgU2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHBsYWluIG5hbWVzcGFjZSBidXQga2VlcCBleGlzdGluZyBuZXN0ZWQgZWxlbWVudHMgYW5kIG9wdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgbmVzdGVkID0gcHJldi5uZXN0ZWRBcnJheTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lc3RlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmFkZChuZXN0ZWRbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHByZXYpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkID0ge307XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNldE9wdGlvbnMocHJldi5vcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXSA9IG9iamVjdDtcbiAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhpcyBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIG5hbWVzcGFjZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcblxuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIFJlZmxlY3Rpb25PYmplY3QpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvYmplY3QgbXVzdCBiZSBhIFJlZmxlY3Rpb25PYmplY3RcIik7XG4gICAgaWYgKG9iamVjdC5wYXJlbnQgIT09IHRoaXMpXG4gICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgZGVsZXRlIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMubmVzdGVkKS5sZW5ndGgpXG4gICAgICAgIHRoaXMubmVzdGVkID0gdW5kZWZpbmVkO1xuXG4gICAgb2JqZWN0Lm9uUmVtb3ZlKHRoaXMpO1xuICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGFkZGl0aWFsIG5hbWVzcGFjZXMgd2l0aGluIHRoaXMgb25lIGlmIG5vdCB5ZXQgZXhpc3RpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGNyZWF0ZVxuICogQHBhcmFtIHsqfSBbanNvbl0gTmVzdGVkIHR5cGVzIHRvIGNyZWF0ZSBmcm9tIEpTT05cbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IFBvaW50ZXIgdG8gdGhlIGxhc3QgbmFtZXNwYWNlIGNyZWF0ZWQgb3IgYHRoaXNgIGlmIHBhdGggaXMgZW1wdHlcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUocGF0aCwganNvbikge1xuXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkpXG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWxsZWdhbCBwYXRoXCIpO1xuICAgIGlmIChwYXRoICYmIHBhdGgubGVuZ3RoICYmIHBhdGhbMF0gPT09IFwiXCIpXG4gICAgICAgIHRocm93IEVycm9yKFwicGF0aCBtdXN0IGJlIHJlbGF0aXZlXCIpO1xuXG4gICAgdmFyIHB0ciA9IHRoaXM7XG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgaWYgKHB0ci5uZXN0ZWQgJiYgcHRyLm5lc3RlZFtwYXJ0XSkge1xuICAgICAgICAgICAgcHRyID0gcHRyLm5lc3RlZFtwYXJ0XTtcbiAgICAgICAgICAgIGlmICghKHB0ciBpbnN0YW5jZW9mIE5hbWVzcGFjZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXRoIGNvbmZsaWN0cyB3aXRoIG5vbi1uYW1lc3BhY2Ugb2JqZWN0c1wiKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBwdHIuYWRkKHB0ciA9IG5ldyBOYW1lc3BhY2UocGFydCkpO1xuICAgIH1cbiAgICBpZiAoanNvbilcbiAgICAgICAgcHRyLmFkZEpTT04oanNvbik7XG4gICAgcmV0dXJuIHB0cjtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBuYW1lc3BhY2UncyBhbmQgYWxsIGl0cyBuZXN0ZWQgb2JqZWN0cycgdHlwZSByZWZlcmVuY2VzLiBVc2VmdWwgdG8gdmFsaWRhdGUgYSByZWZsZWN0aW9uIHRyZWUsIGJ1dCBjb21lcyBhdCBhIGNvc3QuXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgbmVzdGVkID0gdGhpcy5uZXN0ZWRBcnJheSwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBuZXN0ZWQubGVuZ3RoKVxuICAgICAgICBpZiAobmVzdGVkW2ldIGluc3RhbmNlb2YgTmFtZXNwYWNlKVxuICAgICAgICAgICAgbmVzdGVkW2krK10ucmVzb2x2ZUFsbCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXN0ZWRbaSsrXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZSgpO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBsb29rcyB1cCB0aGUgcmVmbGVjdGlvbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBwYXRoIGluIHRoZSBzY29wZSBvZiB0aGlzIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHBhcmFtIHsqfEFycmF5LjwqPn0gZmlsdGVyVHlwZXMgRmlsdGVyIHR5cGVzLCBhbnkgY29tYmluYXRpb24gb2YgdGhlIGNvbnN0cnVjdG9ycyBvZiBgcHJvdG9idWYuVHlwZWAsIGBwcm90b2J1Zi5FbnVtYCwgYHByb3RvYnVmLlNlcnZpY2VgIGV0Yy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudEFscmVhZHlDaGVja2VkPWZhbHNlXSBJZiBrbm93biwgd2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcywgcGFyZW50QWxyZWFkeUNoZWNrZWQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJUeXBlcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcGFyZW50QWxyZWFkeUNoZWNrZWQgPSBmaWx0ZXJUeXBlcztcbiAgICAgICAgZmlsdGVyVHlwZXMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJUeXBlcyAmJiAhQXJyYXkuaXNBcnJheShmaWx0ZXJUeXBlcykpXG4gICAgICAgIGZpbHRlclR5cGVzID0gWyBmaWx0ZXJUeXBlcyBdO1xuXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkgJiYgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IFwiLlwiKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIC8vIFN0YXJ0IGF0IHJvb3QgaWYgcGF0aCBpcyBhYnNvbHV0ZVxuICAgIGlmIChwYXRoWzBdID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmxvb2t1cChwYXRoLnNsaWNlKDEpLCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCBwYXJ0IG1hdGNoZXMgYW55IG5lc3RlZCBvYmplY3QsIGFuZCBpZiBzbywgdHJhdmVyc2UgaWYgcGF0aCBjb250YWlucyBtb3JlXG4gICAgdmFyIGZvdW5kID0gdGhpcy5nZXQocGF0aFswXSk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJUeXBlcyB8fCBmaWx0ZXJUeXBlcy5pbmRleE9mKGZvdW5kLmNvbnN0cnVjdG9yKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAoZm91bmQgPSBmb3VuZC5sb29rdXAocGF0aC5zbGljZSgxKSwgZmlsdGVyVHlwZXMsIHRydWUpKSlcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcblxuICAgIC8vIE90aGVyd2lzZSB0cnkgZWFjaCBuZXN0ZWQgbmFtZXNwYWNlXG4gICAgfSBlbHNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXN0ZWRBcnJheVtpXSBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAoZm91bmQgPSB0aGlzLl9uZXN0ZWRBcnJheVtpXS5sb29rdXAocGF0aCwgZmlsdGVyVHlwZXMsIHRydWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG5cbiAgICAvLyBJZiB0aGVyZSBoYXNuJ3QgYmVlbiBhIG1hdGNoLCB0cnkgYWdhaW4gYXQgdGhlIHBhcmVudFxuICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnRBbHJlYWR5Q2hlY2tlZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Lmxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcyk7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSByZWZsZWN0aW9uIG9iamVjdCBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQG5hbWUgTmFtZXNwYWNlQmFzZSNsb29rdXBcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJlbnRBbHJlYWR5Q2hlY2tlZD1mYWxzZV0gV2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGxvb2t1cChwYXRoOiBzdHJpbmcsIFtwYXJlbnRBbHJlYWR5Q2hlY2tlZDogYm9vbGVhbl0pXG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHtAbGluayBUeXBlfHR5cGV9IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtUeXBlfSBMb29rZWQgdXAgdHlwZVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGVcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBUeXBlID0gZnVuY3Rpb24gbG9va3VwVHlwZShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBUeXBlIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCB0eXBlOiBcIiArIHBhdGgpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHZhbHVlcyBvZiB0aGUge0BsaW5rIEVudW18ZW51bX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge0VudW19IExvb2tlZCB1cCBlbnVtXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGFuIGVudW1cbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBFbnVtID0gZnVuY3Rpb24gbG9va3VwRW51bShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBFbnVtIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBFbnVtICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgVHlwZXx0eXBlfSBvciB7QGxpbmsgRW51bXxlbnVtfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7VHlwZX0gTG9va2VkIHVwIHR5cGUgb3IgZW51bVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGUgb3IgZW51bVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFR5cGVPckVudW0gPSBmdW5jdGlvbiBsb29rdXBUeXBlT3JFbnVtKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFR5cGUsIEVudW0gXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFR5cGUgb3IgRW51bSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUge0BsaW5rIFNlcnZpY2V8c2VydmljZX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge1NlcnZpY2V9IExvb2tlZCB1cCBzZXJ2aWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgc2VydmljZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFNlcnZpY2UgPSBmdW5jdGlvbiBsb29rdXBTZXJ2aWNlKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFNlcnZpY2UgXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFNlcnZpY2UgJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuTmFtZXNwYWNlLl9jb25maWd1cmUgPSBmdW5jdGlvbihUeXBlXywgU2VydmljZV8sIEVudW1fKSB7XG4gICAgVHlwZSAgICA9IFR5cGVfO1xuICAgIFNlcnZpY2UgPSBTZXJ2aWNlXztcbiAgICBFbnVtICAgID0gRW51bV87XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBNYXBGaWVsZDtcblxuLy8gZXh0ZW5kcyBGaWVsZFxudmFyIEZpZWxkID0gcmVxdWlyZShcIi4vZmllbGRcIik7XG4oKE1hcEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmllbGQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBNYXBGaWVsZCkuY2xhc3NOYW1lID0gXCJNYXBGaWVsZFwiO1xuXG52YXIgdHlwZXMgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWFwIGZpZWxkIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWFwIGZpZWxkLlxuICogQGV4dGVuZHMgRmllbGRCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5VHlwZSBLZXkgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxuICovXG5mdW5jdGlvbiBNYXBGaWVsZChuYW1lLCBpZCwga2V5VHlwZSwgdHlwZSwgb3B0aW9ucywgY29tbWVudCkge1xuICAgIEZpZWxkLmNhbGwodGhpcywgbmFtZSwgaWQsIHR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLCBjb21tZW50KTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhrZXlUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwia2V5VHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogS2V5IHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleVR5cGUgPSBrZXlUeXBlOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQga2V5IHR5cGUgaWYgbm90IGEgYmFzaWMgdHlwZS5cbiAgICAgKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRLZXlUeXBlID0gbnVsbDtcblxuICAgIC8vIE92ZXJyaWRlcyBGaWVsZCNtYXBcbiAgICB0aGlzLm1hcCA9IHRydWU7XG59XG5cbi8qKlxuICogTWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElNYXBGaWVsZFxuICogQGV4dGVuZHMge0lGaWVsZH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlUeXBlIEtleSB0eXBlXG4gKi9cblxuLyoqXG4gKiBFeHRlbnNpb24gbWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElFeHRlbnNpb25NYXBGaWVsZFxuICogQGV4dGVuZHMgSU1hcEZpZWxkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXh0ZW5kIEV4dGVuZGVkIHR5cGVcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBtYXAgZmllbGQgZnJvbSBhIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICogQHBhcmFtIHtJTWFwRmllbGR9IGpzb24gTWFwIGZpZWxkIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtNYXBGaWVsZH0gQ3JlYXRlZCBtYXAgZmllbGRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk1hcEZpZWxkLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTWFwRmllbGQobmFtZSwganNvbi5pZCwganNvbi5rZXlUeXBlLCBqc29uLnR5cGUsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtYXAgZmllbGQgdG8gYSBtYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lNYXBGaWVsZH0gTWFwIGZpZWxkIGRlc2NyaXB0b3JcbiAqL1xuTWFwRmllbGQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJrZXlUeXBlXCIgLCB0aGlzLmtleVR5cGUsXG4gICAgICAgIFwidHlwZVwiICAgICwgdGhpcy50eXBlLFxuICAgICAgICBcImlkXCIgICAgICAsIHRoaXMuaWQsXG4gICAgICAgIFwiZXh0ZW5kXCIgICwgdGhpcy5leHRlbmQsXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWFwRmllbGQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIC8vIEJlc2lkZXMgYSB2YWx1ZSB0eXBlLCBtYXAgZmllbGRzIGhhdmUgYSBrZXkgdHlwZSB0aGF0IG1heSBiZSBcImFueSBzY2FsYXIgdHlwZSBleGNlcHQgZm9yIGZsb2F0aW5nIHBvaW50IHR5cGVzIGFuZCBieXRlc1wiXG4gICAgaWYgKHR5cGVzLm1hcEtleVt0aGlzLmtleVR5cGVdID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCBrZXkgdHlwZTogXCIgKyB0aGlzLmtleVR5cGUpO1xuXG4gICAgcmV0dXJuIEZpZWxkLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIE1hcCBmaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgTWFwRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcImJvb2xcInxcInN0cmluZ1wifSBmaWVsZEtleVR5cGUgRmllbGQga2V5IHR5cGVcbiAqIEBwYXJhbSB7XCJkb3VibGVcInxcImZsb2F0XCJ8XCJpbnQzMlwifFwidWludDMyXCJ8XCJzaW50MzJcInxcImZpeGVkMzJcInxcInNmaXhlZDMyXCJ8XCJpbnQ2NFwifFwidWludDY0XCJ8XCJzaW50NjRcInxcImZpeGVkNjRcInxcInNmaXhlZDY0XCJ8XCJib29sXCJ8XCJzdHJpbmdcInxcImJ5dGVzXCJ8T2JqZWN0fENvbnN0cnVjdG9yPHt9Pn0gZmllbGRWYWx1ZVR5cGUgRmllbGQgdmFsdWUgdHlwZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCBMb25nIHwgc3RyaW5nIHwgYm9vbGVhbiB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudW1iZXJbXSB8IE1lc3NhZ2U8e30+IH1cbiAqL1xuTWFwRmllbGQuZCA9IGZ1bmN0aW9uIGRlY29yYXRlTWFwRmllbGQoZmllbGRJZCwgZmllbGRLZXlUeXBlLCBmaWVsZFZhbHVlVHlwZSkge1xuXG4gICAgLy8gc3VibWVzc2FnZSB2YWx1ZTogZGVjb3JhdGUgdGhlIHN1Ym1lc3NhZ2UgYW5kIHVzZSBpdHMgbmFtZSBhcyB0aGUgdHlwZVxuICAgIGlmICh0eXBlb2YgZmllbGRWYWx1ZVR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZmllbGRWYWx1ZVR5cGUgPSB1dGlsLmRlY29yYXRlVHlwZShmaWVsZFZhbHVlVHlwZSkubmFtZTtcblxuICAgIC8vIGVudW0gcmVmZXJlbmNlIHZhbHVlOiBjcmVhdGUgYSByZWZsZWN0ZWQgY29weSBvZiB0aGUgZW51bSBhbmQga2VlcCByZXVzZWluZyBpdFxuICAgIGVsc2UgaWYgKGZpZWxkVmFsdWVUeXBlICYmIHR5cGVvZiBmaWVsZFZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgZmllbGRWYWx1ZVR5cGUgPSB1dGlsLmRlY29yYXRlRW51bShmaWVsZFZhbHVlVHlwZSkubmFtZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXBGaWVsZERlY29yYXRvcihwcm90b3R5cGUsIGZpZWxkTmFtZSkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZShwcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAuYWRkKG5ldyBNYXBGaWVsZChmaWVsZE5hbWUsIGZpZWxkSWQsIGZpZWxkS2V5VHlwZSwgZmllbGRWYWx1ZVR5cGUpKTtcbiAgICB9O1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTWV0aG9kKS5jbGFzc05hbWUgPSBcIk1ldGhvZFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBzZXJ2aWNlIG1ldGhvZCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIHNlcnZpY2UgbWV0aG9kLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB0eXBlIE1ldGhvZCB0eXBlLCB1c3VhbGx5IGBcInJwY1wiYFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgbWVzc2FnZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlIFJlc3BvbnNlIG1lc3NhZ2UgdHlwZVxuICogQHBhcmFtIHtib29sZWFufE9iamVjdC48c3RyaW5nLCo+fSBbcmVxdWVzdFN0cmVhbV0gV2hldGhlciB0aGUgcmVxdWVzdCBpcyBzdHJlYW1lZFxuICogQHBhcmFtIHtib29sZWFufE9iamVjdC48c3RyaW5nLCo+fSBbcmVzcG9uc2VTdHJlYW1dIFdoZXRoZXIgdGhlIHJlc3BvbnNlIGlzIHN0cmVhbWVkXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBUaGUgY29tbWVudCBmb3IgdGhpcyBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zLCBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gTWV0aG9kKG5hbWUsIHR5cGUsIHJlcXVlc3RUeXBlLCByZXNwb25zZVR5cGUsIHJlcXVlc3RTdHJlYW0sIHJlc3BvbnNlU3RyZWFtLCBvcHRpb25zLCBjb21tZW50LCBwYXJzZWRPcHRpb25zKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh1dGlsLmlzT2JqZWN0KHJlcXVlc3RTdHJlYW0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXF1ZXN0U3RyZWFtO1xuICAgICAgICByZXF1ZXN0U3RyZWFtID0gcmVzcG9uc2VTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KHJlc3BvbnNlU3RyZWFtKSkge1xuICAgICAgICBvcHRpb25zID0gcmVzcG9uc2VTdHJlYW07XG4gICAgICAgIHJlc3BvbnNlU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB1dGlsLmlzU3RyaW5nKHR5cGUpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKHJlcXVlc3RUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdFR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhyZXNwb25zZVR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXNwb25zZVR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZSB8fCBcInJwY1wiOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdFR5cGUgPSByZXF1ZXN0VHlwZTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0U3RyZWFtID0gcmVxdWVzdFN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2UgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VTdHJlYW0gPSByZXNwb25zZVN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgcmVxdWVzdCB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIHR5cGUuXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgbWV0aG9kXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHByb3Blcmx5IHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IHBhcnNlZE9wdGlvbnM7XG59XG5cbi8qKlxuICogTWV0aG9kIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElNZXRob2RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZT1cInJwY1wiXSBNZXRob2QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc3BvbnNlVHlwZSBSZXNwb25zZSB0eXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1ZXN0U3RyZWFtPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzcG9uc2VTdHJlYW09ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE1ldGhvZCBvcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29tbWVudCBNZXRob2QgY29tbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBNZXRob2Qgb3B0aW9ucyBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBtZXRob2QgZnJvbSBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7SU1ldGhvZH0ganNvbiBNZXRob2QgZGVzY3JpcHRvclxuICogQHJldHVybnMge01ldGhvZH0gQ3JlYXRlZCBtZXRob2RcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk1ldGhvZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE1ldGhvZChuYW1lLCBqc29uLnR5cGUsIGpzb24ucmVxdWVzdFR5cGUsIGpzb24ucmVzcG9uc2VUeXBlLCBqc29uLnJlcXVlc3RTdHJlYW0sIGpzb24ucmVzcG9uc2VTdHJlYW0sIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50LCBqc29uLnBhcnNlZE9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1ldGhvZCB0byBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU1ldGhvZH0gTWV0aG9kIGRlc2NyaXB0b3JcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgICAsIHRoaXMudHlwZSAhPT0gXCJycGNcIiAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aGlzLnR5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcInJlcXVlc3RUeXBlXCIgICAgLCB0aGlzLnJlcXVlc3RUeXBlLFxuICAgICAgICBcInJlcXVlc3RTdHJlYW1cIiAgLCB0aGlzLnJlcXVlc3RTdHJlYW0sXG4gICAgICAgIFwicmVzcG9uc2VUeXBlXCIgICAsIHRoaXMucmVzcG9uc2VUeXBlLFxuICAgICAgICBcInJlc3BvbnNlU3RyZWFtXCIgLCB0aGlzLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICBcIm9wdGlvbnNcIiAgICAgICAgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICAgICAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJwYXJzZWRPcHRpb25zXCIgICwgdGhpcy5wYXJzZWRPcHRpb25zLFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXF1ZXN0VHlwZSk7XG4gICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXNwb25zZVR5cGUpO1xuXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZSkuY2xhc3NOYW1lID0gXCJTZXJ2aWNlXCI7XG5cbnZhciBNZXRob2QgPSByZXF1aXJlKFwiLi9tZXRob2RcIiksXG4gICAgdXRpbCAgID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBycGMgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgc2VydmljZS5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gU2VydmljZSBvcHRpb25zXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFNlcnZpY2UgbWV0aG9kcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsTWV0aG9kPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGhvZHMgPSB7fTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBtZXRob2RzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtNZXRob2RbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWV0aG9kc0FycmF5ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlXG4gKiBAZXh0ZW5kcyBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElNZXRob2Q+fSBtZXRob2RzIE1ldGhvZCBkZXNjcmlwdG9yc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHNlcnZpY2UgZnJvbSBhIHNlcnZpY2UgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxuICogQHBhcmFtIHtJU2VydmljZX0ganNvbiBTZXJ2aWNlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtTZXJ2aWNlfSBDcmVhdGVkIHNlcnZpY2VcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cblNlcnZpY2UuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIHNlcnZpY2UgPSBuZXcgU2VydmljZShuYW1lLCBqc29uLm9wdGlvbnMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGpzb24ubWV0aG9kcylcbiAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm1ldGhvZHMpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgc2VydmljZS5hZGQoTWV0aG9kLmZyb21KU09OKG5hbWVzW2ldLCBqc29uLm1ldGhvZHNbbmFtZXNbaV1dKSk7XG4gICAgaWYgKGpzb24ubmVzdGVkKVxuICAgICAgICBzZXJ2aWNlLmFkZEpTT04oanNvbi5uZXN0ZWQpO1xuICAgIHNlcnZpY2UuY29tbWVudCA9IGpzb24uY29tbWVudDtcbiAgICByZXR1cm4gc2VydmljZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBzZXJ2aWNlIHRvIGEgc2VydmljZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SVNlcnZpY2V9IFNlcnZpY2UgZGVzY3JpcHRvclxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBpbmhlcml0ZWQgPSBOYW1lc3BhY2UucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMsIHRvSlNPTk9wdGlvbnMpO1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5vcHRpb25zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJtZXRob2RzXCIgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5tZXRob2RzQXJyYXksIHRvSlNPTk9wdGlvbnMpIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9LFxuICAgICAgICBcIm5lc3RlZFwiICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQubmVzdGVkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogTWV0aG9kcyBvZiB0aGlzIHNlcnZpY2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAqIEBuYW1lIFNlcnZpY2UjbWV0aG9kc0FycmF5XG4gKiBAdHlwZSB7TWV0aG9kW119XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlLCBcIm1ldGhvZHNBcnJheVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHNBcnJheSB8fCAodGhpcy5fbWV0aG9kc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMubWV0aG9kcykpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjbGVhckNhY2hlKHNlcnZpY2UpIHtcbiAgICBzZXJ2aWNlLl9tZXRob2RzQXJyYXkgPSBudWxsO1xuICAgIHJldHVybiBzZXJ2aWNlO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZHNbbmFtZV1cbiAgICAgICAgfHwgTmFtZXNwYWNlLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBuYW1lKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIHZhciBtZXRob2RzID0gdGhpcy5tZXRob2RzQXJyYXk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKVxuICAgICAgICBtZXRob2RzW2ldLnJlc29sdmUoKTtcbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5nZXQob2JqZWN0Lm5hbWUpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWV0aG9kKSB7XG4gICAgICAgIHRoaXMubWV0aG9kc1tvYmplY3QubmFtZV0gPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWV0aG9kKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5tZXRob2RzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcnVudGltZSBzZXJ2aWNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcnBjIGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IFJQQyBzZXJ2aWNlLiBVc2VmdWwgd2hlcmUgcmVxdWVzdHMgYW5kL29yIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWQuXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuICAgIHZhciBycGNTZXJ2aWNlID0gbmV3IHJwYy5TZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbWV0aG9kOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5tZXRob2RzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSB1dGlsLmxjRmlyc3QoKG1ldGhvZCA9IHRoaXMuX21ldGhvZHNBcnJheVtpXSkucmVzb2x2ZSgpLm5hbWUpLnJlcGxhY2UoL1teJFxcd19dL2csIFwiXCIpO1xuICAgICAgICBycGNTZXJ2aWNlW21ldGhvZE5hbWVdID0gdXRpbC5jb2RlZ2VuKFtcInJcIixcImNcIl0sIHV0aWwuaXNSZXNlcnZlZChtZXRob2ROYW1lKSA/IG1ldGhvZE5hbWUgKyBcIl9cIiA6IG1ldGhvZE5hbWUpKFwicmV0dXJuIHRoaXMucnBjQ2FsbChtLHEscyxyLGMpXCIpKHtcbiAgICAgICAgICAgIG06IG1ldGhvZCxcbiAgICAgICAgICAgIHE6IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlLmN0b3IsXG4gICAgICAgICAgICBzOiBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY3RvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJwY1NlcnZpY2U7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFic3RyYWN0IHJ1bnRpbWUgbWVzc2FnZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9wZXJ0aWVzPFQ+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgb2JqZWN0ID0gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIE1lc3NhZ2UocHJvcGVydGllcykge1xuICAgIC8vIG5vdCB1c2VkIGludGVybmFsbHlcbiAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIHJlZmxlY3RlZCB0eXBlLlxuICogQG5hbWUgTWVzc2FnZS4kdHlwZVxuICogQHR5cGUge1R5cGV9XG4gKiBAcmVhZG9ubHlcbiAqL1xuXG4vKipcbiAqIFJlZmVyZW5jZSB0byB0aGUgcmVmbGVjdGVkIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlIyR0eXBlXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEByZWFkb25seVxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTxUPn0gTWVzc2FnZSBpbnN0YW5jZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuY3JlYXRlKHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1R8T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSB0byBlbmNvZGVcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gdXNlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBXcml0ZXJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcik7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7VHxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIHRvIGVuY29kZVxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byB1c2VcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IFdyaXRlclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5lbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQG5hbWUgTWVzc2FnZS5kZWNvZGVcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7VH0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmRlY29kZShyZWFkZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBNZXNzYWdlLmRlY29kZURlbGltaXRlZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHtUfSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlRGVsaW1pdGVkKHJlYWRlcik7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLnZlcmlmeVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gKi9cbk1lc3NhZ2UudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS52ZXJpZnkobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtUfSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZnJvbU9iamVjdChvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtUfSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1lc3NhZ2UgdG8gSlNPTi5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnRvT2JqZWN0KHRoaXMsIHV0aWwudG9KU09OT3B0aW9ucyk7XG59O1xuXG4vKmVzbGludC1lbmFibGUgdmFsaWQtanNkb2MqLyIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlcjtcblxudmFyIEVudW0gICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHR5cGVzICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gbWlzc2luZyhmaWVsZCkge1xuICAgIHJldHVybiBcIm1pc3NpbmcgcmVxdWlyZWQgJ1wiICsgZmllbGQubmFtZSArIFwiJ1wiO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29kZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZGVjb2RlcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJyXCIsIFwibFwiXSwgbXR5cGUubmFtZSArIFwiJGRlY29kZVwiKVxuICAgIChcImlmKCEociBpbnN0YW5jZW9mIFJlYWRlcikpXCIpXG4gICAgICAgIChcInI9UmVhZGVyLmNyZWF0ZShyKVwiKVxuICAgIChcInZhciBjPWw9PT11bmRlZmluZWQ/ci5sZW46ci5wb3MrbCxtPW5ldyB0aGlzLmN0b3JcIiArIChtdHlwZS5maWVsZHNBcnJheS5maWx0ZXIoZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGZpZWxkLm1hcDsgfSkubGVuZ3RoID8gXCIsayx2YWx1ZVwiIDogXCJcIikpXG4gICAgKFwid2hpbGUoci5wb3M8Yyl7XCIpXG4gICAgICAgIChcInZhciB0PXIudWludDMyKClcIik7XG4gICAgaWYgKG10eXBlLmdyb3VwKSBnZW5cbiAgICAgICAgKFwiaWYoKHQmNyk9PT00KVwiKVxuICAgICAgICAgICAgKFwiYnJlYWtcIik7XG4gICAgZ2VuXG4gICAgICAgIChcInN3aXRjaCh0Pj4+Myl7XCIpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHR5cGUgID0gZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSA/IFwiaW50MzJcIiA6IGZpZWxkLnR5cGUsXG4gICAgICAgICAgICByZWYgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTsgZ2VuXG4gICAgICAgICAgICAoXCJjYXNlICVpOiB7XCIsIGZpZWxkLmlkKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoJXM9PT11dGlsLmVtcHR5T2JqZWN0KVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcIiVzPXt9XCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJ2YXIgYzIgPSByLnVpbnQzMigpK3IucG9zXCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMuZGVmYXVsdHNbZmllbGQua2V5VHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaz0lalwiLCB0eXBlcy5kZWZhdWx0c1tmaWVsZC5rZXlUeXBlXSk7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIms9bnVsbFwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmRlZmF1bHRzW3R5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcInZhbHVlPSVqXCIsIHR5cGVzLmRlZmF1bHRzW3R5cGVdKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwidmFsdWU9bnVsbFwiKTtcblxuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgKFwid2hpbGUoci5wb3M8YzIpe1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ2YXIgdGFnMj1yLnVpbnQzMigpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcInN3aXRjaCh0YWcyPj4+Myl7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJjYXNlIDE6IGs9ci4lcygpOyBicmVha1wiLCBmaWVsZC5rZXlUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiY2FzZSAyOlwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInZhbHVlPXR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKVwiLCBpKTsgLy8gY2FuJ3QgYmUgZ3JvdXBzXG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInZhbHVlPXIuJXMoKVwiLCB0eXBlKTtcblxuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0YWcyJjcpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwifVwiKVxuICAgICAgICAgICAgICAgIChcIn1cIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5sb25nW2ZpZWxkLmtleVR5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcIiVzW3R5cGVvZiBrPT09XFxcIm9iamVjdFxcXCI/dXRpbC5sb25nVG9IYXNoKGspOmtdPXZhbHVlXCIsIHJlZik7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIiVzW2tdPXZhbHVlXCIsIHJlZik7XG5cbiAgICAgICAgLy8gUmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG5cbiAgICAgICAgICAgICAgICAoXCJpZighKCVzJiYlcy5sZW5ndGgpKVwiLCByZWYsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwiJXM9W11cIiwgcmVmKTtcblxuICAgICAgICAgICAgLy8gUGFja2FibGUgKGFsd2F5cyBjaGVjayBmb3IgZm9yd2FyZCBhbmQgYmFja3dhcmQgY29tcGF0aWJsaXR5KVxuICAgICAgICAgICAgaWYgKHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZigodCY3KT09PTIpe1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ2YXIgYzI9ci51aW50MzIoKStyLnBvc1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ3aGlsZShyLnBvczxjMilcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpXG4gICAgICAgICAgICAgICAgKFwifWVsc2VcIik7XG5cbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcbiAgICAgICAgICAgIGlmICh0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSBnZW4oZmllbGQucmVzb2x2ZWRUeXBlLmdyb3VwXG4gICAgICAgICAgICAgICAgICAgID8gXCIlcy5wdXNoKHR5cGVzWyVpXS5kZWNvZGUocikpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiVzLnB1c2godHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpKVwiLCByZWYsIGkpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiJXMucHVzaChyLiVzKCkpXCIsIHJlZiwgdHlwZSk7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuKGZpZWxkLnJlc29sdmVkVHlwZS5ncm91cFxuICAgICAgICAgICAgICAgID8gXCIlcz10eXBlc1slaV0uZGVjb2RlKHIpXCJcbiAgICAgICAgICAgICAgICA6IFwiJXM9dHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpXCIsIHJlZiwgaSk7XG4gICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwiJXM9ci4lcygpXCIsIHJlZiwgdHlwZSk7XG4gICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICAvLyBVbmtub3duIGZpZWxkc1xuICAgIH0gZ2VuXG4gICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxuICAgICAgICAgICAgICAgIChcInIuc2tpcFR5cGUodCY3KVwiKVxuICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG5cbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAvLyBGaWVsZCBwcmVzZW5jZVxuICAgIGZvciAoaSA9IDA7IGkgPCBtdHlwZS5fZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXTtcbiAgICAgICAgaWYgKHJmaWVsZC5yZXF1aXJlZCkgZ2VuXG4gICAgKFwiaWYoIW0uaGFzT3duUHJvcGVydHkoJWopKVwiLCByZmllbGQubmFtZSlcbiAgICAgICAgKFwidGhyb3cgdXRpbC5Qcm90b2NvbEVycm9yKCVqLHtpbnN0YW5jZTptfSlcIiwgbWlzc2luZyhyZmllbGQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG1cIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB2ZXJpZmllcjtcblxudmFyIEVudW0gICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gaW52YWxpZChmaWVsZCwgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmllbGQubmFtZSArIFwiOiBcIiArIGV4cGVjdGVkICsgKGZpZWxkLnJlcGVhdGVkICYmIGV4cGVjdGVkICE9PSBcImFycmF5XCIgPyBcIltdXCIgOiBmaWVsZC5tYXAgJiYgZXhwZWN0ZWQgIT09IFwib2JqZWN0XCIgPyBcIntrOlwiK2ZpZWxkLmtleVR5cGUrXCJ9XCIgOiBcIlwiKSArIFwiIGV4cGVjdGVkXCI7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSB2ZXJpZmllci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCByZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXG4gICAgICAgICAgICAoXCJzd2l0Y2goJXMpe1wiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJlbnVtIHZhbHVlXCIpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzKSwgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJjYXNlICVpOlwiLCBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzW2tleXNbal1dKTtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgKFwie1wiKVxuICAgICAgICAgICAgICAgIChcInZhciBlPXR5cGVzWyVpXS52ZXJpZnkoJXMpO1wiLCBmaWVsZEluZGV4LCByZWYpXG4gICAgICAgICAgICAgICAgKFwiaWYoZSlcIilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWorZVwiLCBmaWVsZC5uYW1lICsgXCIuXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoIXV0aWwuaXNJbnRlZ2VyKCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzSW50ZWdlciglcykmJiEoJXMmJnV0aWwuaXNJbnRlZ2VyKCVzLmxvdykmJnV0aWwuaXNJbnRlZ2VyKCVzLmhpZ2gpKSlcIiwgcmVmLCByZWYsIHJlZiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJ8TG9uZ1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mICVzIT09XFxcIm51bWJlclxcXCIpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJudW1iZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mICVzIT09XFxcImJvb2xlYW5cXFwiKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhblwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzU3RyaW5nKCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcInN0cmluZ1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoISglcyYmdHlwZW9mICVzLmxlbmd0aD09PVxcXCJudW1iZXJcXFwifHx1dGlsLmlzU3RyaW5nKCVzKSkpXCIsIHJlZiwgcmVmLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYnVmZmVyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIGtleSB2ZXJpZmllci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblZlcmlmeUtleShnZW4sIGZpZWxkLCByZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHN3aXRjaCAoZmllbGQua2V5VHlwZSkge1xuICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XG4gICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTMyUmUudGVzdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXIga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTY0UmUudGVzdCglcykpXCIsIHJlZikgLy8gc2VlIGNvbW1lbnQgYWJvdmU6IHggaXMgb2ssIGQgaXMgbm90XG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyfExvbmcga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTJSZS50ZXN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhbiBrZXlcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHZlcmlmaWVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZlcmlmaWVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cblxuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiXSwgbXR5cGUubmFtZSArIFwiJHZlcmlmeVwiKVxuICAgIChcImlmKHR5cGVvZiBtIT09XFxcIm9iamVjdFxcXCJ8fG09PT1udWxsKVwiKVxuICAgICAgICAoXCJyZXR1cm4lalwiLCBcIm9iamVjdCBleHBlY3RlZFwiKTtcbiAgICB2YXIgb25lb2ZzID0gbXR5cGUub25lb2ZzQXJyYXksXG4gICAgICAgIHNlZW5GaXJzdEZpZWxkID0ge307XG4gICAgaWYgKG9uZW9mcy5sZW5ndGgpIGdlblxuICAgIChcInZhciBwPXt9XCIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgcmVmICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAgICAgKFwiaWYoJXMhPW51bGwmJm0uaGFzT3duUHJvcGVydHkoJWopKXtcIiwgcmVmLCBmaWVsZC5uYW1lKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuXG4gICAgICAgIC8vIG1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmlzT2JqZWN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwib2JqZWN0XCIpKVxuICAgICAgICAgICAgKFwidmFyIGs9T2JqZWN0LmtleXMoJXMpXCIsIHJlZilcbiAgICAgICAgICAgIChcImZvcih2YXIgaT0wO2k8ay5sZW5ndGg7KytpKXtcIik7XG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5S2V5KGdlbiwgZmllbGQsIFwia1tpXVwiKTtcbiAgICAgICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYgKyBcIltrW2ldXVwiKVxuICAgICAgICAgICAgKFwifVwiKTtcblxuICAgICAgICAvLyByZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAgICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYXJyYXlcIikpXG4gICAgICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpe1wiLCByZWYpO1xuICAgICAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZiArIFwiW2ldXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIHJlcXVpcmVkIG9yIHByZXNlbnQgZmllbGRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmllbGQucGFydE9mKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uZW9mUHJvcCA9IHV0aWwuc2FmZVByb3AoZmllbGQucGFydE9mLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuRmlyc3RGaWVsZFtmaWVsZC5wYXJ0T2YubmFtZV0gPT09IDEpIGdlblxuICAgICAgICAgICAgKFwiaWYocCVzPT09MSlcIiwgb25lb2ZQcm9wKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGZpZWxkLnBhcnRPZi5uYW1lICsgXCI6IG11bHRpcGxlIHZhbHVlc1wiKTtcbiAgICAgICAgICAgICAgICBzZWVuRmlyc3RGaWVsZFtmaWVsZC5wYXJ0T2YubmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgKFwicCVzPTFcIiwgb25lb2ZQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAgICAgKFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBudWxsXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFJ1bnRpbWUgbWVzc2FnZSBmcm9tL3RvIHBsYWluIG9iamVjdCBjb252ZXJ0ZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgY29udmVydGVyID0gZXhwb3J0cztcblxudmFyIEVudW0gPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgZnJvbU9iamVjdCBjb252ZXRlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcHJvcCkge1xuICAgIHZhciBkZWZhdWx0QWxyZWFkeUVtaXR0ZWQgPSBmYWxzZTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSkge1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgeyBnZW5cbiAgICAgICAgICAgIChcInN3aXRjaChkJXMpe1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGZvciAodmFyIHZhbHVlcyA9IGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXMsIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnVtIHVua25vd24gdmFsdWVzIHBhc3N0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXlzW2ldXSA9PT0gZmllbGQudHlwZURlZmF1bHQgJiYgIWRlZmF1bHRBbHJlYWR5RW1pdHRlZCkgeyBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZihkJXMpPT09XFxcIm51bWJlclxcXCIpe20lcz1kJXM7YnJlYWt9XCIsIHByb3AsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnJlcGVhdGVkKSBnZW4gLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCB2YWx1ZSBvbmx5IGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXlzLCB0byBhdm9pZCBsZWF2aW5nIGhvbGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIik7ICAgICAgICAgICAvLyBmb3Igbm9uLXJlcGVhdGVkIGZpZWxkcywganVzdCBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEFscmVhZHlFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgKFwiY2FzZSVqOlwiLCBrZXlzW2ldKVxuICAgICAgICAgICAgICAgIChcImNhc2UgJWk6XCIsIHZhbHVlc1trZXlzW2ldXSlcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPSVqXCIsIHByb3AsIHZhbHVlc1trZXlzW2ldXSlcbiAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIik7XG4gICAgICAgICAgICB9IGdlblxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIGdlblxuICAgICAgICAgICAgKFwiaWYodHlwZW9mIGQlcyE9PVxcXCJvYmplY3RcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcInRocm93IFR5cGVFcnJvciglailcIiwgZmllbGQuZnVsbE5hbWUgKyBcIjogb2JqZWN0IGV4cGVjdGVkXCIpXG4gICAgICAgICAgICAoXCJtJXM9dHlwZXNbJWldLmZyb21PYmplY3QoZCVzKVwiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXNVbnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9TnVtYmVyKGQlcylcIiwgcHJvcCwgcHJvcCk7IC8vIGFsc28gY2F0Y2hlcyBcIk5hTlwiLCBcIkluZmluaXR5XCJcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1kJXM+Pj4wXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlc3wwXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgICAgIGlzVW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZih1dGlsLkxvbmcpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcIihtJXM9dXRpbC5Mb25nLmZyb21WYWx1ZShkJXMpKS51bnNpZ25lZD0lalwiLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJzdHJpbmdcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9cGFyc2VJbnQoZCVzLDEwKVwiLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJudW1iZXJcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZih0eXBlb2YgZCVzPT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1uZXcgdXRpbC5Mb25nQml0cyhkJXMubG93Pj4+MCxkJXMuaGlnaD4+PjApLnRvTnVtYmVyKCVzKVwiLCBwcm9wLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkID8gXCJ0cnVlXCIgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YgZCVzPT09XFxcInN0cmluZ1xcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcInV0aWwuYmFzZTY0LmRlY29kZShkJXMsbSVzPXV0aWwubmV3QnVmZmVyKHV0aWwuYmFzZTY0Lmxlbmd0aChkJXMpKSwwKVwiLCBwcm9wLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYoZCVzLmxlbmd0aCA+PSAwKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9U3RyaW5nKGQlcylcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9Qm9vbGVhbihkJXMpXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogZGVmYXVsdDogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhazsgKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBsYWluIG9iamVjdCB0byBydW50aW1lIG1lc3NhZ2UgY29udmVydGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmNvbnZlcnRlci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICB2YXIgZmllbGRzID0gbXR5cGUuZmllbGRzQXJyYXk7XG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJkXCJdLCBtdHlwZS5uYW1lICsgXCIkZnJvbU9iamVjdFwiKVxuICAgIChcImlmKGQgaW5zdGFuY2VvZiB0aGlzLmN0b3IpXCIpXG4gICAgICAgIChcInJldHVybiBkXCIpO1xuICAgIGlmICghZmllbGRzLmxlbmd0aCkgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBuZXcgdGhpcy5jdG9yXCIpO1xuICAgIGdlblxuICAgIChcInZhciBtPW5ldyB0aGlzLmN0b3JcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkICA9IGZpZWxkc1tpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICBwcm9wICAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuXG4gICAgICAgIC8vIE1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxuICAgICAgICAoXCJpZih0eXBlb2YgZCVzIT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxuICAgICAgICAoXCJtJXM9e31cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBrcz1PYmplY3Qua2V5cyhkJXMpLGk9MDtpPGtzLmxlbmd0aDsrK2kpe1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCArIFwiW2tzW2ldXVwiKVxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxuICAgICAgICAoXCJpZighQXJyYXkuaXNBcnJheShkJXMpKVwiLCBwcm9wKVxuICAgICAgICAgICAgKFwidGhyb3cgVHlwZUVycm9yKCVqKVwiLCBmaWVsZC5mdWxsTmFtZSArIFwiOiBhcnJheSBleHBlY3RlZFwiKVxuICAgICAgICAoXCJtJXM9W11cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTxkJXMubGVuZ3RoOysraSl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wICsgXCJbaV1cIilcbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpIGdlbiAvLyBubyBuZWVkIHRvIHRlc3QgZm9yIG51bGwvdW5kZWZpbmVkIGlmIGFuIGVudW0gKHVzZXMgc3dpdGNoKVxuICAgIChcImlmKGQlcyE9bnVsbCl7XCIsIHByb3ApOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG4gICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCk7XG4gICAgICAgICAgICBpZiAoIShmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSkgZ2VuXG4gICAgKFwifVwiKTtcbiAgICAgICAgfVxuICAgIH0gcmV0dXJuIGdlblxuICAgIChcInJldHVybiBtXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIHRvT2JqZWN0IGNvbnZlcnRlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHByb3ApIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSkge1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5lbnVtcz09PVN0cmluZz8odHlwZXNbJWldLnZhbHVlc1ttJXNdPT09dW5kZWZpbmVkP20lczp0eXBlc1slaV0udmFsdWVzW20lc10pOm0lc1wiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wLCBwcm9wKTtcbiAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgIChcImQlcz10eXBlc1slaV0udG9PYmplY3QobSVzLG8pXCIsIHByb3AsIGZpZWxkSW5kZXgsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc1Vuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW8uanNvbiYmIWlzRmluaXRlKG0lcyk/U3RyaW5nKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgICAgIGlzVW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKHR5cGVvZiBtJXM9PT1cXFwibnVtYmVyXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz9TdHJpbmcobSVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgIChcImVsc2VcIikgLy8gTG9uZy1saWtlXG4gICAgICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/dXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0lcyk6by5sb25ncz09PU51bWJlcj9uZXcgdXRpbC5Mb25nQml0cyhtJXMubG93Pj4+MCxtJXMuaGlnaD4+PjApLnRvTnVtYmVyKCVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZCA/IFwidHJ1ZVwiOiBcIlwiLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOiBnZW5cbiAgICAgICAgICAgIChcImQlcz1vLmJ5dGVzPT09U3RyaW5nP3V0aWwuYmFzZTY0LmVuY29kZShtJXMsMCxtJXMubGVuZ3RoKTpvLmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobSVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiBnZW5cbiAgICAgICAgICAgIChcImQlcz1tJXNcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbjtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBydW50aW1lIG1lc3NhZ2UgdG8gcGxhaW4gb2JqZWN0IGNvbnZlcnRlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5jb252ZXJ0ZXIudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICB2YXIgZmllbGRzID0gbXR5cGUuZmllbGRzQXJyYXkuc2xpY2UoKS5zb3J0KHV0aWwuY29tcGFyZUZpZWxkc0J5SWQpO1xuICAgIGlmICghZmllbGRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHV0aWwuY29kZWdlbigpKFwicmV0dXJuIHt9XCIpO1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiLCBcIm9cIl0sIG10eXBlLm5hbWUgKyBcIiR0b09iamVjdFwiKVxuICAgIChcImlmKCFvKVwiKVxuICAgICAgICAoXCJvPXt9XCIpXG4gICAgKFwidmFyIGQ9e31cIik7XG5cbiAgICB2YXIgcmVwZWF0ZWRGaWVsZHMgPSBbXSxcbiAgICAgICAgbWFwRmllbGRzID0gW10sXG4gICAgICAgIG5vcm1hbEZpZWxkcyA9IFtdLFxuICAgICAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKCFmaWVsZHNbaV0ucGFydE9mKVxuICAgICAgICAgICAgKCBmaWVsZHNbaV0ucmVzb2x2ZSgpLnJlcGVhdGVkID8gcmVwZWF0ZWRGaWVsZHNcbiAgICAgICAgICAgIDogZmllbGRzW2ldLm1hcCA/IG1hcEZpZWxkc1xuICAgICAgICAgICAgOiBub3JtYWxGaWVsZHMpLnB1c2goZmllbGRzW2ldKTtcblxuICAgIGlmIChyZXBlYXRlZEZpZWxkcy5sZW5ndGgpIHsgZ2VuXG4gICAgKFwiaWYoby5hcnJheXN8fG8uZGVmYXVsdHMpe1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcGVhdGVkRmllbGRzLmxlbmd0aDsgKytpKSBnZW5cbiAgICAgICAgKFwiZCVzPVtdXCIsIHV0aWwuc2FmZVByb3AocmVwZWF0ZWRGaWVsZHNbaV0ubmFtZSkpO1xuICAgICAgICBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cblxuICAgIGlmIChtYXBGaWVsZHMubGVuZ3RoKSB7IGdlblxuICAgIChcImlmKG8ub2JqZWN0c3x8by5kZWZhdWx0cyl7XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWFwRmllbGRzLmxlbmd0aDsgKytpKSBnZW5cbiAgICAgICAgKFwiZCVzPXt9XCIsIHV0aWwuc2FmZVByb3AobWFwRmllbGRzW2ldLm5hbWUpKTtcbiAgICAgICAgZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsRmllbGRzLmxlbmd0aCkgeyBnZW5cbiAgICAoXCJpZihvLmRlZmF1bHRzKXtcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBub3JtYWxGaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG5vcm1hbEZpZWxkc1tpXSxcbiAgICAgICAgICAgICAgICBwcm9wICA9IHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG4gICAgICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgZ2VuXG4gICAgICAgIChcImQlcz1vLmVudW1zPT09U3RyaW5nPyVqOiVqXCIsIHByb3AsIGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXNCeUlkW2ZpZWxkLnR5cGVEZWZhdWx0XSwgZmllbGQudHlwZURlZmF1bHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubG9uZykgZ2VuXG4gICAgICAgIChcImlmKHV0aWwuTG9uZyl7XCIpXG4gICAgICAgICAgICAoXCJ2YXIgbj1uZXcgdXRpbC5Mb25nKCVpLCVpLCVqKVwiLCBmaWVsZC50eXBlRGVmYXVsdC5sb3csIGZpZWxkLnR5cGVEZWZhdWx0LmhpZ2gsIGZpZWxkLnR5cGVEZWZhdWx0LnVuc2lnbmVkKVxuICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/bi50b1N0cmluZygpOm8ubG9uZ3M9PT1OdW1iZXI/bi50b051bWJlcigpOm5cIiwgcHJvcClcbiAgICAgICAgKFwifWVsc2VcIilcbiAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nPyVqOiVpXCIsIHByb3AsIGZpZWxkLnR5cGVEZWZhdWx0LnRvU3RyaW5nKCksIGZpZWxkLnR5cGVEZWZhdWx0LnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQuYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlEZWZhdWx0ID0gXCJbXCIgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmaWVsZC50eXBlRGVmYXVsdCkuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgKFwiaWYoby5ieXRlcz09PVN0cmluZylkJXM9JWpcIiwgcHJvcCwgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGZpZWxkLnR5cGVEZWZhdWx0KSlcbiAgICAgICAgKFwiZWxzZXtcIilcbiAgICAgICAgICAgIChcImQlcz0lc1wiLCBwcm9wLCBhcnJheURlZmF1bHQpXG4gICAgICAgICAgICAoXCJpZihvLmJ5dGVzIT09QXJyYXkpZCVzPXV0aWwubmV3QnVmZmVyKGQlcylcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgKFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBnZW5cbiAgICAgICAgKFwiZCVzPSVqXCIsIHByb3AsIGZpZWxkLnR5cGVEZWZhdWx0KTsgLy8gYWxzbyBtZXNzYWdlcyAoPW51bGwpXG4gICAgICAgIH0gZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG4gICAgdmFyIGhhc0tzMiA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldLFxuICAgICAgICAgICAgaW5kZXggPSBtdHlwZS5fZmllbGRzQXJyYXkuaW5kZXhPZihmaWVsZCksXG4gICAgICAgICAgICBwcm9wICA9IHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG4gICAgICAgIGlmIChmaWVsZC5tYXApIHtcbiAgICAgICAgICAgIGlmICghaGFzS3MyKSB7IGhhc0tzMiA9IHRydWU7IGdlblxuICAgIChcInZhciBrczJcIik7XG4gICAgICAgICAgICB9IGdlblxuICAgIChcImlmKG0lcyYmKGtzMj1PYmplY3Qua2V5cyhtJXMpKS5sZW5ndGgpe1wiLCBwcm9wLCBwcm9wKVxuICAgICAgICAoXCJkJXM9e31cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBqPTA7ajxrczIubGVuZ3RoOysrail7XCIpO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIC8qIHNvcnRlZCAqLyBpbmRleCwgcHJvcCArIFwiW2tzMltqXV1cIilcbiAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZihtJXMmJm0lcy5sZW5ndGgpe1wiLCBwcm9wLCBwcm9wKVxuICAgICAgICAoXCJkJXM9W11cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBqPTA7ajxtJXMubGVuZ3RoOysrail7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIC8qIHNvcnRlZCAqLyBpbmRleCwgcHJvcCArIFwiW2pdXCIpXG4gICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSB7IGdlblxuICAgIChcImlmKG0lcyE9bnVsbCYmbS5oYXNPd25Qcm9wZXJ0eSglaikpe1wiLCBwcm9wLCBmaWVsZC5uYW1lKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wKTtcbiAgICAgICAgaWYgKGZpZWxkLnBhcnRPZikgZ2VuXG4gICAgICAgIChcImlmKG8ub25lb2ZzKVwiKVxuICAgICAgICAgICAgKFwiZCVzPSVqXCIsIHV0aWwuc2FmZVByb3AoZmllbGQucGFydE9mLm5hbWUpLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIGRcIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFdyYXBwZXJzIGZvciBjb21tb24gdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsSVdyYXBwZXI+fVxuICogQGNvbnN0XG4gKi9cbnZhciB3cmFwcGVycyA9IGV4cG9ydHM7XG5cbnZhciBNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcblxuLyoqXG4gKiBGcm9tIG9iamVjdCBjb252ZXJ0ZXIgcGFydCBvZiBhbiB7QGxpbmsgSVdyYXBwZXJ9LlxuICogQHR5cGVkZWYgV3JhcHBlckZyb21PYmplY3RDb252ZXJ0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gTWVzc2FnZSBpbnN0YW5jZVxuICogQHRoaXMgVHlwZVxuICovXG5cbi8qKlxuICogVG8gb2JqZWN0IGNvbnZlcnRlciBwYXJ0IG9mIGFuIHtAbGluayBJV3JhcHBlcn0uXG4gKiBAdHlwZWRlZiBXcmFwcGVyVG9PYmplY3RDb252ZXJ0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtJQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gKiBAdGhpcyBUeXBlXG4gKi9cblxuLyoqXG4gKiBDb21tb24gdHlwZSB3cmFwcGVyIHBhcnQgb2Yge0BsaW5rIHdyYXBwZXJzfS5cbiAqIEBpbnRlcmZhY2UgSVdyYXBwZXJcbiAqIEBwcm9wZXJ0eSB7V3JhcHBlckZyb21PYmplY3RDb252ZXJ0ZXJ9IFtmcm9tT2JqZWN0XSBGcm9tIG9iamVjdCBjb252ZXJ0ZXJcbiAqIEBwcm9wZXJ0eSB7V3JhcHBlclRvT2JqZWN0Q29udmVydGVyfSBbdG9PYmplY3RdIFRvIG9iamVjdCBjb252ZXJ0ZXJcbiAqL1xuXG4vLyBDdXN0b20gd3JhcHBlciBmb3IgQW55XG53cmFwcGVyc1tcIi5nb29nbGUucHJvdG9idWYuQW55XCJdID0ge1xuXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgICAgLy8gdW53cmFwIHZhbHVlIHR5cGUgaWYgbWFwcGVkXG4gICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0W1wiQHR5cGVcIl0pIHtcbiAgICAgICAgICAgICAvLyBPbmx5IHVzZSBmdWxseSBxdWFsaWZpZWQgdHlwZSBuYW1lIGFmdGVyIHRoZSBsYXN0ICcvJ1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvYmplY3RbXCJAdHlwZVwiXS5zdWJzdHJpbmcob2JqZWN0W1wiQHR5cGVcIl0ubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMubG9va3VwKG5hbWUpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gdHlwZV91cmwgZG9lcyBub3QgYWNjZXB0IGxlYWRpbmcgXCIuXCJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZV91cmwgPSBvYmplY3RbXCJAdHlwZVwiXS5jaGFyQXQoMCkgPT09IFwiLlwiID9cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W1wiQHR5cGVcIl0uc2xpY2UoMSkgOiBvYmplY3RbXCJAdHlwZVwiXTtcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBwcmVmaXggaXMgb3B0aW9uYWwsIGJ1dCBwYXRoIHNlcGVyYXRvciBpcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlX3VybC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZV91cmwgPSBcIi9cIiArIHR5cGVfdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlX3VybDogdHlwZV91cmwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlLmVuY29kZSh0eXBlLmZyb21PYmplY3Qob2JqZWN0KSkuZmluaXNoKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgICB9LFxuXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHByZWZpeFxuICAgICAgICB2YXIgZ29vZ2xlQXBpID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tL1wiO1xuICAgICAgICB2YXIgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8vIGRlY29kZSB2YWx1ZSBpZiByZXF1ZXN0ZWQgYW5kIHVubWFwcGVkXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbiAmJiBtZXNzYWdlLnR5cGVfdXJsICYmIG1lc3NhZ2UudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gICAgICAgICAgICBuYW1lID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcobWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIHRoZSBwcmVmaXggdXNlZFxuICAgICAgICAgICAgcHJlZml4ID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcoMCwgbWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHR5cGUuZGVjb2RlKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JhcCB2YWx1ZSBpZiB1bm1hcHBlZFxuICAgICAgICBpZiAoIShtZXNzYWdlIGluc3RhbmNlb2YgdGhpcy5jdG9yKSAmJiBtZXNzYWdlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG1lc3NhZ2UuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZU5hbWUgPSBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lWzBdID09PSBcIi5cIiA/XG4gICAgICAgICAgICAgICAgbWVzc2FnZS4kdHlwZS5mdWxsTmFtZS5zbGljZSgxKSA6IG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWU7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIHR5cGUuZ29vZ2xlYXBpcy5jb20gcHJlZml4IGlmIG5vIHByZWZpeCBpcyB1c2VkXG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gZ29vZ2xlQXBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IHByZWZpeCArIG1lc3NhZ2VOYW1lO1xuICAgICAgICAgICAgb2JqZWN0W1wiQHR5cGVcIl0gPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH1cbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFR5cGU7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gVHlwZSkuY2xhc3NOYW1lID0gXCJUeXBlXCI7XG5cbnZhciBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIE9uZU9mICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxuICAgIEZpZWxkICAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIE1hcEZpZWxkICA9IHJlcXVpcmUoXCIuL21hcGZpZWxkXCIpLFxuICAgIFNlcnZpY2UgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIiksXG4gICAgTWVzc2FnZSAgID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKSxcbiAgICBSZWFkZXIgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIiksXG4gICAgV3JpdGVyICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgZW5jb2RlciAgID0gcmVxdWlyZShcIi4vZW5jb2RlclwiKSxcbiAgICBkZWNvZGVyICAgPSByZXF1aXJlKFwiLi9kZWNvZGVyXCIpLFxuICAgIHZlcmlmaWVyICA9IHJlcXVpcmUoXCIuL3ZlcmlmaWVyXCIpLFxuICAgIGNvbnZlcnRlciA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlclwiKSxcbiAgICB3cmFwcGVycyAgPSByZXF1aXJlKFwiLi93cmFwcGVyc1wiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlZmxlY3RlZCBtZXNzYWdlIHR5cGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtZXNzYWdlIHR5cGUuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVHlwZShuYW1lLCBvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIGZpZWxkcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsRmllbGQ+fVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRzID0ge307ICAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogT25lb2ZzIGRlY2xhcmVkIHdpdGhpbiB0aGlzIG5hbWVzcGFjZSwgaWYgYW55LlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxPbmVPZj59XG4gICAgICovXG4gICAgdGhpcy5vbmVvZnMgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uIHJhbmdlcywgaWYgYW55LlxuICAgICAqIEB0eXBlIHtudW1iZXJbXVtdfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKj9cbiAgICAgKiBXaGV0aGVyIHRoaXMgdHlwZSBpcyBhIGxlZ2FjeSBncm91cC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5ncm91cCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IGlkLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlcixGaWVsZD58bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGZpZWxkcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7RmllbGRbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGRzQXJyYXkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG9uZW9mcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7T25lT2ZbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25lb2ZzQXJyYXkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGNvbnN0cnVjdG9yLlxuICAgICAqIEB0eXBlIHtDb25zdHJ1Y3Rvcjx7fT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jdG9yID0gbnVsbDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHlwZS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgZmllbGRzIGJ5IGlkLlxuICAgICAqIEBuYW1lIFR5cGUjZmllbGRzQnlJZFxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlcixGaWVsZD59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZmllbGRzQnlJZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNCeUlkO1xuXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW25hbWVzW2ldXSxcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBmaWVsZC5pZDtcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkW2lkXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBpZCArIFwiIGluIFwiICsgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkW2lkXSA9IGZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0J5SWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmllbGRzIG9mIHRoaXMgbWVzc2FnZSBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEBuYW1lIFR5cGUjZmllbGRzQXJyYXlcbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBmaWVsZHNBcnJheToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0FycmF5IHx8ICh0aGlzLl9maWVsZHNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLmZpZWxkcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uZW9mcyBvZiB0aGlzIG1lc3NhZ2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAbmFtZSBUeXBlI29uZW9mc0FycmF5XG4gICAgICogQHR5cGUge09uZU9mW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgb25lb2ZzQXJyYXk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmVvZnNBcnJheSB8fCAodGhpcy5fb25lb2ZzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5vbmVvZnMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciwgaWYgYW55IHJlZ2lzdGVyZWQsIG90aGVyd2lzZSBhIGdlbmVyaWMgY29uc3RydWN0b3IuXG4gICAgICogQXNzaWduaW5nIGEgZnVuY3Rpb24gcmVwbGFjZXMgdGhlIGludGVybmFsIGNvbnN0cnVjdG9yLiBJZiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgZXh0ZW5kIHtAbGluayBNZXNzYWdlfSB5ZXQsIGl0cyBwcm90b3R5cGUgd2lsbCBiZSBzZXR1cCBhY2NvcmRpbmdseSBhbmQgc3RhdGljIG1ldGhvZHMgd2lsbCBiZSBwb3B1bGF0ZWQuIElmIGl0IGFscmVhZHkgZXh0ZW5kcyB7QGxpbmsgTWVzc2FnZX0sIGl0IHdpbGwganVzdCByZXBsYWNlIHRoZSBpbnRlcm5hbCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAbmFtZSBUeXBlI2N0b3JcbiAgICAgKiBAdHlwZSB7Q29uc3RydWN0b3I8e30+fVxuICAgICAqL1xuICAgIGN0b3I6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdG9yIHx8ICh0aGlzLmN0b3IgPSBUeXBlLmdlbmVyYXRlQ29uc3RydWN0b3IodGhpcykoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oY3Rvcikge1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgcHJvcGVyIHByb3RvdHlwZVxuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuICAgICAgICAgICAgaWYgKCEocHJvdG90eXBlIGluc3RhbmNlb2YgTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAoY3Rvci5wcm90b3R5cGUgPSBuZXcgTWVzc2FnZSgpKS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gICAgICAgICAgICAgICAgdXRpbC5tZXJnZShjdG9yLnByb3RvdHlwZSwgcHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xhc3NlcyBhbmQgbWVzc2FnZXMgcmVmZXJlbmNlIHRoZWlyIHJlZmxlY3RlZCB0eXBlXG4gICAgICAgICAgICBjdG9yLiR0eXBlID0gY3Rvci5wcm90b3R5cGUuJHR5cGUgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBNaXggaW4gc3RhdGljIG1ldGhvZHNcbiAgICAgICAgICAgIHV0aWwubWVyZ2UoY3RvciwgTWVzc2FnZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2N0b3IgPSBjdG9yO1xuXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBoYXZlIG5vbi1lbnVtZXJhYmxlIGRlZmF1bHQgdmFsdWVzIG9uIHRoZWlyIHByb3RvdHlwZVxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKTsgLy8gZW5zdXJlcyBhIHByb3BlciB2YWx1ZVxuXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBoYXZlIG5vbi1lbnVtZXJhYmxlIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIGVhY2ggdmlydHVhbCBvbmVvZiBmaWVsZFxuICAgICAgICAgICAgdmFyIGN0b3JQcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5vbmVvZnNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjdG9yUHJvcGVydGllc1t0aGlzLl9vbmVvZnNBcnJheVtpXS5yZXNvbHZlKCkubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogdXRpbC5vbmVPZkdldHRlcih0aGlzLl9vbmVvZnNBcnJheVtpXS5vbmVvZiksXG4gICAgICAgICAgICAgICAgICAgIHNldDogdXRpbC5vbmVPZlNldHRlcih0aGlzLl9vbmVvZnNBcnJheVtpXS5vbmVvZilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3Rvci5wcm90b3R5cGUsIGN0b3JQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuVHlwZS5nZW5lcmF0ZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJ1Y3RvcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJwXCJdLCBtdHlwZS5uYW1lKTtcbiAgICAvLyBleHBsaWNpdGx5IGluaXRpYWxpemUgbXV0YWJsZSBvYmplY3QvYXJyYXkgZmllbGRzIHNvIHRoYXQgdGhlc2UgYXJlbid0IGp1c3QgaW5oZXJpdGVkIGZyb20gdGhlIHByb3RvdHlwZVxuICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IG10eXBlLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoKGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldKS5tYXApIGdlblxuICAgICAgICAgICAgKFwidGhpcyVzPXt9XCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xuICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgZ2VuXG4gICAgICAgICAgICAoXCJ0aGlzJXM9W11cIiwgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKSk7XG4gICAgcmV0dXJuIGdlblxuICAgIChcImlmKHApZm9yKHZhciBrcz1PYmplY3Qua2V5cyhwKSxpPTA7aTxrcy5sZW5ndGg7KytpKWlmKHBba3NbaV1dIT1udWxsKVwiKSAvLyBvbWl0IHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgIChcInRoaXNba3NbaV1dPXBba3NbaV1dXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn07XG5cbmZ1bmN0aW9uIGNsZWFyQ2FjaGUodHlwZSkge1xuICAgIHR5cGUuX2ZpZWxkc0J5SWQgPSB0eXBlLl9maWVsZHNBcnJheSA9IHR5cGUuX29uZW9mc0FycmF5ID0gbnVsbDtcbiAgICBkZWxldGUgdHlwZS5lbmNvZGU7XG4gICAgZGVsZXRlIHR5cGUuZGVjb2RlO1xuICAgIGRlbGV0ZSB0eXBlLnZlcmlmeTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuLyoqXG4gKiBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSVR5cGVcbiAqIEBleHRlbmRzIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSU9uZU9mPn0gW29uZW9mc10gT25lb2YgZGVzY3JpcHRvcnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSUZpZWxkPn0gZmllbGRzIEZpZWxkIGRlc2NyaXB0b3JzXG4gKiBAcHJvcGVydHkge251bWJlcltdW119IFtleHRlbnNpb25zXSBFeHRlbnNpb24gcmFuZ2VzXG4gKiBAcHJvcGVydHkge251bWJlcltdW119IFtyZXNlcnZlZF0gUmVzZXJ2ZWQgcmFuZ2VzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncm91cD1mYWxzZV0gV2hldGhlciBhIGxlZ2FjeSBncm91cCBvciBub3RcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtZXNzYWdlIHR5cGUgZnJvbSBhIG1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWVzc2FnZSBuYW1lXG4gKiBAcGFyYW0ge0lUeXBlfSBqc29uIE1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7VHlwZX0gQ3JlYXRlZCBtZXNzYWdlIHR5cGVcbiAqL1xuVHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKG5hbWUsIGpzb24ub3B0aW9ucyk7XG4gICAgdHlwZS5leHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zO1xuICAgIHR5cGUucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24uZmllbGRzKSxcbiAgICAgICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgdHlwZS5hZGQoXG4gICAgICAgICAgICAoIHR5cGVvZiBqc29uLmZpZWxkc1tuYW1lc1tpXV0ua2V5VHlwZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyBNYXBGaWVsZC5mcm9tSlNPTlxuICAgICAgICAgICAgOiBGaWVsZC5mcm9tSlNPTiApKG5hbWVzW2ldLCBqc29uLmZpZWxkc1tuYW1lc1tpXV0pXG4gICAgICAgICk7XG4gICAgaWYgKGpzb24ub25lb2ZzKVxuICAgICAgICBmb3IgKG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5vbmVvZnMpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdHlwZS5hZGQoT25lT2YuZnJvbUpTT04obmFtZXNbaV0sIGpzb24ub25lb2ZzW25hbWVzW2ldXSkpO1xuICAgIGlmIChqc29uLm5lc3RlZClcbiAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ubmVzdGVkKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5lc3RlZCA9IGpzb24ubmVzdGVkW25hbWVzW2ldXTtcbiAgICAgICAgICAgIHR5cGUuYWRkKCAvLyBtb3N0IHRvIGxlYXN0IGxpa2VseVxuICAgICAgICAgICAgICAgICggbmVzdGVkLmlkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEZpZWxkLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQuZmllbGRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFR5cGUuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC52YWx1ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRW51bS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLm1ldGhvZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gU2VydmljZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogTmFtZXNwYWNlLmZyb21KU09OICkobmFtZXNbaV0sIG5lc3RlZClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICBpZiAoanNvbi5leHRlbnNpb25zICYmIGpzb24uZXh0ZW5zaW9ucy5sZW5ndGgpXG4gICAgICAgIHR5cGUuZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucztcbiAgICBpZiAoanNvbi5yZXNlcnZlZCAmJiBqc29uLnJlc2VydmVkLmxlbmd0aClcbiAgICAgICAgdHlwZS5yZXNlcnZlZCA9IGpzb24ucmVzZXJ2ZWQ7XG4gICAgaWYgKGpzb24uZ3JvdXApXG4gICAgICAgIHR5cGUuZ3JvdXAgPSB0cnVlO1xuICAgIGlmIChqc29uLmNvbW1lbnQpXG4gICAgICAgIHR5cGUuY29tbWVudCA9IGpzb24uY29tbWVudDtcbiAgICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtZXNzYWdlIHR5cGUgdG8gYSBtZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lUeXBlfSBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvclxuICovXG5UeXBlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBpbmhlcml0ZWQgPSBOYW1lc3BhY2UucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMsIHRvSlNPTk9wdGlvbnMpO1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICAgICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5vcHRpb25zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJvbmVvZnNcIiAgICAgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5vbmVvZnNBcnJheSwgdG9KU09OT3B0aW9ucyksXG4gICAgICAgIFwiZmllbGRzXCIgICAgICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMuZmllbGRzQXJyYXkuZmlsdGVyKGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gIW9iai5kZWNsYXJpbmdGaWVsZDsgfSksIHRvSlNPTk9wdGlvbnMpIHx8IHt9LFxuICAgICAgICBcImV4dGVuc2lvbnNcIiAsIHRoaXMuZXh0ZW5zaW9ucyAmJiB0aGlzLmV4dGVuc2lvbnMubGVuZ3RoID8gdGhpcy5leHRlbnNpb25zIDogdW5kZWZpbmVkLFxuICAgICAgICBcInJlc2VydmVkXCIgICAsIHRoaXMucmVzZXJ2ZWQgJiYgdGhpcy5yZXNlcnZlZC5sZW5ndGggPyB0aGlzLnJlc2VydmVkIDogdW5kZWZpbmVkLFxuICAgICAgICBcImdyb3VwXCIgICAgICAsIHRoaXMuZ3JvdXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcIm5lc3RlZFwiICAgICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQubmVzdGVkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50XCIgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblR5cGUucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkc0FycmF5LCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGZpZWxkcy5sZW5ndGgpXG4gICAgICAgIGZpZWxkc1tpKytdLnJlc29sdmUoKTtcbiAgICB2YXIgb25lb2ZzID0gdGhpcy5vbmVvZnNBcnJheTsgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBvbmVvZnMubGVuZ3RoKVxuICAgICAgICBvbmVvZnNbaSsrXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbC5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHlwZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZHNbbmFtZV1cbiAgICAgICAgfHwgdGhpcy5vbmVvZnMgJiYgdGhpcy5vbmVvZnNbbmFtZV1cbiAgICAgICAgfHwgdGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV1cbiAgICAgICAgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQWRkcyBhIG5lc3RlZCBvYmplY3QgdG8gdGhpcyB0eXBlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byBhZGRcbiAqIEByZXR1cm5zIHtUeXBlfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5lc3RlZCBvYmplY3Qgd2l0aCB0aGlzIG5hbWUgb3IsIGlmIGEgZmllbGQsIHdoZW4gdGhlcmUgaXMgYWxyZWFkeSBhIGZpZWxkIHdpdGggdGhpcyBpZFxuICovXG5UeXBlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG5cbiAgICBpZiAodGhpcy5nZXQob2JqZWN0Lm5hbWUpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQgJiYgb2JqZWN0LmV4dGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5PVEU6IEV4dGVuc2lvbiBmaWVsZHMgYXJlbid0IGFjdHVhbCBmaWVsZHMgb24gdGhlIGRlY2xhcmluZyB0eXBlLCBidXQgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgIC8vIFRoZSByb290IG9iamVjdCB0YWtlcyBjYXJlIG9mIGFkZGluZyBkaXN0aW5jdCBzaXN0ZXItZmllbGRzIHRvIHRoZSByZXNwZWN0aXZlIGV4dGVuZGVkXG4gICAgICAgIC8vIHR5cGUgaW5zdGVhZC5cblxuICAgICAgICAvLyBhdm9pZHMgY2FsbGluZyB0aGUgZ2V0dGVyIGlmIG5vdCBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBiZWNhdXNlIGl0J3MgY2FsbGVkIHF1aXRlIGZyZXF1ZW50bHlcbiAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWQgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aGlzLl9maWVsZHNCeUlkW29iamVjdC5pZF0gOiB0aGlzLmZpZWxkc0J5SWRbb2JqZWN0LmlkXSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgb2JqZWN0LmlkICsgXCIgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXNlcnZlZElkKG9iamVjdC5pZCkpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImlkIFwiICsgb2JqZWN0LmlkICsgXCIgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXNlcnZlZE5hbWUob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG5cbiAgICAgICAgaWYgKG9iamVjdC5wYXJlbnQpXG4gICAgICAgICAgICBvYmplY3QucGFyZW50LnJlbW92ZShvYmplY3QpO1xuICAgICAgICB0aGlzLmZpZWxkc1tvYmplY3QubmFtZV0gPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5tZXNzYWdlID0gdGhpcztcbiAgICAgICAgb2JqZWN0Lm9uQWRkKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9uZU9mKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmVvZnMpXG4gICAgICAgICAgICB0aGlzLm9uZW9mcyA9IHt9O1xuICAgICAgICB0aGlzLm9uZW9mc1tvYmplY3QubmFtZV0gPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhpcyB0eXBlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byByZW1vdmVcbiAqIEByZXR1cm5zIHtUeXBlfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYG9iamVjdGAgaXMgbm90IGEgbWVtYmVyIG9mIHRoaXMgdHlwZVxuICovXG5UeXBlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBTZWUgVHlwZSNhZGQgZm9yIHRoZSByZWFzb24gd2h5IGV4dGVuc2lvbiBmaWVsZHMgYXJlIGV4Y2x1ZGVkIGhlcmUuXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5maWVsZHMgfHwgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdO1xuICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcbiAgICAgICAgb2JqZWN0Lm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9uZU9mKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5vbmVvZnMgfHwgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdO1xuICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcbiAgICAgICAgb2JqZWN0Lm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBpZCBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5UeXBlLnByb3RvdHlwZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQoaWQpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWRJZCh0aGlzLnJlc2VydmVkLCBpZCk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuVHlwZS5wcm90b3R5cGUuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiBpc1Jlc2VydmVkTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkTmFtZSh0aGlzLnJlc2VydmVkLCBuYW1lKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gTWVzc2FnZSBpbnN0YW5jZVxuICovXG5UeXBlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgIHJldHVybiBuZXcgdGhpcy5jdG9yKHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIHtAbGluayBUeXBlI2VuY29kZXxlbmNvZGV9LCB7QGxpbmsgVHlwZSNkZWNvZGV8ZGVjb2RlfSBhbmQge0BsaW5rIFR5cGUjdmVyaWZ5fHZlcmlmeX0uXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKi9cblR5cGUucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgLy8gU2V0cyB1cCBldmVyeXRoaW5nIGF0IG9uY2Ugc28gdGhhdCB0aGUgcHJvdG90eXBlIGNoYWluIGRvZXMgbm90IGhhdmUgdG8gYmUgcmUtZXZhbHVhdGVkXG4gICAgLy8gbXVsdGlwbGUgdGltZXMgKFY4LCBzb2Z0LWRlb3B0IHByb3RvdHlwZS1jaGVjaykuXG5cbiAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLmZ1bGxOYW1lLFxuICAgICAgICB0eXBlcyAgICA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgdHlwZXMucHVzaCh0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCkucmVzb2x2ZWRUeXBlKTtcblxuICAgIC8vIFJlcGxhY2Ugc2V0dXAgbWV0aG9kcyB3aXRoIHR5cGUtc3BlY2lmaWMgZ2VuZXJhdGVkIGZ1bmN0aW9uc1xuICAgIHRoaXMuZW5jb2RlID0gZW5jb2Rlcih0aGlzKSh7XG4gICAgICAgIFdyaXRlciA6IFdyaXRlcixcbiAgICAgICAgdHlwZXMgIDogdHlwZXMsXG4gICAgICAgIHV0aWwgICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLmRlY29kZSA9IGRlY29kZXIodGhpcykoe1xuICAgICAgICBSZWFkZXIgOiBSZWFkZXIsXG4gICAgICAgIHR5cGVzICA6IHR5cGVzLFxuICAgICAgICB1dGlsICAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy52ZXJpZnkgPSB2ZXJpZmllcih0aGlzKSh7XG4gICAgICAgIHR5cGVzIDogdHlwZXMsXG4gICAgICAgIHV0aWwgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMuZnJvbU9iamVjdCA9IGNvbnZlcnRlci5mcm9tT2JqZWN0KHRoaXMpKHtcbiAgICAgICAgdHlwZXMgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy50b09iamVjdCA9IGNvbnZlcnRlci50b09iamVjdCh0aGlzKSh7XG4gICAgICAgIHR5cGVzIDogdHlwZXMsXG4gICAgICAgIHV0aWwgIDogdXRpbFxuICAgIH0pO1xuXG4gICAgLy8gSW5qZWN0IGN1c3RvbSB3cmFwcGVycyBmb3IgY29tbW9uIHR5cGVzXG4gICAgdmFyIHdyYXBwZXIgPSB3cmFwcGVyc1tmdWxsTmFtZV07XG4gICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsVGhpcyA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgIC8vIGlmICh3cmFwcGVyLmZyb21PYmplY3QpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsVGhpcy5mcm9tT2JqZWN0ID0gdGhpcy5mcm9tT2JqZWN0O1xuICAgICAgICAgICAgdGhpcy5mcm9tT2JqZWN0ID0gd3JhcHBlci5mcm9tT2JqZWN0LmJpbmQob3JpZ2luYWxUaGlzKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAod3JhcHBlci50b09iamVjdCkge1xuICAgICAgICAgICAgb3JpZ2luYWxUaGlzLnRvT2JqZWN0ID0gdGhpcy50b09iamVjdDtcbiAgICAgICAgICAgIHRoaXMudG9PYmplY3QgPSB3cmFwcGVyLnRvT2JqZWN0LmJpbmQob3JpZ2luYWxUaGlzKTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIFR5cGUjdmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICogQHJldHVybnMge1dyaXRlcn0gd3JpdGVyXG4gKi9cblR5cGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZV9zZXR1cChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpOyAvLyBvdmVycmlkZXMgdGhpcyBtZXRob2Rcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIFR5cGUjdmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICogQHJldHVybnMge1dyaXRlcn0gd3JpdGVyXG4gKi9cblR5cGUucHJvdG90eXBlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyICYmIHdyaXRlci5sZW4gPyB3cml0ZXIuZm9yaygpIDogd3JpdGVyKS5sZGVsaW0oKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggb2YgdGhlIG1lc3NhZ2UsIGlmIGtub3duIGJlZm9yZWhhbmRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICogQHRocm93cyB7dXRpbC5Qcm90b2NvbEVycm9yPHt9Pn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKi9cblR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZV9zZXR1cChyZWFkZXIsIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZGVjb2RlKHJlYWRlciwgbGVuZ3RoKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICogQHRocm93cyB7dXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqL1xuVHlwZS5wcm90b3R5cGUuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mIFJlYWRlcikpXG4gICAgICAgIHJlYWRlciA9IFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGZpZWxkIHZhbHVlcyBhcmUgdmFsaWQgYW5kIHRoYXQgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICovXG5UeXBlLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlfc2V0dXAobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkudmVyaWZ5KG1lc3NhZ2UpOyAvLyBvdmVycmlkZXMgdGhpcyBtZXRob2Rcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqL1xuVHlwZS5wcm90b3R5cGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5mcm9tT2JqZWN0KG9iamVjdCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnNpb24gb3B0aW9ucyBhcyB1c2VkIGJ5IHtAbGluayBUeXBlI3RvT2JqZWN0fSBhbmQge0BsaW5rIE1lc3NhZ2UudG9PYmplY3R9LlxuICogQGludGVyZmFjZSBJQ29udmVyc2lvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsb25nc10gTG9uZyBjb252ZXJzaW9uIHR5cGUuXG4gKiBWYWxpZCB2YWx1ZXMgYXJlIGBTdHJpbmdgIGFuZCBgTnVtYmVyYCAodGhlIGdsb2JhbCB0eXBlcykuXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCBpcyBhIHBvc3NpYmx5IHVuc2FmZSBudW1iZXIgd2l0aG91dCBhbmQgYSB7QGxpbmsgTG9uZ30gd2l0aCBhIGxvbmcgbGlicmFyeS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtlbnVtc10gRW51bSB2YWx1ZSBjb252ZXJzaW9uIHR5cGUuXG4gKiBPbmx5IHZhbGlkIHZhbHVlIGlzIGBTdHJpbmdgICh0aGUgZ2xvYmFsIHR5cGUpLlxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggaXMgdGhlIG51bWVyaWMgaWQuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbYnl0ZXNdIEJ5dGVzIHZhbHVlIGNvbnZlcnNpb24gdHlwZS5cbiAqIFZhbGlkIHZhbHVlcyBhcmUgYEFycmF5YCBhbmQgKGEgYmFzZTY0IGVuY29kZWQpIGBTdHJpbmdgICh0aGUgZ2xvYmFsIHR5cGVzKS5cbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIHVzdWFsbHkgaXMgYSBCdWZmZXIgdW5kZXIgbm9kZSBhbmQgYW4gVWludDhBcnJheSBpbiB0aGUgYnJvd3Nlci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlZmF1bHRzPWZhbHNlXSBBbHNvIHNldHMgZGVmYXVsdCB2YWx1ZXMgb24gdGhlIHJlc3VsdGluZyBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FycmF5cz1mYWxzZV0gU2V0cyBlbXB0eSBhcnJheXMgZm9yIG1pc3NpbmcgcmVwZWF0ZWQgZmllbGRzIGV2ZW4gaWYgYGRlZmF1bHRzPWZhbHNlYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb2JqZWN0cz1mYWxzZV0gU2V0cyBlbXB0eSBvYmplY3RzIGZvciBtaXNzaW5nIG1hcCBmaWVsZHMgZXZlbiBpZiBgZGVmYXVsdHM9ZmFsc2VgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbmVvZnM9ZmFsc2VdIEluY2x1ZGVzIHZpcnR1YWwgb25lb2YgcHJvcGVydGllcyBzZXQgdG8gdGhlIHByZXNlbnQgZmllbGQncyBuYW1lLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2pzb249ZmFsc2VdIFBlcmZvcm1zIGFkZGl0aW9uYWwgSlNPTiBjb21wYXRpYmlsaXR5IGNvbnZlcnNpb25zLCBpLmUuIE5hTiBhbmQgSW5maW5pdHkgdG8gc3RyaW5nc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtJQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gKi9cblR5cGUucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiBhcyByZXR1cm5lZCBieSB7QGxpbmsgVHlwZS5kfSAoVHlwZVNjcmlwdCkuXG4gKiBAdHlwZWRlZiBUeXBlRGVjb3JhdG9yXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFQ+fSB0YXJnZXQgVGFyZ2V0IGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKi9cblxuLyoqXG4gKiBUeXBlIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVOYW1lXSBUeXBlIG5hbWUsIGRlZmF1bHRzIHRvIHRoZSBjb25zdHJ1Y3RvcidzIG5hbWVcbiAqIEByZXR1cm5zIHtUeXBlRGVjb3JhdG9yPFQ+fSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICovXG5UeXBlLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZVR5cGUodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHlwZURlY29yYXRvcih0YXJnZXQpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUodGFyZ2V0LCB0eXBlTmFtZSk7XG4gICAgfTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJvb3Q7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChSb290LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gUm9vdCkuY2xhc3NOYW1lID0gXCJSb290XCI7XG5cbnZhciBGaWVsZCAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgRW51bSAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgT25lT2YgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgVHlwZSwgICAvLyBjeWNsaWNcbiAgICBwYXJzZSwgIC8vIG1pZ2h0IGJlIGV4Y2x1ZGVkXG4gICAgY29tbW9uOyAvLyBcIlxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcm9vdCBuYW1lc3BhY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJvb3QgbmFtZXNwYWNlIHdyYXBwaW5nIGFsbCB0eXBlcywgZW51bXMsIHNlcnZpY2VzLCBzdWItbmFtZXNwYWNlcyBldGMuIHRoYXQgYmVsb25nIHRvZ2V0aGVyLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gVG9wIGxldmVsIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUm9vdChvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgXCJcIiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnJlZCBleHRlbnNpb24gZmllbGRzLlxuICAgICAqIEB0eXBlIHtGaWVsZFtdfVxuICAgICAqL1xuICAgIHRoaXMuZGVmZXJyZWQgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIGZpbGUgbmFtZXMgb2YgbG9hZGVkIGZpbGVzLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGVzID0gW107XG59XG5cbi8qKlxuICogTG9hZHMgYSBuYW1lc3BhY2UgZGVzY3JpcHRvciBpbnRvIGEgcm9vdCBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge0lOYW1lc3BhY2V9IGpzb24gTmFtZWVzcGFjZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcbiAqL1xuUm9vdC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGpzb24sIHJvb3QpIHtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHJvb3QgPSBuZXcgUm9vdCgpO1xuICAgIGlmIChqc29uLm9wdGlvbnMpXG4gICAgICAgIHJvb3Quc2V0T3B0aW9ucyhqc29uLm9wdGlvbnMpO1xuICAgIHJldHVybiByb290LmFkZEpTT04oanNvbi5uZXN0ZWQpO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aCBvZiBhbiBpbXBvcnRlZCBmaWxlLCByZWxhdGl2ZSB0byB0aGUgaW1wb3J0aW5nIG9yaWdpbi5cbiAqIFRoaXMgbWV0aG9kIGV4aXN0cyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggeW91ciBvd24gbG9naWMgaW4gY2FzZSB5b3VyIGltcG9ydHMgYXJlIHNjYXR0ZXJlZCBvdmVyIG11bHRpcGxlIGRpcmVjdG9yaWVzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIFRoZSBmaWxlIG5hbWUgb2YgdGhlIGltcG9ydGluZyBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFRoZSBmaWxlIG5hbWUgYmVpbmcgaW1wb3J0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gUmVzb2x2ZWQgcGF0aCB0byBgdGFyZ2V0YCBvciBgbnVsbGAgdG8gc2tpcCB0aGUgZmlsZVxuICovXG5Sb290LnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IHV0aWwucGF0aC5yZXNvbHZlO1xuXG4vKipcbiAqIEZldGNoIGNvbnRlbnQgZnJvbSBmaWxlIHBhdGggb3IgdXJsXG4gKiBUaGlzIG1ldGhvZCBleGlzdHMgc28geW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duIGxvZ2ljLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBGaWxlIHBhdGggb3IgdXJsXG4gKiBAcGFyYW0ge0ZldGNoQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5Sb290LnByb3RvdHlwZS5mZXRjaCA9IHV0aWwuZmV0Y2g7XG5cbi8vIEEgc3ltYm9sLWxpa2UgZnVuY3Rpb24gdG8gc2FmZWx5IHNpZ25hbCBzeW5jaHJvbm91cyBsb2FkaW5nXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gU1lOQygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBvcHRpb25zIFBhcnNlIG9wdGlvbnNcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUm9vdC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKGxvYWQsIHNlbGYsIGZpbGVuYW1lLCBvcHRpb25zKTtcblxuICAgIHZhciBzeW5jID0gY2FsbGJhY2sgPT09IFNZTkM7IC8vIHVuZG9jdW1lbnRlZFxuXG4gICAgLy8gRmluaXNoZXMgbG9hZGluZyBieSBjYWxsaW5nIHRoZSBjYWxsYmFjayAoZXhhY3RseSBvbmNlKVxuICAgIGZ1bmN0aW9uIGZpbmlzaChlcnIsIHJvb3QpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjYiA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICBjYihlcnIsIHJvb3QpO1xuICAgIH1cblxuICAgIC8vIEJ1bmRsZWQgZGVmaW5pdGlvbiBleGlzdGVuY2UgY2hlY2tpbmdcbiAgICBmdW5jdGlvbiBnZXRCdW5kbGVkRmlsZU5hbWUoZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIGlkeCA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKFwiZ29vZ2xlL3Byb3RvYnVmL1wiKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgYWx0bmFtZSA9IGZpbGVuYW1lLnN1YnN0cmluZyhpZHgpO1xuICAgICAgICAgICAgaWYgKGFsdG5hbWUgaW4gY29tbW9uKSByZXR1cm4gYWx0bmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzZXMgYSBzaW5nbGUgZmlsZVxuICAgIGZ1bmN0aW9uIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoc291cmNlKSAmJiBzb3VyY2UuY2hhckF0KDApID09PSBcIntcIilcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBKU09OLnBhcnNlKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcoc291cmNlKSlcbiAgICAgICAgICAgICAgICBzZWxmLnNldE9wdGlvbnMoc291cmNlLm9wdGlvbnMpLmFkZEpTT04oc291cmNlLm5lc3RlZCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZS5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZShzb3VyY2UsIHNlbGYsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5pbXBvcnRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHBhcnNlZC5pbXBvcnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID0gZ2V0QnVuZGxlZEZpbGVOYW1lKHBhcnNlZC5pbXBvcnRzW2ldKSB8fCBzZWxmLnJlc29sdmVQYXRoKGZpbGVuYW1lLCBwYXJzZWQuaW1wb3J0c1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQud2Vha0ltcG9ydHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJzZWQud2Vha0ltcG9ydHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPSBnZXRCdW5kbGVkRmlsZU5hbWUocGFyc2VkLndlYWtJbXBvcnRzW2ldKSB8fCBzZWxmLnJlc29sdmVQYXRoKGZpbGVuYW1lLCBwYXJzZWQud2Vha0ltcG9ydHNbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHJlc29sdmVkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN5bmMgJiYgIXF1ZXVlZClcbiAgICAgICAgICAgIGZpbmlzaChudWxsLCBzZWxmKTsgLy8gb25seSBvbmNlIGFueXdheVxuICAgIH1cblxuICAgIC8vIEZldGNoZXMgYSBzaW5nbGUgZmlsZVxuICAgIGZ1bmN0aW9uIGZldGNoKGZpbGVuYW1lLCB3ZWFrKSB7XG5cbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGxvYWRlZCAvIGF0dGVtcHRlZFxuICAgICAgICBpZiAoc2VsZi5maWxlcy5pbmRleE9mKGZpbGVuYW1lKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZWxmLmZpbGVzLnB1c2goZmlsZW5hbWUpO1xuXG4gICAgICAgIC8vIFNob3J0Y3V0IGJ1bmRsZWQgZGVmaW5pdGlvbnNcbiAgICAgICAgaWYgKGZpbGVuYW1lIGluIGNvbW1vbikge1xuICAgICAgICAgICAgaWYgKHN5bmMpXG4gICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgY29tbW9uW2ZpbGVuYW1lXSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3F1ZXVlZDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAtLXF1ZXVlZDtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgY29tbW9uW2ZpbGVuYW1lXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UgZmV0Y2ggZnJvbSBkaXNrIG9yIG5ldHdvcmtcbiAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdlYWspXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK3F1ZXVlZDtcbiAgICAgICAgICAgIHNlbGYuZmV0Y2goZmlsZW5hbWUsIGZ1bmN0aW9uKGVyciwgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgLS1xdWV1ZWQ7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB0ZXJtaW5hdGVkIG1lYW53aGlsZVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3ZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFxdWV1ZWQpIC8vIGNhbid0IGJlIGNvdmVyZWQgcmVsaWFibHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChudWxsLCBzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBzb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHF1ZXVlZCA9IDA7XG5cbiAgICAvLyBBc3NlbWJsaW5nIHRoZSByb290IG5hbWVzcGFjZSBkb2Vzbid0IHJlcXVpcmUgd29ya2luZyB0eXBlXG4gICAgLy8gcmVmZXJlbmNlcyBhbnltb3JlLCBzbyB3ZSBjYW4gbG9hZCBldmVyeXRoaW5nIGluIHBhcmFsbGVsXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcoZmlsZW5hbWUpKVxuICAgICAgICBmaWxlbmFtZSA9IFsgZmlsZW5hbWUgXTtcbiAgICBmb3IgKHZhciBpID0gMCwgcmVzb2x2ZWQ7IGkgPCBmaWxlbmFtZS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKHJlc29sdmVkID0gc2VsZi5yZXNvbHZlUGF0aChcIlwiLCBmaWxlbmFtZVtpXSkpXG4gICAgICAgICAgICBmZXRjaChyZXNvbHZlZCk7XG5cbiAgICBpZiAoc3luYylcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKCFxdWV1ZWQpXG4gICAgICAgIGZpbmlzaChudWxsLCBzZWxmKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBvcHRpb25zOklQYXJzZU9wdGlvbnMsIGNhbGxiYWNrOkxvYWRDYWxsYmFjayk6dW5kZWZpbmVkXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAZnVuY3Rpb24gUm9vdCNsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFJvb3Q+fSBQcm9taXNlXG4gKiBAdmFyaWF0aW9uIDNcbiAqL1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIFtvcHRpb25zOklQYXJzZU9wdGlvbnNdKTpQcm9taXNlPFJvb3Q+XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgKG5vZGUgb25seSkuXG4gKiBAZnVuY3Rpb24gUm9vdCNsb2FkU3luY1xuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtSb290fSBSb290IG5hbWVzcGFjZVxuICogQHRocm93cyB7RXJyb3J9IElmIHN5bmNocm9ub3VzIGZldGNoaW5nIGlzIG5vdCBzdXBwb3J0ZWQgKGkuZS4gaW4gYnJvd3NlcnMpIG9yIGlmIGEgZmlsZSdzIHN5bnRheCBpcyBpbnZhbGlkXG4gKi9cblJvb3QucHJvdG90eXBlLmxvYWRTeW5jID0gZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWwuaXNOb2RlKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vdCBzdXBwb3J0ZWRcIik7XG4gICAgcmV0dXJuIHRoaXMubG9hZChmaWxlbmFtZSwgb3B0aW9ucywgU1lOQyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5Sb290LnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICBpZiAodGhpcy5kZWZlcnJlZC5sZW5ndGgpXG4gICAgICAgIHRocm93IEVycm9yKFwidW5yZXNvbHZhYmxlIGV4dGVuc2lvbnM6IFwiICsgdGhpcy5kZWZlcnJlZC5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIidleHRlbmQgXCIgKyBmaWVsZC5leHRlbmQgKyBcIicgaW4gXCIgKyBmaWVsZC5wYXJlbnQuZnVsbE5hbWU7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbC5jYWxsKHRoaXMpO1xufTtcblxuLy8gb25seSB1cHBlcmNhc2VkIChhbmQgdGh1cyBjb25mbGljdC1mcmVlKSBjaGlsZHJlbiBhcmUgZXhwb3NlZCwgc2VlIGJlbG93XG52YXIgZXhwb3NlUmUgPSAvXltBLVpdLztcblxuLyoqXG4gKiBIYW5kbGVzIGEgZGVmZXJyZWQgZGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZCBieSBjcmVhdGluZyBhIHNpc3RlciBmaWVsZCB0byByZXByZXNlbnQgaXQgd2l0aGluIGl0cyBleHRlbmRlZCB0eXBlLlxuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIERlY2xhcmluZyBleHRlbnNpb24gZmllbGQgd2l0aW4gdGhlIGRlY2xhcmluZyB0eXBlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHN1Y2Nlc3NmdWxseSBhZGRlZCB0byB0aGUgZXh0ZW5kZWQgdHlwZSwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEBpbm5lclxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiB0cnlIYW5kbGVFeHRlbnNpb24ocm9vdCwgZmllbGQpIHtcbiAgICB2YXIgZXh0ZW5kZWRUeXBlID0gZmllbGQucGFyZW50Lmxvb2t1cChmaWVsZC5leHRlbmQpO1xuICAgIGlmIChleHRlbmRlZFR5cGUpIHtcbiAgICAgICAgdmFyIHNpc3RlckZpZWxkID0gbmV3IEZpZWxkKGZpZWxkLmZ1bGxOYW1lLCBmaWVsZC5pZCwgZmllbGQudHlwZSwgZmllbGQucnVsZSwgdW5kZWZpbmVkLCBmaWVsZC5vcHRpb25zKTtcbiAgICAgICAgc2lzdGVyRmllbGQuZGVjbGFyaW5nRmllbGQgPSBmaWVsZDtcbiAgICAgICAgZmllbGQuZXh0ZW5zaW9uRmllbGQgPSBzaXN0ZXJGaWVsZDtcbiAgICAgICAgZXh0ZW5kZWRUeXBlLmFkZChzaXN0ZXJGaWVsZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYW55IG9iamVjdCBpcyBhZGRlZCB0byB0aGlzIHJvb3Qgb3IgaXRzIHN1Yi1uYW1lc3BhY2VzLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgT2JqZWN0IGFkZGVkXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuUm9vdC5wcm90b3R5cGUuX2hhbmRsZUFkZCA9IGZ1bmN0aW9uIF9oYW5kbGVBZGQob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkKSB7XG5cbiAgICAgICAgaWYgKC8qIGFuIGV4dGVuc2lvbiBmaWVsZCAoaW1wbGllcyBub3QgcGFydCBvZiBhIG9uZW9mKSAqLyBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQgJiYgLyogbm90IGFscmVhZHkgaGFuZGxlZCAqLyAhb2JqZWN0LmV4dGVuc2lvbkZpZWxkKVxuICAgICAgICAgICAgaWYgKCF0cnlIYW5kbGVFeHRlbnNpb24odGhpcywgb2JqZWN0KSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnB1c2gob2JqZWN0KTtcblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRW51bSkge1xuXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0LnZhbHVlczsgLy8gZXhwb3NlIGVudW0gdmFsdWVzIGFzIHByb3BlcnR5IG9mIGl0cyBwYXJlbnRcblxuICAgIH0gZWxzZSBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikpIC8qIGV2ZXJ5dGhpbmcgZWxzZSBpcyBhIG5hbWVzcGFjZSAqLyB7XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFR5cGUpIC8vIFRyeSB0byBoYW5kbGUgYW55IGRlZmVycmVkIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kZWZlcnJlZC5sZW5ndGg7KVxuICAgICAgICAgICAgICAgIGlmICh0cnlIYW5kbGVFeHRlbnNpb24odGhpcywgdGhpcy5kZWZlcnJlZFtpXSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IC8qIGluaXRpYWxpemVzICovIG9iamVjdC5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraikgLy8gcmVjdXJzZSBpbnRvIHRoZSBuYW1lc3BhY2VcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFkZChvYmplY3QuX25lc3RlZEFycmF5W2pdKTtcbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudFtvYmplY3QubmFtZV0gPSBvYmplY3Q7IC8vIGV4cG9zZSBuYW1lc3BhY2UgYXMgcHJvcGVydHkgb2YgaXRzIHBhcmVudFxuICAgIH1cblxuICAgIC8vIFRoZSBhYm92ZSBhbHNvIGFkZHMgdXBwZXJjYXNlZCAoYW5kIHRodXMgY29uZmxpY3QtZnJlZSkgbmVzdGVkIHR5cGVzLCBzZXJ2aWNlcyBhbmQgZW51bXMgYXNcbiAgICAvLyBwcm9wZXJ0aWVzIG9mIG5hbWVzcGFjZXMganVzdCBsaWtlIHN0YXRpYyBjb2RlIGRvZXMuIFRoaXMgYWxsb3dzIHVzaW5nIGEgLmQudHMgZ2VuZXJhdGVkIGZvclxuICAgIC8vIGEgc3RhdGljIG1vZHVsZSB3aXRoIHJlZmxlY3Rpb24tYmFzZWQgc29sdXRpb25zIHdoZXJlIHRoZSBjb25kaXRpb24gaXMgbWV0LlxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhbnkgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB0aGlzIHJvb3Qgb3IgaXRzIHN1Yi1uYW1lc3BhY2VzLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgT2JqZWN0IHJlbW92ZWRcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5Sb290LnByb3RvdHlwZS5faGFuZGxlUmVtb3ZlID0gZnVuY3Rpb24gX2hhbmRsZVJlbW92ZShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQpIHtcblxuICAgICAgICBpZiAoLyogYW4gZXh0ZW5zaW9uIGZpZWxkICovIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKC8qIGFscmVhZHkgaGFuZGxlZCAqLyBvYmplY3QuZXh0ZW5zaW9uRmllbGQpIHsgLy8gcmVtb3ZlIGl0cyBzaXN0ZXIgZmllbGRcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZW5zaW9uRmllbGQucGFyZW50LnJlbW92ZShvYmplY3QuZXh0ZW5zaW9uRmllbGQpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlbnNpb25GaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBjYW5jZWwgdGhlIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZGVmZXJyZWQuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFbnVtKSB7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBlbnVtIHZhbHVlc1xuXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UpIHtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIG9iamVjdC5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSkgLy8gcmVjdXJzZSBpbnRvIHRoZSBuYW1lc3BhY2VcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVJlbW92ZShvYmplY3QuX25lc3RlZEFycmF5W2ldKTtcblxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0LnBhcmVudFtvYmplY3QubmFtZV07IC8vIHVuZXhwb3NlIG5hbWVzcGFjZXNcblxuICAgIH1cbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuUm9vdC5fY29uZmlndXJlID0gZnVuY3Rpb24oVHlwZV8sIHBhcnNlXywgY29tbW9uXykge1xuICAgIFR5cGUgICA9IFR5cGVfO1xuICAgIHBhcnNlICA9IHBhcnNlXztcbiAgICBjb21tb24gPSBjb21tb25fO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgcm9vdHMgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcblxudmFyIFR5cGUsIC8vIGN5Y2xpY1xuICAgIEVudW07XG5cbnV0aWwuY29kZWdlbiA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9jb2RlZ2VuXCIpO1xudXRpbC5mZXRjaCAgID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2ZldGNoXCIpO1xudXRpbC5wYXRoICAgID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3BhdGhcIik7XG5cbi8qKlxuICogTm9kZSdzIGZzIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XG4gKi9cbnV0aWwuZnMgPSB1dGlsLmlucXVpcmUoXCJmc1wiKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QncyB2YWx1ZXMgdG8gYW4gYXJyYXkuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgT2JqZWN0IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtBcnJheS48Kj59IENvbnZlcnRlZCBhcnJheVxuICovXG51dGlsLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KG9iamVjdCkge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIGtleXMgID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwga2V5cy5sZW5ndGgpXG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSBvYmplY3Rba2V5c1tpbmRleCsrXV07XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBrZXlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZWlyIHJlc3BlY3RpdmUgdmFsdWUgdG8gYW4gb2JqZWN0LCBvbWl0dGluZyB1bmRlZmluZWQgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheS48Kj59IGFycmF5IEFycmF5IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gQ29udmVydGVkIG9iamVjdFxuICovXG51dGlsLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QoYXJyYXkpIHtcbiAgICB2YXIgb2JqZWN0ID0ge30sXG4gICAgICAgIGluZGV4ICA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBhcnJheVtpbmRleCsrXSxcbiAgICAgICAgICAgIHZhbCA9IGFycmF5W2luZGV4KytdO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBzYWZlUHJvcEJhY2tzbGFzaFJlID0gL1xcXFwvZyxcbiAgICBzYWZlUHJvcFF1b3RlUmUgICAgID0gL1wiL2c7XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgYSByZXNlcnZlZCB3b3JkIGluIEpTLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzUmVzZXJ2ZWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkKG5hbWUpIHtcbiAgICByZXR1cm4gL14oPzpkb3xpZnxpbnxmb3J8bGV0fG5ld3x0cnl8dmFyfGNhc2V8ZWxzZXxlbnVtfGV2YWx8ZmFsc2V8bnVsbHx0aGlzfHRydWV8dm9pZHx3aXRofGJyZWFrfGNhdGNofGNsYXNzfGNvbnN0fHN1cGVyfHRocm93fHdoaWxlfHlpZWxkfGRlbGV0ZXxleHBvcnR8aW1wb3J0fHB1YmxpY3xyZXR1cm58c3RhdGljfHN3aXRjaHx0eXBlb2Z8ZGVmYXVsdHxleHRlbmRzfGZpbmFsbHl8cGFja2FnZXxwcml2YXRlfGNvbnRpbnVlfGRlYnVnZ2VyfGZ1bmN0aW9ufGFyZ3VtZW50c3xpbnRlcmZhY2V8cHJvdGVjdGVkfGltcGxlbWVudHN8aW5zdGFuY2VvZikkLy50ZXN0KG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc2FmZSBwcm9wZXJ0eSBhY2Nlc3NvciBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gU2FmZSBhY2Nlc3NvclxuICovXG51dGlsLnNhZmVQcm9wID0gZnVuY3Rpb24gc2FmZVByb3AocHJvcCkge1xuICAgIGlmICghL15bJFxcd19dKyQvLnRlc3QocHJvcCkgfHwgdXRpbC5pc1Jlc2VydmVkKHByb3ApKVxuICAgICAgICByZXR1cm4gXCJbXFxcIlwiICsgcHJvcC5yZXBsYWNlKHNhZmVQcm9wQmFja3NsYXNoUmUsIFwiXFxcXFxcXFxcIikucmVwbGFjZShzYWZlUHJvcFF1b3RlUmUsIFwiXFxcXFxcXCJcIikgKyBcIlxcXCJdXCI7XG4gICAgcmV0dXJuIFwiLlwiICsgcHJvcDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byB1cHBlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLnVjRmlyc3QgPSBmdW5jdGlvbiB1Y0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxudmFyIGNhbWVsQ2FzZVJlID0gL18oW2Etel0pL2c7XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgdG8gY2FtZWwgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5jYW1lbENhc2UgPSBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMSlcbiAgICAgICAgICsgc3RyLnN1YnN0cmluZygxKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoY2FtZWxDYXNlUmUsIGZ1bmN0aW9uKCQwLCAkMSkgeyByZXR1cm4gJDEudG9VcHBlckNhc2UoKTsgfSk7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHJlZmxlY3RlZCBmaWVsZHMgYnkgaWQuXG4gKiBAcGFyYW0ge0ZpZWxkfSBhIEZpcnN0IGZpZWxkXG4gKiBAcGFyYW0ge0ZpZWxkfSBiIFNlY29uZCBmaWVsZFxuICogQHJldHVybnMge251bWJlcn0gQ29tcGFyaXNvbiB2YWx1ZVxuICovXG51dGlsLmNvbXBhcmVGaWVsZHNCeUlkID0gZnVuY3Rpb24gY29tcGFyZUZpZWxkc0J5SWQoYSwgYikge1xuICAgIHJldHVybiBhLmlkIC0gYi5pZDtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIGhlbHBlciBmb3IgdHlwZXMgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlTmFtZV0gVHlwZSBuYW1lLCBkZWZhdWx0cyB0byB0aGUgY29uc3RydWN0b3IncyBuYW1lXG4gKiBAcmV0dXJucyB7VHlwZX0gUmVmbGVjdGVkIHR5cGVcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHByb3BlcnR5IHtSb290fSByb290IERlY29yYXRvcnMgcm9vdFxuICovXG51dGlsLmRlY29yYXRlVHlwZSA9IGZ1bmN0aW9uIGRlY29yYXRlVHlwZShjdG9yLCB0eXBlTmFtZSkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGN0b3IuJHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVOYW1lICYmIGN0b3IuJHR5cGUubmFtZSAhPT0gdHlwZU5hbWUpIHtcbiAgICAgICAgICAgIHV0aWwuZGVjb3JhdGVSb290LnJlbW92ZShjdG9yLiR0eXBlKTtcbiAgICAgICAgICAgIGN0b3IuJHR5cGUubmFtZSA9IHR5cGVOYW1lO1xuICAgICAgICAgICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKGN0b3IuJHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdG9yLiR0eXBlO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFUeXBlKVxuICAgICAgICBUeXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcblxuICAgIHZhciB0eXBlID0gbmV3IFR5cGUodHlwZU5hbWUgfHwgY3Rvci5uYW1lKTtcbiAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQodHlwZSk7XG4gICAgdHlwZS5jdG9yID0gY3RvcjsgLy8gc2V0cyB1cCAuZW5jb2RlLCAuZGVjb2RlIGV0Yy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3RvciwgXCIkdHlwZVwiLCB7IHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsIFwiJHR5cGVcIiwgeyB2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG52YXIgZGVjb3JhdGVFbnVtSW5kZXggPSAwO1xuXG4vKipcbiAqIERlY29yYXRvciBoZWxwZXIgZm9yIGVudW1zIChUeXBlU2NyaXB0KS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgRW51bSBvYmplY3RcbiAqIEByZXR1cm5zIHtFbnVtfSBSZWZsZWN0ZWQgZW51bVxuICovXG51dGlsLmRlY29yYXRlRW51bSA9IGZ1bmN0aW9uIGRlY29yYXRlRW51bShvYmplY3QpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvYmplY3QuJHR5cGUpXG4gICAgICAgIHJldHVybiBvYmplY3QuJHR5cGU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghRW51bSlcbiAgICAgICAgRW51bSA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5cbiAgICB2YXIgZW5tID0gbmV3IEVudW0oXCJFbnVtXCIgKyBkZWNvcmF0ZUVudW1JbmRleCsrLCBvYmplY3QpO1xuICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZChlbm0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIFwiJHR5cGVcIiwgeyB2YWx1ZTogZW5tLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gZW5tO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYnkgcHJvcGVydHkgcGF0aC4gSWYgYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cywgaXQgaXMgdHVybmVkIHRvIGFuIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBkb3QgJy4nIGRlbGltaXRlZCBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG51dGlsLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkoZHN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHNldFByb3AoZHN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgaWYgKHBhcnQgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRzdFtwYXJ0XSA9IHNldFByb3AoZHN0W3BhcnRdIHx8IHt9LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gZHN0W3BhcnRdO1xuICAgICAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChwcmV2VmFsdWUpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgICAgICBkc3RbcGFydF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZHN0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJkc3QgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJwYXRoIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIHJldHVybiBzZXRQcm9wKGRzdCwgcGF0aCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3Igcm9vdCAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSB1dGlsLmRlY29yYXRlUm9vdFxuICogQHR5cGUge1Jvb3R9XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHV0aWwsIFwiZGVjb3JhdGVSb290XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcm9vdHNbXCJkZWNvcmF0ZWRcIl0gfHwgKHJvb3RzW1wiZGVjb3JhdGVkXCJdID0gbmV3IChyZXF1aXJlKFwiLi9yb290XCIpKSgpKTtcbiAgICB9XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdGlvbk9iamVjdDtcblxuUmVmbGVjdGlvbk9iamVjdC5jbGFzc05hbWUgPSBcIlJlZmxlY3Rpb25PYmplY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgUm9vdDsgLy8gY3ljbGljXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0aW9uIG9iamVjdCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGlvbiBvYmplY3RzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPYmplY3QgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBhYnN0cmFjdFxuICovXG5mdW5jdGlvbiBSZWZsZWN0aW9uT2JqZWN0KG5hbWUsIG9wdGlvbnMpIHtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgIXV0aWwuaXNPYmplY3Qob3B0aW9ucykpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZWQgT3B0aW9ucy5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCo+Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5wYXJzZWRPcHRpb25zID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIFBhcmVudCBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUge05hbWVzcGFjZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYWxyZWFkeSByZXNvbHZlZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCB0ZXh0LCBpZiBhbnkuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmluZyBmaWxlIG5hbWUuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSByb290IG5hbWVzcGFjZS5cbiAgICAgKiBAbmFtZSBSZWZsZWN0aW9uT2JqZWN0I3Jvb3RcbiAgICAgKiBAdHlwZSB7Um9vdH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICByb290OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHRyID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChwdHIucGFyZW50ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gcHRyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bGwgbmFtZSBpbmNsdWRpbmcgbGVhZGluZyBkb3QuXG4gICAgICogQG5hbWUgUmVmbGVjdGlvbk9iamVjdCNmdWxsTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZnVsbE5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gWyB0aGlzLm5hbWUgXSxcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwdHIpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQocHRyLm5hbWUpO1xuICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgcmVmbGVjdGlvbiBvYmplY3QgdG8gaXRzIGRlc2NyaXB0b3IgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc2NyaXB0b3JcbiAqIEBhYnN0cmFjdFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS50b0pTT04gPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdGhyb3cgRXJyb3IoKTsgLy8gbm90IGltcGxlbWVudGVkLCBzaG91bGRuJ3QgaGFwcGVuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIGFkZGVkIHRvIGEgcGFyZW50LlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBwYXJlbnQgUGFyZW50IGFkZGVkIHRvXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uIG9uQWRkKHBhcmVudCkge1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudCAhPT0gcGFyZW50KVxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciByb290ID0gcGFyZW50LnJvb3Q7XG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBSb290KVxuICAgICAgICByb290Ll9oYW5kbGVBZGQodGhpcyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBhIHBhcmVudC5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gcGFyZW50IFBhcmVudCByZW1vdmVkIGZyb21cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gb25SZW1vdmUocGFyZW50KSB7XG4gICAgdmFyIHJvb3QgPSBwYXJlbnQucm9vdDtcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHJvb3QuX2hhbmRsZVJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIG9iamVjdHMgdHlwZSByZWZlcmVuY2VzLlxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlOyAvLyBvbmx5IGlmIHBhcnQgb2YgYSByb290XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gb3B0aW9uIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT3B0aW9uIG5hbWVcbiAqIEByZXR1cm5zIHsqfSBPcHRpb24gdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWYgbm90IHNldFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbiBnZXRPcHRpb24obmFtZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZV07XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBvcHRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPcHRpb24gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0XSBTZXRzIHRoZSBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIHNldE9wdGlvbihuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpIHtcbiAgICBpZiAoIWlmTm90U2V0IHx8ICF0aGlzLm9wdGlvbnMgfHwgdGhpcy5vcHRpb25zW25hbWVdID09PSB1bmRlZmluZWQpXG4gICAgICAgICh0aGlzLm9wdGlvbnMgfHwgKHRoaXMub3B0aW9ucyA9IHt9KSlbbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIHBhcnNlZCBvcHRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBwYXJzZWQgT3B0aW9uIG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgZG90ICcuJyBkZWxpbWl0ZWQgZnVsbCBwYXRoIG9mIHByb3BlcnR5IHdpdGhpbiB0aGUgb3B0aW9uIHRvIHNldC4gaWYgdW5kZWZpbmVkXFxlbXB0eSwgd2lsbCBhZGQgYSBuZXcgb3B0aW9uIHdpdGggdGhhdCB2YWx1ZVxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRQYXJzZWRPcHRpb24gPSBmdW5jdGlvbiBzZXRQYXJzZWRPcHRpb24obmFtZSwgdmFsdWUsIHByb3BOYW1lKSB7XG4gICAgaWYgKCF0aGlzLnBhcnNlZE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wYXJzZWRPcHRpb25zID0gW107XG4gICAgfVxuICAgIHZhciBwYXJzZWRPcHRpb25zID0gdGhpcy5wYXJzZWRPcHRpb25zO1xuICAgIGlmIChwcm9wTmFtZSkge1xuICAgICAgICAvLyBJZiBzZXR0aW5nIGEgc3ViIHByb3BlcnR5IG9mIGFuIG9wdGlvbiB0aGVuIHRyeSB0byBtZXJnZSBpdFxuICAgICAgICAvLyB3aXRoIGFuIGV4aXN0aW5nIG9wdGlvblxuICAgICAgICB2YXIgb3B0ID0gcGFyc2VkT3B0aW9ucy5maW5kKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0LCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGFuIGV4aXN0aW5nIG9wdGlvbiAtIGp1c3QgbWVyZ2UgdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBvcHRbbmFtZV07XG4gICAgICAgICAgICB1dGlsLnNldFByb3BlcnR5KG5ld1ZhbHVlLCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgb3B0aW9uLCBzZXQgaXQncyBwcm9wZXJ0eSBhbmQgYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICAgICAgICBvcHQgPSB7fTtcbiAgICAgICAgICAgIG9wdFtuYW1lXSA9IHV0aWwuc2V0UHJvcGVydHkoe30sIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zLnB1c2gob3B0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFsd2F5cyBjcmVhdGUgYSBuZXcgb3B0aW9uIHdoZW4gc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBpdHNlbGZcbiAgICAgICAgdmFyIG5ld09wdCA9IHt9O1xuICAgICAgICBuZXdPcHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcGFyc2VkT3B0aW9ucy5wdXNoKG5ld09wdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIG11bHRpcGxlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zIE9wdGlvbnMgdG8gc2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldF0gU2V0cyBhbiBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGlmTm90U2V0KSB7XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb24oa2V5c1tpXSwgb3B0aW9uc1trZXlzW2ldXSwgaWZOb3RTZXQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGluc3RhbmNlIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDbGFzcyBuYW1lWywgc3BhY2UsIGZ1bGwgbmFtZV1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWUsXG4gICAgICAgIGZ1bGxOYW1lICA9IHRoaXMuZnVsbE5hbWU7XG4gICAgaWYgKGZ1bGxOYW1lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIFwiICsgZnVsbE5hbWU7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuUmVmbGVjdGlvbk9iamVjdC5fY29uZmlndXJlID0gZnVuY3Rpb24oUm9vdF8pIHtcbiAgICBSb290ID0gUm9vdF87XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBFbnVtO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChFbnVtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEVudW0pLmNsYXNzTmFtZSA9IFwiRW51bVwiO1xuXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgZW51bSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIGVudW0uXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLG51bWJlcj59IFt2YWx1ZXNdIEVudW0gdmFsdWVzIGFzIGFuIG9iamVjdCwgYnkgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gVGhlIGNvbW1lbnQgZm9yIHRoaXMgZW51bVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBbY29tbWVudHNdIFRoZSB2YWx1ZSBjb21tZW50cyBmb3IgdGhpcyBlbnVtXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLE9iamVjdDxzdHJpbmcsKj4+fHVuZGVmaW5lZH0gW3ZhbHVlc09wdGlvbnNdIFRoZSB2YWx1ZSBvcHRpb25zIGZvciB0aGlzIGVudW1cbiAqL1xuZnVuY3Rpb24gRW51bShuYW1lLCB2YWx1ZXMsIG9wdGlvbnMsIGNvbW1lbnQsIGNvbW1lbnRzLCB2YWx1ZXNPcHRpb25zKSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlcyAmJiB0eXBlb2YgdmFsdWVzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJ2YWx1ZXMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG5cbiAgICAvKipcbiAgICAgKiBFbnVtIHZhbHVlcyBieSBpZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlc0J5SWQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEVudW0gdmFsdWVzIGJ5IG5hbWUuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHRoaXMudmFsdWVzQnlJZCk7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBFbnVtIGNvbW1lbnQgdGV4dC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGNvbW1lbnQgdGV4dHMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnRzID0gY29tbWVudHMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZXMgb3B0aW9ucywgaWYgYW55XG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsICo+Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNPcHRpb25zID0gdmFsdWVzT3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIFJlc2VydmVkIHJhbmdlcywgaWYgYW55LlxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyW118c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2VydmVkID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8vIE5vdGUgdGhhdCB2YWx1ZXMgaW5oZXJpdCB2YWx1ZXNCeUlkIG9uIHRoZWlyIHByb3RvdHlwZSB3aGljaCBtYWtlcyB0aGVtIGEgVHlwZVNjcmlwdC1cbiAgICAvLyBjb21wYXRpYmxlIGVudW0uIFRoaXMgaXMgdXNlZCBieSBwYnRzIHRvIHdyaXRlIGFjdHVhbCBlbnVtIGRlZmluaXRpb25zIHRoYXQgd29yayBmb3JcbiAgICAvLyBzdGF0aWMgYW5kIHJlZmxlY3Rpb24gY29kZSBhbGlrZSBpbnN0ZWFkIG9mIGVtaXR0aW5nIGdlbmVyaWMgb2JqZWN0IGRlZmluaXRpb25zLlxuXG4gICAgaWYgKHZhbHVlcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleXNbaV1dID09PSBcIm51bWJlclwiKSAvLyB1c2UgZm9yd2FyZCBlbnRyaWVzIG9ubHlcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc0J5SWRbIHRoaXMudmFsdWVzW2tleXNbaV1dID0gdmFsdWVzW2tleXNbaV1dIF0gPSBrZXlzW2ldO1xufVxuXG4vKipcbiAqIEVudW0gZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUVudW1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn0gdmFsdWVzIEVudW0gdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRW51bSBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW0gZnJvbSBhbiBlbnVtIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFbnVtIG5hbWVcbiAqIEBwYXJhbSB7SUVudW19IGpzb24gRW51bSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7RW51bX0gQ3JlYXRlZCBlbnVtXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5FbnVtLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHZhciBlbm0gPSBuZXcgRW51bShuYW1lLCBqc29uLnZhbHVlcywganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQsIGpzb24uY29tbWVudHMpO1xuICAgIGVubS5yZXNlcnZlZCA9IGpzb24ucmVzZXJ2ZWQ7XG4gICAgcmV0dXJuIGVubTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBlbnVtIHRvIGFuIGVudW0gZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lFbnVtfSBFbnVtIGRlc2NyaXB0b3JcbiAqL1xuRW51bS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAgICAgICAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJ2YWx1ZXNPcHRpb25zXCIgLCB0aGlzLnZhbHVlc09wdGlvbnMsXG4gICAgICAgIFwidmFsdWVzXCIgICAgICAgICwgdGhpcy52YWx1ZXMsXG4gICAgICAgIFwicmVzZXJ2ZWRcIiAgICAgICwgdGhpcy5yZXNlcnZlZCAmJiB0aGlzLnJlc2VydmVkLmxlbmd0aCA/IHRoaXMucmVzZXJ2ZWQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICAgICAgICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkLFxuICAgICAgICBcImNvbW1lbnRzXCIgICAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudHMgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIHZhbHVlIHRvIHRoaXMgZW51bS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFZhbHVlIG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBWYWx1ZSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50LCBpZiBhbnlcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+fHVuZGVmaW5lZH0gW29wdGlvbnNdIE9wdGlvbnMsIGlmIGFueVxuICogQHJldHVybnMge0VudW19IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgdmFsdWUgd2l0aCB0aGlzIG5hbWUgb3IgaWRcbiAqL1xuRW51bS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGlkLCBjb21tZW50LCBvcHRpb25zKSB7XG4gICAgLy8gdXRpbGl6ZWQgYnkgdGhlIHBhcnNlciBidXQgbm90IGJ5IC5mcm9tSlNPTlxuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzW25hbWVdICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuaXNSZXNlcnZlZElkKGlkKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpZCBcIiArIGlkICsgXCIgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWROYW1lKG5hbWUpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzQnlJZFtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmFsbG93X2FsaWFzKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlc1tuYW1lXSA9IGlkO1xuICAgIH0gZWxzZVxuICAgICAgICB0aGlzLnZhbHVlc0J5SWRbdGhpcy52YWx1ZXNbbmFtZV0gPSBpZF0gPSBuYW1lO1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzT3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy52YWx1ZXNPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMudmFsdWVzT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnMgfHwgbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbW1lbnRzW25hbWVdID0gY29tbWVudCB8fCBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGlzIGVudW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFZhbHVlIG5hbWVcbiAqIEByZXR1cm5zIHtFbnVtfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYG5hbWVgIGlzIG5vdCBhIG5hbWUgb2YgdGhpcyBlbnVtXG4gKi9cbkVudW0ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG5cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcobmFtZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlc1tuYW1lXTtcbiAgICBpZiAodmFsID09IG51bGwpXG4gICAgICAgIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0IGluIFwiICsgdGhpcyk7XG5cbiAgICBkZWxldGUgdGhpcy52YWx1ZXNCeUlkW3ZhbF07XG4gICAgZGVsZXRlIHRoaXMudmFsdWVzW25hbWVdO1xuICAgIGRlbGV0ZSB0aGlzLmNvbW1lbnRzW25hbWVdO1xuICAgIGlmICh0aGlzLnZhbHVlc09wdGlvbnMpXG4gICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlc09wdGlvbnNbbmFtZV07XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBpZCBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5FbnVtLnByb3RvdHlwZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQoaWQpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWRJZCh0aGlzLnJlc2VydmVkLCBpZCk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuRW51bS5wcm90b3R5cGUuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiBpc1Jlc2VydmVkTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkTmFtZSh0aGlzLnJlc2VydmVkLCBuYW1lKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZXI7XG5cbnZhciBFbnVtICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCBtZXNzYWdlIHR5cGUgZW5jb2Rlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCByZWYpIHtcbiAgICByZXR1cm4gZmllbGQucmVzb2x2ZWRUeXBlLmdyb3VwXG4gICAgICAgID8gZ2VuKFwidHlwZXNbJWldLmVuY29kZSglcyx3LnVpbnQzMiglaSkpLnVpbnQzMiglaSlcIiwgZmllbGRJbmRleCwgcmVmLCAoZmllbGQuaWQgPDwgMyB8IDMpID4+PiAwLCAoZmllbGQuaWQgPDwgMyB8IDQpID4+PiAwKVxuICAgICAgICA6IGdlbihcInR5cGVzWyVpXS5lbmNvZGUoJXMsdy51aW50MzIoJWkpLmZvcmsoKSkubGRlbGltKClcIiwgZmllbGRJbmRleCwgcmVmLCAoZmllbGQuaWQgPDwgMyB8IDIpID4+PiAwKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gZW5jb2RlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBlbmNvZGVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiLCBcIndcIl0sIG10eXBlLm5hbWUgKyBcIiRlbmNvZGVcIilcbiAgICAoXCJpZighdylcIilcbiAgICAgICAgKFwidz1Xcml0ZXIuY3JlYXRlKClcIik7XG5cbiAgICB2YXIgaSwgcmVmO1xuXG4gICAgLy8gXCJ3aGVuIGEgbWVzc2FnZSBpcyBzZXJpYWxpemVkIGl0cyBrbm93biBmaWVsZHMgc2hvdWxkIGJlIHdyaXR0ZW4gc2VxdWVudGlhbGx5IGJ5IGZpZWxkIG51bWJlclwiXG4gICAgdmFyIGZpZWxkcyA9IC8qIGluaXRpYWxpemVzICovIG10eXBlLmZpZWxkc0FycmF5LnNsaWNlKCkuc29ydCh1dGlsLmNvbXBhcmVGaWVsZHNCeUlkKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCAgICA9IGZpZWxkc1tpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICBpbmRleCAgICA9IG10eXBlLl9maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKSxcbiAgICAgICAgICAgIHR5cGUgICAgID0gZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSA/IFwiaW50MzJcIiA6IGZpZWxkLnR5cGUsXG4gICAgICAgICAgICB3aXJlVHlwZSA9IHR5cGVzLmJhc2ljW3R5cGVdO1xuICAgICAgICAgICAgcmVmICAgICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7XG4gICAgICAgICAgICBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwlaikpe1wiLCByZWYsIGZpZWxkLm5hbWUpIC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgKFwiZm9yKHZhciBrcz1PYmplY3Qua2V5cyglcyksaT0wO2k8a3MubGVuZ3RoOysraSl7XCIsIHJlZilcbiAgICAgICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKCkudWludDMyKCVpKS4lcyhrc1tpXSlcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMCwgOCB8IHR5cGVzLm1hcEtleVtmaWVsZC5rZXlUeXBlXSwgZmllbGQua2V5VHlwZSk7XG4gICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAoXCJ0eXBlc1slaV0uZW5jb2RlKCVzW2tzW2ldXSx3LnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKS5sZGVsaW0oKVwiLCBpbmRleCwgcmVmKTsgLy8gY2FuJ3QgYmUgZ3JvdXBzXG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwiLnVpbnQzMiglaSkuJXMoJXNba3NbaV1dKS5sZGVsaW0oKVwiLCAxNiB8IHdpcmVUeXBlLCB0eXBlLCByZWYpO1xuICAgICAgICAgICAgZ2VuXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmJXMubGVuZ3RoKXtcIiwgcmVmLCByZWYpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG5cbiAgICAgICAgICAgIC8vIFBhY2tlZCByZXBlYXRlZFxuICAgICAgICAgICAgaWYgKGZpZWxkLnBhY2tlZCAmJiB0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCkgeyBnZW5cblxuICAgICAgICAoXCJ3LnVpbnQzMiglaSkuZm9yaygpXCIsIChmaWVsZC5pZCA8PCAzIHwgMikgPj4+IDApXG4gICAgICAgIChcImZvcih2YXIgaT0wO2k8JXMubGVuZ3RoOysraSlcIiwgcmVmKVxuICAgICAgICAgICAgKFwidy4lcyglc1tpXSlcIiwgdHlwZSwgcmVmKVxuICAgICAgICAoXCJ3LmxkZWxpbSgpXCIpO1xuXG4gICAgICAgICAgICAvLyBOb24tcGFja2VkXG4gICAgICAgICAgICB9IGVsc2UgeyBnZW5cblxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpXCIsIHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBpbmRleCwgcmVmICsgXCJbaV1cIik7XG4gICAgICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgIChcIncudWludDMyKCVpKS4lcyglc1tpXSlcIiwgKGZpZWxkLmlkIDw8IDMgfCB3aXJlVHlwZSkgPj4+IDAsIHR5cGUsIHJlZik7XG5cbiAgICAgICAgICAgIH0gZ2VuXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBOb24tcmVwZWF0ZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgKFwiaWYoJXMhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sJWopKVwiLCByZWYsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG5cbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBpbmRleCwgcmVmKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgIChcIncudWludDMyKCVpKS4lcyglcylcIiwgKGZpZWxkLmlkIDw8IDMgfCB3aXJlVHlwZSkgPj4+IDAsIHR5cGUsIHJlZik7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gd1wiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5kZXgtbWluaW1hbFwiKTtcblxucHJvdG9idWYuYnVpbGQgPSBcImxpZ2h0XCI7XG5cbi8qKlxuICogQSBub2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIGxvYWR9IGFuZCB7QGxpbmsgUm9vdCNsb2FkfS5cbiAqIEB0eXBlZGVmIExvYWRDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290LCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAc2VlIHtAbGluayBSb290I2xvYWR9XG4gKi9cbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIHJvb3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiByb290ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSByb290O1xuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICB9IGVsc2UgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICByZXR1cm4gcm9vdC5sb2FkKGZpbGVuYW1lLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQG5hbWUgbG9hZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBuYW1lIGxvYWRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHJldHVybnMge1Byb21pc2U8Um9vdD59IFByb21pc2VcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqIEB2YXJpYXRpb24gM1xuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgW3Jvb3Q6Um9vdF0pOlByb21pc2U8Um9vdD5cblxucHJvdG9idWYubG9hZCA9IGxvYWQ7XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIChub2RlIG9ubHkpLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc3luY2hyb25vdXMgZmV0Y2hpbmcgaXMgbm90IHN1cHBvcnRlZCAoaS5lLiBpbiBicm93c2Vycykgb3IgaWYgYSBmaWxlJ3Mgc3ludGF4IGlzIGludmFsaWRcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZFN5bmN9XG4gKi9cbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCByb290KSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICByZXR1cm4gcm9vdC5sb2FkU3luYyhmaWxlbmFtZSk7XG59XG5cbnByb3RvYnVmLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLmVuY29kZXIgICAgICAgICAgPSByZXF1aXJlKFwiLi9lbmNvZGVyXCIpO1xucHJvdG9idWYuZGVjb2RlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2RlY29kZXJcIik7XG5wcm90b2J1Zi52ZXJpZmllciAgICAgICAgID0gcmVxdWlyZShcIi4vdmVyaWZpZXJcIik7XG5wcm90b2J1Zi5jb252ZXJ0ZXIgICAgICAgID0gcmVxdWlyZShcIi4vY29udmVydGVyXCIpO1xuXG4vLyBSZWZsZWN0aW9uXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xucHJvdG9idWYuTmFtZXNwYWNlICAgICAgICA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbnByb3RvYnVmLlJvb3QgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9yb290XCIpO1xucHJvdG9idWYuRW51bSAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5wcm90b2J1Zi5UeXBlICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnByb3RvYnVmLkZpZWxkICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKTtcbnByb3RvYnVmLk9uZU9mICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcbnByb3RvYnVmLk1hcEZpZWxkICAgICAgICAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKTtcbnByb3RvYnVmLlNlcnZpY2UgICAgICAgICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xucHJvdG9idWYuTWV0aG9kICAgICAgICAgICA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKTtcblxuLy8gUnVudGltZVxucHJvdG9idWYuTWVzc2FnZSAgICAgICAgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIik7XG5wcm90b2J1Zi53cmFwcGVycyAgICAgICAgID0gcmVxdWlyZShcIi4vd3JhcHBlcnNcIik7XG5cbi8vIFV0aWxpdHlcbnByb3RvYnVmLnR5cGVzICAgICAgICAgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnByb3RvYnVmLnV0aWwgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vLyBTZXQgdXAgcG9zc2libHkgY3ljbGljIHJlZmxlY3Rpb24gZGVwZW5kZW5jaWVzXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0Ll9jb25maWd1cmUocHJvdG9idWYuUm9vdCk7XG5wcm90b2J1Zi5OYW1lc3BhY2UuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlLCBwcm90b2J1Zi5TZXJ2aWNlLCBwcm90b2J1Zi5FbnVtKTtcbnByb3RvYnVmLlJvb3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlKTtcbnByb3RvYnVmLkZpZWxkLl9jb25maWd1cmUocHJvdG9idWYuVHlwZSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHRva2VuaXplO1xuXG52YXIgZGVsaW1SZSAgICAgICAgPSAvW1xcc3t9PTs6W1xcXSwnXCIoKTw+XS9nLFxuICAgIHN0cmluZ0RvdWJsZVJlID0gLyg/OlwiKFteXCJcXFxcXSooPzpcXFxcLlteXCJcXFxcXSopKilcIikvZyxcbiAgICBzdHJpbmdTaW5nbGVSZSA9IC8oPzonKFteJ1xcXFxdKig/OlxcXFwuW14nXFxcXF0qKSopJykvZztcblxudmFyIHNldENvbW1lbnRSZSA9IC9eICpbKi9dKyAqLyxcbiAgICBzZXRDb21tZW50QWx0UmUgPSAvXlxccypcXCo/XFwvKi8sXG4gICAgc2V0Q29tbWVudFNwbGl0UmUgPSAvXFxuL2csXG4gICAgd2hpdGVzcGFjZVJlID0gL1xccy8sXG4gICAgdW5lc2NhcGVSZSA9IC9cXFxcKC4/KS9nO1xuXG52YXIgdW5lc2NhcGVNYXAgPSB7XG4gICAgXCIwXCI6IFwiXFwwXCIsXG4gICAgXCJyXCI6IFwiXFxyXCIsXG4gICAgXCJuXCI6IFwiXFxuXCIsXG4gICAgXCJ0XCI6IFwiXFx0XCJcbn07XG5cbi8qKlxuICogVW5lc2NhcGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gdW5lc2NhcGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVuZXNjYXBlZCBzdHJpbmdcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gbWFwIFNwZWNpYWwgY2hhcmFjdGVycyBtYXBcbiAqIEBtZW1iZXJvZiB0b2tlbml6ZVxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UodW5lc2NhcGVSZSwgZnVuY3Rpb24oJDAsICQxKSB7XG4gICAgICAgIHN3aXRjaCAoJDEpIHtcbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQxO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5lc2NhcGVNYXBbJDFdIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudG9rZW5pemUudW5lc2NhcGUgPSB1bmVzY2FwZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuZXh0IHRva2VuIGFuZCBhZHZhbmNlcy5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZU5leHRcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gTmV4dCB0b2tlbiBvciBgbnVsbGAgb24gZW9mXG4gKi9cblxuLyoqXG4gKiBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4uXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVQZWVrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICovXG5cbi8qKlxuICogUHVzaGVzIGEgdG9rZW4gYmFjayB0byB0aGUgc3RhY2suXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVQdXNoXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVG9rZW5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCB0b2tlbi5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZVNraXBcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCBFeHBlY3RlZCB0b2tlblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWw9ZmFsc2VdIElmIG9wdGlvbmFsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdG9rZW4gbWF0Y2hlZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0b2tlbiBkaWRuJ3QgbWF0Y2ggYW5kIGlzIG5vdCBvcHRpb25hbFxuICovXG5cbi8qKlxuICogR2V0cyB0aGUgY29tbWVudCBvbiB0aGUgcHJldmlvdXMgbGluZSBvciwgYWx0ZXJuYXRpdmVseSwgdGhlIGxpbmUgY29tbWVudCBvbiB0aGUgc3BlY2lmaWVkIGxpbmUuXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVDbW50XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge251bWJlcn0gW2xpbmVdIExpbmUgbnVtYmVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IENvbW1lbnQgdGV4dCBvciBgbnVsbGAgaWYgbm9uZVxuICovXG5cbi8qKlxuICogSGFuZGxlIG9iamVjdCByZXR1cm5lZCBmcm9tIHtAbGluayB0b2tlbml6ZX0uXG4gKiBAaW50ZXJmYWNlIElUb2tlbml6ZXJIYW5kbGVcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlTmV4dH0gbmV4dCBHZXRzIHRoZSBuZXh0IHRva2VuIGFuZCBhZHZhbmNlcyAoYG51bGxgIG9uIGVvZilcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlUGVla30gcGVlayBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4gKGBudWxsYCBvbiBlb2YpXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVB1c2h9IHB1c2ggUHVzaGVzIGEgdG9rZW4gYmFjayB0byB0aGUgc3RhY2tcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlU2tpcH0gc2tpcCBTa2lwcyBhIHRva2VuLCByZXR1cm5zIGl0cyBwcmVzZW5jZSBhbmQgYWR2YW5jZXMgb3IsIGlmIG5vbi1vcHRpb25hbCBhbmQgbm90IHByZXNlbnQsIHRocm93c1xuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVDbW50fSBjbW50IEdldHMgdGhlIGNvbW1lbnQgb24gdGhlIHByZXZpb3VzIGxpbmUgb3IgdGhlIGxpbmUgY29tbWVudCBvbiB0aGUgc3BlY2lmaWVkIGxpbmUsIGlmIGFueVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmUgQ3VycmVudCBsaW5lIG51bWJlclxuICovXG5cbi8qKlxuICogVG9rZW5pemVzIHRoZSBnaXZlbiAucHJvdG8gc291cmNlIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHVzZWZ1bCB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsdGVybmF0ZUNvbW1lbnRNb2RlIFdoZXRoZXIgd2Ugc2hvdWxkIGFjdGl2YXRlIGFsdGVybmF0ZSBjb21tZW50IHBhcnNpbmcgbW9kZS5cbiAqIEByZXR1cm5zIHtJVG9rZW5pemVySGFuZGxlfSBUb2tlbml6ZXIgaGFuZGxlXG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKHNvdXJjZSwgYWx0ZXJuYXRlQ29tbWVudE1vZGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYWxsYmFjay1yZXR1cm4gKi9cbiAgICBzb3VyY2UgPSBzb3VyY2UudG9TdHJpbmcoKTtcblxuICAgIHZhciBvZmZzZXQgPSAwLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLFxuICAgICAgICBsaW5lID0gMSxcbiAgICAgICAgbGFzdENvbW1lbnRMaW5lID0gMCxcbiAgICAgICAgY29tbWVudHMgPSB7fTtcblxuICAgIHZhciBzdGFjayA9IFtdO1xuXG4gICAgdmFyIHN0cmluZ0RlbGltID0gbnVsbDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciBmb3IgaWxsZWdhbCBzeW50YXguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmplY3QgU3ViamVjdFxuICAgICAqIEByZXR1cm5zIHtFcnJvcn0gRXJyb3IgY3JlYXRlZFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlsbGVnYWwoc3ViamVjdCkge1xuICAgICAgICByZXR1cm4gRXJyb3IoXCJpbGxlZ2FsIFwiICsgc3ViamVjdCArIFwiIChsaW5lIFwiICsgbGluZSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHN0cmluZyB0aWxsIGl0cyBlbmQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nKCkge1xuICAgICAgICB2YXIgcmUgPSBzdHJpbmdEZWxpbSA9PT0gXCInXCIgPyBzdHJpbmdTaW5nbGVSZSA6IHN0cmluZ0RvdWJsZVJlO1xuICAgICAgICByZS5sYXN0SW5kZXggPSBvZmZzZXQgLSAxO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHNvdXJjZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwic3RyaW5nXCIpO1xuICAgICAgICBvZmZzZXQgPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHB1c2goc3RyaW5nRGVsaW0pO1xuICAgICAgICBzdHJpbmdEZWxpbSA9IG51bGw7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZShtYXRjaFsxXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2hhcmFjdGVyIGF0IGBwb3NgIHdpdGhpbiB0aGUgc291cmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDaGFyYWN0ZXJcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFyQXQocG9zKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuY2hhckF0KHBvcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBjb21tZW50IHRleHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMZWFkaW5nIHNldCBpZiBhIGxlYWRpbmcgY29tbWVudFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q29tbWVudChzdGFydCwgZW5kLCBpc0xlYWRpbmcpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBzb3VyY2UuY2hhckF0KHN0YXJ0KyspLFxuICAgICAgICAgICAgbGluZUVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIGxlYWRpbmc6IGlzTGVhZGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvb2tiYWNrO1xuICAgICAgICBpZiAoYWx0ZXJuYXRlQ29tbWVudE1vZGUpIHtcbiAgICAgICAgICAgIGxvb2tiYWNrID0gMjsgIC8vIGFsdGVybmF0ZSBjb21tZW50IHBhcnNpbmc6IFwiLy9cIiBvciBcIi8qXCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb2tiYWNrID0gMzsgIC8vIFwiLy8vXCIgb3IgXCIvKipcIlxuICAgICAgICB9XG4gICAgICAgIHZhciBjb21tZW50T2Zmc2V0ID0gc3RhcnQgLSBsb29rYmFjayxcbiAgICAgICAgICAgIGM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICgtLWNvbW1lbnRPZmZzZXQgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIChjID0gc291cmNlLmNoYXJBdChjb21tZW50T2Zmc2V0KSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50LmxpbmVFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFx0XCIpO1xuICAgICAgICB2YXIgbGluZXMgPSBzb3VyY2VcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoc3RhcnQsIGVuZClcbiAgICAgICAgICAgIC5zcGxpdChzZXRDb21tZW50U3BsaXRSZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYWx0ZXJuYXRlQ29tbWVudE1vZGUgPyBzZXRDb21tZW50QWx0UmUgOiBzZXRDb21tZW50UmUsIFwiXCIpXG4gICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgY29tbWVudC50ZXh0ID0gbGluZXNcbiAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAudHJpbSgpO1xuXG4gICAgICAgIGNvbW1lbnRzW2xpbmVdID0gY29tbWVudDtcbiAgICAgICAgbGFzdENvbW1lbnRMaW5lID0gbGluZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUoc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgdmFyIGVuZE9mZnNldCA9IGZpbmRFbmRPZkxpbmUoc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgIC8vIHNlZSBpZiByZW1haW5pbmcgbGluZSBtYXRjaGVzIGNvbW1lbnQgcGF0dGVyblxuICAgICAgICB2YXIgbGluZVRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICAvLyBsb29rIGZvciAxIG9yIDIgc2xhc2hlcyBzaW5jZSBzdGFydE9mZnNldCB3b3VsZCBhbHJlYWR5IHBvaW50IHBhc3RcbiAgICAgICAgLy8gdGhlIGZpcnN0IHNsYXNoIHRoYXQgc3RhcnRlZCB0aGUgY29tbWVudC5cbiAgICAgICAgdmFyIGlzQ29tbWVudCA9IC9eXFxzKlxcL3sxLDJ9Ly50ZXN0KGxpbmVUZXh0KTtcbiAgICAgICAgcmV0dXJuIGlzQ29tbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kRW5kT2ZMaW5lKGN1cnNvcikge1xuICAgICAgICAvLyBmaW5kIGVuZCBvZiBjdXJzb3IncyBsaW5lXG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBjdXJzb3I7XG4gICAgICAgIHdoaWxlIChlbmRPZmZzZXQgPCBsZW5ndGggJiYgY2hhckF0KGVuZE9mZnNldCkgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmRPZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzdHJpbmdEZWxpbSlcbiAgICAgICAgICAgIHJldHVybiByZWFkU3RyaW5nKCk7XG4gICAgICAgIHZhciByZXBlYXQsXG4gICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgY3VycixcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgaXNEb2MsXG4gICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gb2Zmc2V0ID09PSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh3aGl0ZXNwYWNlUmUudGVzdChjdXJyID0gY2hhckF0KG9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhckF0KG9mZnNldCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcImNvbW1lbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFyQXQob2Zmc2V0KSA9PT0gXCIvXCIpIHsgLy8gTGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdHJpcGxlLXNsYXNoIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRG9jID0gY2hhckF0KHN0YXJ0ID0gb2Zmc2V0ICsgMSkgPT09IFwiL1wiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckF0KCsrb2Zmc2V0KSAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICArK29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCAtIDEsIGlzTGVhZGluZ0NvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWlsaW5nIGNvbW1lbnQgY2Fubm90IG5vdCBiZSBtdWx0aS1saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGxlYWRpbmcgY29tbWVudCBzdGF0ZSBzaG91bGQgYmUgcmVzZXQgdG8gaGFuZGxlIHBvdGVudGlhbCBuZXh0IGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRvdWJsZS1zbGFzaCBjb21tZW50cywgY29uc29saWRhdGluZyBjb25zZWN1dGl2ZSBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG91YmxlU2xhc2hDb21tZW50TGluZShvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZmluZEVuZE9mTGluZShvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTGVhZGluZ0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWlsaW5nIGNvbW1lbnQgY2Fubm90IG5vdCBiZSBtdWx0aS1saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGlzRG91YmxlU2xhc2hDb21tZW50TGluZShvZmZzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4obGVuZ3RoLCBmaW5kRW5kT2ZMaW5lKG9mZnNldCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCwgaXNMZWFkaW5nQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoY3VyciA9IGNoYXJBdChvZmZzZXQpKSA9PT0gXCIqXCIpIHsgLyogQmxvY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIC8qKiAocmVndWxhciBjb21tZW50IG1vZGUpIG9yIC8qIChhbHRlcm5hdGUgY29tbWVudCBtb2RlKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlzRG9jID0gYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgY2hhckF0KHN0YXJ0KSA9PT0gXCIqXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGNoYXJBdChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwcmV2ICE9PSBcIipcIiB8fCBjdXJyICE9PSBcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICsrb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCAtIDIsIGlzTGVhZGluZ0NvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChyZXBlYXQpO1xuXG4gICAgICAgIC8vIG9mZnNldCAhPT0gbGVuZ3RoIGlmIHdlIGdvdCBoZXJlXG5cbiAgICAgICAgdmFyIGVuZCA9IG9mZnNldDtcbiAgICAgICAgZGVsaW1SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgZGVsaW0gPSBkZWxpbVJlLnRlc3QoY2hhckF0KGVuZCsrKSk7XG4gICAgICAgIGlmICghZGVsaW0pXG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoICYmICFkZWxpbVJlLnRlc3QoY2hhckF0KGVuZCkpKVxuICAgICAgICAgICAgICAgICsrZW5kO1xuICAgICAgICB2YXIgdG9rZW4gPSBzb3VyY2Uuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ID0gZW5kKTtcbiAgICAgICAgaWYgKHRva2VuID09PSBcIlxcXCJcIiB8fCB0b2tlbiA9PT0gXCInXCIpXG4gICAgICAgICAgICBzdHJpbmdEZWxpbSA9IHRva2VuO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgdG9rZW4gYmFjayB0byB0aGUgc3RhY2suXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdXNoKHRva2VuKSB7XG4gICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlZWtzIGZvciB0aGUgbmV4dCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gbmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNraXBzIGEgdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkIEV4cGVjdGVkIHRva2VuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHRva2VuIGlzIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCB3aGVuIHNraXBwZWQsIGBmYWxzZWAgaWYgbm90XG4gICAgICogQHRocm93cyB7RXJyb3J9IFdoZW4gYSByZXF1aXJlZCB0b2tlbiBpcyBub3QgcHJlc2VudFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNraXAoZXhwZWN0ZWQsIG9wdGlvbmFsKSB7XG4gICAgICAgIHZhciBhY3R1YWwgPSBwZWVrKCksXG4gICAgICAgICAgICBlcXVhbHMgPSBhY3R1YWwgPT09IGV4cGVjdGVkO1xuICAgICAgICBpZiAoZXF1YWxzKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbmFsKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcInRva2VuICdcIiArIGFjdHVhbCArIFwiJywgJ1wiICsgZXhwZWN0ZWQgKyBcIicgZXhwZWN0ZWRcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgY29tbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RyYWlsaW5nTGluZV0gTGluZSBudW1iZXIgaWYgbG9va2luZyBmb3IgYSB0cmFpbGluZyBjb21tZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBDb21tZW50IHRleHRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbW50KHRyYWlsaW5nTGluZSkge1xuICAgICAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICAgICAgdmFyIGNvbW1lbnQ7XG4gICAgICAgIGlmICh0cmFpbGluZ0xpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2xpbmUgLSAxXTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb21tZW50c1tsaW5lIC0gMV07XG4gICAgICAgICAgICBpZiAoY29tbWVudCAmJiAoYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgY29tbWVudC50eXBlID09PSBcIipcIiB8fCBjb21tZW50LmxpbmVFbXB0eSkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjb21tZW50LmxlYWRpbmcgPyBjb21tZW50LnRleHQgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChsYXN0Q29tbWVudExpbmUgPCB0cmFpbGluZ0xpbmUpIHtcbiAgICAgICAgICAgICAgICBwZWVrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tZW50ID0gY29tbWVudHNbdHJhaWxpbmdMaW5lXTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb21tZW50c1t0cmFpbGluZ0xpbmVdO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnQgJiYgIWNvbW1lbnQubGluZUVtcHR5ICYmIChhbHRlcm5hdGVDb21tZW50TW9kZSB8fCBjb21tZW50LnR5cGUgPT09IFwiL1wiKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbW1lbnQubGVhZGluZyA/IG51bGwgOiBjb21tZW50LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgbmV4dDogbmV4dCxcbiAgICAgICAgcGVlazogcGVlayxcbiAgICAgICAgcHVzaDogcHVzaCxcbiAgICAgICAgc2tpcDogc2tpcCxcbiAgICAgICAgY21udDogY21udFxuICAgIH0sIFwibGluZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lOyB9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBjYWxsYmFjay1yZXR1cm4gKi9cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5cbnBhcnNlLmZpbGVuYW1lID0gbnVsbDtcbnBhcnNlLmRlZmF1bHRzID0geyBrZWVwQ2FzZTogZmFsc2UgfTtcblxudmFyIHRva2VuaXplICA9IHJlcXVpcmUoXCIuL3Rva2VuaXplXCIpLFxuICAgIFJvb3QgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RcIiksXG4gICAgVHlwZSAgICAgID0gcmVxdWlyZShcIi4vdHlwZVwiKSxcbiAgICBGaWVsZCAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBNYXBGaWVsZCAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKSxcbiAgICBPbmVPZiAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIFNlcnZpY2UgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIiksXG4gICAgTWV0aG9kICAgID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpLFxuICAgIHR5cGVzICAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBiYXNlMTBSZSAgICA9IC9eWzEtOV1bMC05XSokLyxcbiAgICBiYXNlMTBOZWdSZSA9IC9eLT9bMS05XVswLTldKiQvLFxuICAgIGJhc2UxNlJlICAgID0gL14wW3hdWzAtOWEtZkEtRl0rJC8sXG4gICAgYmFzZTE2TmVnUmUgPSAvXi0/MFt4XVswLTlhLWZBLUZdKyQvLFxuICAgIGJhc2U4UmUgICAgID0gL14wWzAtN10rJC8sXG4gICAgYmFzZThOZWdSZSAgPSAvXi0/MFswLTddKyQvLFxuICAgIG51bWJlclJlICAgID0gL14oPyFbZUVdKVswLTldKig/OlxcLlswLTldKik/KD86W2VFXVsrLV0/WzAtOV0rKT8kLyxcbiAgICBuYW1lUmUgICAgICA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKiQvLFxuICAgIHR5cGVSZWZSZSAgID0gL14oPzpcXC4/W2EtekEtWl9dW2EtekEtWl8wLTldKikoPzpcXC5bYS16QS1aX11bYS16QS1aXzAtOV0qKSokLyxcbiAgICBmcVR5cGVSZWZSZSA9IC9eKD86XFwuW2EtekEtWl9dW2EtekEtWl8wLTldKikrJC87XG5cbi8qKlxuICogUmVzdWx0IG9iamVjdCByZXR1cm5lZCBmcm9tIHtAbGluayBwYXJzZX0uXG4gKiBAaW50ZXJmYWNlIElQYXJzZXJSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gcGFja2FnZSBQYWNrYWdlIG5hbWUsIGlmIGRlY2xhcmVkXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfHVuZGVmaW5lZH0gaW1wb3J0cyBJbXBvcnRzLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW118dW5kZWZpbmVkfSB3ZWFrSW1wb3J0cyBXZWFrIGltcG9ydHMsIGlmIGFueVxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBzeW50YXggU3ludGF4LCBpZiBzcGVjaWZpZWQgKGVpdGhlciBgXCJwcm90bzJcImAgb3IgYFwicHJvdG8zXCJgKVxuICogQHByb3BlcnR5IHtSb290fSByb290IFBvcHVsYXRlZCByb290IGluc3RhbmNlXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb2Yge0BsaW5rIHBhcnNlfS5cbiAqIEBpbnRlcmZhY2UgSVBhcnNlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBba2VlcENhc2U9ZmFsc2VdIEtlZXBzIGZpZWxkIGNhc2luZyBpbnN0ZWFkIG9mIGNvbnZlcnRpbmcgdG8gY2FtZWwgY2FzZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWx0ZXJuYXRlQ29tbWVudE1vZGU9ZmFsc2VdIFJlY29nbml6ZSBkb3VibGUtc2xhc2ggY29tbWVudHMgaW4gYWRkaXRpb24gdG8gZG9jLWJsb2NrIGNvbW1lbnRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcHJlZmVyVHJhaWxpbmdDb21tZW50PWZhbHNlXSBVc2UgdHJhaWxpbmcgY29tbWVudCB3aGVuIGJvdGggbGVhZGluZyBjb21tZW50IGFuZCB0cmFpbGluZyBjb21tZW50IGV4aXN0LlxuICovXG5cbi8qKlxuICogT3B0aW9ucyBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9mIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqIEBpbnRlcmZhY2UgSVRvSlNPTk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlZXBDb21tZW50cz1mYWxzZV0gU2VyaWFsaXplcyBjb21tZW50cy5cbiAqL1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gLnByb3RvIHNvdXJjZSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIGNvbnRlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBTb3VyY2UgY29udGVudHNcbiAqIEBwYXJhbSB7Um9vdH0gcm9vdCBSb290IHRvIHBvcHVsYXRlXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtJUGFyc2VyUmVzdWx0fSBQYXJzZXIgcmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZW5hbWU9bnVsbCBDdXJyZW50bHkgcHJvY2Vzc2luZyBmaWxlIG5hbWUgZm9yIGVycm9yIHJlcG9ydGluZywgaWYga25vd25cbiAqIEBwcm9wZXJ0eSB7SVBhcnNlT3B0aW9uc30gZGVmYXVsdHMgRGVmYXVsdCB7QGxpbmsgSVBhcnNlT3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc291cmNlLCByb290LCBvcHRpb25zKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY2FsbGJhY2stcmV0dXJuICovXG4gICAgaWYgKCEocm9vdCBpbnN0YW5jZW9mIFJvb3QpKSB7XG4gICAgICAgIG9wdGlvbnMgPSByb290O1xuICAgICAgICByb290ID0gbmV3IFJvb3QoKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgICBvcHRpb25zID0gcGFyc2UuZGVmYXVsdHM7XG5cbiAgICB2YXIgcHJlZmVyVHJhaWxpbmdDb21tZW50ID0gb3B0aW9ucy5wcmVmZXJUcmFpbGluZ0NvbW1lbnQgfHwgZmFsc2U7XG4gICAgdmFyIHRuID0gdG9rZW5pemUoc291cmNlLCBvcHRpb25zLmFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGZhbHNlKSxcbiAgICAgICAgbmV4dCA9IHRuLm5leHQsXG4gICAgICAgIHB1c2ggPSB0bi5wdXNoLFxuICAgICAgICBwZWVrID0gdG4ucGVlayxcbiAgICAgICAgc2tpcCA9IHRuLnNraXAsXG4gICAgICAgIGNtbnQgPSB0bi5jbW50O1xuXG4gICAgdmFyIGhlYWQgPSB0cnVlLFxuICAgICAgICBwa2csXG4gICAgICAgIGltcG9ydHMsXG4gICAgICAgIHdlYWtJbXBvcnRzLFxuICAgICAgICBzeW50YXgsXG4gICAgICAgIGlzUHJvdG8zID0gZmFsc2U7XG5cbiAgICB2YXIgcHRyID0gcm9vdDtcblxuICAgIHZhciBhcHBseUNhc2UgPSBvcHRpb25zLmtlZXBDYXNlID8gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gbmFtZTsgfSA6IHV0aWwuY2FtZWxDYXNlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBpbGxlZ2FsKHRva2VuLCBuYW1lLCBpbnNpZGVUcnlDYXRjaCkge1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcbiAgICAgICAgaWYgKCFpbnNpZGVUcnlDYXRjaClcbiAgICAgICAgICAgIHBhcnNlLmZpbGVuYW1lID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIEVycm9yKFwiaWxsZWdhbCBcIiArIChuYW1lIHx8IFwidG9rZW5cIikgKyBcIiAnXCIgKyB0b2tlbiArIFwiJyAoXCIgKyAoZmlsZW5hbWUgPyBmaWxlbmFtZSArIFwiLCBcIiA6IFwiXCIpICsgXCJsaW5lIFwiICsgdG4ubGluZSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICAgICB0b2tlbjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHRva2VuID0gbmV4dCgpKSAhPT0gXCJcXFwiXCIgJiYgdG9rZW4gIT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuZXh0KCkpO1xuICAgICAgICAgICAgc2tpcCh0b2tlbik7XG4gICAgICAgICAgICB0b2tlbiA9IHBlZWsoKTtcbiAgICAgICAgfSB3aGlsZSAodG9rZW4gPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuam9pbihcIlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVmFsdWUoYWNjZXB0VHlwZVJlZikge1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBjYXNlIFwiXFxcIlwiOlxuICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOiBjYXNlIFwiVFJVRVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6IGNhc2UgXCJGQUxTRVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyKHRva2VuLCAvKiBpbnNpZGVUcnlDYXRjaCAqLyB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGFjY2VwdFR5cGVSZWYgJiYgdHlwZVJlZlJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwidmFsdWVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkUmFuZ2VzKHRhcmdldCwgYWNjZXB0U3RyaW5ncykge1xuICAgICAgICB2YXIgdG9rZW4sIHN0YXJ0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0U3RyaW5ncyAmJiAoKHRva2VuID0gcGVlaygpKSA9PT0gXCJcXFwiXCIgfHwgdG9rZW4gPT09IFwiJ1wiKSlcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChyZWFkU3RyaW5nKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKFsgc3RhcnQgPSBwYXJzZUlkKG5leHQoKSksIHNraXAoXCJ0b1wiLCB0cnVlKSA/IHBhcnNlSWQobmV4dCgpKSA6IHN0YXJ0IF0pO1xuICAgICAgICB9IHdoaWxlIChza2lwKFwiLFwiLCB0cnVlKSk7XG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyKHRva2VuLCBpbnNpZGVUcnlDYXRjaCkge1xuICAgICAgICB2YXIgc2lnbiA9IDE7XG4gICAgICAgIGlmICh0b2tlbi5jaGFyQXQoMCkgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5mXCI6IGNhc2UgXCJJTkZcIjogY2FzZSBcIkluZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XG4gICAgICAgICAgICBjYXNlIFwibmFuXCI6IGNhc2UgXCJOQU5cIjogY2FzZSBcIk5hblwiOiBjYXNlIFwiTmFOXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UxMFJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgMTApO1xuICAgICAgICBpZiAoYmFzZTE2UmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHRva2VuLCAxNik7XG4gICAgICAgIGlmIChiYXNlOFJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgOCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKG51bWJlclJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHRva2VuKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm51bWJlclwiLCBpbnNpZGVUcnlDYXRjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJZCh0b2tlbiwgYWNjZXB0TmVnYXRpdmUpIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIm1heFwiOiBjYXNlIFwiTUFYXCI6IGNhc2UgXCJNYXhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNTM2ODcwOTExO1xuICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWFjY2VwdE5lZ2F0aXZlICYmIHRva2VuLmNoYXJBdCgwKSA9PT0gXCItXCIpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcImlkXCIpO1xuXG4gICAgICAgIGlmIChiYXNlMTBOZWdSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0b2tlbiwgMTApO1xuICAgICAgICBpZiAoYmFzZTE2TmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDE2KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoYmFzZThOZWdSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0b2tlbiwgOCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJpZFwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhY2thZ2UoKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwa2cgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJwYWNrYWdlXCIpO1xuXG4gICAgICAgIHBrZyA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdChwa2cpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChwa2csIFwibmFtZVwiKTtcblxuICAgICAgICBwdHIgPSBwdHIuZGVmaW5lKHBrZyk7XG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW1wb3J0KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBwZWVrKCk7XG4gICAgICAgIHZhciB3aGljaEltcG9ydHM7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWFrXCI6XG4gICAgICAgICAgICAgICAgd2hpY2hJbXBvcnRzID0gd2Vha0ltcG9ydHMgfHwgKHdlYWtJbXBvcnRzID0gW10pO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwdWJsaWNcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB3aGljaEltcG9ydHMgPSBpbXBvcnRzIHx8IChpbXBvcnRzID0gW10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gcmVhZFN0cmluZygpO1xuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgd2hpY2hJbXBvcnRzLnB1c2godG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3ludGF4KCkge1xuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgc3ludGF4ID0gcmVhZFN0cmluZygpO1xuICAgICAgICBpc1Byb3RvMyA9IHN5bnRheCA9PT0gXCJwcm90bzNcIjtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFpc1Byb3RvMyAmJiBzeW50YXggIT09IFwicHJvdG8yXCIpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHN5bnRheCwgXCJzeW50YXhcIik7XG5cbiAgICAgICAgc2tpcChcIjtcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb21tb24ocGFyZW50LCB0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBwYXJzZVR5cGUocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VFbnVtKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwic2VydmljZVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlU2VydmljZShwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcImV4dGVuZFwiOlxuICAgICAgICAgICAgICAgIHBhcnNlRXh0ZW5zaW9uKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZkJsb2NrKG9iaiwgZm5JZiwgZm5FbHNlKSB7XG4gICAgICAgIHZhciB0cmFpbGluZ0xpbmUgPSB0bi5saW5lO1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygb2JqLmNvbW1lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgb2JqLmNvbW1lbnQgPSBjbW50KCk7IC8vIHRyeSBibG9jay10eXBlIGNvbW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5maWxlbmFtZSA9IHBhcnNlLmZpbGVuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwKFwie1wiLCB0cnVlKSkge1xuICAgICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgIT09IFwifVwiKVxuICAgICAgICAgICAgICAgIGZuSWYodG9rZW4pO1xuICAgICAgICAgICAgc2tpcChcIjtcIiwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm5FbHNlKVxuICAgICAgICAgICAgICAgIGZuRWxzZSgpO1xuICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICBpZiAob2JqICYmICh0eXBlb2Ygb2JqLmNvbW1lbnQgIT09IFwic3RyaW5nXCIgfHwgcHJlZmVyVHJhaWxpbmdDb21tZW50KSlcbiAgICAgICAgICAgICAgICBvYmouY29tbWVudCA9IGNtbnQodHJhaWxpbmdMaW5lKSB8fCBvYmouY29tbWVudDsgLy8gdHJ5IGxpbmUtdHlwZSBjb21tZW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVR5cGUocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwidHlwZSBuYW1lXCIpO1xuXG4gICAgICAgIHZhciB0eXBlID0gbmV3IFR5cGUodG9rZW4pO1xuICAgICAgICBpZkJsb2NrKHR5cGUsIGZ1bmN0aW9uIHBhcnNlVHlwZV9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHBhcnNlQ29tbW9uKHR5cGUsIHRva2VuKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VNYXBGaWVsZCh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvdG8zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwicHJvdG8zX29wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlT25lT2YodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJleHRlbnNpb25zXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRSYW5nZXModHlwZS5leHRlbnNpb25zIHx8ICh0eXBlLmV4dGVuc2lvbnMgPSBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNlcnZlZFwiOlxuICAgICAgICAgICAgICAgICAgICByZWFkUmFuZ2VzKHR5cGUucmVzZXJ2ZWQgfHwgKHR5cGUucmVzZXJ2ZWQgPSBbXSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvdG8zIHx8ICF0eXBlUmVmUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQodHlwZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGaWVsZChwYXJlbnQsIHJ1bGUsIGV4dGVuZCkge1xuICAgICAgICB2YXIgdHlwZSA9IG5leHQoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgcGFyc2VHcm91cChwYXJlbnQsIHJ1bGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHR5cGUsIFwidHlwZVwiKTtcblxuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwobmFtZSwgXCJuYW1lXCIpO1xuXG4gICAgICAgIG5hbWUgPSBhcHBseUNhc2UobmFtZSk7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuXG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChuYW1lLCBwYXJzZUlkKG5leHQoKSksIHR5cGUsIHJ1bGUsIGV4dGVuZCk7XG4gICAgICAgIGlmQmxvY2soZmllbGQsIGZ1bmN0aW9uIHBhcnNlRmllbGRfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGZpZWxkLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9LCBmdW5jdGlvbiBwYXJzZUZpZWxkX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZmllbGQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocnVsZSA9PT0gXCJwcm90bzNfb3B0aW9uYWxcIikge1xuICAgICAgICAgICAgLy8gZm9yIHByb3RvMyBvcHRpb25hbCBmaWVsZHMsIHdlIGNyZWF0ZSBhIHNpbmdsZS1tZW1iZXIgT25lb2YgdG8gbWltaWMgXCJvcHRpb25hbFwiIGJlaGF2aW9yXG4gICAgICAgICAgICB2YXIgb25lb2YgPSBuZXcgT25lT2YoXCJfXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIGZpZWxkLnNldE9wdGlvbihcInByb3RvM19vcHRpb25hbFwiLCB0cnVlKTtcbiAgICAgICAgICAgIG9uZW9mLmFkZChmaWVsZCk7XG4gICAgICAgICAgICBwYXJlbnQuYWRkKG9uZW9mKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hZGQoZmllbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSlNPTiBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZSBpZiBub3Qgc2V0IHNvIHdlIGhhdmUgdG8gc2V0IHBhY2tlZD1mYWxzZSBleHBsaWNpdHkgd2hlblxuICAgICAgICAvLyBwYXJzaW5nIHByb3RvMiBkZXNjcmlwdG9ycyB3aXRob3V0IHRoZSBvcHRpb24sIHdoZXJlIGFwcGxpY2FibGUuIFRoaXMgbXVzdCBiZSBkb25lIGZvclxuICAgICAgICAvLyBhbGwga25vd24gcGFja2FibGUgdHlwZXMgYW5kIGFueXRoaW5nIHRoYXQgY291bGQgYmUgYW4gZW51bSAoPSBpcyBub3QgYSBiYXNpYyB0eXBlKS5cbiAgICAgICAgaWYgKCFpc1Byb3RvMyAmJiBmaWVsZC5yZXBlYXRlZCAmJiAodHlwZXMucGFja2VkW3R5cGVdICE9PSB1bmRlZmluZWQgfHwgdHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJwYWNrZWRcIiwgZmFsc2UsIC8qIGlmTm90U2V0ICovIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlR3JvdXAocGFyZW50LCBydWxlKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IHV0aWwubGNGaXJzdChuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IGZpZWxkTmFtZSlcbiAgICAgICAgICAgIG5hbWUgPSB1dGlsLnVjRmlyc3QobmFtZSk7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgaWQgPSBwYXJzZUlkKG5leHQoKSk7XG4gICAgICAgIHZhciB0eXBlID0gbmV3IFR5cGUobmFtZSk7XG4gICAgICAgIHR5cGUuZ3JvdXAgPSB0cnVlO1xuICAgICAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQoZmllbGROYW1lLCBpZCwgbmFtZSwgcnVsZSk7XG4gICAgICAgIGZpZWxkLmZpbGVuYW1lID0gcGFyc2UuZmlsZW5hbWU7XG4gICAgICAgIGlmQmxvY2sodHlwZSwgZnVuY3Rpb24gcGFyc2VHcm91cF9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbih0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3RvMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcInByb3RvM19vcHRpb25hbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgXCJvcHRpb25hbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlVHlwZSh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VFbnVtKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pOyAvLyB0aGVyZSBhcmUgbm8gZ3JvdXBzIHdpdGggcHJvdG8zIHNlbWFudGljc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZCh0eXBlKVxuICAgICAgICAgICAgICAuYWRkKGZpZWxkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1hcEZpZWxkKHBhcmVudCkge1xuICAgICAgICBza2lwKFwiPFwiKTtcbiAgICAgICAgdmFyIGtleVR5cGUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0eXBlcy5tYXBLZXlba2V5VHlwZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoa2V5VHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHNraXAoXCIsXCIpO1xuICAgICAgICB2YXIgdmFsdWVUeXBlID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHZhbHVlVHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHZhbHVlVHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHNraXAoXCI+XCIpO1xuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwobmFtZSwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgZmllbGQgPSBuZXcgTWFwRmllbGQoYXBwbHlDYXNlKG5hbWUpLCBwYXJzZUlkKG5leHQoKSksIGtleVR5cGUsIHZhbHVlVHlwZSk7XG4gICAgICAgIGlmQmxvY2soZmllbGQsIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGRfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGZpZWxkLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9LCBmdW5jdGlvbiBwYXJzZU1hcEZpZWxkX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZmllbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChmaWVsZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPbmVPZihwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBvbmVvZiA9IG5ldyBPbmVPZihhcHBseUNhc2UodG9rZW4pKTtcbiAgICAgICAgaWZCbG9jayhvbmVvZiwgZnVuY3Rpb24gcGFyc2VPbmVPZl9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ob25lb2YsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgcGFyc2VGaWVsZChvbmVvZiwgXCJvcHRpb25hbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQob25lb2YpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW51bShwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBlbm0gPSBuZXcgRW51bSh0b2tlbik7XG4gICAgICAgIGlmQmxvY2soZW5tLCBmdW5jdGlvbiBwYXJzZUVudW1fYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICBzd2l0Y2godG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZW5tLCB0b2tlbik7XG4gICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInJlc2VydmVkXCI6XG4gICAgICAgICAgICAgIHJlYWRSYW5nZXMoZW5tLnJlc2VydmVkIHx8IChlbm0ucmVzZXJ2ZWQgPSBbXSksIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcGFyc2VFbnVtVmFsdWUoZW5tLCB0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChlbm0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSWQobmV4dCgpLCB0cnVlKSxcbiAgICAgICAgICAgIGR1bW15ID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZHVtbXkuc2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBpZkJsb2NrKGR1bW15LCBmdW5jdGlvbiBwYXJzZUVudW1WYWx1ZV9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZHVtbXksIHRva2VuKTsgLy8gc2tpcFxuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWVfbGluZSgpIHtcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhkdW1teSk7IC8vIHNraXBcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQodG9rZW4sIHZhbHVlLCBkdW1teS5jb21tZW50LCBkdW1teS5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9wdGlvbihwYXJlbnQsIHRva2VuKSB7XG4gICAgICAgIHZhciBpc0N1c3RvbSA9IHNraXAoXCIoXCIsIHRydWUpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xuICAgICAgICB2YXIgb3B0aW9uID0gbmFtZTtcbiAgICAgICAgdmFyIHByb3BOYW1lO1xuXG4gICAgICAgIGlmIChpc0N1c3RvbSkge1xuICAgICAgICAgICAgc2tpcChcIilcIik7XG4gICAgICAgICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICAgICAgICBvcHRpb24gPSBuYW1lO1xuICAgICAgICAgICAgdG9rZW4gPSBwZWVrKCk7XG4gICAgICAgICAgICBpZiAoZnFUeXBlUmVmUmUudGVzdCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBwcm9wTmFtZSA9IHRva2VuLnNsaWNlKDEpOyAvL3JlbW92ZSAnLicgYmVmb3JlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICBuYW1lICs9IHRva2VuO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgdmFyIG9wdGlvblZhbHVlID0gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICBzZXRQYXJzZWRPcHRpb24ocGFyZW50LCBvcHRpb24sIG9wdGlvblZhbHVlLCBwcm9wTmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgLy8geyBhOiBcImZvb1wiIGIgeyBjOiBcImJhclwiIH0gfVxuICAgICAgICBpZiAoc2tpcChcIntcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3RSZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgd2hpbGUgKCFza2lwKFwifVwiLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gdG9rZW47XG5cbiAgICAgICAgICAgICAgICBza2lwKFwiOlwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwie1wiKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lICsgXCIuXCIgKyB0b2tlbik7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb24gKG15X29wdGlvbikgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICByZXBlYXRlZF92YWx1ZTogWyBcImZvb1wiLCBcImJhclwiIF1cbiAgICAgICAgICAgICAgICAgICAgLy8gfTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXAoXCJbXCIsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gcmVhZFZhbHVlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2gobGFzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHNraXAoXCIsXCIsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXAoXCJdXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0VmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24ocGFyZW50LCBuYW1lICsgXCIuXCIgKyB0b2tlbiwgbGFzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZFZhbHVlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24ocGFyZW50LCBuYW1lICsgXCIuXCIgKyB0b2tlbiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBvYmplY3RSZXN1bHRbcHJvcE5hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXS5jb25jYXQocHJldlZhbHVlKS5jb25jYXQodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgb2JqZWN0UmVzdWx0W3Byb3BOYW1lXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VtaWNvbG9ucyBhbmQgY29tbWFzIGNhbiBiZSBvcHRpb25hbFxuICAgICAgICAgICAgICAgIHNraXAoXCIsXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0UmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpbXBsZVZhbHVlID0gcmVhZFZhbHVlKHRydWUpO1xuICAgICAgICBzZXRPcHRpb24ocGFyZW50LCBuYW1lLCBzaW1wbGVWYWx1ZSk7XG4gICAgICAgIHJldHVybiBzaW1wbGVWYWx1ZTtcbiAgICAgICAgLy8gRG9lcyBub3QgZW5mb3JjZSBhIGRlbGltaXRlciB0byBiZSB1bml2ZXJzYWxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPcHRpb24ocGFyZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAocGFyZW50LnNldE9wdGlvbilcbiAgICAgICAgICAgIHBhcmVudC5zZXRPcHRpb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFBhcnNlZE9wdGlvbihwYXJlbnQsIG5hbWUsIHZhbHVlLCBwcm9wTmFtZSkge1xuICAgICAgICBpZiAocGFyZW50LnNldFBhcnNlZE9wdGlvbilcbiAgICAgICAgICAgIHBhcmVudC5zZXRQYXJzZWRPcHRpb24obmFtZSwgdmFsdWUsIHByb3BOYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlubGluZU9wdGlvbnMocGFyZW50KSB7XG4gICAgICAgIGlmIChza2lwKFwiW1wiLCB0cnVlKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHBhcmVudCwgXCJvcHRpb25cIik7XG4gICAgICAgICAgICB9IHdoaWxlIChza2lwKFwiLFwiLCB0cnVlKSk7XG4gICAgICAgICAgICBza2lwKFwiXVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2VydmljZShwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJzZXJ2aWNlIG5hbWVcIik7XG5cbiAgICAgICAgdmFyIHNlcnZpY2UgPSBuZXcgU2VydmljZSh0b2tlbik7XG4gICAgICAgIGlmQmxvY2soc2VydmljZSwgZnVuY3Rpb24gcGFyc2VTZXJ2aWNlX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VDb21tb24oc2VydmljZSwgdG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJycGNcIilcbiAgICAgICAgICAgICAgICBwYXJzZU1ldGhvZChzZXJ2aWNlLCB0b2tlbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKHNlcnZpY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTWV0aG9kKHBhcmVudCwgdG9rZW4pIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjb21tZW50IG9mIHRoZSBwcmVjZWRpbmcgbGluZSBub3cgKGlmIG9uZSBleGlzdHMpIGluIGNhc2UgdGhlXG4gICAgICAgIC8vIG1ldGhvZCBpcyBkZWZpbmVkIGFjcm9zcyBtdWx0aXBsZSBsaW5lcy5cbiAgICAgICAgdmFyIGNvbW1lbnRUZXh0ID0gY21udCgpO1xuXG4gICAgICAgIHZhciB0eXBlID0gdG9rZW47XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBuYW1lID0gdG9rZW4sXG4gICAgICAgICAgICByZXF1ZXN0VHlwZSwgcmVxdWVzdFN0cmVhbSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZSwgcmVzcG9uc2VTdHJlYW07XG5cbiAgICAgICAgc2tpcChcIihcIik7XG4gICAgICAgIGlmIChza2lwKFwic3RyZWFtXCIsIHRydWUpKVxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbSA9IHRydWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgcmVxdWVzdFR5cGUgPSB0b2tlbjtcbiAgICAgICAgc2tpcChcIilcIik7IHNraXAoXCJyZXR1cm5zXCIpOyBza2lwKFwiKFwiKTtcbiAgICAgICAgaWYgKHNraXAoXCJzdHJlYW1cIiwgdHJ1ZSkpXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbSA9IHRydWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgcmVzcG9uc2VUeXBlID0gdG9rZW47XG4gICAgICAgIHNraXAoXCIpXCIpO1xuXG4gICAgICAgIHZhciBtZXRob2QgPSBuZXcgTWV0aG9kKG5hbWUsIHR5cGUsIHJlcXVlc3RUeXBlLCByZXNwb25zZVR5cGUsIHJlcXVlc3RTdHJlYW0sIHJlc3BvbnNlU3RyZWFtKTtcbiAgICAgICAgbWV0aG9kLmNvbW1lbnQgPSBjb21tZW50VGV4dDtcbiAgICAgICAgaWZCbG9jayhtZXRob2QsIGZ1bmN0aW9uIHBhcnNlTWV0aG9kX2Jsb2NrKHRva2VuKSB7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihtZXRob2QsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKG1ldGhvZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHRlbnNpb24ocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwicmVmZXJlbmNlXCIpO1xuXG4gICAgICAgIHZhciByZWZlcmVuY2UgPSB0b2tlbjtcbiAgICAgICAgaWZCbG9jayhudWxsLCBmdW5jdGlvbiBwYXJzZUV4dGVuc2lvbl9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCB0b2tlbiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3RvMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZChwYXJlbnQsIFwicHJvdG8zX29wdGlvbmFsXCIsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgXCJvcHRpb25hbFwiLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm90bzMgfHwgIXR5cGVSZWZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZChwYXJlbnQsIFwib3B0aW9uYWxcIiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0b2tlbjtcbiAgICB3aGlsZSAoKHRva2VuID0gbmV4dCgpKSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgIGNhc2UgXCJwYWNrYWdlXCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VQYWNrYWdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJpbXBvcnRcIjpcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghaGVhZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgICAgICAgICBwYXJzZUltcG9ydCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic3ludGF4XCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VTeW50YXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuXG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ocHRyLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbihwdHIsIHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZS5maWxlbmFtZSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJwYWNrYWdlXCIgICAgIDogcGtnLFxuICAgICAgICBcImltcG9ydHNcIiAgICAgOiBpbXBvcnRzLFxuICAgICAgICAgd2Vha0ltcG9ydHMgIDogd2Vha0ltcG9ydHMsXG4gICAgICAgICBzeW50YXggICAgICAgOiBzeW50YXgsXG4gICAgICAgICByb290ICAgICAgICAgOiByb290XG4gICAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBjb250ZW50cy5cbiAqIEBuYW1lIHBhcnNlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtJUGFyc2VyUmVzdWx0fSBQYXJzZXIgcmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZW5hbWU9bnVsbCBDdXJyZW50bHkgcHJvY2Vzc2luZyBmaWxlIG5hbWUgZm9yIGVycm9yIHJlcG9ydGluZywgaWYga25vd25cbiAqIEBwcm9wZXJ0eSB7SVBhcnNlT3B0aW9uc30gZGVmYXVsdHMgRGVmYXVsdCB7QGxpbmsgSVBhcnNlT3B0aW9uc31cbiAqIEB2YXJpYXRpb24gMlxuICovXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGNvbW1vbjtcblxudmFyIGNvbW1vblJlID0gL1xcL3xcXC4vO1xuXG4vKipcbiAqIFByb3ZpZGVzIGNvbW1vbiB0eXBlIGRlZmluaXRpb25zLlxuICogQ2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGFkZGl0aW9uYWwgZ29vZ2xlIHR5cGVzIG9yIHlvdXIgb3duIGN1c3RvbSB0eXBlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNob3J0IG5hbWUgYXMgaW4gYGdvb2dsZS9wcm90b2J1Zi9bbmFtZV0ucHJvdG9gIG9yIGZ1bGwgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIEpTT04gZGVmaW5pdGlvbiB3aXRoaW4gYGdvb2dsZS5wcm90b2J1ZmAgaWYgYSBzaG9ydCBuYW1lLCBvdGhlcndpc2UgdGhlIGZpbGUncyByb290IGRlZmluaXRpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG8gQW55XG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90byBEdXJhdGlvblxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvZW1wdHkucHJvdG8gRW1wdHlcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2ZpZWxkX21hc2sucHJvdG8gRmllbGRNYXNrXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG8gU3RydWN0LCBWYWx1ZSwgTnVsbFZhbHVlIGFuZCBMaXN0VmFsdWVcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90byBUaW1lc3RhbXBcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvIFdyYXBwZXJzXG4gKiBAZXhhbXBsZVxuICogLy8gbWFudWFsbHkgcHJvdmlkZXMgZGVzY3JpcHRvci5wcm90byAoYXNzdW1lcyBnb29nbGUvcHJvdG9idWYvIG5hbWVzcGFjZSBhbmQgLnByb3RvIGV4dGVuc2lvbilcbiAqIHByb3RvYnVmLmNvbW1vbihcImRlc2NyaXB0b3JcIiwgZGVzY3JpcHRvckpzb24pO1xuICpcbiAqIC8vIG1hbnVhbGx5IHByb3ZpZGVzIGEgY3VzdG9tIGRlZmluaXRpb24gKHVzZXMgbXkuZm9vIG5hbWVzcGFjZSlcbiAqIHByb3RvYnVmLmNvbW1vbihcIm15L2Zvby9iYXIucHJvdG9cIiwgbXlGb29CYXJKc29uKTtcbiAqL1xuZnVuY3Rpb24gY29tbW9uKG5hbWUsIGpzb24pIHtcbiAgICBpZiAoIWNvbW1vblJlLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IFwiZ29vZ2xlL3Byb3RvYnVmL1wiICsgbmFtZSArIFwiLnByb3RvXCI7XG4gICAgICAgIGpzb24gPSB7IG5lc3RlZDogeyBnb29nbGU6IHsgbmVzdGVkOiB7IHByb3RvYnVmOiB7IG5lc3RlZDoganNvbiB9IH0gfSB9IH07XG4gICAgfVxuICAgIGNvbW1vbltuYW1lXSA9IGpzb247XG59XG5cbi8vIE5vdCBwcm92aWRlZCBiZWNhdXNlIG9mIGxpbWl0ZWQgdXNlIChmZWVsIGZyZWUgdG8gZGlzY3VzcyBvciB0byBwcm92aWRlIHlvdXJzZWxmKTpcbi8vXG4vLyBnb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5wcm90b1xuLy8gZ29vZ2xlL3Byb3RvYnVmL3NvdXJjZV9jb250ZXh0LnByb3RvXG4vLyBnb29nbGUvcHJvdG9idWYvdHlwZS5wcm90b1xuLy9cbi8vIFN0cmlwcGVkIGFuZCBwcmUtcGFyc2VkIHZlcnNpb25zIG9mIHRoZXNlIG5vbi1idW5kbGVkIGZpbGVzIGFyZSBpbnN0ZWFkIGF2YWlsYWJsZSBhcyBwYXJ0IG9mXG4vLyB0aGUgcmVwb3NpdG9yeSBvciBwYWNrYWdlIHdpdGhpbiB0aGUgZ29vZ2xlL3Byb3RvYnVmIGRpcmVjdG9yeS5cblxuY29tbW9uKFwiYW55XCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQW55IG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJQW55XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVVcmxdXG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbYnl0ZXNdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEFueToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHR5cGVfdXJsOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgICAgIGlkOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIHRpbWVUeXBlO1xuXG5jb21tb24oXCJkdXJhdGlvblwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRHVyYXRpb25cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFtzZWNvbmRzXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbmFub3NdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIER1cmF0aW9uOiB0aW1lVHlwZSA9IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBzZWNvbmRzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFub3M6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDMyXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJ0aW1lc3RhbXBcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElUaW1lc3RhbXBcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFtzZWNvbmRzXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbmFub3NdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFRpbWVzdGFtcDogdGltZVR5cGVcbn0pO1xuXG5jb21tb24oXCJlbXB0eVwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkVtcHR5IG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRW1wdHlcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRW1wdHk6IHtcbiAgICAgICAgZmllbGRzOiB7fVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJzdHJ1Y3RcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElTdHJ1Y3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSVZhbHVlPn0gW2ZpZWxkc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgU3RydWN0OiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2luZF1cbiAgICAgKiBAcHJvcGVydHkgezB9IFtudWxsVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1iZXJWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0cmluZ1ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Jvb2xWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge0lTdHJ1Y3R9IFtzdHJ1Y3RWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge0lMaXN0VmFsdWV9IFtsaXN0VmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFZhbHVlOiB7XG4gICAgICAgIG9uZW9mczoge1xuICAgICAgICAgICAga2luZDoge1xuICAgICAgICAgICAgICAgIG9uZW9mOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibnVsbFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibnVtYmVyVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImJvb2xWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cnVjdFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlzdFZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgbnVsbFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJOdWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bWJlclZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkb3VibGVcIixcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvb2xWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgIGlkOiA0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RydWN0VmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlN0cnVjdFwiLFxuICAgICAgICAgICAgICAgIGlkOiA1XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJMaXN0VmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogNlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIE51bGxWYWx1ZToge1xuICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIE5VTExfVkFMVUU6IDBcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUxpc3RWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBcnJheS48SVZhbHVlPn0gW3ZhbHVlc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgTGlzdFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgcnVsZTogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcIndyYXBwZXJzXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElEb3VibGVWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRG91YmxlVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG91YmxlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElGbG9hdFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBGbG9hdFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElJbnQ2NFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEludDY0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVUludDY0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElVSW50NjRWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBVSW50NjRWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUludDMyVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEludDMyVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50MzJcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElVSW50MzJWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVUludDMyVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDMyXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUJvb2xWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEJvb2xWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJU3RyaW5nVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFN0cmluZ1ZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJQnl0ZXNWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEJ5dGVzVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcImZpZWxkX21hc2tcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2sgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElEb3VibGVWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRmllbGRNYXNrOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgcGF0aHM6IHtcbiAgICAgICAgICAgICAgICBydWxlOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgcm9vdCBkZWZpbml0aW9uIG9mIHRoZSBzcGVjaWZpZWQgY29tbW9uIHByb3RvIGZpbGUuXG4gKlxuICogQnVuZGxlZCBkZWZpbml0aW9ucyBhcmU6XG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9lbXB0eS5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgUHJvdG8gZmlsZSBuYW1lXG4gKiBAcmV0dXJucyB7SU5hbWVzcGFjZXxudWxsfSBSb290IGRlZmluaXRpb24gb3IgYG51bGxgIGlmIG5vdCBkZWZpbmVkXG4gKi9cbmNvbW1vbi5nZXQgPSBmdW5jdGlvbiBnZXQoZmlsZSkge1xuICAgIHJldHVybiBjb21tb25bZmlsZV0gfHwgbnVsbDtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2luZGV4LWxpZ2h0XCIpO1xuXG5wcm90b2J1Zi5idWlsZCA9IFwiZnVsbFwiO1xuXG4vLyBQYXJzZXJcbnByb3RvYnVmLnRva2VuaXplICAgICAgICAgPSByZXF1aXJlKFwiLi90b2tlbml6ZVwiKTtcbnByb3RvYnVmLnBhcnNlICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcbnByb3RvYnVmLmNvbW1vbiAgICAgICAgICAgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5cbi8vIENvbmZpZ3VyZSBwYXJzZXJcbnByb3RvYnVmLlJvb3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlLCBwcm90b2J1Zi5wYXJzZSwgcHJvdG9idWYuY29tbW9uKTtcbiIsICIvLyBmdWxsIGxpYnJhcnkgZW50cnkgcG9pbnQuXG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXhcIik7XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiLyoqXG4gKiBOb2RlLmpzIG1vZHVsZSBmb3IgRm9yZ2UuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9uczoge1xuICAgIHVzZVB1cmVKYXZhU2NyaXB0OiBmYWxzZVxuICB9XG59O1xuIiwgIi8qKlxuICogQmFzZS1OL0Jhc2UtWCBlbmNvZGluZy9kZWNvZGluZyBmdW5jdGlvbnMuXG4gKlxuICogT3JpZ2luYWwgaW1wbGVtZW50YXRpb24gZnJvbSBiYXNlLXg6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2Jhc2UteFxuICpcbiAqIFdoaWNoIGlzIE1JVCBsaWNlbnNlZDpcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgYmFzZS14IGNvbnRyaWJ1dG9ycyAoYykgMjAxNlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbnZhciBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vLyBiYXNlTiBhbHBoYWJldCBpbmRleGVzXG52YXIgX3JldmVyc2VBbHBoYWJldHMgPSB7fTtcblxuLyoqXG4gKiBCYXNlTi1lbmNvZGVzIGEgVWludDhBcnJheSB1c2luZyB0aGUgZ2l2ZW4gYWxwaGFiZXQuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlTi1lbmNvZGVkIG91dHB1dCBzdHJpbmcuXG4gKi9cbmFwaS5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgYWxwaGFiZXQsIG1heGxpbmUpIHtcbiAgaWYodHlwZW9mIGFscGhhYmV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWxwaGFiZXRcIiBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG4gIGlmKG1heGxpbmUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbWF4bGluZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm1heGxpbmVcIiBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICB9XG5cbiAgdmFyIG91dHB1dCA9ICcnO1xuXG4gIGlmKCEoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIC8vIGFzc3VtZSBmb3JnZSBieXRlIGJ1ZmZlclxuICAgIG91dHB1dCA9IF9lbmNvZGVXaXRoQnl0ZUJ1ZmZlcihpbnB1dCwgYWxwaGFiZXQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYmFzZSA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gICAgdmFyIGRpZ2l0cyA9IFswXTtcbiAgICBmb3IoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSBpbnB1dFtpXTsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSBiYXNlO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIGJhc2UpIHwgMDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoY2FycnkgPiAwKSB7XG4gICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgYmFzZSk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgZm9yKGkgPSAwOyBpbnB1dFtpXSA9PT0gMCAmJiBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBvdXRwdXQgKz0gZmlyc3Q7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gICAgZm9yKGkgPSBkaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICAgIH1cbiAgfVxuXG4gIGlmKG1heGxpbmUpIHtcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCcuezEsJyArIG1heGxpbmUgKyAnfScsICdnJyk7XG4gICAgb3V0cHV0ID0gb3V0cHV0Lm1hdGNoKHJlZ2V4KS5qb2luKCdcXHJcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiYXNlTi1lbmNvZGVkICh1c2luZyB0aGUgZ2l2ZW4gYWxwaGFiZXQpIHN0cmluZyB0byBhXG4gKiBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZU4tZW5jb2RlZCBpbnB1dCBzdHJpbmcuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheS5cbiAqL1xuYXBpLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCkge1xuICBpZih0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJpbnB1dFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYodHlwZW9mIGFscGhhYmV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWxwaGFiZXRcIiBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgdmFyIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdO1xuICBpZighdGFibGUpIHtcbiAgICAvLyBjb21wdXRlIHJldmVyc2UgYWxwaGFiZXRcbiAgICB0YWJsZSA9IF9yZXZlcnNlQWxwaGFiZXRzW2FscGhhYmV0XSA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7ICsraSkge1xuICAgICAgdGFibGVbYWxwaGFiZXQuY2hhckNvZGVBdChpKV0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9cXHMvZywgJycpO1xuXG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBieXRlcyA9IFswXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gdGFibGVbaW5wdXQuY2hhckNvZGVBdChpKV07XG4gICAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvcih2YXIgaiA9IDAsIGNhcnJ5ID0gdmFsdWU7IGogPCBieXRlcy5sZW5ndGg7ICsraikge1xuICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiBiYXNlO1xuICAgICAgYnl0ZXNbal0gPSBjYXJyeSAmIDB4ZmY7XG4gICAgICBjYXJyeSA+Pj0gODtcbiAgICB9XG5cbiAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKTtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gIGZvcih2YXIgayA9IDA7IGlucHV0W2tdID09PSBmaXJzdCAmJiBrIDwgaW5wdXQubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgYnl0ZXMucHVzaCgwKTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzLnJldmVyc2UoKSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMucmV2ZXJzZSgpKTtcbn07XG5cbmZ1bmN0aW9uIF9lbmNvZGVXaXRoQnl0ZUJ1ZmZlcihpbnB1dCwgYWxwaGFiZXQpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgYmFzZSA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgdmFyIGZpcnN0ID0gYWxwaGFiZXQuY2hhckF0KDApO1xuICB2YXIgZGlnaXRzID0gWzBdO1xuICBmb3IoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGgoKTsgKytpKSB7XG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSBpbnB1dC5hdChpKTsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG4gICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICBjYXJyeSA9IChjYXJyeSAvIGJhc2UpIHwgMDtcbiAgICB9XG5cbiAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgYmFzZSk7XG4gICAgICBjYXJyeSA9IChjYXJyeSAvIGJhc2UpIHwgMDtcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKGkgPSAwOyBpbnB1dC5hdChpKSA9PT0gMCAmJiBpIDwgaW5wdXQubGVuZ3RoKCkgLSAxOyArK2kpIHtcbiAgICBvdXRwdXQgKz0gZmlyc3Q7XG4gIH1cbiAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgZm9yKGkgPSBkaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBvdXRwdXQgKz0gYWxwaGFiZXRbZGlnaXRzW2ldXTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCAiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnZhciBiYXNlTiA9IHJlcXVpcmUoJy4vYmFzZU4nKTtcblxuLyogVXRpbGl0aWVzIEFQSSAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuKGZ1bmN0aW9uKCkge1xuICAvLyB1c2UgbmF0aXZlIG5leHRUaWNrICh1bmxlc3Mgd2UncmUgaW4gd2VicGFjaylcbiAgLy8gd2VicGFjayAob3IgYmV0dGVyIG5vZGUtbGlicy1icm93c2VyIHBvbHlmaWxsKSBzZXRzIHByb2Nlc3MuYnJvd3Nlci5cbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGRldGVjdCB3ZWJwYWNrIHByb3Blcmx5XG4gIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB1dGlsLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggbmV4dFRpY2ssIG9sZGVyIHZlcnNpb25zIG9mIG5vZGVcbiAgICAgIC8vICh0aG9zZSB3L28gc2V0SW1tZWRpYXRlKSB3b24ndCB0b3RhbGx5IHN0YXJ2ZSBJT1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSB1dGlsLm5leHRUaWNrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwb2x5ZmlsbCBuZXh0VGljayB3aXRoIG5hdGl2ZSBzZXRJbW1lZGlhdGVcbiAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9O1xuICAgIHV0aWwubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBOb3RlOiBBIHBvbHlmaWxsIHVwZ3JhZGUgcGF0dGVybiBpcyB1c2VkIGhlcmUgdG8gYWxsb3cgY29tYmluaW5nXG4gIHBvbHlmaWxscy4gRm9yIGV4YW1wbGUsIE11dGF0aW9uT2JzZXJ2ZXIgaXMgZmFzdCwgYnV0IGJsb2NrcyBVSSB1cGRhdGVzLFxuICBzbyBpdCBuZWVkcyB0byBhbGxvdyBVSSB1cGRhdGVzIHBlcmlvZGljYWxseSwgc28gaXQgZmFsbHMgYmFjayBvblxuICBwb3N0TWVzc2FnZSBvciBzZXRUaW1lb3V0LiAqL1xuXG4gIC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dFxuICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH07XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgcG9zdE1lc3NhZ2VcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG1zZyA9ICdmb3JnZS5zZXRJbW1lZGlhdGUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAvLyBvbmx5IHNlbmQgbWVzc2FnZSB3aGVuIG9uZSBoYXNuJ3QgYmVlbiBzZW50IGluXG4gICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZihldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfVxuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgaWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcG9seWZpbGwgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGF0dHIgPSB0cnVlO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgIHZhciBvbGRTZXRJbW1lZGlhdGUgPSB1dGlsLnNldEltbWVkaWF0ZTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZihEYXRlLm5vdygpIC0gbm93ID4gMTUpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG9ic2VydmVyIHdoZW4gaXQgaGFzbid0IGJlZW4gdHJpZ2dlcmVkIGluXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2EnLCBhdHRyID0gIWF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHV0aWwubmV4dFRpY2sgPSB1dGlsLnNldEltbWVkaWF0ZTtcbn0pKCk7XG5cbi8vIGNoZWNrIGlmIHJ1bm5pbmcgdW5kZXIgTm9kZS5qc1xudXRpbC5pc05vZGVqcyA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcblxuXG4vLyAnc2VsZicgd2lsbCBhbHNvIHdvcmsgaW4gV2ViIFdvcmtlcnMgKGluc3RhbmNlIG9mIFdvcmtlckdsb2JhbFNjb3BlKSB3aGlsZVxuLy8gaXQgd2lsbCBwb2ludCB0byBgd2luZG93YCBpbiB0aGUgbWFpbiB0aHJlYWQuXG4vLyBUbyByZW1haW4gY29tcGF0aWJsZSB3aXRoIG9sZGVyIGJyb3dzZXJzLCB3ZSBmYWxsIGJhY2sgdG8gJ3dpbmRvdycgaWYgJ3NlbGYnXG4vLyBpcyBub3QgYXZhaWxhYmxlLlxudXRpbC5nbG9iYWxTY29wZSA9IChmdW5jdGlvbigpIHtcbiAgaWYodXRpbC5pc05vZGVqcykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnID8gd2luZG93IDogc2VsZjtcbn0pKCk7XG5cbi8vIGRlZmluZSBpc0FycmF5XG51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIGRlZmluZSBpc0FycmF5QnVmZmVyXG51dGlsLmlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5cbi8vIGRlZmluZSBpc0FycmF5QnVmZmVyVmlld1xudXRpbC5pc0FycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggJiYgdXRpbC5pc0FycmF5QnVmZmVyKHguYnVmZmVyKSAmJiB4LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRW5zdXJlIGEgYml0cyBwYXJhbSBpcyA4LCAxNiwgMjQsIG9yIDMyLiBVc2VkIHRvIHZhbGlkYXRlIGlucHV0IGZvclxuICogYWxnb3JpdGhtcyB3aGVyZSBiaXQgbWFuaXB1bGF0aW9uLCBKYXZhU2NyaXB0IGxpbWl0YXRpb25zLCBhbmQvb3IgYWxnb3JpdGhtXG4gKiBkZXNpZ24gb25seSBhbGxvdyBmb3IgYnl0ZSBvcGVyYXRpb25zIG9mIGEgbGltaXRlZCBzaXplLlxuICpcbiAqIEBwYXJhbSBuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIFRocm93IEVycm9yIGlmIG4gaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gX2NoZWNrQml0c1BhcmFtKG4pIHtcbiAgaWYoIShuID09PSA4IHx8IG4gPT09IDE2IHx8IG4gPT09IDI0IHx8IG4gPT09IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSA4LCAxNiwgMjQsIG9yIDMyIGJpdHMgc3VwcG9ydGVkOiAnICsgbik7XG4gIH1cbn1cblxuLy8gVE9ETzogc2V0IEJ5dGVCdWZmZXIgdG8gYmVzdCBhdmFpbGFibGUgYmFja2luZ1xudXRpbC5CeXRlQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyoqIEJ1ZmZlciB3L0JpbmFyeVN0cmluZyBiYWNraW5nICovXG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIGEgYmluYXJ5IHN0cmluZyBiYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIFtiXSB0aGUgYnl0ZXMgdG8gd3JhcCAoZWl0aGVyIGVuY29kZWQgYXMgc3RyaW5nLCBvbmUgYnl0ZSBwZXJcbiAqICAgICAgICAgIGNoYXJhY3Rlciwgb3IgYXMgYW4gQXJyYXlCdWZmZXIgb3IgVHlwZWQgQXJyYXkpLlxuICovXG5mdW5jdGlvbiBCeXRlU3RyaW5nQnVmZmVyKGIpIHtcbiAgLy8gVE9ETzogdXBkYXRlIHRvIG1hdGNoIERhdGFCdWZmZXIgQVBJXG5cbiAgLy8gdGhlIGRhdGEgaW4gdGhpcyBidWZmZXJcbiAgdGhpcy5kYXRhID0gJyc7XG4gIC8vIHRoZSBwb2ludGVyIGZvciByZWFkaW5nIGZyb20gdGhpcyBidWZmZXJcbiAgdGhpcy5yZWFkID0gMDtcblxuICBpZih0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmRhdGEgPSBiO1xuICB9IGVsc2UgaWYodXRpbC5pc0FycmF5QnVmZmVyKGIpIHx8IHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYikpIHtcbiAgICBpZih0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBiIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICB0aGlzLmRhdGEgPSBiLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29udmVydCBuYXRpdmUgYnVmZmVyIHRvIGZvcmdlIGJ1ZmZlclxuICAgICAgLy8gRklYTUU6IHN1cHBvcnQgbmF0aXZlIGJ1ZmZlcnMgaW50ZXJuYWxseSBpbnN0ZWFkXG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMucHV0Qnl0ZShhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYiBpbnN0YW5jZW9mIEJ5dGVTdHJpbmdCdWZmZXIgfHxcbiAgICAodHlwZW9mIGIgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiLmRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGIucmVhZCA9PT0gJ251bWJlcicpKSB7XG4gICAgLy8gY29weSBleGlzdGluZyBidWZmZXJcbiAgICB0aGlzLmRhdGEgPSBiLmRhdGE7XG4gICAgdGhpcy5yZWFkID0gYi5yZWFkO1xuICB9XG5cbiAgLy8gdXNlZCBmb3Igdjggb3B0aW1pemF0aW9uXG4gIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbn1cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlciA9IEJ5dGVTdHJpbmdCdWZmZXI7XG5cbi8qIE5vdGU6IFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIGZvciBWOC1iYXNlZCBicm93c2Vycy4gV2hlbiBWOCBjb25jYXRlbmF0ZXNcbiAgYSBzdHJpbmcsIHRoZSBzdHJpbmdzIGFyZSBvbmx5IGpvaW5lZCBsb2dpY2FsbHkgdXNpbmcgYSBcImNvbnMgc3RyaW5nXCIgb3JcbiAgXCJjb25zdHJ1Y3RlZC9jb25jYXRlbmF0ZWQgc3RyaW5nXCIuIFRoZXNlIGNvbnRhaW5lcnMga2VlcCByZWZlcmVuY2VzIHRvIG9uZVxuICBhbm90aGVyIGFuZCBjYW4gcmVzdWx0IGluIHZlcnkgbGFyZ2UgbWVtb3J5IHVzYWdlLiBGb3IgZXhhbXBsZSwgaWYgYSAyTUJcbiAgc3RyaW5nIGlzIGNvbnN0cnVjdGVkIGJ5IGNvbmNhdGVuYXRpbmcgNCBieXRlcyB0b2dldGhlciBhdCBhIHRpbWUsIHRoZVxuICBtZW1vcnkgdXNhZ2Ugd2lsbCBiZSB+NDRNQjsgc28gfjIyeCBpbmNyZWFzZS4gVGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkXG4gIHRvZ2V0aGVyIHdoZW4gYW4gb3BlcmF0aW9uIHJlcXVpcmluZyB0aGVpciBqb2luaW5nIHRha2VzIHBsYWNlLCBzdWNoIGFzXG4gIHN1YnN0cigpLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGFkZGluZyBkYXRhIHRvIHRoaXMgYnVmZmVyIHRvIGVuc3VyZVxuICB0aGVzZSB0eXBlcyBvZiBzdHJpbmdzIGFyZSBwZXJpb2RpY2FsbHkgam9pbmVkIHRvIHJlZHVjZSB0aGUgbWVtb3J5XG4gIGZvb3RwcmludC4gKi9cbnZhciBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEggPSA0MDk2O1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggKz0geDtcbiAgaWYodGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPiBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEgpIHtcbiAgICAvLyB0aGlzIHN1YnN0cigpIHNob3VsZCBjYXVzZSB0aGUgY29uc3RydWN0ZWQgc3RyaW5nIHRvIGpvaW5cbiAgICB0aGlzLmRhdGEuc3Vic3RyKDAsIDEpO1xuICAgIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCAtIHRoaXMucmVhZDtcbn07XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGlzIGJ1ZmZlciBpcyBlbXB0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBidWZmZXIgaXMgZW1wdHksIGZhbHNlIGlmIG5vdC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCgpIDw9IDA7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIGIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpO1xuICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgZCArPSBiO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYiArPSBiO1xuICAgIH1cbiAgfVxuICB0aGlzLmRhdGEgPSBkO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKG4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIChhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZykgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcykge1xuICB0aGlzLmRhdGEgKz0gYnl0ZXM7XG4gIHRoaXMuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcoYnl0ZXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBVVEYtMTYgZW5jb2RlZCBzdHJpbmcgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKHV0aWwuZW5jb2RlVXRmOChzdHIpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MTZMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNExlID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMkxlID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhbiBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHZhciBieXRlcyA9ICcnO1xuICBkbyB7XG4gICAgbiAtPSA4O1xuICAgIGJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGkgPj4gbikgJiAweEZGKTtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuIFR3bydzXG4gKiBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICAvLyBwdXRJbnQgY2hlY2tzIG5cbiAgaWYoaSA8IDApIHtcbiAgICBpICs9IDIgPDwgKG4gLSAxKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wdXRJbnQoaSwgbik7XG59O1xuXG4vKipcbiAqIFB1dHMgdGhlIGdpdmVuIGJ1ZmZlciBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgdGhlIGJ1ZmZlciB0byBwdXQgaW50byB0aGlzIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhidWZmZXIuZ2V0Qnl0ZXMoKSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGZyb20gdGhpcyBidWZmZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgMS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDE2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSk7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDI0IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMykpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDgpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpIDw8IDI0KTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBjZWlsKG4vOCkuXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGVcbiAqIGJ1ZmZlci4gTm90ZSB0aGF0IHRoZSByZXN1bHRpbmcgc3RyaW5nIGlzIGJpbmFyeSBlbmNvZGVkIChpbiBub2RlLmpzIHRoaXNcbiAqIGVuY29kaW5nIGlzIHJlZmVycmVkIHRvIGFzIGBiaW5hcnlgLCBpdCBpcyAqbm90KiBgdXRmOGApLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dFxuICogbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIGJpbmFyeSBlbmNvZGVkIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICByZXR1cm4gKHR5cGVvZihjb3VudCkgPT09ICd1bmRlZmluZWQnID9cbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKSA6XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyKDAsIHRoaXMucmVhZCArIGkpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpICtcbiAgICB0aGlzLmRhdGEuc3Vic3RyKHRoaXMucmVhZCArIGkgKyAxKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxhc3QgYnl0ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGxhc3QgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLmRhdGEubGVuZ3RoIC0gMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNvcHkuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYyA9IHV0aWwuY3JlYXRlQnVmZmVyKHRoaXMuZGF0YSk7XG4gIGMucmVhZCA9IHRoaXMucmVhZDtcbiAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqIENvbXBhY3RzIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLnJlYWQgPiAwKSB7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5yZWFkID0gMDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kYXRhID0gJyc7XG4gIHRoaXMucmVhZCA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaG9ydGVucyB0aGlzIGJ1ZmZlciBieSB0cmltaW5nIGJ5dGVzIG9mZiBvZiB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHRyaW0gb2ZmLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgoKSAtIGNvdW50KTtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQsIGxlbik7XG4gIHRoaXMucmVhZCA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gJyc7XG4gIGZvcih2YXIgaSA9IHRoaXMucmVhZDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBiID0gdGhpcy5kYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBVVEYtMTYgc3RyaW5nIChzdGFuZGFyZCBKYXZhU2NyaXB0IHN0cmluZykuXG4gKlxuICogQHJldHVybiBhIFVURi0xNiBzdHJpbmcuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHV0aWwuZGVjb2RlVXRmOCh0aGlzLmJ5dGVzKCkpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9CaW5hcnlTdHJpbmcgYmFja2luZyAqL1xuXG4vKiogQnVmZmVyIHcvVUludDhBcnJheSBiYWNraW5nICovXG5cbi8qKlxuICogRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG4gKlxuICogQ29uc3RydWN0b3IgZm9yIGFuIEFycmF5QnVmZmVyLWJhY2tlZCBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUaGUgYnVmZmVyIG1heSBiZSBjb25zdHJ1Y3RlZCBmcm9tIGEgc3RyaW5nLCBhbiBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIG9yIGFcbiAqIFR5cGVkQXJyYXkuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgZ2l2ZW4sIGl0cyBlbmNvZGluZyBzaG91bGQgYmUgcHJvdmlkZWQgYXMgYW4gb3B0aW9uLFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgZGVmYXVsdCB0byAnYmluYXJ5Jy4gQSAnYmluYXJ5JyBzdHJpbmcgaXMgZW5jb2RlZCBzdWNoXG4gKiB0aGF0IGVhY2ggY2hhcmFjdGVyIGlzIG9uZSBieXRlIGluIGxlbmd0aCBhbmQgc2l6ZS5cbiAqXG4gKiBJZiBhbiBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIG9yIFR5cGVkQXJyYXkgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgdXNlZFxuICogKmRpcmVjdGx5KiB3aXRob3V0IGFueSBjb3B5aW5nLiBOb3RlIHRoYXQsIGlmIGEgd3JpdGUgdG8gdGhlIGJ1ZmZlciByZXF1aXJlc1xuICogbW9yZSBzcGFjZSwgdGhlIGJ1ZmZlciB3aWxsIGFsbG9jYXRlIGEgbmV3IGJhY2tpbmcgQXJyYXlCdWZmZXIgdG9cbiAqIGFjY29tbW9kYXRlLiBUaGUgc3RhcnRpbmcgcmVhZCBhbmQgd3JpdGUgb2Zmc2V0cyBmb3IgdGhlIGJ1ZmZlciBtYXkgYmVcbiAqIGdpdmVuIGFzIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIFtiXSB0aGUgaW5pdGlhbCBieXRlcyBmb3IgdGhpcyBidWZmZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbcmVhZE9mZnNldF0gdGhlIHN0YXJ0aW5nIHJlYWQgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogMCkuXG4gKiAgICAgICAgICBbd3JpdGVPZmZzZXRdIHRoZSBzdGFydGluZyB3cml0ZSBvZmZzZXQgdG8gdXNlIChkZWZhdWx0OiB0aGVcbiAqICAgICAgICAgICAgbGVuZ3RoIG9mIHRoZSBmaXJzdCBwYXJhbWV0ZXIpLlxuICogICAgICAgICAgW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgdG9cbiAqICAgICAgICAgICAgYWNjb21tb2RhdGUgd3JpdGVzIChkZWZhdWx0OiAxMDI0KS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nICgnYmluYXJ5JywgJ3V0ZjgnLCAndXRmMTYnLCAnaGV4JykgZm9yIHRoZVxuICogICAgICAgICAgICBmaXJzdCBwYXJhbWV0ZXIsIGlmIGl0IGlzIGEgc3RyaW5nIChkZWZhdWx0OiAnYmluYXJ5JykuXG4gKi9cbmZ1bmN0aW9uIERhdGFCdWZmZXIoYiwgb3B0aW9ucykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gcG9pbnRlcnMgZm9yIHJlYWQgZnJvbS93cml0ZSB0byBidWZmZXJcbiAgdGhpcy5yZWFkID0gb3B0aW9ucy5yZWFkT2Zmc2V0IHx8IDA7XG4gIHRoaXMuZ3Jvd1NpemUgPSBvcHRpb25zLmdyb3dTaXplIHx8IDEwMjQ7XG5cbiAgdmFyIGlzQXJyYXlCdWZmZXIgPSB1dGlsLmlzQXJyYXlCdWZmZXIoYik7XG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYik7XG4gIGlmKGlzQXJyYXlCdWZmZXIgfHwgaXNBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAvLyB1c2UgQXJyYXlCdWZmZXIgZGlyZWN0bHlcbiAgICBpZihpc0FycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkanVzdCByZWFkL3dyaXRlIG9mZnNldCBiYXNlZCBvbiB0aGUgdHlwZSBvZiB2aWV3XG4gICAgICAvLyBvciBzcGVjaWZ5IHRoYXQgdGhpcyBtdXN0IGJlIGRvbmUgaW4gdGhlIG9wdGlvbnMgLi4uIHRoYXQgdGhlXG4gICAgICAvLyBvZmZzZXRzIGFyZSBieXRlLWJhc2VkXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhpcy53cml0ZSA9ICgnd3JpdGVPZmZzZXQnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy53cml0ZU9mZnNldCA6IHRoaXMuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHRvIGVtcHR5IGFycmF5IGJ1ZmZlciBhbmQgYWRkIGFueSBnaXZlbiBieXRlcyB1c2luZyBwdXRCeXRlc1xuICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgdGhpcy53cml0ZSA9IDA7XG5cbiAgaWYoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnB1dEJ5dGVzKGIpO1xuICB9XG5cbiAgaWYoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy53cml0ZSA9IG9wdGlvbnMud3JpdGVPZmZzZXQ7XG4gIH1cbn1cbnV0aWwuRGF0YUJ1ZmZlciA9IERhdGFCdWZmZXI7XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUgLSB0aGlzLnJlYWQ7XG59O1xuXG4vKipcbiAqIEdldHMgd2hldGhlciBvciBub3QgdGhpcyBidWZmZXIgaXMgZW1wdHkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgYnVmZmVyIGlzIGVtcHR5LCBmYWxzZSBpZiBub3QuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGgoKSA8PSAwO1xufTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoaXMgYnVmZmVyIGhhcyBlbm91Z2ggZW1wdHkgc3BhY2UgdG8gYWNjb21tb2RhdGUgdGhlIGdpdmVuIG51bWJlclxuICogb2YgYnl0ZXMuIEFuIG9wdGlvbmFsIHBhcmFtZXRlciBtYXkgYmUgZ2l2ZW4gdGhhdCBpbmRpY2F0ZXMgYSBtaW5pbXVtXG4gKiBhbW91bnQgdG8gZ3JvdyB0aGUgYnVmZmVyIGlmIG5lY2Vzc2FyeS4gSWYgdGhlIHBhcmFtZXRlciBpcyBub3QgZ2l2ZW4sXG4gKiB0aGUgYnVmZmVyIHdpbGwgYmUgZ3Jvd24gYnkgc29tZSBwcmV2aW91c2x5LXNwZWNpZmllZCBkZWZhdWx0IGFtb3VudFxuICogb3IgaGV1cmlzdGljLlxuICpcbiAqIEBwYXJhbSBhbW91bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBhY2NvbW1vZGF0ZS5cbiAqIEBwYXJhbSBbZ3Jvd1NpemVdIHRoZSBtaW5pbXVtIGFtb3VudCwgaW4gYnl0ZXMsIHRvIGdyb3cgdGhlIGJ1ZmZlciBieSBpZlxuICogICAgICAgICAgbmVjZXNzYXJ5LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmFjY29tbW9kYXRlID0gZnVuY3Rpb24oYW1vdW50LCBncm93U2l6ZSkge1xuICBpZih0aGlzLmxlbmd0aCgpID49IGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyb3dTaXplID0gTWF0aC5tYXgoZ3Jvd1NpemUgfHwgdGhpcy5ncm93U2l6ZSwgYW1vdW50KTtcblxuICAvLyBncm93IGJ1ZmZlclxuICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgdGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5kYXRhLmJ5dGVPZmZzZXQsIHRoaXMuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKyBncm93U2l6ZSk7XG4gIGRzdC5zZXQoc3JjKTtcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGRzdC5idWZmZXIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlID0gZnVuY3Rpb24oYikge1xuICB0aGlzLmFjY29tbW9kYXRlKDEpO1xuICB0aGlzLmRhdGEuc2V0VWludDgodGhpcy53cml0ZSsrLCBiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyIE4gdGltZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyBvZiB2YWx1ZSBiIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHRoaXMuZGF0YS5zZXRVaW50OChiKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBieXRlcyBpbiB0aGlzIGJ1ZmZlci4gVGhlIGJ5dGVzIG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZywgYW5cbiAqIEFycmF5QnVmZmVyLCBhIERhdGFWaWV3LCBvciBhIFR5cGVkQXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBwdXQuXG4gKiBAcGFyYW0gW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgZm9yIHRoZSBmaXJzdCBwYXJhbWV0ZXIgKCdiaW5hcnknLCAndXRmOCcsXG4gKiAgICAgICAgICAndXRmMTYnLCAnaGV4JyksIGlmIGl0IGlzIGEgc3RyaW5nIChkZWZhdWx0OiAnYmluYXJ5JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzLCBlbmNvZGluZykge1xuICBpZih1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBsZW4gPSBzcmMuYnl0ZUxlbmd0aCAtIHNyYy5ieXRlT2Zmc2V0O1xuICAgIHRoaXMuYWNjb21tb2RhdGUobGVuKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyKGJ5dGVzKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpO1xuICAgIGRzdC5zZXQoc3JjLCB0aGlzLndyaXRlKTtcbiAgICB0aGlzLndyaXRlICs9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gYnl0ZXMgaXMgYSB1dGlsLkRhdGFCdWZmZXIgb3IgZXF1aXZhbGVudFxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuRGF0YUJ1ZmZlciB8fFxuICAgICh0eXBlb2YgYnl0ZXMgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGJ5dGVzLnJlYWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBieXRlcy53cml0ZSA9PT0gJ251bWJlcicgJiZcbiAgICB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzLmRhdGEpKSkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcy5kYXRhLmJ5dGVMZW5ndGgsIGJ5dGVzLnJlYWQsIGJ5dGVzLmxlbmd0aCgpKTtcbiAgICB0aGlzLmFjY29tbW9kYXRlKHNyYy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCB0aGlzLndyaXRlKTtcbiAgICBkc3Quc2V0KHNyYyk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKGJ5dGVzIGluc3RhbmNlb2YgdXRpbC5CeXRlU3RyaW5nQnVmZmVyKSB7XG4gICAgLy8gY29weSBiaW5hcnkgc3RyaW5nIGFuZCBwcm9jZXNzIGFzIHRoZSBzYW1lIGFzIGEgc3RyaW5nIHBhcmFtZXRlciBiZWxvd1xuICAgIGJ5dGVzID0gYnl0ZXMuZGF0YTtcbiAgICBlbmNvZGluZyA9ICdiaW5hcnknO1xuICB9XG5cbiAgLy8gc3RyaW5nIGNvbnZlcnNpb25cbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgaWYodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciB2aWV3O1xuXG4gICAgLy8gZGVjb2RlIGZyb20gc3RyaW5nXG4gICAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKE1hdGguY2VpbChieXRlcy5sZW5ndGggLyAyKSk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmhleC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gNCkgKiAzKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZShieXRlcywgdmlldywgdGhpcy53cml0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdGV4dCBhcyBVVEYtOCBieXRlc1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIC8vIGVuY29kZSBhcyBVVEYtOCB0aGVuIGRlY29kZSBzdHJpbmcgYXMgcmF3IGJpbmFyeVxuICAgICAgYnl0ZXMgPSB1dGlsLmVuY29kZVV0ZjgoYnl0ZXMpO1xuICAgICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgICB9XG5cbiAgICAvLyBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgICAvLyBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LnJhdy5kZWNvZGUodmlldyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdGV4dCBhcyBVVEYtMTYgYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgICAgLy8gdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXJcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoYnl0ZXMubGVuZ3RoICogMik7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLnRleHQudXRmMTYuZW5jb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG5cbiAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyOiAnICsgYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdGhpcy5wdXRCeXRlcyhidWZmZXIpO1xuICBidWZmZXIuY2xlYXIoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzdHJpbmcgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgc3RyaW5nIChkZWZhdWx0OiAndXRmMTYnKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhzdHIsICd1dGYxNicpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNiA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGkpO1xuICB0aGlzLndyaXRlICs9IDI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNCA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGkgPj4gOCAmIDB4RkZGRik7XG4gIHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUsIGkgPj4gMTYgJiAweEZGKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzIgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoNCk7XG4gIHRoaXMuZGF0YS5zZXRJbnQzMih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSA0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTZMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNExlID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDMpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYsIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMkxlID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSwgdHJ1ZSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB0aGlzLmFjY29tbW9kYXRlKG4gLyA4KTtcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlKyssIChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuIFR3bydzXG4gKiBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQgKyAyKSk7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQzMih0aGlzLnJlYWQpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCwgdHJ1ZSk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCArIDEsIHRydWUpIDw8IDgpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzJMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQzMih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZVxuICogcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50ID0gZnVuY3Rpb24obikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHZhciBydmFsID0gMDtcbiAgZG8ge1xuICAgIC8vIFRPRE86IFVzZSAocnZhbCAqIDB4MTAwKSBpZiBhZGRpbmcgc3VwcG9ydCBmb3IgMzMgdG8gNTMgYml0cy5cbiAgICBydmFsID0gKHJ2YWwgPDwgOCkgKyB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyk7XG4gICAgbiAtPSA4O1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIsIHVzaW5nXG4gKiB0d28ncyBjb21wbGVtZW50LCBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldFNpZ25lZEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgLy8gZ2V0SW50IGNoZWNrcyBuXG4gIHZhciB4ID0gdGhpcy5nZXRJbnQobik7XG4gIHZhciBtYXggPSAyIDw8IChuIC0gMik7XG4gIGlmKHggPj0gbWF4KSB7XG4gICAgeCAtPSBtYXggPDwgMTtcbiAgfVxuICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogUmVhZHMgYnl0ZXMgb3V0IGFzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIGFuZCBjbGVhcnMgdGhlbSBmcm9tIHRoZVxuICogYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkIGFuZFxuICAvLyB0aGlzLnRvU3RyaW5nKCdiaW5hcnknKSByZXBsYWNlcyBpdFxuICAvLyBhZGQgYSB0b1R5cGVkQXJyYXkoKS90b0FycmF5QnVmZmVyKCkgZnVuY3Rpb25cbiAgdmFyIHJ2YWw7XG4gIGlmKGNvdW50KSB7XG4gICAgLy8gcmVhZCBjb3VudCBieXRlc1xuICAgIGNvdW50ID0gTWF0aC5taW4odGhpcy5sZW5ndGgoKSwgY291bnQpO1xuICAgIHJ2YWwgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCk7XG4gICAgdGhpcy5yZWFkICs9IGNvdW50O1xuICB9IGVsc2UgaWYoY291bnQgPT09IDApIHtcbiAgICBydmFsID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBhbGwgYnl0ZXMsIG9wdGltaXplIHRvIG9ubHkgY29weSB3aGVuIG5lZWRlZFxuICAgIHJ2YWwgPSAodGhpcy5yZWFkID09PSAwKSA/IHRoaXMuZGF0YSA6IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYnl0ZXMgZnJvbSB0aGlzIGJ1ZmZlciB3aXRob3V0XG4gKiBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZXQsIG9taXQgdG8gZ2V0IGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIGZ1bGwgb2YgYmluYXJ5IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkLCBhZGQgXCJnZXRTdHJpbmcoKVwiXG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEuc2V0VWludDgoaSwgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUgLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgdXRpbC5EYXRhQnVmZmVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLnJlYWQpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QpO1xuICAgIHRoaXMud3JpdGUgLT0gdGhpcy5yZWFkO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHRoaXMud3JpdGUgPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuZ2V0VWludDgoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBzdHJpbmcsIHVzaW5nIHRoZSBnaXZlbiBlbmNvZGluZy4gSWYgbm9cbiAqIGVuY29kaW5nIGlzIGdpdmVuLCAndXRmOCcgKFVURi04KSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyB0byB1c2U6ICdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnLFxuICogICAgICAgICAgJ2Jhc2U2NCcgKGRlZmF1bHQ6ICd1dGY4JykuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgdGhpcy5yZWFkLCB0aGlzLmxlbmd0aCgpKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gZW5jb2RlIHRvIHN0cmluZ1xuICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LnJhdy5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUodmlldyk7XG4gIH1cblxuICAvLyBkZWNvZGUgdG8gdGV4dFxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgcmV0dXJuIHV0aWwudGV4dC51dGY4LmRlY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmMTYuZGVjb2RlKHZpZXcpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYnVmZmVyIHRoYXQgc3RvcmVzIGJ5dGVzLiBBIHZhbHVlIG1heSBiZSBnaXZlbiB0byBwb3B1bGF0ZSB0aGVcbiAqIGJ1ZmZlciB3aXRoIGRhdGEuIFRoaXMgdmFsdWUgY2FuIGVpdGhlciBiZSBzdHJpbmcgb2YgZW5jb2RlZCBieXRlcyBvciBhXG4gKiByZWd1bGFyIHN0cmluZyBvZiBjaGFyYWN0ZXJzLiBXaGVuIHBhc3NpbmcgYSBzdHJpbmcgb2YgYmluYXJ5IGVuY29kZWRcbiAqIGJ5dGVzLCB0aGUgZW5jb2RpbmcgYHJhd2Agc2hvdWxkIGJlIGdpdmVuLiBUaGlzIGlzIGFsc28gdGhlIGRlZmF1bHQuIFdoZW5cbiAqIHBhc3NpbmcgYSBzdHJpbmcgb2YgY2hhcmFjdGVycywgdGhlIGVuY29kaW5nIGB1dGY4YCBzaG91bGQgYmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIFtpbnB1dF0gYSBzdHJpbmcgd2l0aCBlbmNvZGVkIGJ5dGVzIHRvIHN0b3JlIGluIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0gW2VuY29kaW5nXSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICovXG51dGlsLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGlucHV0LCBlbmNvZGluZykge1xuICAvLyBUT0RPOiBkZXByZWNhdGUsIHVzZSBuZXcgQnl0ZUJ1ZmZlcigpIGluc3RlYWRcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAncmF3JztcbiAgaWYoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgaW5wdXQgPSB1dGlsLmVuY29kZVV0ZjgoaW5wdXQpO1xuICB9XG4gIHJldHVybiBuZXcgdXRpbC5CeXRlQnVmZmVyKGlucHV0KTtcbn07XG5cbi8qKlxuICogRmlsbHMgYSBzdHJpbmcgd2l0aCBhIHBhcnRpY3VsYXIgdmFsdWUuIElmIHlvdSB3YW50IHRoZSBzdHJpbmcgdG8gYmUgYSBieXRlXG4gKiBzdHJpbmcsIHBhc3MgaW4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGVCeXRlKS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY2hhcmFjdGVyIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoLCB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICogICAgICAgICAgdG8gZmlsbCB0aGUgc3RyaW5nIHdpdGggYSBieXRlIHZhbHVlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHZhbHVlIGMgdG8gZmlsbCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbGxlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZmlsbFN0cmluZyA9IGZ1bmN0aW9uKGMsIG4pIHtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgcyArPSBjO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYyArPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBwZXIgYnl0ZSBYT1IgYmV0d2VlbiB0d28gYnl0ZSBzdHJpbmdzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYVxuICogc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzMSBmaXJzdCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gczIgc2Vjb25kIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gWE9SLlxuICpcbiAqIEByZXR1cm4gdGhlIFhPUidkIHJlc3VsdC5cbiAqL1xudXRpbC54b3JCeXRlcyA9IGZ1bmN0aW9uKHMxLCBzMiwgbikge1xuICB2YXIgczMgPSAnJztcbiAgdmFyIGIgPSAnJztcbiAgdmFyIHQgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB2YXIgYyA9IDA7XG4gIGZvcig7IG4gPiAwOyAtLW4sICsraSkge1xuICAgIGIgPSBzMS5jaGFyQ29kZUF0KGkpIF4gczIuY2hhckNvZGVBdChpKTtcbiAgICBpZihjID49IDEwKSB7XG4gICAgICBzMyArPSB0O1xuICAgICAgdCA9ICcnO1xuICAgICAgYyA9IDA7XG4gICAgfVxuICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICArK2M7XG4gIH1cbiAgczMgKz0gdDtcbiAgcmV0dXJuIHMzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5oZXhUb0J5dGVzID0gZnVuY3Rpb24oaGV4KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmRlY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBydmFsID0gJyc7XG4gIHZhciBpID0gMDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEgPT0gMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBydmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4WzBdLCAxNikpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5ieXRlc1RvSGV4ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5oZXguZW5jb2RlIGluc3RlYWQuXCJcbiAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKS50b0hleCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiAzMi1iaXQgaW50ZWdlciB0byA0LWJpZy1lbmRpYW4gYnl0ZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGkgdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBzdHJpbmcuXG4gKi9cbnV0aWwuaW50MzJUb0J5dGVzID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLy8gYmFzZTY0IGNoYXJhY3RlcnMsIHJldmVyc2UgbWFwcGluZ1xudmFyIF9iYXNlNjQgPVxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xudmFyIF9iYXNlNjRJZHggPSBbXG4vKjQzIC00MyA9IDAqL1xuLyonKycsICAxLCAgMiwgIDMsJy8nICovXG4gICA2MiwgLTEsIC0xLCAtMSwgNjMsXG5cbi8qJzAnLCcxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknICovXG4gICA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSxcblxuLyoxNSwgMTYsIDE3LCc9JywgMTksIDIwLCAyMSAqL1xuICAtMSwgLTEsIC0xLCA2NCwgLTEsIC0xLCAtMSxcblxuLyo2NSAtIDQzID0gMjIqL1xuLyonQScsJ0InLCdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsICovXG4gICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLFxuXG4vKidOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJyAqL1xuICAgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsXG5cbi8qOTEgLSA0MyA9IDQ4ICovXG4vKjQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMgKi9cbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuLyo5NyAtIDQzID0gNTQqL1xuLyonYScsJ2InLCdjJywnZCcsJ2UnLCdmJywnZycsJ2gnLCdpJywnaicsJ2snLCdsJywnbScgKi9cbiAgIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LFxuXG4vKiduJywnbycsJ3AnLCdxJywncicsJ3MnLCd0JywndScsJ3YnLCd3JywneCcsJ3knLCd6JyAqL1xuICAgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTFcbl07XG5cbi8vIGJhc2U1OCBjaGFyYWN0ZXJzIChCaXRjb2luIGFscGhhYmV0KVxudmFyIF9iYXNlNTggPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5cbi8qKlxuICogQmFzZTY0IGVuY29kZXMgYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcyB0byBiYXNlNjQtZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dC5cbiAqL1xudXRpbC5lbmNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQgZGVjb2RlcyBhIHN0cmluZyBpbnRvIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZGVjb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgaW5zdGVhZC5cIlxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCkpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBvZiBjaGFyYWN0ZXJzIChhIHN0YW5kYXJkIEphdmFTY3JpcHRcbiAqIHN0cmluZykgYXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgd2hlcmUgdGhlIGJ5dGVzIHJlcHJlc2VudFxuICogYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiBjaGFyYWN0ZXJzLiBOb24tQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlXG4gKiBlbmNvZGVkIGFzIG11bHRpcGxlIGJ5dGVzIGFjY29yZGluZyB0byBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIGEgc3RhbmRhcmQgc3RyaW5nIG9mIGNoYXJhY3RlcnMgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5lbmNvZGVVdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgdGhhdCBjb250YWlucyBieXRlcyB0aGF0XG4gKiByZXByZXNlbnQgYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiBjaGFyYWN0ZXJzIC0tIGludG8gYVxuICogc3RyaW5nIG9mIGNoYXJhY3RlcnMgKGEgc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0YW5kYXJkIHN0cmluZyBvZiBjaGFyYWN0ZXJzLlxuICovXG51dGlsLmRlY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59O1xuXG4vLyBiaW5hcnkgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC5iaW5hcnkgPSB7XG4gIHJhdzoge30sXG4gIGhleDoge30sXG4gIGJhc2U2NDoge30sXG4gIGJhc2U1ODoge30sXG4gIGJhc2VOIDoge1xuICAgIGVuY29kZTogYmFzZU4uZW5jb2RlLFxuICAgIGRlY29kZTogYmFzZU4uZGVjb2RlXG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIFVpbnQ4QXJyYXkgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5lbmNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LiBUaGlzIGVuY29kaW5nIHVzZXNcbiAqIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5yYXcuZGVjb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0W2orK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgJ2JpbmFyeScgc3RyaW5nLCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIFR5cGVkQXJyYXksIG9yXG4gKiBCeXRlQnVmZmVyIGFzIGEgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLmJpbmFyeS5oZXguZW5jb2RlID0gdXRpbC5ieXRlc1RvSGV4O1xuXG4vKipcbiAqIERlY29kZXMgYSBoZXgtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuaGV4LmRlY29kZSA9IGZ1bmN0aW9uKGhleCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMikpO1xuICB9XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG4gIGlmKGhleC5sZW5ndGggJiAxKSB7XG4gICAgLy8gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBjb252ZXJ0IGZpcnN0IGNoYXJhY3RlciBhbG9uZVxuICAgIGkgPSAxO1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4WzBdLCAxNik7XG4gIH1cbiAgLy8gY29udmVydCAyIGNoYXJhY3RlcnMgKDEgYnl0ZSkgYXQgYSB0aW1lXG4gIGZvcig7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBvdXRbaisrXSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQtZW5jb2RlcyBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlNjQtZW5jb2RlZCBvdXRwdXQgc3RyaW5nLlxuICovXG51dGlsLmJpbmFyeS5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgdmFyIGxpbmUgPSAnJztcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZShpIDwgaW5wdXQuYnl0ZUxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dFtpKytdO1xuICAgIGNocjIgPSBpbnB1dFtpKytdO1xuICAgIGNocjMgPSBpbnB1dFtpKytdO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJhc2U2NC1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyA0KSAqIDMpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFsbCBub24tYmFzZTY0IGNoYXJhY3RlcnNcbiAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpO1xuXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgdmFyIGkgPSAwLCBqID0gb2Zmc2V0O1xuXG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMiA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzMgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG5cbiAgICBvdXRbaisrXSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgaWYoZW5jMyAhPT0gNjQpIHtcbiAgICAgIC8vIGRlY29kZWQgYXQgbGVhc3QgMiBieXRlc1xuICAgICAgb3V0W2orK10gPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRbaisrXSA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgcmVzdWx0IGlzIHRoZSBleGFjdCBkZWNvZGVkIGxlbmd0aFxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0LnN1YmFycmF5KDAsIGopO1xufTtcblxuLy8gYWRkIHN1cHBvcnQgZm9yIGJhc2U1OCBlbmNvZGluZy9kZWNvZGluZyB3aXRoIEJpdGNvaW4gYWxwaGFiZXRcbnV0aWwuYmluYXJ5LmJhc2U1OC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZW5jb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG51dGlsLmJpbmFyeS5iYXNlNTguZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2VOLmRlY29kZShpbnB1dCwgX2Jhc2U1OCwgbWF4bGluZSk7XG59O1xuXG4vLyB0ZXh0IGVuY29kaW5nL2RlY29kaW5nIHRvb2xzXG4vLyBGSVhNRTogRXhwZXJpbWVudGFsLiBEbyBub3QgdXNlIHlldC5cbnV0aWwudGV4dCA9IHtcbiAgdXRmODoge30sXG4gIHV0ZjE2OiB7fVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTggaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmOC5lbmNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHN0ciA9IHV0aWwuZW5jb2RlVXRmOChzdHIpO1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0W2orK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBVVEYtOCBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGY4LmRlY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcykpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTE2IGluIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC50ZXh0LnV0ZjE2LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGggKiAyKTtcbiAgfVxuICB2YXIgdmlldyA9IG5ldyBVaW50MTZBcnJheShvdXQuYnVmZmVyKTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICB2YXIgayA9IG9mZnNldDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIHZpZXdbaysrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGogKz0gMjtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBVVEYtMTYgY29udGVudHMgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGRlY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICovXG51dGlsLnRleHQudXRmMTYuZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ5dGVzLmJ1ZmZlcikpO1xufTtcblxuLyoqXG4gKiBEZWZsYXRlcyB0aGUgZ2l2ZW4gZGF0YSB1c2luZyBhIGZsYXNoIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGRhdGEuXG4gKiBAcGFyYW0gcmF3IHRydWUgdG8gcmV0dXJuIG9ubHkgcmF3IGRlZmxhdGUgZGF0YSwgZmFsc2UgdG8gaW5jbHVkZSB6bGliXG4gKiAgICAgICAgICBoZWFkZXIgYW5kIHRyYWlsZXIuXG4gKlxuICogQHJldHVybiB0aGUgZGVmbGF0ZWQgZGF0YSBhcyBhIHN0cmluZy5cbiAqL1xudXRpbC5kZWZsYXRlID0gZnVuY3Rpb24oYXBpLCBieXRlcywgcmF3KSB7XG4gIGJ5dGVzID0gdXRpbC5kZWNvZGU2NChhcGkuZGVmbGF0ZSh1dGlsLmVuY29kZTY0KGJ5dGVzKSkucnZhbCk7XG5cbiAgLy8gc3RyaXAgemxpYiBoZWFkZXIgYW5kIHRyYWlsZXIgaWYgbmVjZXNzYXJ5XG4gIGlmKHJhdykge1xuICAgIC8vIHpsaWIgaGVhZGVyIGlzIDIgYnl0ZXMgKENNRixGTEcpIHdoZXJlIEZMRyBpbmRpY2F0ZXMgdGhhdFxuICAgIC8vIHRoZXJlIGlzIGEgNC1ieXRlIERJQ1QgKGFsZGVyLTMyKSBibG9jayBiZWZvcmUgdGhlIGRhdGEgaWZcbiAgICAvLyBpdHMgNXRoIGJpdCBpcyBzZXRcbiAgICB2YXIgc3RhcnQgPSAyO1xuICAgIHZhciBmbGcgPSBieXRlcy5jaGFyQ29kZUF0KDEpO1xuICAgIGlmKGZsZyAmIDB4MjApIHtcbiAgICAgIHN0YXJ0ID0gNjtcbiAgICB9XG4gICAgLy8gemxpYiB0cmFpbGVyIGlzIDQgYnl0ZXMgb2YgYWRsZXItMzJcbiAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZyhzdGFydCwgYnl0ZXMubGVuZ3RoIC0gNCk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIEluZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSBpZiB0aGUgaW5jb21pbmcgZGF0YSBoYXMgbm8gemxpYiBoZWFkZXIgb3IgdHJhaWxlciBhbmQgaXNcbiAqICAgICAgICAgIHJhdyBERUZMQVRFIGRhdGEuXG4gKlxuICogQHJldHVybiB0aGUgaW5mbGF0ZWQgZGF0YSBhcyBhIHN0cmluZywgbnVsbCBvbiBlcnJvci5cbiAqL1xudXRpbC5pbmZsYXRlID0gZnVuY3Rpb24oYXBpLCBieXRlcywgcmF3KSB7XG4gIC8vIFRPRE86IGFkZCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnkvcG9zc2libGVcbiAgdmFyIHJ2YWwgPSBhcGkuaW5mbGF0ZSh1dGlsLmVuY29kZTY0KGJ5dGVzKSkucnZhbDtcbiAgcmV0dXJuIChydmFsID09PSBudWxsKSA/IG51bGwgOiB1dGlsLmRlY29kZTY0KHJ2YWwpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIG9iaiB0aGUgc3RvcmFnZSBvYmplY3QsIG51bGwgdG8gcmVtb3ZlLlxuICovXG52YXIgX3NldFN0b3JhZ2VPYmplY3QgPSBmdW5jdGlvbihhcGksIGlkLCBvYmopIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgdmFyIHJ2YWw7XG4gIGlmKG9iaiA9PT0gbnVsbCkge1xuICAgIHJ2YWwgPSBhcGkucmVtb3ZlSXRlbShpZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8ganNvbi1lbmNvZGUgYW5kIGJhc2U2NC1lbmNvZGUgb2JqZWN0XG4gICAgb2JqID0gdXRpbC5lbmNvZGU2NChKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICBydmFsID0gYXBpLnNldEl0ZW0oaWQsIG9iaik7XG4gIH1cblxuICAvLyBoYW5kbGUgcG90ZW50aWFsIGZsYXNoIGVycm9yXG4gIGlmKHR5cGVvZihydmFsKSAhPT0gJ3VuZGVmaW5lZCcgJiYgcnZhbC5ydmFsICE9PSB0cnVlKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJ2YWwuZXJyb3IubWVzc2FnZSk7XG4gICAgZXJyb3IuaWQgPSBydmFsLmVycm9yLmlkO1xuICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyBhIHN0b3JhZ2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdG9yYWdlIG9iamVjdCBlbnRyeSBvciBudWxsIGlmIG5vbmUgZXhpc3RzLlxuICovXG52YXIgX2dldFN0b3JhZ2VPYmplY3QgPSBmdW5jdGlvbihhcGksIGlkKSB7XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgZXhpc3RpbmcgZW50cnlcbiAgdmFyIHJ2YWwgPSBhcGkuZ2V0SXRlbShpZCk7XG5cbiAgLyogTm90ZTogV2UgY2hlY2sgYXBpLmluaXQgYmVjYXVzZSB3ZSBjYW4ndCBkbyAoYXBpID09IGxvY2FsU3RvcmFnZSlcbiAgICBvbiBJRSBiZWNhdXNlIG9mIFwiQ2xhc3MgZG9lc24ndCBzdXBwb3J0IEF1dG9tYXRpb25cIiBleGNlcHRpb24uIE9ubHlcbiAgICB0aGUgZmxhc2ggYXBpIGhhcyBhbiBpbml0IG1ldGhvZCBzbyB0aGlzIHdvcmtzIHRvbywgYnV0IHdlIG5lZWQgYVxuICAgIGJldHRlciBzb2x1dGlvbiBpbiB0aGUgZnV0dXJlLiAqL1xuXG4gIC8vIGZsYXNoIHJldHVybnMgaXRlbSB3cmFwcGVkIGluIGFuIG9iamVjdCwgaGFuZGxlIHNwZWNpYWwgY2FzZVxuICBpZihhcGkuaW5pdCkge1xuICAgIGlmKHJ2YWwucnZhbCA9PT0gbnVsbCkge1xuICAgICAgaWYocnZhbC5lcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IuaWQgPSBydmFsLmVycm9yLmlkO1xuICAgICAgICBlcnJvci5uYW1lID0gcnZhbC5lcnJvci5uYW1lO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIG5vIGVycm9yLCBidXQgYWxzbyBubyBpdGVtXG4gICAgICBydmFsID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbCA9IHJ2YWwucnZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgZGVjb2RpbmdcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIGJhc2U2NC1kZWNvZGUgYW5kIGpzb24tZGVjb2RlIGRhdGFcbiAgICBydmFsID0gSlNPTi5wYXJzZSh1dGlsLmRlY29kZTY0KHJ2YWwpKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBpbiBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGl0ZW0gKGFueSBqYXZhc2NyaXB0IG9iamVjdC9wcmltaXRpdmUpLlxuICovXG52YXIgX3NldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHN0b3JhZ2Ugb2JqZWN0XG4gICAgb2JqID0ge307XG4gIH1cbiAgLy8gdXBkYXRlIGtleVxuICBvYmpba2V5XSA9IGRhdGE7XG5cbiAgLy8gc2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIF9zZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQsIG9iaik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXRlbSBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpdGVtLlxuICovXG52YXIgX2dldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXkpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBydmFsID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gIGlmKHJ2YWwgIT09IG51bGwpIHtcbiAgICAvLyByZXR1cm4gZGF0YSBhdCBrZXlcbiAgICBydmFsID0gKGtleSBpbiBydmFsKSA/IHJ2YWxba2V5XSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICovXG52YXIgX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXkpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYob2JqICE9PSBudWxsICYmIGtleSBpbiBvYmopIHtcbiAgICAvLyByZW1vdmUga2V5XG4gICAgZGVsZXRlIG9ialtrZXldO1xuXG4gICAgLy8gc2VlIGlmIGVudHJ5IGhhcyBubyBrZXlzIHJlbWFpbmluZ1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZihlbXB0eSkge1xuICAgICAgLy8gcmVtb3ZlIGVudHJ5IGVudGlyZWx5IGlmIG5vIGtleXMgYXJlIGxlZnRcbiAgICAgIG9iaiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0b3JhZ2Ugb2JqZWN0XG4gICAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxvY2FsIGRpc2sgc3RvcmFnZSBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKi9cbnZhciBfY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgc3RvcmFnZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gZnVuYyB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBsb2NhdGlvbiB0aGUgbG9jYXRpb24gYXJndW1lbnQuXG4gKlxuICogQHJldHVybiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uLlxuICovXG52YXIgX2NhbGxTdG9yYWdlRnVuY3Rpb24gPSBmdW5jdGlvbihmdW5jLCBhcmdzLCBsb2NhdGlvbikge1xuICB2YXIgcnZhbCA9IG51bGw7XG5cbiAgLy8gZGVmYXVsdCBzdG9yYWdlIHR5cGVzXG4gIGlmKHR5cGVvZihsb2NhdGlvbikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYXRpb24gPSBbJ3dlYicsICdmbGFzaCddO1xuICB9XG5cbiAgLy8gYXBwbHkgc3RvcmFnZSB0eXBlcyBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gIHZhciB0eXBlO1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgZXhjZXB0aW9uID0gbnVsbDtcbiAgZm9yKHZhciBpZHggaW4gbG9jYXRpb24pIHtcbiAgICB0eXBlID0gbG9jYXRpb25baWR4XTtcbiAgICB0cnkge1xuICAgICAgaWYodHlwZSA9PT0gJ2ZsYXNoJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYoYXJnc1swXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhc2ggbG9jYWwgc3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBkb25lID0gKHR5cGUgPT09ICdmbGFzaCcpO1xuICAgICAgfVxuICAgICAgaWYodHlwZSA9PT0gJ3dlYicgfHwgdHlwZSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBsb2NhbFN0b3JhZ2U7XG4gICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGV4KSB7XG4gICAgICBleGNlcHRpb24gPSBleDtcbiAgICB9XG4gICAgaWYoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoIWRvbmUpIHtcbiAgICB0aHJvdyBleGNlcHRpb247XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU3RvcmVzIGFuIGl0ZW0gb24gbG9jYWwgZGlzay5cbiAqXG4gKiBUaGUgYXZhaWxhYmxlIHR5cGVzIG9mIGxvY2FsIHN0b3JhZ2UgaW5jbHVkZSAnZmxhc2gnLCAnd2ViJywgYW5kICdib3RoJy5cbiAqXG4gKiBUaGUgdHlwZSAnZmxhc2gnIHJlZmVycyB0byBmbGFzaCBsb2NhbCBzdG9yYWdlIChTaGFyZWRPYmplY3QpLiBJbiBvcmRlclxuICogdG8gdXNlIGZsYXNoIGxvY2FsIHN0b3JhZ2UsIHRoZSAnYXBpJyBwYXJhbWV0ZXIgbXVzdCBiZSB2YWxpZC4gVGhlIHR5cGVcbiAqICd3ZWInIHJlZmVycyB0byBXZWJTdG9yYWdlLCBpZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuIFRoZSB0eXBlICdib3RoJ1xuICogcmVmZXJzIHRvIHN0b3JpbmcgdXNpbmcgYm90aCAnZmxhc2gnIGFuZCAnd2ViJywgbm90IGp1c3Qgb25lIG9yIHRoZVxuICogb3RoZXIuXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IHNob3VsZCBsaXN0IHRoZSBzdG9yYWdlIHR5cGVzIHRvIHVzZSBpbiBvcmRlciBvZlxuICogcHJlZmVyZW5jZTpcbiAqXG4gKiBbJ2ZsYXNoJ106IGZsYXNoIG9ubHkgc3RvcmFnZVxuICogWyd3ZWInXTogd2ViIG9ubHkgc3RvcmFnZVxuICogWydib3RoJ106IHRyeSB0byBzdG9yZSBpbiBib3RoXG4gKiBbJ2ZsYXNoJywnd2ViJ106IHN0b3JlIGluIGZsYXNoIGZpcnN0LCBidXQgaWYgbm90IGF2YWlsYWJsZSwgJ3dlYidcbiAqIFsnd2ViJywnZmxhc2gnXTogc3RvcmUgaW4gd2ViIGZpcnN0LCBidXQgaWYgbm90IGF2YWlsYWJsZSwgJ2ZsYXNoJ1xuICpcbiAqIFRoZSBsb2NhdGlvbiBhcnJheSBkZWZhdWx0cyB0bzogWyd3ZWInLCAnZmxhc2gnXVxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGl0ZW0gKGFueSBqYXZhc2NyaXB0IG9iamVjdC9wcmltaXRpdmUpLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5zZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBkYXRhLCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfc2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UsIG51bGwgdG8gdXNlIG9ubHkgV2ViU3RvcmFnZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpdGVtLlxuICovXG51dGlsLmdldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGxvY2F0aW9uKSB7XG4gIHJldHVybiBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfZ2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX3JlbW92ZUl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxvY2FsIGRpc2sgc3RvcmFnZSBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBTZXQgc2V0SXRlbSgpIGZvciBkZXRhaWxzIG9uIHN0b3JhZ2UgdHlwZXMuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlIGlmIGZsYXNoIGlzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLmNsZWFySXRlbXMgPSBmdW5jdGlvbihhcGksIGlkLCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfY2xlYXJJdGVtcywgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBUYWtlbiBmcm9tOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QtZnJvbS1qc29uLzY3OTkzNyM2Nzk5MzdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2hlY2suXG4gKi9cbnV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgd2l0aCBzaW1wbGUgcHJpbnRmLXN0eWxlIGludGVycG9sYXRpb24uXG4gKlxuICogJSU6IGxpdGVyYWwgJyUnXG4gKiAlcywlbzogY29udmVydCBuZXh0IGFyZ3VtZW50IGludG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGZvcm1hdCB0aGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSAuLi4gYXJndW1lbnRzIHRvIGludGVycG9sYXRlIGludG8gdGhlIGZvcm1hdCBzdHJpbmcuXG4gKi9cbnV0aWwuZm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gIHZhciByZSA9IC8lLi9nO1xuICAvLyBjdXJyZW50IG1hdGNoXG4gIHZhciBtYXRjaDtcbiAgLy8gY3VycmVudCBwYXJ0XG4gIHZhciBwYXJ0O1xuICAvLyBjdXJyZW50IGFyZyBpbmRleFxuICB2YXIgYXJnaSA9IDA7XG4gIC8vIGNvbGxlY3RlZCBwYXJ0cyB0byByZWNvbWJpbmUgbGF0ZXJcbiAgdmFyIHBhcnRzID0gW107XG4gIC8vIGxhc3QgaW5kZXggZm91bmRcbiAgdmFyIGxhc3QgPSAwO1xuICAvLyBsb29wIHdoaWxlIG1hdGNoZXMgcmVtYWluXG4gIHdoaWxlKChtYXRjaCA9IHJlLmV4ZWMoZm9ybWF0KSkpIHtcbiAgICBwYXJ0ID0gZm9ybWF0LnN1YnN0cmluZyhsYXN0LCByZS5sYXN0SW5kZXggLSAyKTtcbiAgICAvLyBkb24ndCBhZGQgZW1wdHkgc3RyaW5ncyAoaWUsIHBhcnRzIGJldHdlZW4gJXMlcylcbiAgICBpZihwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGxhc3QgPSByZS5sYXN0SW5kZXg7XG4gICAgLy8gc3dpdGNoIG9uICUgY29kZVxuICAgIHZhciBjb2RlID0gbWF0Y2hbMF1bMV07XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICBjYXNlICdzJzpcbiAgICBjYXNlICdvJzpcbiAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCBhcmd1bWVudHMgd2VyZSBnaXZlblxuICAgICAgaWYoYXJnaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChhcmd1bWVudHNbYXJnaSsrICsgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaCgnPD8+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBGSVhNRTogZG8gcHJvcGVyIGZvcm1hdGluZyBmb3IgbnVtYmVycywgZXRjXG4gICAgLy9jYXNlICdmJzpcbiAgICAvL2Nhc2UgJ2QnOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcGFydHMucHVzaCgnJScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcnRzLnB1c2goJzwlJyArIGNvZGUgKyAnPz4nKTtcbiAgICB9XG4gIH1cbiAgLy8gYWRkIHRyYWlsaW5nIHBhcnQgb2YgZm9ybWF0IHN0cmluZ1xuICBwYXJ0cy5wdXNoKGZvcm1hdC5zdWJzdHJpbmcobGFzdCkpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0NS9qYXZhc2NyaXB0LW51bWJlcmZvcm1hdC0tcG9ydGVkLWZyb20tcGhwL1xuICovXG51dGlsLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCkge1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vY3Jlc3RpZGcuY29tKVxuICAvLyArICAgICBidWdmaXggYnk6IEJlbmphbWluIEx1cHRvblxuICAvLyArICAgICBidWdmaXggYnk6IEFsbGFuIEplbnNlbiAoaHR0cDovL3d3dy53aW50ZXJuZXQubm8pXG4gIC8vICsgICAgcmV2aXNlZCBieTogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyAqICAgICBleGFtcGxlIDE6IG51bWJlcl9mb3JtYXQoMTIzNC41Njc4LCAyLCAnLicsICcnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjM0LjU3XG5cbiAgdmFyIG4gPSBudW1iZXIsIGMgPSBpc05hTihkZWNpbWFscyA9IE1hdGguYWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHM7XG4gIHZhciBkID0gZGVjX3BvaW50ID09PSB1bmRlZmluZWQgPyAnLCcgOiBkZWNfcG9pbnQ7XG4gIHZhciB0ID0gdGhvdXNhbmRzX3NlcCA9PT0gdW5kZWZpbmVkID9cbiAgICcuJyA6IHRob3VzYW5kc19zZXAsIHMgPSBuIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgaSA9IHBhcnNlSW50KChuID0gTWF0aC5hYnMoK24gfHwgMCkudG9GaXhlZChjKSksIDEwKSArICcnO1xuICB2YXIgaiA9IChpLmxlbmd0aCA+IDMpID8gaS5sZW5ndGggJSAzIDogMDtcbiAgcmV0dXJuIHMgKyAoaiA/IGkuc3Vic3RyKDAsIGopICsgdCA6ICcnKSArXG4gICAgaS5zdWJzdHIoaikucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csICckMScgKyB0KSArXG4gICAgKGMgPyBkICsgTWF0aC5hYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiAnJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBieXRlIHNpemUuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0OS9mb3JtYXQtaHVtYW5pemUtZmlsZS1ieXRlLXNpemUtcHJlc2VudGF0aW9uLWluLWphdmFzY3JpcHQvXG4gKi9cbnV0aWwuZm9ybWF0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYoc2l6ZSA+PSAxMDczNzQxODI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDczNzQxODI0LCAyLCAnLicsICcnKSArICcgR2lCJztcbiAgfSBlbHNlIGlmKHNpemUgPj0gMTA0ODU3Nikge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA0ODU3NiwgMiwgJy4nLCAnJykgKyAnIE1pQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwMjQpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwMjQsIDApICsgJyBLaUInO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplLCAwKSArICcgYnl0ZXMnO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBvciBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSA0LWJ5dGUgSVB2NiBvciAxNi1ieXRlIElQdjYgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0XG4gKiAgICAgICAgIGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlmKGlwLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY0KGlwKTtcbiAgfVxuICBpZihpcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NihpcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlwID0gaXAuc3BsaXQoJy4nKTtcbiAgaWYoaXAubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbnVtID0gcGFyc2VJbnQoaXBbaV0sIDEwKTtcbiAgICBpZihpc05hTihudW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYi5wdXRCeXRlKG51bSk7XG4gIH1cbiAgcmV0dXJuIGIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSAxNi1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NiA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBibGFua3MgPSAwO1xuICBpcCA9IGlwLnNwbGl0KCc6JykuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICBpZihlLmxlbmd0aCA9PT0gMCkgKytibGFua3M7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICB2YXIgemVyb3MgPSAoOCAtIGlwLmxlbmd0aCArIGJsYW5rcykgKiAyO1xuICB2YXIgYiA9IHV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICBpZighaXBbaV0gfHwgaXBbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBiLmZpbGxXaXRoQnl0ZSgwLCB6ZXJvcyk7XG4gICAgICB6ZXJvcyA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gdXRpbC5oZXhUb0J5dGVzKGlwW2ldKTtcbiAgICBpZihieXRlcy5sZW5ndGggPCAyKSB7XG4gICAgICBiLnB1dEJ5dGUoMCk7XG4gICAgfVxuICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciAxNi1ieXRlcyBpbnRvXG4gKiBhbiBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmUgaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiA0IG9yIDE2IGJ5dGVzLFxuICogICAgICAgICByZXNwZWN0aXZlbHksIGFyZSBnaXZlbiwgb3RoZXJ3aXNlIG51bGwuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjQoYnl0ZXMpO1xuICB9XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc1RvSVB2NihieXRlcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpcCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpcC5wdXNoKGJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICB9XG4gIHJldHVybiBpcC5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDE2LWJ5dGVzIGludG8gYW4gSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZVxuICogaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NiA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgdmFyIHplcm9Hcm91cHMgPSBbXTtcbiAgdmFyIHplcm9NYXhHcm91cCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBoZXggPSB1dGlsLmJ5dGVzVG9IZXgoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0pO1xuICAgIC8vIGNhbm9uaWNhbGl6ZSB6ZXJvIHJlcHJlc2VudGF0aW9uXG4gICAgd2hpbGUoaGV4WzBdID09PSAnMCcgJiYgaGV4ICE9PSAnMCcpIHtcbiAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGlmKGhleCA9PT0gJzAnKSB7XG4gICAgICB2YXIgbGFzdCA9IHplcm9Hcm91cHNbemVyb0dyb3Vwcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpZHggPSBpcC5sZW5ndGg7XG4gICAgICBpZighbGFzdCB8fCBpZHggIT09IGxhc3QuZW5kICsgMSkge1xuICAgICAgICB6ZXJvR3JvdXBzLnB1c2goe3N0YXJ0OiBpZHgsIGVuZDogaWR4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0LmVuZCA9IGlkeDtcbiAgICAgICAgaWYoKGxhc3QuZW5kIC0gbGFzdC5zdGFydCkgPlxuICAgICAgICAgICh6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF0uZW5kIC0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLnN0YXJ0KSkge1xuICAgICAgICAgIHplcm9NYXhHcm91cCA9IHplcm9Hcm91cHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpcC5wdXNoKGhleCk7XG4gIH1cbiAgaWYoemVyb0dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGdyb3VwID0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdO1xuICAgIC8vIG9ubHkgc2hvcnRlbiBncm91cCBvZiBsZW5ndGggPiAwXG4gICAgaWYoZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgPiAwKSB7XG4gICAgICBpcC5zcGxpY2UoZ3JvdXAuc3RhcnQsIGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ICsgMSwgJycpO1xuICAgICAgaWYoZ3JvdXAuc3RhcnQgPT09IDApIHtcbiAgICAgICAgaXAudW5zaGlmdCgnJyk7XG4gICAgICB9XG4gICAgICBpZihncm91cC5lbmQgPT09IDcpIHtcbiAgICAgICAgaXAucHVzaCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpcC5qb2luKCc6Jyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlcyB0aGF0IGNhbiBiZSBydW4gY29uY3VycmVudGx5LiBJZlxuICogY3JlYXRpbmcgV2ViIFdvcmtlcnMsIGtlZXAgaW4gbWluZCB0aGF0IHRoZSBtYWluIEphdmFTY3JpcHQgcHJvY2VzcyBuZWVkc1xuICogaXRzIG93biBjb3JlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIHVwZGF0ZSB0cnVlIHRvIGZvcmNlIGFuIHVwZGF0ZSAobm90IHVzZSB0aGUgY2FjaGVkIHZhbHVlKS5cbiAqIEBwYXJhbSBjYWxsYmFjayhlcnIsIG1heCkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnV0aWwuZXN0aW1hdGVDb3JlcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoJ2NvcmVzJyBpbiB1dGlsICYmICFvcHRpb25zLnVwZGF0ZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICdoYXJkd2FyZUNvbmN1cnJlbmN5JyBpbiBuYXZpZ2F0b3IgJiZcbiAgICBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSA+IDApIHtcbiAgICB1dGlsLmNvcmVzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd29ya2VycyBub3QgYXZhaWxhYmxlXG4gICAgdXRpbC5jb3JlcyA9IDE7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNhbid0IGVzdGltYXRlLCBkZWZhdWx0IHRvIDJcbiAgICB1dGlsLmNvcmVzID0gMjtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgd29ya2VyIGNvbmN1cnJlbmN5IGVzdGltYXRpb24gY29kZSBhcyBibG9iXG4gIHZhciBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBydW4gd29ya2VyIGZvciA0IG1zXG4gICAgICAgIHZhciBzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBldCA9IHN0ICsgNDtcbiAgICAgICAgd2hpbGUoRGF0ZS5ub3coKSA8IGV0KTtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7c3Q6IHN0LCBldDogZXR9KTtcbiAgICAgIH0pO1xuICAgIH0udG9TdHJpbmcoKSxcbiAgJykoKSddLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSkpO1xuXG4gIC8vIHRha2UgNSBzYW1wbGVzIHVzaW5nIDE2IHdvcmtlcnNcbiAgc2FtcGxlKFtdLCA1LCAxNik7XG5cbiAgZnVuY3Rpb24gc2FtcGxlKG1heCwgc2FtcGxlcywgbnVtV29ya2Vycykge1xuICAgIGlmKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIGdldCBvdmVybGFwIGF2ZXJhZ2VcbiAgICAgIHZhciBhdmcgPSBNYXRoLmZsb29yKG1heC5yZWR1Y2UoZnVuY3Rpb24oYXZnLCB4KSB7XG4gICAgICAgIHJldHVybiBhdmcgKyB4O1xuICAgICAgfSwgMCkgLyBtYXgubGVuZ3RoKTtcbiAgICAgIHV0aWwuY29yZXMgPSBNYXRoLm1heCgxLCBhdmcpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgICB9XG4gICAgbWFwKG51bVdvcmtlcnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgbWF4LnB1c2gocmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpKTtcbiAgICAgIHNhbXBsZShtYXgsIHNhbXBsZXMgLSAxLCBudW1Xb3JrZXJzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChudW1Xb3JrZXJzLCBjYWxsYmFjaykge1xuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZS5kYXRhKTtcbiAgICAgICAgaWYocmVzdWx0cy5sZW5ndGggPT09IG51bVdvcmtlcnMpIHtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5wb3N0TWVzc2FnZShpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykge1xuICAgIC8vIGZpbmQgb3ZlcmxhcHBpbmcgdGltZSB3aW5kb3dzXG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IG51bVdvcmtlcnM7ICsrbikge1xuICAgICAgdmFyIHIxID0gcmVzdWx0c1tuXTtcbiAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbbl0gPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgaWYobiA9PT0gaSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByMiA9IHJlc3VsdHNbaV07XG4gICAgICAgIGlmKChyMS5zdCA+IHIyLnN0ICYmIHIxLnN0IDwgcjIuZXQpIHx8XG4gICAgICAgICAgKHIyLnN0ID4gcjEuc3QgJiYgcjIuc3QgPCByMS5ldCkpIHtcbiAgICAgICAgICBvdmVybGFwLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2V0IG1heGltdW0gb3ZlcmxhcHMgLi4uIGRvbid0IGluY2x1ZGUgb3ZlcmxhcHBpbmcgd29ya2VyIGl0c2VsZlxuICAgIC8vIGFzIHRoZSBtYWluIEpTIHByb2Nlc3Mgd2FzIGFsc28gYmVpbmcgc2NoZWR1bGVkIGR1cmluZyB0aGUgd29yayBhbmRcbiAgICAvLyB3b3VsZCBoYXZlIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgZXN0aW1hdGUgYW55d2F5XG4gICAgcmV0dXJuIG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIG92ZXJsYXApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIG92ZXJsYXAubGVuZ3RoKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcbiIsICIvKipcbiAqIE9iamVjdCBJRHMgZm9yIEFTTi4xLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xuXG5mb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLm9pZHMgPSBmb3JnZS5vaWRzID0gZm9yZ2Uub2lkcyB8fCB7fTtcblxuLy8gc2V0IGlkIHRvIG5hbWUgbWFwcGluZyBhbmQgbmFtZSB0byBpZCBtYXBwaW5nXG5mdW5jdGlvbiBfSU4oaWQsIG5hbWUpIHtcbiAgb2lkc1tpZF0gPSBuYW1lO1xuICBvaWRzW25hbWVdID0gaWQ7XG59XG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIG9ubHlcbmZ1bmN0aW9uIF9JXyhpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG59XG5cbi8vIGFsZ29yaXRobSBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xJywgJ3JzYUVuY3J5cHRpb24nKTtcbi8vIE5vdGU6IG1kMiAmIG1kNCBub3QgaW1wbGVtZW50ZWRcbi8vX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMicsICdtZDJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4zJywgJ21kNFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS40JywgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS41JywgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuNycsICdSU0FFUy1PQUVQJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS44JywgJ21nZjEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjknLCAncFNwZWNpZmllZCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTAnLCAnUlNBU1NBLVBTUycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTEnLCAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEyJywgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMycsICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy8gRWR3YXJkcy1jdXJ2ZSBEaWdpdGFsIFNpZ25hdHVyZSBBbGdvcml0aG0gKEVkRFNBKSBFZDI1NTE5XG5fSU4oJzEuMy4xMDEuMTEyJywgJ0VkRFNBMjU1MTknKTtcblxuX0lOKCcxLjIuODQwLjEwMDQwLjQuMycsICdkc2Etd2l0aC1zaGExJyk7XG5cbl9JTignMS4zLjE0LjMuMi43JywgJ2Rlc0NCQycpO1xuXG5fSU4oJzEuMy4xNC4zLjIuMjYnLCAnc2hhMScpO1xuLy8gRGVwcmVjYXRlZCBlcXVpdmFsZW50IG9mIHNoYTFXaXRoUlNBRW5jcnlwdGlvblxuX0lOKCcxLjMuMTQuMy4yLjI5JywgJ3NoYTFXaXRoUlNBU2lnbmF0dXJlJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnLCAnc2hhMjU2Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjInLCAnc2hhMzg0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjMnLCAnc2hhNTEyJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjQnLCAnc2hhMjI0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjUnLCAnc2hhNTEyLTIyNCcpO1xuX0lOKCcyLjE2Ljg0MC4xLjEwMS4zLjQuMi42JywgJ3NoYTUxMi0yNTYnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4yJywgJ21kMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjUnLCAnbWQ1Jyk7XG5cbi8vIHBrY3MjNyBjb250ZW50IHR5cGVzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4xJywgJ2RhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjInLCAnc2lnbmVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMycsICdlbnZlbG9wZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy40JywgJ3NpZ25lZEFuZEVudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjUnLCAnZGlnZXN0ZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy42JywgJ2VuY3J5cHRlZERhdGEnKTtcblxuLy8gcGtjcyM5IG9pZHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjEnLCAnZW1haWxBZGRyZXNzJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yJywgJ3Vuc3RydWN0dXJlZE5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjMnLCAnY29udGVudFR5cGUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjQnLCAnbWVzc2FnZURpZ2VzdCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNScsICdzaWduaW5nVGltZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNicsICdjb3VudGVyU2lnbmF0dXJlJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS43JywgJ2NoYWxsZW5nZVBhc3N3b3JkJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS44JywgJ3Vuc3RydWN0dXJlZEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjE0JywgJ2V4dGVuc2lvblJlcXVlc3QnKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMjAnLCAnZnJpZW5kbHlOYW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMScsICdsb2NhbEtleUlkJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMi4xJywgJ3g1MDlDZXJ0aWZpY2F0ZScpO1xuXG4vLyBwa2NzIzEyIHNhZmUgYmFnc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMScsICdrZXlCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjInLCAncGtjczhTaHJvdWRlZEtleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMycsICdjZXJ0QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS40JywgJ2NybEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNScsICdzZWNyZXRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjYnLCAnc2FmZUNvbnRlbnRzQmFnJyk7XG5cbi8vIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gZm9yIHBrY3MjMTJcbl9JTignMS4yLjg0MC4xMTM1NDkuMS41LjEzJywgJ3BrY3M1UEJFUzInKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS41LjEyJywgJ3BrY3M1UEJLREYyJyk7XG5cbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjEnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMicsICdwYmVXaXRoU0hBQW5kNDBCaXRSQzQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjMnLCAncGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuNCcsICdwYmVXaXRoU0hBQW5kMi1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS41JywgJ3BiZVdpdGhTSEFBbmQxMjhCaXRSQzItQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS42JywgJ3BiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkMnKTtcblxuLy8gaG1hYyBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNycsICdobWFjV2l0aFNIQTEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi44JywgJ2htYWNXaXRoU0hBMjI0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuOScsICdobWFjV2l0aFNIQTI1NicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjEwJywgJ2htYWNXaXRoU0hBMzg0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTEnLCAnaG1hY1dpdGhTSEE1MTInKTtcblxuLy8gc3ltbWV0cmljIGtleSBhbGdvcml0aG0gb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4zLjcnLCAnZGVzLUVERTMtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjInLCAnYWVzMTI4LUNCQycpO1xuX0lOKCcyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yMicsICdhZXMxOTItQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjQyJywgJ2FlczI1Ni1DQkMnKTtcblxuLy8gY2VydGlmaWNhdGUgaXNzdWVyL3N1YmplY3QgT0lEc1xuX0lOKCcyLjUuNC4zJywgJ2NvbW1vbk5hbWUnKTtcbl9JTignMi41LjQuNCcsICdzdXJuYW1lJyk7XG5fSU4oJzIuNS40LjUnLCAnc2VyaWFsTnVtYmVyJyk7XG5fSU4oJzIuNS40LjYnLCAnY291bnRyeU5hbWUnKTtcbl9JTignMi41LjQuNycsICdsb2NhbGl0eU5hbWUnKTtcbl9JTignMi41LjQuOCcsICdzdGF0ZU9yUHJvdmluY2VOYW1lJyk7XG5fSU4oJzIuNS40LjknLCAnc3RyZWV0QWRkcmVzcycpO1xuX0lOKCcyLjUuNC4xMCcsICdvcmdhbml6YXRpb25OYW1lJyk7XG5fSU4oJzIuNS40LjExJywgJ29yZ2FuaXphdGlvbmFsVW5pdE5hbWUnKTtcbl9JTignMi41LjQuMTInLCAndGl0bGUnKTtcbl9JTignMi41LjQuMTMnLCAnZGVzY3JpcHRpb24nKTtcbl9JTignMi41LjQuMTUnLCAnYnVzaW5lc3NDYXRlZ29yeScpO1xuX0lOKCcyLjUuNC4xNycsICdwb3N0YWxDb2RlJyk7XG5fSU4oJzIuNS40LjQyJywgJ2dpdmVuTmFtZScpO1xuX0lOKCcxLjMuNi4xLjQuMS4zMTEuNjAuMi4xLjInLCAnanVyaXNkaWN0aW9uT2ZJbmNvcnBvcmF0aW9uU3RhdGVPclByb3ZpbmNlTmFtZScpO1xuX0lOKCcxLjMuNi4xLjQuMS4zMTEuNjAuMi4xLjMnLCAnanVyaXNkaWN0aW9uT2ZJbmNvcnBvcmF0aW9uQ291bnRyeU5hbWUnKTtcblxuLy8gWC41MDkgZXh0ZW5zaW9uIE9JRHNcbl9JTignMi4xNi44NDAuMS4xMTM3MzAuMS4xJywgJ25zQ2VydFR5cGUnKTtcbl9JTignMi4xNi44NDAuMS4xMTM3MzAuMS4xMycsICduc0NvbW1lbnQnKTsgLy8gZGVwcmVjYXRlZCBpbiB0aGVvcnk7IHN0aWxsIHdpZGVseSB1c2VkXG5fSV8oJzIuNS4yOS4xJywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zNVxuX0lfKCcyLjUuMjkuMicsICdrZXlBdHRyaWJ1dGVzJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS4zJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zMlxuX0lfKCcyLjUuMjkuNCcsICdrZXlVc2FnZVJlc3RyaWN0aW9uJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS41JywgJ3BvbGljeU1hcHBpbmcnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMzXG5fSV8oJzIuNS4yOS42JywgJ3N1YnRyZWVzQ29uc3RyYWludCcpOyAvLyBvYnNvbGV0ZSB1c2UgLjMwXG5fSV8oJzIuNS4yOS43JywgJ3N1YmplY3RBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xN1xuX0lfKCcyLjUuMjkuOCcsICdpc3N1ZXJBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xOFxuX0lfKCcyLjUuMjkuOScsICdzdWJqZWN0RGlyZWN0b3J5QXR0cmlidXRlcycpO1xuX0lfKCcyLjUuMjkuMTAnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JXygnMi41LjI5LjExJywgJ25hbWVDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzBcbl9JXygnMi41LjI5LjEyJywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zNlxuX0lfKCcyLjUuMjkuMTMnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JTignMi41LjI5LjE0JywgJ3N1YmplY3RLZXlJZGVudGlmaWVyJyk7XG5fSU4oJzIuNS4yOS4xNScsICdrZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuMTYnLCAncHJpdmF0ZUtleVVzYWdlUGVyaW9kJyk7XG5fSU4oJzIuNS4yOS4xNycsICdzdWJqZWN0QWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTgnLCAnaXNzdWVyQWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTknLCAnYmFzaWNDb25zdHJhaW50cycpO1xuX0lfKCcyLjUuMjkuMjAnLCAnY1JMTnVtYmVyJyk7XG5fSV8oJzIuNS4yOS4yMScsICdjUkxSZWFzb24nKTtcbl9JXygnMi41LjI5LjIyJywgJ2V4cGlyYXRpb25EYXRlJyk7XG5fSV8oJzIuNS4yOS4yMycsICdpbnN0cnVjdGlvbkNvZGUnKTtcbl9JXygnMi41LjI5LjI0JywgJ2ludmFsaWRpdHlEYXRlJyk7XG5fSV8oJzIuNS4yOS4yNScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMxXG5fSV8oJzIuNS4yOS4yNicsICdpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjI4XG5fSV8oJzIuNS4yOS4yNycsICdkZWx0YUNSTEluZGljYXRvcicpO1xuX0lfKCcyLjUuMjkuMjgnLCAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7XG5fSV8oJzIuNS4yOS4yOScsICdjZXJ0aWZpY2F0ZUlzc3VlcicpO1xuX0lfKCcyLjUuMjkuMzAnLCAnbmFtZUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zMScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTtcbl9JTignMi41LjI5LjMyJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTtcbl9JXygnMi41LjI5LjMzJywgJ3BvbGljeU1hcHBpbmdzJyk7XG5fSV8oJzIuNS4yOS4zNCcsICdwb2xpY3lDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzZcbl9JTignMi41LjI5LjM1JywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTtcbl9JXygnMi41LjI5LjM2JywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zNycsICdleHRLZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuNDYnLCAnZnJlc2hlc3RDUkwnKTtcbl9JXygnMi41LjI5LjU0JywgJ2luaGliaXRBbnlQb2xpY3knKTtcblxuLy8gZXh0S2V5VXNhZ2UgcHVycG9zZXNcbl9JTignMS4zLjYuMS40LjEuMTExMjkuMi40LjInLCAndGltZXN0YW1wTGlzdCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjEuMScsICdhdXRob3JpdHlJbmZvQWNjZXNzJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4xJywgJ3NlcnZlckF1dGgnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjInLCAnY2xpZW50QXV0aCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMycsICdjb2RlU2lnbmluZycpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuNCcsICdlbWFpbFByb3RlY3Rpb24nKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjgnLCAndGltZVN0YW1waW5nJyk7XG4iLCAiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBbiBBUEkgZm9yIHN0b3JpbmcgZGF0YSB1c2luZyB0aGUgQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmVcbiAqIGZvcm1hdCB1c2luZyBERVIgKERpc3Rpbmd1aXNoZWQgRW5jb2RpbmcgUnVsZXMpIGVuY29kaW5nLiBUaGlzIGVuY29kaW5nIGlzXG4gKiBjb21tb25seSB1c2VkIHRvIHN0b3JlIGRhdGEgZm9yIFBLSSwgaS5lLiBYLjUwOSBDZXJ0aWZpY2F0ZXMsIGFuZCB0aGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBleGlzdHMgZm9yIHRoYXQgcHVycG9zZS5cbiAqXG4gKiBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZSAoQVNOLjEpIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBhYnN0cmFjdFxuICogc3ludGF4IG9mIGluZm9ybWF0aW9uIHdpdGhvdXQgcmVzdHJpY3RpbmcgdGhlIHdheSB0aGUgaW5mb3JtYXRpb24gaXMgZW5jb2RlZFxuICogZm9yIHRyYW5zbWlzc2lvbi4gSXQgcHJvdmlkZXMgYSBzdGFuZGFyZCB0aGF0IGFsbG93cyBmb3Igb3BlbiBzeXN0ZW1zXG4gKiBjb21tdW5pY2F0aW9uLiBBU04uMSBkZWZpbmVzIHRoZSBzeW50YXggb2YgaW5mb3JtYXRpb24gZGF0YSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNpbXBsZSBkYXRhIHR5cGVzIGFzIHdlbGwgYXMgYSBub3RhdGlvbiBmb3IgZGVzY3JpYmluZyB0aGVtIGFuZCBzcGVjaWZ5aW5nXG4gKiB2YWx1ZXMgZm9yIHRoZW0uXG4gKlxuICogVGhlIFJTQSBhbGdvcml0aG0gY3JlYXRlcyBwdWJsaWMgYW5kIHByaXZhdGUga2V5cyB0aGF0IGFyZSBvZnRlbiBzdG9yZWQgaW5cbiAqIFguNTA5IG9yIFBLQ1MjWCBmb3JtYXRzIC0tIHdoaWNoIHVzZSBBU04uMSAoZW5jb2RlZCBpbiBERVIgZm9ybWF0KS4gVGhpc1xuICogY2xhc3MgcHJvdmlkZXMgdGhlIG1vc3QgYmFzaWMgZnVuY3Rpb25hbGl0eSByZXF1aXJlZCB0byBzdG9yZSBhbmQgbG9hZCBEU0FcbiAqIGtleXMgdGhhdCBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gQVNOLjEuXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIGJpbmFyeSBlbmNvZGluZ3MgZm9yIEFTTi4xIGFyZSBCRVIgKEJhc2ljIEVuY29kaW5nIFJ1bGVzKVxuICogYW5kIERFUiAoRGlzdGluZ3Vpc2hlZCBFbmNvZGluZyBSdWxlcykuIERFUiBpcyBqdXN0IGEgc3Vic2V0IG9mIEJFUiB0aGF0XG4gKiBoYXMgc3RyaWN0ZXIgcmVxdWlyZW1lbnRzIGZvciBob3cgZGF0YSBtdXN0IGJlIGVuY29kZWQuXG4gKlxuICogRWFjaCBBU04uMSBzdHJ1Y3R1cmUgaGFzIGEgdGFnIChhIGJ5dGUgaWRlbnRpZnlpbmcgdGhlIEFTTi4xIHN0cnVjdHVyZSB0eXBlKVxuICogYW5kIGEgYnl0ZSBhcnJheSBmb3IgdGhlIHZhbHVlIG9mIHRoaXMgQVNOMSBzdHJ1Y3R1cmUgd2hpY2ggbWF5IGJlIGRhdGEgb3IgYVxuICogbGlzdCBvZiBBU04uMSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEVhY2ggQVNOLjEgc3RydWN0dXJlIHVzaW5nIEJFUiBpcyAoVGFnLUxlbmd0aC1WYWx1ZSk6XG4gKlxuICogfCBieXRlIDAgfCBieXRlcyBYIHwgYnl0ZXMgWSB8XG4gKiB8LS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS1cbiAqIHwgIHRhZyAgIHwgbGVuZ3RoICB8ICB2YWx1ZSAgfFxuICpcbiAqIEFTTi4xIGFsbG93cyBmb3IgdGFncyB0byBiZSBvZiBcIkhpZ2gtdGFnLW51bWJlciBmb3JtXCIgd2hpY2ggYWxsb3dzIGEgdGFnIHRvXG4gKiBiZSB0d28gb3IgbW9yZSBvY3RldHMsIGJ1dCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBjbGFzcy4gQSB0YWcgaXNcbiAqIG9ubHkgMSBieXRlLiBCaXRzIDEtNSBnaXZlIHRoZSB0YWcgbnVtYmVyIChpZSB0aGUgZGF0YSB0eXBlIHdpdGhpbiBhXG4gKiBwYXJ0aWN1bGFyICdjbGFzcycpLCA2IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgQVNOLjEgdmFsdWUgaXNcbiAqIGNvbnN0cnVjdGVkIGZyb20gb3RoZXIgQVNOLjEgdmFsdWVzLCBhbmQgYml0cyA3IGFuZCA4IGdpdmUgdGhlICdjbGFzcycuIElmXG4gKiBiaXRzIDcgYW5kIDggYXJlIGJvdGggemVybywgdGhlIGNsYXNzIGlzIFVOSVZFUlNBTC4gSWYgb25seSBiaXQgNyBpcyBzZXQsXG4gKiB0aGVuIHRoZSBjbGFzcyBpcyBBUFBMSUNBVElPTi4gSWYgb25seSBiaXQgOCBpcyBzZXQsIHRoZW4gdGhlIGNsYXNzIGlzXG4gKiBDT05URVhUX1NQRUNJRklDLiBJZiBib3RoIGJpdHMgNyBhbmQgOCBhcmUgc2V0LCB0aGVuIHRoZSBjbGFzcyBpcyBQUklWQVRFLlxuICogVGhlIHRhZyBudW1iZXJzIGZvciB0aGUgZGF0YSB0eXBlcyBmb3IgdGhlIGNsYXNzIFVOSVZFUlNBTCBhcmUgbGlzdGVkIGJlbG93OlxuICpcbiAqIFVOSVZFUlNBTCAwIFJlc2VydmVkIGZvciB1c2UgYnkgdGhlIGVuY29kaW5nIHJ1bGVzXG4gKiBVTklWRVJTQUwgMSBCb29sZWFuIHR5cGVcbiAqIFVOSVZFUlNBTCAyIEludGVnZXIgdHlwZVxuICogVU5JVkVSU0FMIDMgQml0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA0IE9jdGV0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA1IE51bGwgdHlwZVxuICogVU5JVkVSU0FMIDYgT2JqZWN0IGlkZW50aWZpZXIgdHlwZVxuICogVU5JVkVSU0FMIDcgT2JqZWN0IGRlc2NyaXB0b3IgdHlwZVxuICogVU5JVkVSU0FMIDggRXh0ZXJuYWwgdHlwZSBhbmQgSW5zdGFuY2Utb2YgdHlwZVxuICogVU5JVkVSU0FMIDkgUmVhbCB0eXBlXG4gKiBVTklWRVJTQUwgMTAgRW51bWVyYXRlZCB0eXBlXG4gKiBVTklWRVJTQUwgMTEgRW1iZWRkZWQtcGR2IHR5cGVcbiAqIFVOSVZFUlNBTCAxMiBVVEY4U3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCAxMyBSZWxhdGl2ZSBvYmplY3QgaWRlbnRpZmllciB0eXBlXG4gKiBVTklWRVJTQUwgMTQtMTUgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSBlZGl0aW9uc1xuICogVU5JVkVSU0FMIDE2IFNlcXVlbmNlIGFuZCBTZXF1ZW5jZS1vZiB0eXBlc1xuICogVU5JVkVSU0FMIDE3IFNldCBhbmQgU2V0LW9mIHR5cGVzXG4gKiBVTklWRVJTQUwgMTgtMjIsIDI1LTMwIENoYXJhY3RlciBzdHJpbmcgdHlwZXNcbiAqIFVOSVZFUlNBTCAyMy0yNCBUaW1lIHR5cGVzXG4gKlxuICogVGhlIGxlbmd0aCBvZiBhbiBBU04uMSBzdHJ1Y3R1cmUgaXMgc3BlY2lmaWVkIGFmdGVyIHRoZSB0YWcgaWRlbnRpZmllci5cbiAqIFRoZXJlIGlzIGEgZGVmaW5pdGUgZm9ybSBhbmQgYW4gaW5kZWZpbml0ZSBmb3JtLiBUaGUgaW5kZWZpbml0ZSBmb3JtIG1heVxuICogYmUgdXNlZCBpZiB0aGUgZW5jb2RpbmcgaXMgY29uc3RydWN0ZWQgYW5kIG5vdCBhbGwgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICogVGhlIGluZGVmaW5pdGUgZm9ybSBpcyBlbmNvZGVkIHVzaW5nIGEgbGVuZ3RoIGJ5dGUgd2l0aCBvbmx5IHRoZSA4dGggYml0XG4gKiBzZXQuIFRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdGVkIG9iamVjdCBpcyBtYXJrZWQgdXNpbmcgZW5kLW9mLWNvbnRlbnRzXG4gKiBvY3RldHMgKHR3byB6ZXJvIGJ5dGVzKS5cbiAqXG4gKiBUaGUgZGVmaW5pdGUgZm9ybSBsb29rcyBsaWtlIHRoaXM6XG4gKlxuICogVGhlIGxlbmd0aCBtYXkgdGFrZSB1cCAxIG9yIG1vcmUgYnl0ZXMsIGl0IGRlcGVuZHMgb24gdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHZhbHVlIG9mIHRoZSBBU04uMSBzdHJ1Y3R1cmUuIERFUiBlbmNvZGluZyByZXF1aXJlcyB0aGF0IGlmIHRoZSBBU04uMVxuICogc3RydWN0dXJlIGhhcyBhIHZhbHVlIHRoYXQgaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxMjcsIG1vcmUgdGhhbiAxIGJ5dGVcbiAqIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBpdHMgbGVuZ3RoLCBvdGhlcndpc2UganVzdCBvbmUgYnl0ZSB3aWxsIGJlIHVzZWQuXG4gKiBUaGlzIGlzIHN0cmljdC5cbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIEFTTi4xIHZhbHVlIGlzIGxlc3MgdGhhbiAxMjcsIDEgb2N0ZXRcbiAqIChieXRlKSBpcyB1c2VkIHRvIHN0b3JlIHRoZSBcInNob3J0IGZvcm1cIiBsZW5ndGguIFRoZSA4dGggYml0IGhhcyBhIHZhbHVlIG9mXG4gKiAwIGluZGljYXRpbmcgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBhbmQgbm90IFwibG9uZyBmb3JtXCIgYW5kIGJpdHMgNy0xXG4gKiBnaXZlIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEuIChUaGUgOHRoIGJpdCBpcyB0aGUgbGVmdC1tb3N0LCBtb3N0IHNpZ25pZmljYW50XG4gKiBiaXQ6IGFsc28ga25vd24gYXMgYmlnIGVuZGlhbiBvciBuZXR3b3JrIGZvcm1hdCkuXG4gKlxuICogSW4gdGhlIGNhc2UgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBBU04uMSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTI3LCAyIHRvXG4gKiAxMjcgb2N0ZXRzIChieXRlcykgYXJlIHVzZWQgdG8gc3RvcmUgdGhlIFwibG9uZyBmb3JtXCIgbGVuZ3RoLiBUaGUgZmlyc3RcbiAqIGJ5dGUncyA4dGggYml0IGlzIHNldCB0byAxIHRvIGluZGljYXRlIHRoZSBsZW5ndGggaXMgXCJsb25nIGZvcm0uXCIgQml0cyA3LTFcbiAqIGdpdmUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG9jdGV0cy4gQWxsIGZvbGxvd2luZyBvY3RldHMgYXJlIGluIGJhc2UgMjU2XG4gKiB3aXRoIHRoZSBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0ICh0eXBpY2FsIGJpZy1lbmRpYW4gYmluYXJ5IHVuc2lnbmVkXG4gKiBpbnRlZ2VyIHN0b3JhZ2UpLiBTbywgZm9yIGluc3RhbmNlLCBpZiB0aGUgbGVuZ3RoIG9mIGEgdmFsdWUgd2FzIDI1NywgdGhlXG4gKiBmaXJzdCBieXRlIHdvdWxkIGJlIHNldCB0bzpcbiAqXG4gKiAxMDAwMDAxMCA9IDEzMCA9IDB4ODIuXG4gKlxuICogVGhpcyBpbmRpY2F0ZXMgdGhlcmUgYXJlIDIgb2N0ZXRzIChiYXNlIDI1NikgZm9yIHRoZSBsZW5ndGguIFRoZSBzZWNvbmQgYW5kXG4gKiB0aGlyZCBieXRlcyAodGhlIG9jdGV0cyBqdXN0IG1lbnRpb25lZCkgd291bGQgc3RvcmUgdGhlIGxlbmd0aCBpbiBiYXNlIDI1NjpcbiAqXG4gKiBvY3RldCAyOiAwMDAwMDAwMSA9IDEgKiAyNTZeMSA9IDI1NlxuICogb2N0ZXQgMzogMDAwMDAwMDEgPSAxICogMjU2XjAgPSAxXG4gKiB0b3RhbCA9IDI1N1xuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIGNvbnZlcnRpbmcgYSBqcyBpbnRlZ2VyIHZhbHVlIG9mIDI1NyB0byBiYXNlLTI1NiBpczpcbiAqXG4gKiB2YXIgdmFsdWUgPSAyNTc7XG4gKiB2YXIgYnl0ZXMgPSBbXTtcbiAqIGJ5dGVzWzBdID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7IC8vIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdFxuICogYnl0ZXNbMV0gPSB2YWx1ZSAmIDB4RkY7ICAgICAgICAvLyBsZWFzdCBzaWduaWZpY2FudCBieXRlIGxhc3RcbiAqXG4gKiBPbiB0aGUgQVNOLjEgVU5JVkVSU0FMIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIHR5cGU6XG4gKlxuICogQW4gT0lEIGNhbiBiZSB3cml0dGVuIGxpa2U6IFwidmFsdWUxLnZhbHVlMi52YWx1ZTMuLi52YWx1ZU5cIlxuICpcbiAqIFRoZSBERVIgZW5jb2RpbmcgcnVsZXM6XG4gKlxuICogVGhlIGZpcnN0IGJ5dGUgaGFzIHRoZSB2YWx1ZSA0MCAqIHZhbHVlMSArIHZhbHVlMi5cbiAqIFRoZSBmb2xsb3dpbmcgYnl0ZXMsIGlmIGFueSwgZW5jb2RlIHRoZSByZW1haW5pbmcgdmFsdWVzLiBFYWNoIHZhbHVlIGlzXG4gKiBlbmNvZGVkIGluIGJhc2UgMTI4LCBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0IChiaWcgZW5kaWFuKSwgd2l0aCBhc1xuICogZmV3IGRpZ2l0cyBhcyBwb3NzaWJsZSwgYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiBlYWNoIGJ5dGUgc2V0XG4gKiB0byAxIGV4Y2VwdCB0aGUgbGFzdCBpbiBlYWNoIHZhbHVlJ3MgZW5jb2RpbmcuIEZvciBleGFtcGxlOiBHaXZlbiB0aGVcbiAqIE9JRCBcIjEuMi44NDAuMTEzNTQ5XCIsIGl0cyBERVIgZW5jb2RpbmcgaXMgKHJlbWVtYmVyIGVhY2ggYnl0ZSBleGNlcHQgdGhlXG4gKiBsYXN0IG9uZSBpbiBlYWNoIGVuY29kaW5nIGlzIE9SJ2Qgd2l0aCAweDgwKTpcbiAqXG4gKiBieXRlIDE6IDQwICogMSArIDIgPSA0MiA9IDB4MkEuXG4gKiBieXRlcyAyLTM6IDEyOCAqIDYgKyA3MiA9IDg0MCA9IDYgNzIgPSA2IDcyID0gMHgwNjQ4ID0gMHg4NjQ4XG4gKiBieXRlcyA0LTY6IDE2Mzg0ICogNiArIDEyOCAqIDExOSArIDEzID0gNiAxMTkgMTMgPSAweDA2NzcwRCA9IDB4ODZGNzBEXG4gKlxuICogVGhlIGZpbmFsIHZhbHVlIGlzOiAweDJBODY0ODg2RjcwRC5cbiAqIFRoZSBmdWxsIE9JRCAoaW5jbHVkaW5nIEFTTi4xIHRhZyBhbmQgbGVuZ3RoIG9mIDYgYnl0ZXMpIGlzOlxuICogMHgwNjA2MkE4NjQ4ODZGNzBEXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi9vaWRzJyk7XG5cbi8qIEFTTi4xIEFQSSAqL1xudmFyIGFzbjEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmFzbjEgPSBmb3JnZS5hc24xIHx8IHt9O1xuXG4vKipcbiAqIEFTTi4xIGNsYXNzZXMuXG4gKi9cbmFzbjEuQ2xhc3MgPSB7XG4gIFVOSVZFUlNBTDogICAgICAgIDB4MDAsXG4gIEFQUExJQ0FUSU9OOiAgICAgIDB4NDAsXG4gIENPTlRFWFRfU1BFQ0lGSUM6IDB4ODAsXG4gIFBSSVZBVEU6ICAgICAgICAgIDB4QzBcbn07XG5cbi8qKlxuICogQVNOLjEgdHlwZXMuIE5vdCBhbGwgdHlwZXMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uLCBvbmx5XG4gKiB0aG9zZSBuZWNlc3NhcnkgdG8gaW1wbGVtZW50IGEgc2ltcGxlIFBLSSBhcmUgaW1wbGVtZW50ZWQuXG4gKi9cbmFzbjEuVHlwZSA9IHtcbiAgTk9ORTogICAgICAgICAgICAgMCxcbiAgQk9PTEVBTjogICAgICAgICAgMSxcbiAgSU5URUdFUjogICAgICAgICAgMixcbiAgQklUU1RSSU5HOiAgICAgICAgMyxcbiAgT0NURVRTVFJJTkc6ICAgICAgNCxcbiAgTlVMTDogICAgICAgICAgICAgNSxcbiAgT0lEOiAgICAgICAgICAgICAgNixcbiAgT0RFU0M6ICAgICAgICAgICAgNyxcbiAgRVhURVJOQUw6ICAgICAgICAgOCxcbiAgUkVBTDogICAgICAgICAgICAgOSxcbiAgRU5VTUVSQVRFRDogICAgICAxMCxcbiAgRU1CRURERUQ6ICAgICAgICAxMSxcbiAgVVRGODogICAgICAgICAgICAxMixcbiAgUk9JRDogICAgICAgICAgICAxMyxcbiAgU0VRVUVOQ0U6ICAgICAgICAxNixcbiAgU0VUOiAgICAgICAgICAgICAxNyxcbiAgUFJJTlRBQkxFU1RSSU5HOiAxOSxcbiAgSUE1U1RSSU5HOiAgICAgICAyMixcbiAgVVRDVElNRTogICAgICAgICAyMyxcbiAgR0VORVJBTElaRURUSU1FOiAyNCxcbiAgQk1QU1RSSU5HOiAgICAgICAzMFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGFzbjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0YWdDbGFzcyB0aGUgdGFnIGNsYXNzIGZvciB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHR5cGUgdGhlIGRhdGEgdHlwZSAodGFnIG51bWJlcikgZm9yIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0gY29uc3RydWN0ZWQgdHJ1ZSBpZiB0aGUgYXNuMSBvYmplY3QgaXMgaW4gY29uc3RydWN0ZWQgZm9ybS5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgZm9yIHRoZSBvYmplY3QsIGlmIGl0IGlzIG5vdCBjb25zdHJ1Y3RlZC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2JpdFN0cmluZ0NvbnRlbnRzXSB0aGUgcGxhaW4gQklUIFNUUklORyBjb250ZW50IGluY2x1ZGluZyBwYWRkaW5nXG4gKiAgICAgICAgICAgIGJ5dGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuY3JlYXRlID0gZnVuY3Rpb24odGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAvKiBBbiBhc24xIG9iamVjdCBoYXMgYSB0YWdDbGFzcywgYSB0eXBlLCBhIGNvbnN0cnVjdGVkIGZsYWcsIGFuZCBhXG4gICAgdmFsdWUuIFRoZSB2YWx1ZSdzIHR5cGUgZGVwZW5kcyBvbiB0aGUgY29uc3RydWN0ZWQgZmxhZy4gSWZcbiAgICBjb25zdHJ1Y3RlZCwgaXQgd2lsbCBjb250YWluIGEgbGlzdCBvZiBvdGhlciBhc24xIG9iamVjdHMuIElmIG5vdCxcbiAgICBpdCB3aWxsIGNvbnRhaW4gdGhlIEFTTi4xIHZhbHVlIGFzIGFuIGFycmF5IG9mIGJ5dGVzIGZvcm1hdHRlZFxuICAgIGFjY29yZGluZyB0byB0aGUgQVNOLjEgZGF0YSB0eXBlLiAqL1xuXG4gIC8vIHJlbW92ZSB1bmRlZmluZWQgdmFsdWVzXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgdG1wID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZih2YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRtcC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSB0bXA7XG4gIH1cblxuICB2YXIgb2JqID0ge1xuICAgIHRhZ0NsYXNzOiB0YWdDbGFzcyxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbnN0cnVjdGVkOiBjb25zdHJ1Y3RlZCxcbiAgICBjb21wb3NlZDogY29uc3RydWN0ZWQgfHwgZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbiAgaWYob3B0aW9ucyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgb2JqLmJpdFN0cmluZ0NvbnRlbnRzID0gb3B0aW9ucy5iaXRTdHJpbmdDb250ZW50cztcbiAgICAvLyBUT0RPOiBhZGQgcmVhZG9ubHkgZmxhZyB0byBhdm9pZCB0aGlzIG92ZXJoZWFkXG4gICAgLy8gc2F2ZSBjb3B5IHRvIGRldGVjdCBjaGFuZ2VzXG4gICAgb2JqLm9yaWdpbmFsID0gYXNuMS5jb3B5KG9iaik7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQ29waWVzIGFuIGFzbjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIFtvcHRpb25zXSBjb3B5IG9wdGlvbnM6XG4gKiAgICAgICAgICBbZXhjbHVkZUJpdFN0cmluZ0NvbnRlbnRzXSB0cnVlIHRvIG5vdCBjb3B5IGJpdFN0cmluZ0NvbnRlbnRzXG4gKlxuICogQHJldHVybiB0aGUgYSBjb3B5IG9mIHRoZSBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5jb3B5ID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gIHZhciBjb3B5O1xuXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShvYmopKSB7XG4gICAgY29weSA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvcHkucHVzaChhc24xLmNvcHkob2JqW2ldLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgaWYodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGNvcHkgPSB7XG4gICAgdGFnQ2xhc3M6IG9iai50YWdDbGFzcyxcbiAgICB0eXBlOiBvYmoudHlwZSxcbiAgICBjb25zdHJ1Y3RlZDogb2JqLmNvbnN0cnVjdGVkLFxuICAgIGNvbXBvc2VkOiBvYmouY29tcG9zZWQsXG4gICAgdmFsdWU6IGFzbjEuY29weShvYmoudmFsdWUsIG9wdGlvbnMpXG4gIH07XG4gIGlmKG9wdGlvbnMgJiYgIW9wdGlvbnMuZXhjbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgLy8gVE9ETzogY29weSBieXRlIGJ1ZmZlciBpZiBpdCdzIGEgYnVmZmVyIG5vdCBhIHN0cmluZ1xuICAgIGNvcHkuYml0U3RyaW5nQ29udGVudHMgPSBvYmouYml0U3RyaW5nQ29udGVudHM7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIGFzbjEgb2JqZWN0cyBmb3IgZXF1YWxpdHkuXG4gKlxuICogTm90ZSB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJ1biBpbiBjb25zdGFudCB0aW1lLlxuICpcbiAqIEBwYXJhbSBvYmoxIHRoZSBmaXJzdCBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBvYmoyIHRoZSBzZWNvbmQgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gW29wdGlvbnNdIGNvbXBhcmUgb3B0aW9uczpcbiAqICAgICAgICAgIFtpbmNsdWRlQml0U3RyaW5nQ29udGVudHNdIHRydWUgdG8gY29tcGFyZSBiaXRTdHJpbmdDb250ZW50c1xuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgYXNuMSBvYmplY3RzIGFyZSBlcXVhbC5cbiAqL1xuYXNuMS5lcXVhbHMgPSBmdW5jdGlvbihvYmoxLCBvYmoyLCBvcHRpb25zKSB7XG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShvYmoxKSkge1xuICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkob2JqMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZighYXNuMS5lcXVhbHMob2JqMVtpXSwgb2JqMltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvYmoxICE9PSB0eXBlb2Ygb2JqMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBvYmoxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xuICB9XG5cbiAgdmFyIGVxdWFsID0gb2JqMS50YWdDbGFzcyA9PT0gb2JqMi50YWdDbGFzcyAmJlxuICAgIG9iajEudHlwZSA9PT0gb2JqMi50eXBlICYmXG4gICAgb2JqMS5jb25zdHJ1Y3RlZCA9PT0gb2JqMi5jb25zdHJ1Y3RlZCAmJlxuICAgIG9iajEuY29tcG9zZWQgPT09IG9iajIuY29tcG9zZWQgJiZcbiAgICBhc24xLmVxdWFscyhvYmoxLnZhbHVlLCBvYmoyLnZhbHVlKTtcbiAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVCaXRTdHJpbmdDb250ZW50cykge1xuICAgIGVxdWFsID0gZXF1YWwgJiYgKG9iajEuYml0U3RyaW5nQ29udGVudHMgPT09IG9iajIuYml0U3RyaW5nQ29udGVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGVxdWFsO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsZW5ndGggb2YgYSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZS5cbiAqXG4gKiBJbiBjYXNlIHRoZSBsZW5ndGggaXMgbm90IHNwZWNpZmllZCwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBCRVItZW5jb2RlZCBBU04uMSBieXRlIGJ1ZmZlciwgc3RhcnRpbmcgd2l0aCB0aGUgZmlyc3RcbiAqICAgICAgICAgIGxlbmd0aCBieXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgQkVSLWVuY29kZWQgQVNOLjEgdmFsdWUgb3IgdW5kZWZpbmVkLlxuICovXG5hc24xLmdldEJlclZhbHVlTGVuZ3RoID0gZnVuY3Rpb24oYikge1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gYW5kIHJlbGF0ZWQgREVSL0JFUiBmdW5jdGlvbnMgdG8gYSBkZXIuanNcbiAgLy8gZmlsZTsgYmV0dGVyIGFic3RyYWN0IEFTTi4xIGF3YXkgZnJvbSBkZXIvYmVyLlxuICB2YXIgYjIgPSBiLmdldEJ5dGUoKTtcbiAgaWYoYjIgPT09IDB4ODApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gc2VlIGlmIHRoZSBsZW5ndGggaXMgXCJzaG9ydCBmb3JtXCIgb3IgXCJsb25nIGZvcm1cIiAoYml0IDggc2V0KVxuICB2YXIgbGVuZ3RoO1xuICB2YXIgbG9uZ0Zvcm0gPSBiMiAmIDB4ODA7XG4gIGlmKCFsb25nRm9ybSkge1xuICAgIC8vIGxlbmd0aCBpcyBqdXN0IHRoZSBmaXJzdCBieXRlXG4gICAgbGVuZ3RoID0gYjI7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgbGVuZ3RoIGlzIHNwZWNpZmllZCBpbiBiaXRzIDcgdGhyb3VnaCAxXG4gICAgLy8gYW5kIGVhY2ggbGVuZ3RoIGJ5dGUgaXMgaW4gYmlnLWVuZGlhbiBiYXNlLTI1NlxuICAgIGxlbmd0aCA9IGIuZ2V0SW50KChiMiAmIDB4N0YpIDw8IDMpO1xuICB9XG4gIHJldHVybiBsZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBieXRlIGJ1ZmZlciBoYXMgZW5vdWdoIGJ5dGVzLiBUaHJvd3MgYW4gRXJyb3IgaWYgbm90LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSByZW1haW5pbmcgdGhlIGJ5dGVzIHJlbWFpbmluZyBpbiB0aGUgY3VycmVudCBwYXJzaW5nIHN0YXRlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIG11c3QgaGF2ZS5cbiAqL1xuZnVuY3Rpb24gX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIG4pIHtcbiAgaWYobiA+IHJlbWFpbmluZykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVG9vIGZldyBieXRlcyB0byBwYXJzZSBERVIuJyk7XG4gICAgZXJyb3IuYXZhaWxhYmxlID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgZXJyb3IucmVtYWluaW5nID0gcmVtYWluaW5nO1xuICAgIGVycm9yLnJlcXVlc3RlZCA9IG47XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsZW5ndGggb2YgYSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZS5cbiAqXG4gKiBJbiBjYXNlIHRoZSBsZW5ndGggaXMgbm90IHNwZWNpZmllZCwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSByZW1haW5pbmcgdGhlIGJ5dGVzIHJlbWFpbmluZyBpbiB0aGUgY3VycmVudCBwYXJzaW5nIHN0YXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgQkVSLWVuY29kZWQgQVNOLjEgdmFsdWUgb3IgdW5kZWZpbmVkLlxuICovXG52YXIgX2dldFZhbHVlTGVuZ3RoID0gZnVuY3Rpb24oYnl0ZXMsIHJlbWFpbmluZykge1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gYW5kIHJlbGF0ZWQgREVSL0JFUiBmdW5jdGlvbnMgdG8gYSBkZXIuanNcbiAgLy8gZmlsZTsgYmV0dGVyIGFic3RyYWN0IEFTTi4xIGF3YXkgZnJvbSBkZXIvYmVyLlxuICAvLyBmcm9tRGVyIGFscmVhZHkgY2hlY2tlZCB0aGF0IHRoaXMgYnl0ZSBleGlzdHNcbiAgdmFyIGIyID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICByZW1haW5pbmctLTtcbiAgaWYoYjIgPT09IDB4ODApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gc2VlIGlmIHRoZSBsZW5ndGggaXMgXCJzaG9ydCBmb3JtXCIgb3IgXCJsb25nIGZvcm1cIiAoYml0IDggc2V0KVxuICB2YXIgbGVuZ3RoO1xuICB2YXIgbG9uZ0Zvcm0gPSBiMiAmIDB4ODA7XG4gIGlmKCFsb25nRm9ybSkge1xuICAgIC8vIGxlbmd0aCBpcyBqdXN0IHRoZSBmaXJzdCBieXRlXG4gICAgbGVuZ3RoID0gYjI7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgbGVuZ3RoIGlzIHNwZWNpZmllZCBpbiBiaXRzIDcgdGhyb3VnaCAxXG4gICAgLy8gYW5kIGVhY2ggbGVuZ3RoIGJ5dGUgaXMgaW4gYmlnLWVuZGlhbiBiYXNlLTI1NlxuICAgIHZhciBsb25nRm9ybUJ5dGVzID0gYjIgJiAweDdGO1xuICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCBsb25nRm9ybUJ5dGVzKTtcbiAgICBsZW5ndGggPSBieXRlcy5nZXRJbnQobG9uZ0Zvcm1CeXRlcyA8PCAzKTtcbiAgfVxuICAvLyBGSVhNRTogdGhpcyB3aWxsIG9ubHkgaGFwcGVuIGZvciAzMiBiaXQgZ2V0SW50IHdpdGggaGlnaCBiaXQgc2V0XG4gIGlmKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZ2F0aXZlIGxlbmd0aDogJyArIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGFuIGFzbjEgb2JqZWN0IGZyb20gYSBieXRlIGJ1ZmZlciBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gcGFyc2UgZnJvbS5cbiAqIEBwYXJhbSBbc3RyaWN0XSB0cnVlIHRvIGJlIHN0cmljdCB3aGVuIGNoZWNraW5nIHZhbHVlIGxlbmd0aHMsIGZhbHNlIHRvXG4gKiAgICAgICAgICBhbGxvdyB0cnVuY2F0ZWQgdmFsdWVzIChkZWZhdWx0OiB0cnVlKS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gb2JqZWN0IHdpdGggb3B0aW9ucyBvciBib29sZWFuIHN0cmljdCBmbGFnXG4gKiAgICAgICAgICBbc3RyaWN0XSB0cnVlIHRvIGJlIHN0cmljdCB3aGVuIGNoZWNraW5nIHZhbHVlIGxlbmd0aHMsIGZhbHNlIHRvXG4gKiAgICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICogICAgICAgICAgW3BhcnNlQWxsQnl0ZXNdIHRydWUgdG8gZW5zdXJlIGFsbCBieXRlcyBhcmUgcGFyc2VkXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgW2RlY29kZUJpdFN0cmluZ3NdIHRydWUgdG8gYXR0ZW1wdCB0byBkZWNvZGUgdGhlIGNvbnRlbnQgb2ZcbiAqICAgICAgICAgICAgQklUIFNUUklOR3MgKG5vdCBPQ1RFVCBTVFJJTkdzKSB1c2luZyBzdHJpY3QgbW9kZS4gTm90ZSB0aGF0XG4gKiAgICAgICAgICAgIHdpdGhvdXQgc2NoZW1hIHN1cHBvcnQgdG8gdW5kZXJzdGFuZCB0aGUgZGF0YSBjb250ZXh0IHRoaXMgY2FuXG4gKiAgICAgICAgICAgIGVycm9uZW91c2x5IGRlY29kZSB2YWx1ZXMgdGhhdCBoYXBwZW4gdG8gYmUgdmFsaWQgQVNOLjEuIFRoaXNcbiAqICAgICAgICAgICAgZmxhZyB3aWxsIGJlIGRlcHJlY2F0ZWQgb3IgcmVtb3ZlZCBhcyBzb29uIGFzIHNjaGVtYSBzdXBwb3J0IGlzXG4gKiAgICAgICAgICAgIGF2YWlsYWJsZS4gKGRlZmF1bHQ6IHRydWUpXG4gKlxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGZvciB2YXJpb3VzIG1hbGZvcm1lZCBpbnB1dCBjb25kaXRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5mcm9tRGVyID0gZnVuY3Rpb24oYnl0ZXMsIG9wdGlvbnMpIHtcbiAgaWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIHBhcnNlQWxsQnl0ZXM6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogb3B0aW9ucyxcbiAgICAgIHBhcnNlQWxsQnl0ZXM6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZighKCdzdHJpY3QnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5zdHJpY3QgPSB0cnVlO1xuICB9XG4gIGlmKCEoJ3BhcnNlQWxsQnl0ZXMnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5wYXJzZUFsbEJ5dGVzID0gdHJ1ZTtcbiAgfVxuICBpZighKCdkZWNvZGVCaXRTdHJpbmdzJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuZGVjb2RlQml0U3RyaW5ncyA9IHRydWU7XG4gIH1cblxuICAvLyB3cmFwIGluIGJ1ZmZlciBpZiBuZWVkZWRcbiAgaWYodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYnl0ZXMpO1xuICB9XG5cbiAgdmFyIGJ5dGVDb3VudCA9IGJ5dGVzLmxlbmd0aCgpO1xuICB2YXIgdmFsdWUgPSBfZnJvbURlcihieXRlcywgYnl0ZXMubGVuZ3RoKCksIDAsIG9wdGlvbnMpO1xuICBpZihvcHRpb25zLnBhcnNlQWxsQnl0ZXMgJiYgYnl0ZXMubGVuZ3RoKCkgIT09IDApIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1VucGFyc2VkIERFUiBieXRlcyByZW1haW4gYWZ0ZXIgQVNOLjEgcGFyc2luZy4nKTtcbiAgICBlcnJvci5ieXRlQ291bnQgPSBieXRlQ291bnQ7XG4gICAgZXJyb3IucmVtYWluaW5nID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBhbiBhc24xIG9iamVjdCBmcm9tIGEgYnl0ZSBidWZmZXIgaW4gREVSIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGZvciB0aGlzIGNodW5rLlxuICogQHBhcmFtIGRlcHRoIHRoZSBjdXJyZW50IHBhcnNpbmcgZGVwdGguXG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3Qgd2l0aCBzYW1lIG9wdGlvbnMgYXMgZnJvbURlcigpLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGgsIG9wdGlvbnMpIHtcbiAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvbnN1bXB0aW9uIGNhbGN1bGF0aW9uc1xuICB2YXIgc3RhcnQ7XG5cbiAgLy8gbWluaW11bSBsZW5ndGggZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmUgaXMgMlxuICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgLy8gY29uc3VtZWQgb25lIGJ5dGVcbiAgcmVtYWluaW5nLS07XG5cbiAgLy8gZ2V0IHRoZSB0YWcgY2xhc3NcbiAgdmFyIHRhZ0NsYXNzID0gKGIxICYgMHhDMCk7XG5cbiAgLy8gZ2V0IHRoZSB0eXBlIChiaXRzIDEtNSlcbiAgdmFyIHR5cGUgPSBiMSAmIDB4MUY7XG5cbiAgLy8gZ2V0IHRoZSB2YXJpYWJsZSB2YWx1ZSBsZW5ndGggYW5kIGFkanVzdCByZW1haW5pbmcgYnl0ZXNcbiAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgdmFyIGxlbmd0aCA9IF9nZXRWYWx1ZUxlbmd0aChieXRlcywgcmVtYWluaW5nKTtcbiAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG5cbiAgLy8gZW5zdXJlIHRoZXJlIGFyZSBlbm91Z2ggYnl0ZXMgdG8gZ2V0IHRoZSB2YWx1ZVxuICBpZihsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHJlYWQgQVNOLjEgdmFsdWUuJyk7XG4gICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIGVycm9yLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICAgIGVycm9yLnJlcXVlc3RlZCA9IGxlbmd0aDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBOb3RlOiBiZSBsZW5pZW50IHdpdGggdHJ1bmNhdGVkIHZhbHVlcyBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIC8vIHZhbHVlIHN0b3JhZ2VcbiAgdmFyIHZhbHVlO1xuICAvLyBwb3NzaWJsZSBCSVQgU1RSSU5HIGNvbnRlbnRzIHN0b3JhZ2VcbiAgdmFyIGJpdFN0cmluZ0NvbnRlbnRzO1xuXG4gIC8vIGNvbnN0cnVjdGVkIGZsYWcgaXMgYml0IDYgKDMyID0gMHgyMCkgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGNvbnN0cnVjdGVkID0gKChiMSAmIDB4MjApID09PSAweDIwKTtcbiAgaWYoY29uc3RydWN0ZWQpIHtcbiAgICAvLyBwYXJzZSBjaGlsZCBhc24xIG9iamVjdHMgZnJvbSB0aGUgdmFsdWVcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhc24xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aCwgcmVhZCB1bnRpbCBlbmQgdGFnXG4gICAgICBmb3IoOzspIHtcbiAgICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuICAgICAgICBpZihieXRlcy5ieXRlcygyKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwKSkge1xuICAgICAgICAgIGJ5dGVzLmdldEJ5dGVzKDIpO1xuICAgICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIHZhbHVlLnB1c2goX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBvcHRpb25zKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJzaW5nIGFzbjEgb2JqZWN0IG9mIGRlZmluaXRlIGxlbmd0aFxuICAgICAgd2hpbGUobGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCBsZW5ndGgsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgbGVuZ3RoIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYSBCSVQgU1RSSU5HLCBzYXZlIHRoZSBjb250ZW50cyBpbmNsdWRpbmcgcGFkZGluZ1xuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIHR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICBiaXRTdHJpbmdDb250ZW50cyA9IGJ5dGVzLmJ5dGVzKGxlbmd0aCk7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgaWYgYSBub24tY29uc3RydWN0ZWQgdmFsdWUgc2hvdWxkIGJlIGRlY29kZWQgYXMgYSBjb21wb3NlZFxuICAvLyB2YWx1ZSB0aGF0IGNvbnRhaW5zIG90aGVyIEFTTi4xIG9iamVjdHMuIEJJVCBTVFJJTkdzIChhbmQgT0NURVQgU1RSSU5HcylcbiAgLy8gY2FuIGJlIHVzZWQgdGhpcyB3YXkuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzICYmXG4gICAgdGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMICYmXG4gICAgLy8gRklYTUU6IE9DVEVUIFNUUklOR3Mgbm90IHlldCBzdXBwb3J0ZWQgaGVyZVxuICAgIC8vIC4uIG90aGVyIHBhcnRzIG9mIGZvcmdlIGV4cGVjdCB0byBkZWNvZGUgT0NURVQgU1RSSU5HcyBtYW51YWxseVxuICAgICh0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HIC8qfHwgdHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKi8pICYmXG4gICAgbGVuZ3RoID4gMSkge1xuICAgIC8vIHNhdmUgcmVhZCBwb3NpdGlvblxuICAgIHZhciBzYXZlZFJlYWQgPSBieXRlcy5yZWFkO1xuICAgIHZhciBzYXZlZFJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICBpZih0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAvKiBUaGUgZmlyc3Qgb2N0ZXQgZ2l2ZXMgdGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgIGJpdCBzdHJpbmcgaXMgbGVzcyB0aGFuIHRoZSBuZXh0IG11bHRpcGxlIG9mIGVpZ2h0ICh0aGlzIGlzIGNhbGxlZFxuICAgICAgICB0aGUgXCJudW1iZXIgb2YgdW51c2VkIGJpdHNcIikuXG5cbiAgICAgICAgVGhlIHNlY29uZCBhbmQgZm9sbG93aW5nIG9jdGV0cyBnaXZlIHRoZSB2YWx1ZSBvZiB0aGUgYml0IHN0cmluZ1xuICAgICAgICBjb252ZXJ0ZWQgdG8gYW4gb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDEpO1xuICAgICAgdW51c2VkID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgcmVtYWluaW5nLS07XG4gICAgfVxuICAgIC8vIGlmIGFsbCBiaXRzIGFyZSB1c2VkLCBtYXliZSB0aGUgQklUL09DVEVUIFNUUklORyBob2xkcyBBU04uMSBvYmpzXG4gICAgaWYodW51c2VkID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHBhcnNlIGNoaWxkIGFzbjEgb2JqZWN0IGZyb20gdGhlIHZhbHVlXG4gICAgICAgIC8vIChzdG9yZWQgaW4gYXJyYXkgdG8gc2lnbmFsIGNvbXBvc2VkIHZhbHVlKVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3ViT3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBlbmZvcmNlIHN0cmljdCBtb2RlIHRvIGF2b2lkIHBhcnNpbmcgQVNOLjEgZnJvbSBwbGFpbiBkYXRhXG4gICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgIGRlY29kZUJpdFN0cmluZ3M6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbXBvc2VkID0gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBzdWJPcHRpb25zKTtcbiAgICAgICAgdmFyIHVzZWQgPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICByZW1haW5pbmcgLT0gdXNlZDtcbiAgICAgICAgaWYodHlwZSA9PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAgICAgdXNlZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgYWxsIGRlY29kZWQgYW5kIHRoZSBjbGFzcyBpbmRpY2F0ZXMgVU5JVkVSU0FMIG9yXG4gICAgICAgIC8vIENPTlRFWFRfU1BFQ0lGSUMgdGhlbiBhc3N1bWUgd2UndmUgZ290IGFuIGVuY2Fwc3VsYXRlZCBBU04uMSBvYmplY3RcbiAgICAgICAgdmFyIHRjID0gY29tcG9zZWQudGFnQ2xhc3M7XG4gICAgICAgIGlmKHVzZWQgPT09IGxlbmd0aCAmJlxuICAgICAgICAgICh0YyA9PT0gYXNuMS5DbGFzcy5VTklWRVJTQUwgfHwgdGMgPT09IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQykpIHtcbiAgICAgICAgICB2YWx1ZSA9IFtjb21wb3NlZF07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmVzdG9yZSByZWFkIHBvc2l0aW9uXG4gICAgICBieXRlcy5yZWFkID0gc2F2ZWRSZWFkO1xuICAgICAgcmVtYWluaW5nID0gc2F2ZWRSZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGFzbjEgbm90IGNvbnN0cnVjdGVkIG9yIGNvbXBvc2VkLCBnZXQgcmF3IHZhbHVlXG4gICAgLy8gVE9ETzogZG8gREVSIHRvIE9JRCBjb252ZXJzaW9uIGFuZCB2aWNlLXZlcnNhIGluIC50b0Rlcj9cblxuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1jb25zdHJ1Y3RlZCBBU04uMSBvYmplY3Qgb2YgaW5kZWZpbml0ZSBsZW5ndGguJyk7XG4gICAgICB9XG4gICAgICAvLyBiZSBsZW5pZW50IGFuZCB1c2UgcmVtYWluaW5nIHN0YXRlIGJ5dGVzXG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuXG4gICAgaWYodHlwZSA9PT0gYXNuMS5UeXBlLkJNUFNUUklORykge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICAgIGZvcig7IGxlbmd0aCA+IDA7IGxlbmd0aCAtPSAyKSB7XG4gICAgICAgIF9jaGVja0J1ZmZlckxlbmd0aChieXRlcywgcmVtYWluaW5nLCAyKTtcbiAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlcy5nZXRJbnQxNigpKTtcbiAgICAgICAgcmVtYWluaW5nIC09IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gYnl0ZXMuZ2V0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgIHJlbWFpbmluZyAtPSBsZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlXG4gIHZhciBhc24xT3B0aW9ucyA9IGJpdFN0cmluZ0NvbnRlbnRzID09PSB1bmRlZmluZWQgPyBudWxsIDoge1xuICAgIGJpdFN0cmluZ0NvbnRlbnRzOiBiaXRTdHJpbmdDb250ZW50c1xuICB9O1xuXG4gIC8vIGNyZWF0ZSBhbmQgcmV0dXJuIGFzbjEgb2JqZWN0XG4gIHJldHVybiBhc24xLmNyZWF0ZSh0YWdDbGFzcywgdHlwZSwgY29uc3RydWN0ZWQsIHZhbHVlLCBhc24xT3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGFzbjEgb2JqZWN0IHRvIGEgYnVmZmVyIG9mIGJ5dGVzIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGFzbjEgdGhlIGFzbjEgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgYnVmZmVyIG9mIGJ5dGVzLlxuICovXG5hc24xLnRvRGVyID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gYnVpbGQgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGIxID0gb2JqLnRhZ0NsYXNzIHwgb2JqLnR5cGU7XG5cbiAgLy8gZm9yIHN0b3JpbmcgdGhlIEFTTi4xIHZhbHVlXG4gIHZhciB2YWx1ZSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlIGFuZCBkYXRhIG5vdCBjaGFuZ2VkXG4gIHZhciB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGZhbHNlO1xuICBpZignYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgIHVzZUJpdFN0cmluZ0NvbnRlbnRzID0gdHJ1ZTtcbiAgICBpZihvYmoub3JpZ2luYWwpIHtcbiAgICAgIHVzZUJpdFN0cmluZ0NvbnRlbnRzID0gYXNuMS5lcXVhbHMob2JqLCBvYmoub3JpZ2luYWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmKHVzZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgdmFsdWUucHV0Qnl0ZXMob2JqLmJpdFN0cmluZ0NvbnRlbnRzKTtcbiAgfSBlbHNlIGlmKG9iai5jb21wb3NlZCkge1xuICAgIC8vIGlmIGNvbXBvc2VkLCB1c2UgZWFjaCBjaGlsZCBhc24xIG9iamVjdCdzIERFUiBieXRlcyBhcyB2YWx1ZVxuICAgIC8vIHR1cm4gb24gNnRoIGJpdCAoMHgyMCA9IDMyKSB0byBpbmRpY2F0ZSBhc24xIGlzIGNvbnN0cnVjdGVkXG4gICAgLy8gZnJvbSBvdGhlciBhc24xIG9iamVjdHNcbiAgICBpZihvYmouY29uc3RydWN0ZWQpIHtcbiAgICAgIGIxIHw9IDB4MjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR5cGUgaXMgYSBiaXQgc3RyaW5nLCBhZGQgdW51c2VkIGJpdHMgb2YgMHgwMFxuICAgICAgdmFsdWUucHV0Qnl0ZSgweDAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYWxsIG9mIHRoZSBjaGlsZCBERVIgYnl0ZXMgdG9nZXRoZXJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZihvYmoudmFsdWVbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZS5wdXRCdWZmZXIoYXNuMS50b0RlcihvYmoudmFsdWVbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGFzbjEudmFsdWUgZGlyZWN0bHlcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLkJNUFNUUklORykge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWx1ZS5wdXRJbnQxNihvYmoudmFsdWUuY2hhckNvZGVBdChpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuc3VyZSBpbnRlZ2VyIGlzIG1pbmltYWxseS1lbmNvZGVkXG4gICAgICAvLyBUT0RPOiBzaG91bGQgYWxsIGxlYWRpbmcgYnl0ZXMgYmUgc3RyaXBwZWQgdnMganVzdCBvbmU/XG4gICAgICAvLyAuLiBleCAnMDAgMDAgMDEnID0+ICcwMSc/XG4gICAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIgJiZcbiAgICAgICAgb2JqLnZhbHVlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgLy8gbGVhZGluZyAweDAwIGZvciBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgICAgICgob2JqLnZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IDAgJiZcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDApIHx8XG4gICAgICAgIC8vIGxlYWRpbmcgMHhGRiBmb3IgbmVnYXRpdmUgaW50ZWdlclxuICAgICAgICAob2JqLnZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IDB4RkYgJiZcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDB4ODApKSkge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUuc3Vic3RyKDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLnB1dEJ5dGVzKG9iai52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRhZyBieXRlXG4gIGJ5dGVzLnB1dEJ5dGUoYjEpO1xuXG4gIC8vIHVzZSBcInNob3J0IGZvcm1cIiBlbmNvZGluZ1xuICBpZih2YWx1ZS5sZW5ndGgoKSA8PSAxMjcpIHtcbiAgICAvLyBvbmUgYnl0ZSBkZXNjcmliZXMgdGhlIGxlbmd0aFxuICAgIC8vIGJpdCA4ID0gMCBhbmQgYml0cyA3LTEgPSBsZW5ndGhcbiAgICBieXRlcy5wdXRCeXRlKHZhbHVlLmxlbmd0aCgpICYgMHg3Rik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIFwibG9uZyBmb3JtXCIgZW5jb2RpbmdcbiAgICAvLyAyIHRvIDEyNyBieXRlcyBkZXNjcmliZSB0aGUgbGVuZ3RoXG4gICAgLy8gZmlyc3QgYnl0ZTogYml0IDggPSAxIGFuZCBiaXRzIDctMSA9ICMgb2YgYWRkaXRpb25hbCBieXRlc1xuICAgIC8vIG90aGVyIGJ5dGVzOiBsZW5ndGggaW4gYmFzZSAyNTYsIGJpZy1lbmRpYW5cbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoKCk7XG4gICAgdmFyIGxlbkJ5dGVzID0gJyc7XG4gICAgZG8ge1xuICAgICAgbGVuQnl0ZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4gJiAweEZGKTtcbiAgICAgIGxlbiA9IGxlbiA+Pj4gODtcbiAgICB9IHdoaWxlKGxlbiA+IDApO1xuXG4gICAgLy8gc2V0IGZpcnN0IGJ5dGUgdG8gIyBieXRlcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggYW5kIHR1cm4gb25cbiAgICAvLyBiaXQgOCB0byBpbmRpY2F0ZSBsb25nLWZvcm0gbGVuZ3RoIGlzIHVzZWRcbiAgICBieXRlcy5wdXRCeXRlKGxlbkJ5dGVzLmxlbmd0aCB8IDB4ODApO1xuXG4gICAgLy8gY29uY2F0ZW5hdGUgbGVuZ3RoIGJ5dGVzIGluIHJldmVyc2Ugc2luY2UgdGhleSB3ZXJlIGdlbmVyYXRlZFxuICAgIC8vIGxpdHRsZSBlbmRpYW4gYW5kIHdlIG5lZWQgYmlnIGVuZGlhblxuICAgIGZvcih2YXIgaSA9IGxlbkJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBieXRlcy5wdXRCeXRlKGxlbkJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbmNhdGVuYXRlIHZhbHVlIGJ5dGVzXG4gIGJ5dGVzLnB1dEJ1ZmZlcih2YWx1ZSk7XG4gIHJldHVybiBieXRlcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nIHRvIGEgYnl0ZSBidWZmZXIuIFRoZSBieXRlIGJ1ZmZlclxuICogY29udGFpbnMgb25seSB0aGUgREVSLWVuY29kZWQgdmFsdWUsIG5vdCBhbnkgdGFnIG9yIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBPSUQgZG90LXNlcGFyYXRlZCBzdHJpbmcuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEub2lkVG9EZXIgPSBmdW5jdGlvbihvaWQpIHtcbiAgLy8gc3BsaXQgT0lEIGludG8gaW5kaXZpZHVhbCB2YWx1ZXNcbiAgdmFyIHZhbHVlcyA9IG9pZC5zcGxpdCgnLicpO1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgYnl0ZXMucHV0Qnl0ZSg0MCAqIHBhcnNlSW50KHZhbHVlc1swXSwgMTApICsgcGFyc2VJbnQodmFsdWVzWzFdLCAxMCkpO1xuICAvLyBvdGhlciBieXRlcyBhcmUgZWFjaCB2YWx1ZSBpbiBiYXNlIDEyOCB3aXRoIDh0aCBiaXQgc2V0IGV4Y2VwdCBmb3JcbiAgLy8gdGhlIGxhc3QgYnl0ZSBmb3IgZWFjaCB2YWx1ZVxuICB2YXIgbGFzdCwgdmFsdWVCeXRlcywgdmFsdWUsIGI7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBwcm9kdWNlIHZhbHVlIGJ5dGVzIGluIHJldmVyc2UgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGhvdyBtYW55XG4gICAgLy8gYnl0ZXMgaXQgd2lsbCB0YWtlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgIGxhc3QgPSB0cnVlO1xuICAgIHZhbHVlQnl0ZXMgPSBbXTtcbiAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlc1tpXSwgMTApO1xuICAgIGRvIHtcbiAgICAgIGIgPSB2YWx1ZSAmIDB4N0Y7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgLy8gaWYgdmFsdWUgaXMgbm90IGxhc3QsIHRoZW4gdHVybiBvbiA4dGggYml0XG4gICAgICBpZighbGFzdCkge1xuICAgICAgICBiIHw9IDB4ODA7XG4gICAgICB9XG4gICAgICB2YWx1ZUJ5dGVzLnB1c2goYik7XG4gICAgICBsYXN0ID0gZmFsc2U7XG4gICAgfSB3aGlsZSh2YWx1ZSA+IDApO1xuXG4gICAgLy8gYWRkIHZhbHVlIGJ5dGVzIGluIHJldmVyc2UgKG5lZWRzIHRvIGJlIGluIGJpZyBlbmRpYW4pXG4gICAgZm9yKHZhciBuID0gdmFsdWVCeXRlcy5sZW5ndGggLSAxOyBuID49IDA7IC0tbikge1xuICAgICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZUJ5dGVzW25dKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYW4gT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLiBUaGVcbiAqIGJ5dGUgYnVmZmVyIHNob3VsZCBjb250YWluIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvclxuICogbGVuZ3RoIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICovXG5hc24xLmRlclRvT2lkID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdmFyIG9pZDtcblxuICAvLyB3cmFwIGluIGJ1ZmZlciBpZiBuZWVkZWRcbiAgaWYodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYnl0ZXMpO1xuICB9XG5cbiAgLy8gZmlyc3QgYnl0ZSBpcyA0MCAqIHZhbHVlMSArIHZhbHVlMlxuICB2YXIgYiA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgb2lkID0gTWF0aC5mbG9vcihiIC8gNDApICsgJy4nICsgKGIgJSA0MCk7XG5cbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIHZhbHVlID0gMDtcbiAgd2hpbGUoYnl0ZXMubGVuZ3RoKCkgPiAwKSB7XG4gICAgYiA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgICB2YWx1ZSA9IHZhbHVlIDw8IDc7XG4gICAgLy8gbm90IHRoZSBsYXN0IGJ5dGUgZm9yIHRoZSB2YWx1ZVxuICAgIGlmKGIgJiAweDgwKSB7XG4gICAgICB2YWx1ZSArPSBiICYgMHg3RjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGFzdCBieXRlXG4gICAgICBvaWQgKz0gJy4nICsgKHZhbHVlICsgYik7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9pZDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVVENUaW1lIHZhbHVlIHRvIGEgZGF0ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gUGFyc2luZyB0aGF0IHN0cnVjdHVyZSBoYXNuJ3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXQuXG4gKlxuICogQHBhcmFtIHV0YyB0aGUgVVRDVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEudXRjVGltZVRvRGF0ZSA9IGZ1bmN0aW9uKHV0Yykge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWU1NRERoaG1tWlxuICAgIFlZTU1ERGhobW0raGgnbW0nXG4gICAgWVlNTUREaGhtbS1oaCdtbSdcbiAgICBZWU1NRERoaG1tc3NaXG4gICAgWVlNTUREaGhtbXNzK2hoJ21tJ1xuICAgIFlZTU1ERGhobW1zcy1oaCdtbSdcblxuICAgIFdoZXJlOlxuXG4gICAgWVkgaXMgdGhlIGxlYXN0IHNpZ25pZmljYW50IHR3byBkaWdpdHMgb2YgdGhlIHllYXJcbiAgICBNTSBpcyB0aGUgbW9udGggKDAxIHRvIDEyKVxuICAgIEREIGlzIHRoZSBkYXkgKDAxIHRvIDMxKVxuICAgIGhoIGlzIHRoZSBob3VyICgwMCB0byAyMylcbiAgICBtbSBhcmUgdGhlIG1pbnV0ZXMgKDAwIHRvIDU5KVxuICAgIHNzIGFyZSB0aGUgc2Vjb25kcyAoMDAgdG8gNTkpXG4gICAgWiBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIEdNVCwgKyBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzXG4gICAgbGF0ZXIgdGhhbiBHTVQsIGFuZCAtIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgZWFybGllciB0aGFuIEdNVFxuICAgIGhoJyBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIG9mZnNldCBmcm9tIEdNVCBpbiBob3Vyc1xuICAgIG1tJyBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIG9mZnNldCBmcm9tIEdNVCBpbiBtaW51dGVzICovXG4gIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICAvLyBpZiBZWSA+PSA1MCB1c2UgMTl4eCwgaWYgWVkgPCA1MCB1c2UgMjB4eFxuICB2YXIgeWVhciA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoMCwgMiksIDEwKTtcbiAgeWVhciA9ICh5ZWFyID49IDUwKSA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG4gIHZhciBNTSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoMiwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludCh1dGMuc3Vic3RyKDQsIDIpLCAxMCk7XG4gIHZhciBoaCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoNiwgMiksIDEwKTtcbiAgdmFyIG1tID0gcGFyc2VJbnQodXRjLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgc3MgPSAwO1xuXG4gIC8vIG5vdCBqdXN0IFlZTU1ERGhobW1aXG4gIGlmKHV0Yy5sZW5ndGggPiAxMSkge1xuICAgIC8vIGdldCBjaGFyYWN0ZXIgYWZ0ZXIgbWludXRlc1xuICAgIHZhciBjID0gdXRjLmNoYXJBdCgxMCk7XG4gICAgdmFyIGVuZCA9IDEwO1xuXG4gICAgLy8gc2VlIGlmIHNlY29uZHMgYXJlIHByZXNlbnRcbiAgICBpZihjICE9PSAnKycgJiYgYyAhPT0gJy0nKSB7XG4gICAgICAvLyBnZXQgc2Vjb25kc1xuICAgICAgc3MgPSBwYXJzZUludCh1dGMuc3Vic3RyKDEwLCAyKSwgMTApO1xuICAgICAgZW5kICs9IDI7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIGRhdGVcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCBNTSwgREQpO1xuICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIDApO1xuXG4gIGlmKGVuZCkge1xuICAgIC8vIGdldCArLy0gYWZ0ZXIgZW5kIG9mIHRpbWVcbiAgICBjID0gdXRjLmNoYXJBdChlbmQpO1xuICAgIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAgIC8vIGdldCBob3VycyttaW51dGVzIG9mZnNldFxuICAgICAgdmFyIGhob2Zmc2V0ID0gcGFyc2VJbnQodXRjLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgICAgdmFyIG1tb2Zmc2V0ID0gcGFyc2VJbnQodXRjLnN1YnN0cihlbmQgKyA0LCAyKSwgMTApO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAgdmFyIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICAgIG9mZnNldCAqPSA2MDAwMDtcblxuICAgICAgLy8gYXBwbHkgb2Zmc2V0XG4gICAgICBpZihjID09PSAnKycpIHtcbiAgICAgICAgZGF0ZS5zZXRUaW1lKCtkYXRlIC0gb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgR2VuZXJhbGl6ZWRUaW1lIHZhbHVlIHRvIGEgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZ2VudGltZSB0aGUgR2VuZXJhbGl6ZWRUaW1lIHZhbHVlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZGF0ZS5cbiAqL1xuYXNuMS5nZW5lcmFsaXplZFRpbWVUb0RhdGUgPSBmdW5jdGlvbihnZW50aW1lKSB7XG4gIC8qIFRoZSBmb2xsb3dpbmcgZm9ybWF0cyBjYW4gYmUgdXNlZDpcblxuICAgIFlZWVlNTURESEhNTVNTXG4gICAgWVlZWU1NRERISE1NU1MuZmZmXG4gICAgWVlZWU1NRERISE1NU1NaXG4gICAgWVlZWU1NRERISE1NU1MuZmZmWlxuICAgIFlZWVlNTURESEhNTVNTK2hoJ21tJ1xuICAgIFlZWVlNTURESEhNTVNTLmZmZitoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy1oaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZWVkgaXMgdGhlIHllYXJcbiAgICBNTSBpcyB0aGUgbW9udGggKDAxIHRvIDEyKVxuICAgIEREIGlzIHRoZSBkYXkgKDAxIHRvIDMxKVxuICAgIGhoIGlzIHRoZSBob3VyICgwMCB0byAyMylcbiAgICBtbSBhcmUgdGhlIG1pbnV0ZXMgKDAwIHRvIDU5KVxuICAgIHNzIGFyZSB0aGUgc2Vjb25kcyAoMDAgdG8gNTkpXG4gICAgLmZmZiBpcyB0aGUgc2Vjb25kIGZyYWN0aW9uLCBhY2N1cmF0ZSB0byB0aHJlZSBkZWNpbWFsIHBsYWNlc1xuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgdmFyIFlZWVkgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigwLCA0KSwgMTApO1xuICB2YXIgTU0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig0LCAyKSwgMTApIC0gMTsgLy8gdXNlIDAtMTEgZm9yIG1vbnRoXG4gIHZhciBERCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBoaCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDgsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDEwLCAyKSwgMTApO1xuICB2YXIgc3MgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMiwgMiksIDEwKTtcbiAgdmFyIGZmZiA9IDA7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgaXNVVEMgPSBmYWxzZTtcblxuICBpZihnZW50aW1lLmNoYXJBdChnZW50aW1lLmxlbmd0aCAtIDEpID09PSAnWicpIHtcbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICB2YXIgZW5kID0gZ2VudGltZS5sZW5ndGggLSA1LCBjID0gZ2VudGltZS5jaGFyQXQoZW5kKTtcbiAgaWYoYyA9PT0gJysnIHx8IGMgPT09ICctJykge1xuICAgIC8vIGdldCBob3VycyttaW51dGVzIG9mZnNldFxuICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDEsIDIpLCAxMCk7XG4gICAgdmFyIG1tb2Zmc2V0ID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgb2Zmc2V0ID0gaGhvZmZzZXQgKiA2MCArIG1tb2Zmc2V0O1xuICAgIG9mZnNldCAqPSA2MDAwMDtcblxuICAgIC8vIGFwcGx5IG9mZnNldFxuICAgIGlmKGMgPT09ICcrJykge1xuICAgICAgb2Zmc2V0ICo9IC0xO1xuICAgIH1cblxuICAgIGlzVVRDID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBzZWNvbmQgZnJhY3Rpb25cbiAgaWYoZ2VudGltZS5jaGFyQXQoMTQpID09PSAnLicpIHtcbiAgICBmZmYgPSBwYXJzZUZsb2F0KGdlbnRpbWUuc3Vic3RyKDE0KSwgMTApICogMTAwMDtcbiAgfVxuXG4gIGlmKGlzVVRDKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihZWVlZLCBNTSwgREQpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoaGgsIG1tLCBzcywgZmZmKTtcblxuICAgIC8vIGFwcGx5IG9mZnNldFxuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIG9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihZWVlZLCBNTSwgREQpO1xuICAgIGRhdGUuc2V0SG91cnMoaGgsIG1tLCBzcywgZmZmKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBVVENUaW1lIHZhbHVlLlxuICpcbiAqIE5vdGU6IEdlbmVyYWxpemVkVGltZSBoYXMgNCBkaWdpdHMgZm9yIHRoZSB5ZWFyIGFuZCBpcyB1c2VkIGZvciBYLjUwOVxuICogZGF0ZXMgcGFzdCAyMDQ5LiBDb252ZXJ0aW5nIHRvIGEgR2VuZXJhbGl6ZWRUaW1lIGhhc24ndCBiZWVuXG4gKiBpbXBsZW1lbnRlZCB5ZXQuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVVENUaW1lIHZhbHVlLlxuICovXG5hc24xLmRhdGVUb1V0Y1RpbWUgPSBmdW5jdGlvbihkYXRlKSB7XG4gIC8vIFRPRE86IHZhbGlkYXRlOyBjdXJyZW50bHkgYXNzdW1lcyBwcm9wZXIgZm9ybWF0XG4gIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBjcmVhdGUgZm9ybWF0IFlZTU1ERGhobW1zc1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgoJycgKyBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpLnN1YnN0cigyKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGF0ZSB0byBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSB0aGUgZGF0ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSBhcyBhIHN0cmluZy5cbiAqL1xuYXNuMS5kYXRlVG9HZW5lcmFsaXplZFRpbWUgPSBmdW5jdGlvbihkYXRlKSB7XG4gIC8vIFRPRE86IHZhbGlkYXRlOyBjdXJyZW50bHkgYXNzdW1lcyBwcm9wZXIgZm9ybWF0XG4gIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBjcmVhdGUgZm9ybWF0IFlZWVlNTURESEhNTVNTWlxuICB2YXIgZm9ybWF0ID0gW107XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgZm9ybWF0LnB1c2goJycgKyAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0hvdXJzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDTWludXRlcygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ1NlY29uZHMoKSk7XG5cbiAgLy8gZW5zdXJlIDIgZGlnaXRzIGFyZSB1c2VkIGZvciBlYWNoIGZvcm1hdCBlbnRyeVxuICBmb3IodmFyIGkgPSAwOyBpIDwgZm9ybWF0Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYoZm9ybWF0W2ldLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJ2YWwgKz0gJzAnO1xuICAgIH1cbiAgICBydmFsICs9IGZvcm1hdFtpXTtcbiAgfVxuICBydmFsICs9ICdaJztcblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBqYXZhc2NyaXB0IGludGVnZXIgdG8gYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBiZSB1c2VkXG4gKiBhcyB0aGUgdmFsdWUgZm9yIGFuIElOVEVHRVIgdHlwZS5cbiAqXG4gKiBAcGFyYW0geCB0aGUgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlIGJ1ZmZlci5cbiAqL1xuYXNuMS5pbnRlZ2VyVG9EZXIgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgaWYoeCA+PSAtMHg4MCAmJiB4IDwgMHg4MCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCA4KTtcbiAgfVxuICBpZih4ID49IC0weDgwMDAgJiYgeCA8IDB4ODAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAxNik7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAgJiYgeCA8IDB4ODAwMDAwKSB7XG4gICAgcmV0dXJuIHJ2YWwucHV0U2lnbmVkSW50KHgsIDI0KTtcbiAgfVxuICBpZih4ID49IC0weDgwMDAwMDAwICYmIHggPCAweDgwMDAwMDAwKSB7XG4gICAgcmV0dXJuIHJ2YWwucHV0U2lnbmVkSW50KHgsIDMyKTtcbiAgfVxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludGVnZXIgdG9vIGxhcmdlOyBtYXggaXMgMzItYml0cy4nKTtcbiAgZXJyb3IuaW50ZWdlciA9IHg7XG4gIHRocm93IGVycm9yO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGEgamF2YXNjcmlwdCBpbnRlZ2VyLiBUaGlzIGlzXG4gKiB0eXBpY2FsbHkgdXNlZCB0byBkZWNvZGUgdGhlIHZhbHVlIG9mIGFuIElOVEVHRVIgdHlwZS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbmFzbjEuZGVyVG9JbnRlZ2VyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHZhciBuID0gYnl0ZXMubGVuZ3RoKCkgKiA4O1xuICBpZihuID4gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgdG9vIGxhcmdlOyBtYXggaXMgMzItYml0cy4nKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuZ2V0U2lnbmVkSW50KG4pO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgZ2l2ZW4gQVNOLjEgb2JqZWN0IGlzIGF0IGxlYXN0IGEgc3VwZXIgc2V0IG9mIHRoZVxuICogZ2l2ZW4gQVNOLjEgc3RydWN0dXJlLiBPbmx5IHRhZyBjbGFzc2VzIGFuZCB0eXBlcyBhcmUgY2hlY2tlZC4gQW5cbiAqIG9wdGlvbmFsIG1hcCBtYXkgYWxzbyBiZSBwcm92aWRlZCB0byBjYXB0dXJlIEFTTi4xIHZhbHVlcyB3aGlsZSB0aGVcbiAqIHN0cnVjdHVyZSBpcyBjaGVja2VkLlxuICpcbiAqIFRvIGNhcHR1cmUgYW4gQVNOLjEgdmFsdWUsIHNldCBhbiBvYmplY3QgaW4gdGhlIHZhbGlkYXRvcidzICdjYXB0dXJlJ1xuICogcGFyYW1ldGVyIHRvIHRoZSBrZXkgdG8gdXNlIGluIHRoZSBjYXB0dXJlIG1hcC4gVG8gY2FwdHVyZSB0aGUgZnVsbFxuICogQVNOLjEgb2JqZWN0LCBzcGVjaWZ5ICdjYXB0dXJlQXNuMScuIFRvIGNhcHR1cmUgQklUIFNUUklORyBieXRlcywgaW5jbHVkaW5nXG4gKiB0aGUgbGVhZGluZyB1bnVzZWQgYml0cyBjb3VudGVyIGJ5dGUsIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdDb250ZW50cycuXG4gKiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIHdpdGhvdXQgdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLFxuICogc3BlY2lmeSAnY2FwdHVyZUJpdFN0cmluZ1ZhbHVlJy5cbiAqXG4gKiBPYmplY3RzIGluIHRoZSB2YWxpZGF0b3IgbWF5IHNldCBhIGZpZWxkICdvcHRpb25hbCcgdG8gdHJ1ZSB0byBpbmRpY2F0ZVxuICogdGhhdCBpdCBpc24ndCBuZWNlc3NhcnkgdG8gcGFzcyB2YWxpZGF0aW9uLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIG9iamVjdCB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSB2IHRoZSBBU04uMSBzdHJ1Y3R1cmUgdmFsaWRhdG9yLlxuICogQHBhcmFtIGNhcHR1cmUgYW4gb3B0aW9uYWwgbWFwIHRvIGNhcHR1cmUgdmFsdWVzIGluLlxuICogQHBhcmFtIGVycm9ycyBhbiBvcHRpb25hbCBhcnJheSBmb3Igc3RvcmluZyB2YWxpZGF0aW9uIGVycm9ycy5cbiAqXG4gKiBAcmV0dXJuIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZS5cbiAqL1xuYXNuMS52YWxpZGF0ZSA9IGZ1bmN0aW9uKG9iaiwgdiwgY2FwdHVyZSwgZXJyb3JzKSB7XG4gIHZhciBydmFsID0gZmFsc2U7XG5cbiAgLy8gZW5zdXJlIHRhZyBjbGFzcyBhbmQgdHlwZSBhcmUgdGhlIHNhbWUgaWYgc3BlY2lmaWVkXG4gIGlmKChvYmoudGFnQ2xhc3MgPT09IHYudGFnQ2xhc3MgfHwgdHlwZW9mKHYudGFnQ2xhc3MpID09PSAndW5kZWZpbmVkJykgJiZcbiAgICAob2JqLnR5cGUgPT09IHYudHlwZSB8fCB0eXBlb2Yodi50eXBlKSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgLy8gZW5zdXJlIGNvbnN0cnVjdGVkIGZsYWcgaXMgdGhlIHNhbWUgaWYgc3BlY2lmaWVkXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkID09PSB2LmNvbnN0cnVjdGVkIHx8XG4gICAgICB0eXBlb2Yodi5jb25zdHJ1Y3RlZCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBydmFsID0gdHJ1ZTtcblxuICAgICAgLy8gaGFuZGxlIHN1YiB2YWx1ZXNcbiAgICAgIGlmKHYudmFsdWUgJiYgZm9yZ2UudXRpbC5pc0FycmF5KHYudmFsdWUpKSB7XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgcnZhbCAmJiBpIDwgdi52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHJ2YWwgPSB2LnZhbHVlW2ldLm9wdGlvbmFsIHx8IGZhbHNlO1xuICAgICAgICAgIGlmKG9iai52YWx1ZVtqXSkge1xuICAgICAgICAgICAgcnZhbCA9IGFzbjEudmFsaWRhdGUob2JqLnZhbHVlW2pdLCB2LnZhbHVlW2ldLCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgICAgICAgaWYocnZhbCkge1xuICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9IGVsc2UgaWYodi52YWx1ZVtpXS5vcHRpb25hbCkge1xuICAgICAgICAgICAgICBydmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIXJ2YWwgJiYgZXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICAgICAgICdUYWcgY2xhc3MgXCInICsgdi50YWdDbGFzcyArICdcIiwgdHlwZSBcIicgK1xuICAgICAgICAgICAgICB2LnR5cGUgKyAnXCIgZXhwZWN0ZWQgdmFsdWUgbGVuZ3RoIFwiJyArXG4gICAgICAgICAgICAgIHYudmFsdWUubGVuZ3RoICsgJ1wiLCBnb3QgXCInICtcbiAgICAgICAgICAgICAgb2JqLnZhbHVlLmxlbmd0aCArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihydmFsICYmIGNhcHR1cmUpIHtcbiAgICAgICAgaWYodi5jYXB0dXJlKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVdID0gb2JqLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUFzbjEpIHtcbiAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUFzbjFdID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ0NvbnRlbnRzICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50c10gPSBvYmouYml0U3RyaW5nQ29udGVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYodi5jYXB0dXJlQml0U3RyaW5nVmFsdWUgJiYgJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgaWYob2JqLmJpdFN0cmluZ0NvbnRlbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nVmFsdWVdID0gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IHVudXNlZCBiaXRzIHdpdGggZGF0YSBzaGlmdGluZ1xuICAgICAgICAgICAgdmFyIHVudXNlZCA9IG9iai5iaXRTdHJpbmdDb250ZW50cy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYodW51c2VkICE9PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnY2FwdHVyZUJpdFN0cmluZ1ZhbHVlIG9ubHkgc3VwcG9ydGVkIGZvciB6ZXJvIHVudXNlZCBiaXRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9IG9iai5iaXRTdHJpbmdDb250ZW50cy5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCBjb25zdHJ1Y3RlZCBcIicgKyB2LmNvbnN0cnVjdGVkICsgJ1wiLCBnb3QgXCInICtcbiAgICAgICAgb2JqLmNvbnN0cnVjdGVkICsgJ1wiJyk7XG4gICAgfVxuICB9IGVsc2UgaWYoZXJyb3JzKSB7XG4gICAgaWYob2JqLnRhZ0NsYXNzICE9PSB2LnRhZ0NsYXNzKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCB0YWcgY2xhc3MgXCInICsgdi50YWdDbGFzcyArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai50YWdDbGFzcyArICdcIicpO1xuICAgIH1cbiAgICBpZihvYmoudHlwZSAhPT0gdi50eXBlKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCB0eXBlIFwiJyArIHYudHlwZSArICdcIiwgZ290IFwiJyArIG9iai50eXBlICsgJ1wiJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLy8gcmVnZXggZm9yIHRlc3RpbmcgZm9yIG5vbi1sYXRpbiBjaGFyYWN0ZXJzXG52YXIgX25vbkxhdGluUmVnZXggPSAvW15cXFxcdTAwMDAtXFxcXHUwMGZmXS87XG5cbi8qKlxuICogUHJldHR5IHByaW50cyBhbiBBU04uMSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHRvIHdyaXRlIG91dC5cbiAqIEBwYXJhbSBsZXZlbCB0aGUgbGV2ZWwgaW4gdGhlIHRyZWUuXG4gKiBAcGFyYW0gaW5kZW50YXRpb24gdGhlIGluZGVudGF0aW9uIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcuXG4gKi9cbmFzbjEucHJldHR5UHJpbnQgPSBmdW5jdGlvbihvYmosIGxldmVsLCBpbmRlbnRhdGlvbikge1xuICB2YXIgcnZhbCA9ICcnO1xuXG4gIC8vIHNldCBkZWZhdWx0IGxldmVsIGFuZCBpbmRlbnRhdGlvblxuICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gIGluZGVudGF0aW9uID0gaW5kZW50YXRpb24gfHwgMjtcblxuICAvLyBzdGFydCBuZXcgbGluZSBmb3IgZGVlcCBsZXZlbHNcbiAgaWYobGV2ZWwgPiAwKSB7XG4gICAgcnZhbCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpbmRlbnRcbiAgdmFyIGluZGVudCA9ICcnO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGV2ZWwgKiBpbmRlbnRhdGlvbjsgKytpKSB7XG4gICAgaW5kZW50ICs9ICcgJztcbiAgfVxuXG4gIC8vIHByaW50IGNsYXNzOnR5cGVcbiAgcnZhbCArPSBpbmRlbnQgKyAnVGFnOiAnO1xuICBzd2l0Y2gob2JqLnRhZ0NsYXNzKSB7XG4gIGNhc2UgYXNuMS5DbGFzcy5VTklWRVJTQUw6XG4gICAgcnZhbCArPSAnVW5pdmVyc2FsOic7XG4gICAgYnJlYWs7XG4gIGNhc2UgYXNuMS5DbGFzcy5BUFBMSUNBVElPTjpcbiAgICBydmFsICs9ICdBcHBsaWNhdGlvbjonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQzpcbiAgICBydmFsICs9ICdDb250ZXh0LVNwZWNpZmljOic7XG4gICAgYnJlYWs7XG4gIGNhc2UgYXNuMS5DbGFzcy5QUklWQVRFOlxuICAgIHJ2YWwgKz0gJ1ByaXZhdGU6JztcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmKG9iai50YWdDbGFzcyA9PT0gYXNuMS5DbGFzcy5VTklWRVJTQUwpIHtcbiAgICBydmFsICs9IG9iai50eXBlO1xuXG4gICAgLy8ga25vd24gdHlwZXNcbiAgICBzd2l0Y2gob2JqLnR5cGUpIHtcbiAgICBjYXNlIGFzbjEuVHlwZS5OT05FOlxuICAgICAgcnZhbCArPSAnIChOb25lKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CT09MRUFOOlxuICAgICAgcnZhbCArPSAnIChCb29sZWFuKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5JTlRFR0VSOlxuICAgICAgcnZhbCArPSAnIChJbnRlZ2VyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CSVRTVFJJTkc6XG4gICAgICBydmFsICs9ICcgKEJpdCBzdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9DVEVUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChPY3RldCBzdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk5VTEw6XG4gICAgICBydmFsICs9ICcgKE51bGwpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9ERVNDOlxuICAgICAgcnZhbCArPSAnIChPYmplY3QgRGVzY3JpcHRvciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRVhURVJOQUw6XG4gICAgICBydmFsICs9ICcgKEV4dGVybmFsIG9yIEluc3RhbmNlIG9mKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5SRUFMOlxuICAgICAgcnZhbCArPSAnIChSZWFsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5FTlVNRVJBVEVEOlxuICAgICAgcnZhbCArPSAnIChFbnVtZXJhdGVkKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5FTUJFRERFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW1iZWRkZWQgUERWKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5VVEY4OlxuICAgICAgcnZhbCArPSAnIChVVEY4KSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5ST0lEOlxuICAgICAgcnZhbCArPSAnIChSZWxhdGl2ZSBPYmplY3QgSWRlbnRpZmllciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VRVUVOQ0U6XG4gICAgICBydmFsICs9ICcgKFNlcXVlbmNlKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5TRVQ6XG4gICAgICBydmFsICs9ICcgKFNldCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChQcmludGFibGUgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5JQTVTdHJpbmc6XG4gICAgICBydmFsICs9ICcgKElBNVN0cmluZyAoQVNDSUkpKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5VVENUSU1FOlxuICAgICAgcnZhbCArPSAnIChVVEMgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FOlxuICAgICAgcnZhbCArPSAnIChHZW5lcmFsaXplZCB0aW1lKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CTVBTVFJJTkc6XG4gICAgICBydmFsICs9ICcgKEJNUCBTdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IG9iai50eXBlO1xuICB9XG5cbiAgcnZhbCArPSAnXFxuJztcbiAgcnZhbCArPSBpbmRlbnQgKyAnQ29uc3RydWN0ZWQ6ICcgKyBvYmouY29uc3RydWN0ZWQgKyAnXFxuJztcblxuICBpZihvYmouY29tcG9zZWQpIHtcbiAgICB2YXIgc3VidmFsdWVzID0gMDtcbiAgICB2YXIgc3ViID0gJyc7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VidmFsdWVzICs9IDE7XG4gICAgICAgIHN1YiArPSBhc24xLnByZXR0eVByaW50KG9iai52YWx1ZVtpXSwgbGV2ZWwgKyAxLCBpbmRlbnRhdGlvbik7XG4gICAgICAgIGlmKChpICsgMSkgPCBvYmoudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgc3ViICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBydmFsICs9IGluZGVudCArICdTdWIgdmFsdWVzOiAnICsgc3VidmFsdWVzICsgc3ViO1xuICB9IGVsc2Uge1xuICAgIHJ2YWwgKz0gaW5kZW50ICsgJ1ZhbHVlOiAnO1xuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuT0lEKSB7XG4gICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChvYmoudmFsdWUpO1xuICAgICAgcnZhbCArPSBvaWQ7XG4gICAgICBpZihmb3JnZS5wa2kgJiYgZm9yZ2UucGtpLm9pZHMpIHtcbiAgICAgICAgaWYob2lkIGluIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgnICsgZm9yZ2UucGtpLm9pZHNbb2lkXSArICcpICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydmFsICs9IGFzbjEuZGVyVG9JbnRlZ2VyKG9iai52YWx1ZSk7XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgLy8gVE9ETzogc2hpZnQgYml0cyBhcyBuZWVkZWQgdG8gZGlzcGxheSB3aXRob3V0IHBhZGRpbmdcbiAgICAgIGlmKG9iai52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSB1bnVzZWQgYml0cyBmaWVsZFxuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlLnNsaWNlKDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgKz0gJyhub25lKSc7XG4gICAgICB9XG4gICAgICAvLyBzaG93IHVudXNlZCBiaXQgY291bnRcbiAgICAgIGlmKG9iai52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB1bnVzZWQgPSBvYmoudmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYodW51c2VkID09IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKDEgdW51c2VkIGJpdCBzaG93biknO1xuICAgICAgICB9IGVsc2UgaWYodW51c2VkID4gMSkge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIHVudXNlZCArICcgdW51c2VkIGJpdHMgc2hvd24pJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgICBpZighX25vbkxhdGluUmVnZXgudGVzdChvYmoudmFsdWUpKSB7XG4gICAgICAgIHJ2YWwgKz0gJygnICsgb2JqLnZhbHVlICsgJykgJztcbiAgICAgIH1cbiAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ2YWwgKz0gZm9yZ2UudXRpbC5kZWNvZGVVdGY4KG9iai52YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgaWYoZS5tZXNzYWdlID09PSAnVVJJIG1hbGZvcm1lZCcpIHtcbiAgICAgICAgICBydmFsICs9XG4gICAgICAgICAgICAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZSkgKyAnIChtYWxmb3JtZWQgVVRGOCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5QUklOVEFCTEVTVFJJTkcgfHxcbiAgICAgIG9iai50eXBlID09PSBhc24xLlR5cGUuSUE1U3RyaW5nKSB7XG4gICAgICBydmFsICs9IG9iai52YWx1ZTtcbiAgICB9IGVsc2UgaWYoX25vbkxhdGluUmVnZXgudGVzdChvYmoudmFsdWUpKSB7XG4gICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYob2JqLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcnZhbCArPSAnW251bGxdJztcbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbCArPSBvYmoudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuIiwgIi8qKlxuICogQ2lwaGVyIGJhc2UgQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyByZWdpc3RlcmVkIGFsZ29yaXRobXNcbmZvcmdlLmNpcGhlci5hbGdvcml0aG1zID0gZm9yZ2UuY2lwaGVyLmFsZ29yaXRobXMgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNpcGhlciBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuXG4gKiBhbGdvcml0aG0gYW5kIGtleS4gVGhlIGFsZ29yaXRobSBtYXkgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcgdmFsdWUgZm9yIGFcbiAqIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBhbGdvcml0aG0gb3IgaXQgbWF5IGJlIGdpdmVuIGFzIGEgY2lwaGVyIGFsZ29yaXRobVxuICogQVBJIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlLCBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gYWxnb3JpdGhtIEFQSVxuICogICAgICAgICAgb2JqZWN0LlxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYVxuICogICAgICAgICAgYnl0ZSBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oYWxnb3JpdGhtLCBrZXkpIHtcbiAgdmFyIGFwaSA9IGFsZ29yaXRobTtcbiAgaWYodHlwZW9mIGFwaSA9PT0gJ3N0cmluZycpIHtcbiAgICBhcGkgPSBmb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtKGFwaSk7XG4gICAgaWYoYXBpKSB7XG4gICAgICBhcGkgPSBhcGkoKTtcbiAgICB9XG4gIH1cbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIC8vIGFzc3VtZSBibG9jayBjaXBoZXJcbiAgcmV0dXJuIG5ldyBmb3JnZS5jaXBoZXIuQmxvY2tDaXBoZXIoe1xuICAgIGFsZ29yaXRobTogYXBpLFxuICAgIGtleToga2V5LFxuICAgIGRlY3J5cHQ6IGZhbHNlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVjaXBoZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlblxuICogYWxnb3JpdGhtIGFuZCBrZXkuIFRoZSBhbGdvcml0aG0gbWF5IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHZhbHVlIGZvciBhXG4gKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWxnb3JpdGhtIG9yIGl0IG1heSBiZSBnaXZlbiBhcyBhIGNpcGhlciBhbGdvcml0aG1cbiAqIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSwgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFsZ29yaXRobSBBUElcbiAqICAgICAgICAgIG9iamVjdC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGFcbiAqICAgICAgICAgIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyID0gZnVuY3Rpb24oYWxnb3JpdGhtLCBrZXkpIHtcbiAgdmFyIGFwaSA9IGFsZ29yaXRobTtcbiAgaWYodHlwZW9mIGFwaSA9PT0gJ3N0cmluZycpIHtcbiAgICBhcGkgPSBmb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtKGFwaSk7XG4gICAgaWYoYXBpKSB7XG4gICAgICBhcGkgPSBhcGkoKTtcbiAgICB9XG4gIH1cbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIC8vIGFzc3VtZSBibG9jayBjaXBoZXJcbiAgcmV0dXJuIG5ldyBmb3JnZS5jaXBoZXIuQmxvY2tDaXBoZXIoe1xuICAgIGFsZ29yaXRobTogYXBpLFxuICAgIGtleToga2V5LFxuICAgIGRlY3J5cHQ6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBhbGdvcml0aG0gYnkgbmFtZS4gSWYgdGhlIG5hbWUgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCwgdGhlXG4gKiBhbGdvcml0aG0gQVBJIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gQVBJIG9iamVjdC5cbiAqL1xuZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgYWxnb3JpdGhtKSB7XG4gIG5hbWUgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zW25hbWVdID0gYWxnb3JpdGhtO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgcmVnaXN0ZXJlZCBhbGdvcml0aG0gYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICpcbiAqIEByZXR1cm4gdGhlIGFsZ29yaXRobSwgaWYgZm91bmQsIG51bGwgaWYgbm90LlxuICovXG5mb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBpZihuYW1lIGluIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zKSB7XG4gICAgcmV0dXJuIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zW25hbWVdO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIEJsb2NrQ2lwaGVyID0gZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICB0aGlzLm1vZGUgPSB0aGlzLmFsZ29yaXRobS5tb2RlO1xuICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMubW9kZS5ibG9ja1NpemU7XG4gIHRoaXMuX2ZpbmlzaCA9IGZhbHNlO1xuICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gIHRoaXMub3V0cHV0ID0gbnVsbDtcbiAgdGhpcy5fb3AgPSBvcHRpb25zLmRlY3J5cHQgPyB0aGlzLm1vZGUuZGVjcnlwdCA6IHRoaXMubW9kZS5lbmNyeXB0O1xuICB0aGlzLl9kZWNyeXB0ID0gb3B0aW9ucy5kZWNyeXB0O1xuICB0aGlzLmFsZ29yaXRobS5pbml0aWFsaXplKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLCB3aGljaGV2ZXJcbiAqIHdhcyBwcmV2aW91c2x5IGNvbmZpZ3VyZWQuXG4gKlxuICogRm9yIG5vbi1HQ00gbW9kZSwgdGhlIElWIG1heSBiZSBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXlcbiAqIG9mIGJ5dGVzLCBhIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuIElmIHRoZSBJViBpcyBpblxuICogYnl0ZXMsIHRoZW4gaXQgbXVzdCBiZSBOYiAoMTYpIGJ5dGVzIGluIGxlbmd0aC4gSWYgdGhlIElWIGlzIGdpdmVuIGluIGFzXG4gKiAzMi1iaXQgaW50ZWdlcnMsIHRoZW4gaXQgbXVzdCBiZSA0IGludGVnZXJzIGxvbmcuXG4gKlxuICogTm90ZTogYW4gSVYgaXMgbm90IHJlcXVpcmVkIG9yIHVzZWQgaW4gRUNCIG1vZGUuXG4gKlxuICogRm9yIEdDTS1tb2RlLCB0aGUgSVYgbXVzdCBiZSBnaXZlbiBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvclxuICogYSBieXRlIGJ1ZmZlci4gVGhlIG51bWJlciBvZiBieXRlcyBzaG91bGQgYmUgMTIgKDk2IGJpdHMpIGFzIHJlY29tbWVuZGVkXG4gKiBieSBOSVNUIFNQLTgwMC0zOEQgYnV0IGFub3RoZXIgbGVuZ3RoIG1heSBiZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZlxuICogICAgICAgICAgICBieXRlcywgbnVsbCB0byByZXVzZSB0aGUgbGFzdCBjaXBoZXJlZCBibG9jayBmcm9tIGEgcHJldmlvdXNcbiAqICAgICAgICAgICAgdXBkYXRlKCkgKHRoaXMgXCJyZXNpZHVlXCIgbWV0aG9kIGlzIGZvciBsZWdhY3kgc3VwcG9ydCBvbmx5KS5cbiAqICAgICAgICAgIGFkZGl0aW9uYWxEYXRhIGFkZGl0aW9uYWwgYXV0aGVudGljYXRpb24gZGF0YSBhcyBhIGJpbmFyeS1lbmNvZGVkXG4gKiAgICAgICAgICAgIHN0cmluZyBvZiBieXRlcywgZm9yICdHQ00nIG1vZGUsIChkZWZhdWx0OiBub25lKS5cbiAqICAgICAgICAgIHRhZ0xlbmd0aCBkZXNpcmVkIGxlbmd0aCBvZiBhdXRoZW50aWNhdGlvbiB0YWcsIGluIGJpdHMsIGZvclxuICogICAgICAgICAgICAnR0NNJyBtb2RlICgwLTEyOCwgZGVmYXVsdDogMTI4KS5cbiAqICAgICAgICAgIHRhZyB0aGUgYXV0aGVudGljYXRpb24gdGFnIHRvIGNoZWNrIGlmIGRlY3J5cHRpbmcsIGFzIGFcbiAqICAgICAgICAgICAgIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqL1xuQmxvY2tDaXBoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG9wdHMgPSB7fTtcbiAgZm9yKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgIG9wdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuICBvcHRzLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLm91dHB1dCA9IG9wdGlvbnMub3V0cHV0IHx8IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMubW9kZS5zdGFydChvcHRzKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgbmV4dCBibG9jayBhY2NvcmRpbmcgdG8gdGhlIGNpcGhlciBtb2RlLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAqL1xuQmxvY2tDaXBoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmKGlucHV0KSB7XG4gICAgLy8gaW5wdXQgZ2l2ZW4sIHNvIGVtcHR5IGl0IGludG8gdGhlIGlucHV0IGJ1ZmZlclxuICAgIHRoaXMuX2lucHV0LnB1dEJ1ZmZlcihpbnB1dCk7XG4gIH1cblxuICAvLyBkbyBjaXBoZXIgb3BlcmF0aW9uIHVudGlsIGl0IG5lZWRzIG1vcmUgaW5wdXQgYW5kIG5vdCBmaW5pc2hlZFxuICB3aGlsZSghdGhpcy5fb3AuY2FsbCh0aGlzLm1vZGUsIHRoaXMuX2lucHV0LCB0aGlzLm91dHB1dCwgdGhpcy5fZmluaXNoKSAmJlxuICAgICF0aGlzLl9maW5pc2gpIHt9XG5cbiAgLy8gZnJlZSBjb25zdW1lZCBtZW1vcnkgZnJvbSBpbnB1dCBidWZmZXJcbiAgdGhpcy5faW5wdXQuY29tcGFjdCgpO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyBlbmNyeXB0aW5nIG9yIGRlY3J5cHRpbmcuXG4gKlxuICogQHBhcmFtIHBhZCBhIHBhZGRpbmcgZnVuY3Rpb24gdG8gdXNlIGluIENCQyBtb2RlLCBudWxsIGZvciBkZWZhdWx0LFxuICogICAgICAgICAgc2lnbmF0dXJlKGJsb2NrU2l6ZSwgYnVmZmVyLCBkZWNyeXB0KS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb24gZXJyb3IuXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihwYWQpIHtcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgdy9kZXByZWNhdGVkIHBhZGRpbmcgQVBJXG4gIC8vIE5vdGU6IHdpbGwgb3ZlcndyaXRlIHBhZGRpbmcgZnVuY3Rpb25zIGV2ZW4gYWZ0ZXIgYW5vdGhlciBzdGFydCgpIGNhbGxcbiAgaWYocGFkICYmICh0aGlzLm1vZGUubmFtZSA9PT0gJ0VDQicgfHwgdGhpcy5tb2RlLm5hbWUgPT09ICdDQkMnKSkge1xuICAgIHRoaXMubW9kZS5wYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIHBhZCh0aGlzLmJsb2NrU2l6ZSwgaW5wdXQsIGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMubW9kZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgcmV0dXJuIHBhZCh0aGlzLmJsb2NrU2l6ZSwgb3V0cHV0LCB0cnVlKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gYnVpbGQgb3B0aW9ucyBmb3IgcGFkZGluZyBhbmQgYWZ0ZXJGaW5pc2ggZnVuY3Rpb25zXG4gIHZhciBvcHRpb25zID0ge307XG4gIG9wdGlvbnMuZGVjcnlwdCA9IHRoaXMuX2RlY3J5cHQ7XG5cbiAgLy8gZ2V0ICMgb2YgYnl0ZXMgdGhhdCB3b24ndCBmaWxsIGEgYmxvY2tcbiAgb3B0aW9ucy5vdmVyZmxvdyA9IHRoaXMuX2lucHV0Lmxlbmd0aCgpICUgdGhpcy5ibG9ja1NpemU7XG5cbiAgaWYoIXRoaXMuX2RlY3J5cHQgJiYgdGhpcy5tb2RlLnBhZCkge1xuICAgIGlmKCF0aGlzLm1vZGUucGFkKHRoaXMuX2lucHV0LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRvIGZpbmFsIHVwZGF0ZVxuICB0aGlzLl9maW5pc2ggPSB0cnVlO1xuICB0aGlzLnVwZGF0ZSgpO1xuXG4gIGlmKHRoaXMuX2RlY3J5cHQgJiYgdGhpcy5tb2RlLnVucGFkKSB7XG4gICAgaWYoIXRoaXMubW9kZS51bnBhZCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZih0aGlzLm1vZGUuYWZ0ZXJGaW5pc2gpIHtcbiAgICBpZighdGhpcy5tb2RlLmFmdGVyRmluaXNoKHRoaXMub3V0cHV0LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsICIvKipcbiAqIFN1cHBvcnRlZCBjaXBoZXIgbW9kZXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyBzdXBwb3J0ZWQgY2lwaGVyIG1vZGVzXG52YXIgbW9kZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlci5tb2RlcyA9IGZvcmdlLmNpcGhlci5tb2RlcyB8fCB7fTtcblxuLyoqIEVsZWN0cm9uaWMgY29kZWJvb2sgKEVDQikgKERvbid0IHVzZSB0aGlzOyBpdCdzIG5vdCBzZWN1cmUpICoqL1xuXG5tb2Rlcy5lY2IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnRUNCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge307XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gIHZhciBwYWRkaW5nID0gKGlucHV0Lmxlbmd0aCgpID09PSB0aGlzLmJsb2NrU2l6ZSA/XG4gICAgdGhpcy5ibG9ja1NpemUgOiAodGhpcy5ibG9ja1NpemUgLSBpbnB1dC5sZW5ndGgoKSkpO1xuICBpbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2tTaXplXG4gIGlmKG9wdGlvbnMub3ZlcmZsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICB2YXIgbGVuID0gb3V0cHV0Lmxlbmd0aCgpO1xuICB2YXIgY291bnQgPSBvdXRwdXQuYXQobGVuIC0gMSk7XG4gIGlmKGNvdW50ID4gKHRoaXMuYmxvY2tTaXplIDw8IDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICBvdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKiBDaXBoZXItYmxvY2sgQ2hhaW5pbmcgKENCQykgKiovXG5cbm1vZGVzLmNiYyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDQkMnO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE5vdGU6IGxlZ2FjeSBzdXBwb3J0IGZvciB1c2luZyBJViByZXNpZHVlIChoYXMgc2VjdXJpdHkgZmxhd3MpXG4gIC8vIGlmIElWIGlzIG51bGwsIHJldXNlIGJsb2NrIGZyb20gcHJldmlvdXMgcHJvY2Vzc2luZ1xuICBpZihvcHRpb25zLml2ID09PSBudWxsKSB7XG4gICAgLy8gbXVzdCBoYXZlIGEgcHJldmlvdXMgYmxvY2tcbiAgICBpZighdGhpcy5fcHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5faXYgPSB0aGlzLl9wcmV2LnNsaWNlKDApO1xuICB9IGVsc2UgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYXZlIElWIGFzIFwicHJldmlvdXNcIiBibG9ja1xuICAgIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdiwgdGhpcy5ibG9ja1NpemUpO1xuICAgIHRoaXMuX3ByZXYgPSB0aGlzLl9pdi5zbGljZSgwKTtcbiAgfVxufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIC8vIENCQyBYT1IncyBJViAob3IgcHJldmlvdXMgYmxvY2spIHdpdGggcGxhaW50ZXh0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcHJldltpXSBeIGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dCwgc2F2ZSBwcmV2aW91cyBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxuICB0aGlzLl9wcmV2ID0gdGhpcy5fb3V0QmxvY2s7XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB9XG5cbiAgLy8gZGVjcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5kZWNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyB3cml0ZSBvdXRwdXQsIHNhdmUgcHJldmlvdXMgY2lwaGVyZWQgYmxvY2tcbiAgLy8gQ0JDIFhPUidzIElWIChvciBwcmV2aW91cyBibG9jaykgd2l0aCBjaXBoZXJ0ZXh0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fcHJldltpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxuICB0aGlzLl9wcmV2ID0gdGhpcy5faW5CbG9jay5zbGljZSgwKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUucGFkID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gYWRkIFBLQ1MjNyBwYWRkaW5nIHRvIGJsb2NrIChlYWNoIHBhZCBieXRlIGlzIHRoZVxuICAvLyB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHBhZCBieXRlcylcbiAgdmFyIHBhZGRpbmcgPSAoaW5wdXQubGVuZ3RoKCkgPT09IHRoaXMuYmxvY2tTaXplID9cbiAgICB0aGlzLmJsb2NrU2l6ZSA6ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0Lmxlbmd0aCgpKSk7XG4gIGlucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nLCBwYWRkaW5nKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLnVucGFkID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIC8vIGNoZWNrIGZvciBlcnJvcjogaW5wdXQgZGF0YSBub3QgYSBtdWx0aXBsZSBvZiBibG9ja1NpemVcbiAgaWYob3B0aW9ucy5vdmVyZmxvdyA+IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBlbnN1cmUgcGFkZGluZyBieXRlIGNvdW50IGlzIHZhbGlkXG4gIHZhciBsZW4gPSBvdXRwdXQubGVuZ3RoKCk7XG4gIHZhciBjb3VudCA9IG91dHB1dC5hdChsZW4gLSAxKTtcbiAgaWYoY291bnQgPiAodGhpcy5ibG9ja1NpemUgPDwgMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB0cmltIG9mZiBwYWRkaW5nIGJ5dGVzXG4gIG91dHB1dC50cnVuY2F0ZShjb3VudCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqIENpcGhlciBmZWVkYmFjayAoQ0ZCKSAqKi9cblxubW9kZXMuY2ZiID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0NGQic7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBudWxsO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fcGFydGlhbEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLmNmYi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gdXNlIElWIGFzIGZpcnN0IGlucHV0XG4gIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdiwgdGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl9pbkJsb2NrID0gdGhpcy5faXYuc2xpY2UoMCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5jZmIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV07XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwYXJ0aWFsIGJsb2NrXG4gIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICB9XG5cbiAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBwYXJ0aWFsIG91dHB1dFxuICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV07XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxCbG9ja1tpXTtcbiAgICB9XG4gIH1cblxuICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA+IDApIHtcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwICYmICFmaW5pc2gpIHtcbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IHBhcnRpYWxCeXRlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5jZmIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9jayAoQ0ZCIGFsd2F5cyB1c2VzIGVuY3J5cHRpb24gbW9kZSlcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9pbkJsb2NrW2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgcGFydGlhbCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKHRoaXMuX3BhcnRpYWxCbG9ja1tpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsQmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxuLyoqIE91dHB1dCBmZWVkYmFjayAoT0ZCKSAqKi9cblxubW9kZXMub2ZiID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ09GQic7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBudWxsO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fcGFydGlhbE91dHB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5vZmIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZighKCdpdicgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVYgcGFyYW1ldGVyLicpO1xuICB9XG4gIC8vIHVzZSBJViBhcyBmaXJzdCBpbnB1dFxuICB0aGlzLl9pdiA9IHRyYW5zZm9ybUlWKG9wdGlvbnMuaXYsIHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKE9GQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCBhbmQgdXBkYXRlIG5leHQgaW5wdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX291dEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIENvdW50ZXIgKENUUikgKiovXG5cbm1vZGVzLmN0ciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDVFInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2LCB0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9pdi5zbGljZSgwKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLmN0ci5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gIGlmKGlucHV0TGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrIChDVFIgYWx3YXlzIHVzZXMgZW5jcnlwdGlvbiBtb2RlKVxuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gICAgfVxuXG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG5cbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gICAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG4gIH1cblxuICAvLyBibG9jayBjb21wbGV0ZSwgaW5jcmVtZW50IGNvdW50ZXIgKGlucHV0IGJsb2NrKVxuICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcbn07XG5cbm1vZGVzLmN0ci5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLmN0ci5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIEdhbG9pcy9Db3VudGVyIE1vZGUgKEdDTSkgKiovXG5cbm1vZGVzLmdjbSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdHQ00nO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fcGFydGlhbE91dHB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG5cbiAgLy8gUiBpcyBhY3R1YWxseSB0aGlzIHZhbHVlIGNvbmNhdGVuYXRlZCB3aXRoIDEyMCBtb3JlIHplcm8gYml0cywgYnV0XG4gIC8vIHdlIG9ubHkgWE9SIGFnYWluc3QgUiBzbyB0aGUgb3RoZXIgemVyb3MgaGF2ZSBubyBlZmZlY3QgLS0gd2UganVzdFxuICAvLyBhcHBseSB0aGlzIHZhbHVlIHRvIHRoZSBmaXJzdCBpbnRlZ2VyIGluIGEgYmxvY2tcbiAgdGhpcy5fUiA9IDB4RTEwMDAwMDA7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZighKCdpdicgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVYgcGFyYW1ldGVyLicpO1xuICB9XG4gIC8vIGVuc3VyZSBJViBpcyBhIGJ5dGUgYnVmZmVyXG4gIHZhciBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMuaXYpO1xuXG4gIC8vIG5vIGNpcGhlcmVkIGRhdGEgcHJvY2Vzc2VkIHlldFxuICB0aGlzLl9jaXBoZXJMZW5ndGggPSAwO1xuXG4gIC8vIGRlZmF1bHQgYWRkaXRpb25hbCBkYXRhIGlzIG5vbmVcbiAgdmFyIGFkZGl0aW9uYWxEYXRhO1xuICBpZignYWRkaXRpb25hbERhdGEnIGluIG9wdGlvbnMpIHtcbiAgICBhZGRpdGlvbmFsRGF0YSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMuYWRkaXRpb25hbERhdGEpO1xuICB9IGVsc2Uge1xuICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdGFnIGxlbmd0aCBpcyAxMjggYml0c1xuICBpZigndGFnTGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fdGFnTGVuZ3RoID0gb3B0aW9ucy50YWdMZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdGFnTGVuZ3RoID0gMTI4O1xuICB9XG5cbiAgLy8gaWYgdGFnIGlzIGdpdmVuLCBlbnN1cmUgdGFnIG1hdGNoZXMgdGFnIGxlbmd0aFxuICB0aGlzLl90YWcgPSBudWxsO1xuICBpZihvcHRpb25zLmRlY3J5cHQpIHtcbiAgICAvLyBzYXZlIHRhZyB0byBjaGVjayBsYXRlclxuICAgIHRoaXMuX3RhZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMudGFnKS5nZXRCeXRlcygpO1xuICAgIGlmKHRoaXMuX3RhZy5sZW5ndGggIT09ICh0aGlzLl90YWdMZW5ndGggLyA4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiB0YWcgZG9lcyBub3QgbWF0Y2ggdGFnIGxlbmd0aC4nKTtcbiAgICB9XG4gIH1cblxuICAvLyBjcmVhdGUgdG1wIHN0b3JhZ2UgZm9yIGhhc2ggY2FsY3VsYXRpb25cbiAgdGhpcy5faGFzaEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuXG4gIC8vIG5vIHRhZyBnZW5lcmF0ZWQgeWV0XG4gIHRoaXMudGFnID0gbnVsbDtcblxuICAvLyBnZW5lcmF0ZSBoYXNoIHN1YmtleVxuICAvLyAoYXBwbHkgYmxvY2sgY2lwaGVyIHRvIFwiemVyb1wiIGJsb2NrKVxuICB0aGlzLl9oYXNoU3Via2V5ID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KFswLCAwLCAwLCAwXSwgdGhpcy5faGFzaFN1YmtleSk7XG5cbiAgLy8gZ2VuZXJhdGUgdGFibGUgTVxuICAvLyB1c2UgNC1iaXQgdGFibGVzICgzMiBjb21wb25lbnQgZGVjb21wb3NpdGlvbiBvZiBhIDE2IGJ5dGUgdmFsdWUpXG4gIC8vIDgtYml0IHRhYmxlcyB0YWtlIG1vcmUgc3BhY2UgYW5kIGFyZSBrbm93biB0byBoYXZlIHNlY3VyaXR5XG4gIC8vIHZ1bG5lcmFiaWxpdGllcyAoaW4gbmF0aXZlIGltcGxlbWVudGF0aW9ucylcbiAgdGhpcy5jb21wb25lbnRCaXRzID0gNDtcbiAgdGhpcy5fbSA9IHRoaXMuZ2VuZXJhdGVIYXNoVGFibGUodGhpcy5faGFzaFN1YmtleSwgdGhpcy5jb21wb25lbnRCaXRzKTtcblxuICAvLyBOb3RlOiBzdXBwb3J0IElWIGxlbmd0aCBkaWZmZXJlbnQgZnJvbSA5NiBiaXRzPyAob25seSBzdXBwb3J0aW5nXG4gIC8vIDk2IGJpdHMgaXMgcmVjb21tZW5kZWQgYnkgTklTVCBTUC04MDAtMzhEKVxuICAvLyBnZW5lcmF0ZSBKXzBcbiAgdmFyIGl2TGVuZ3RoID0gaXYubGVuZ3RoKCk7XG4gIGlmKGl2TGVuZ3RoID09PSAxMikge1xuICAgIC8vIDk2LWJpdCBJVlxuICAgIHRoaXMuX2owID0gW2l2LmdldEludDMyKCksIGl2LmdldEludDMyKCksIGl2LmdldEludDMyKCksIDFdO1xuICB9IGVsc2Uge1xuICAgIC8vIElWIGlzIE5PVCA5Ni1iaXRzXG4gICAgdGhpcy5fajAgPSBbMCwgMCwgMCwgMF07XG4gICAgd2hpbGUoaXYubGVuZ3RoKCkgPiAwKSB7XG4gICAgICB0aGlzLl9qMCA9IHRoaXMuZ2hhc2goXG4gICAgICAgIHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX2owLFxuICAgICAgICBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKV0pO1xuICAgIH1cbiAgICB0aGlzLl9qMCA9IHRoaXMuZ2hhc2goXG4gICAgICB0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9qMCwgWzAsIDBdLmNvbmNhdChmcm9tNjRUbzMyKGl2TGVuZ3RoICogOCkpKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIElDQiAoaW5pdGlhbCBjb3VudGVyIGJsb2NrKVxuICB0aGlzLl9pbkJsb2NrID0gdGhpcy5fajAuc2xpY2UoMCk7XG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuXG4gIC8vIGNvbnN1bWUgYXV0aGVudGljYXRpb24gZGF0YVxuICBhZGRpdGlvbmFsRGF0YSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGFkZGl0aW9uYWxEYXRhKTtcbiAgLy8gc2F2ZSBhZGRpdGlvbmFsIGRhdGEgbGVuZ3RoIGFzIGEgQkUgNjQtYml0IG51bWJlclxuICB0aGlzLl9hRGF0YUxlbmd0aCA9IGZyb202NFRvMzIoYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgKiA4KTtcbiAgLy8gcGFkIGFkZGl0aW9uYWwgZGF0YSB0byAxMjggYml0ICgxNiBieXRlKSBibG9jayBzaXplXG4gIHZhciBvdmVyZmxvdyA9IGFkZGl0aW9uYWxEYXRhLmxlbmd0aCgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKG92ZXJmbG93KSB7XG4gICAgYWRkaXRpb25hbERhdGEuZmlsbFdpdGhCeXRlKDAsIHRoaXMuYmxvY2tTaXplIC0gb3ZlcmZsb3cpO1xuICB9XG4gIHRoaXMuX3MgPSBbMCwgMCwgMCwgMF07XG4gIHdoaWxlKGFkZGl0aW9uYWxEYXRhLmxlbmd0aCgpID4gMCkge1xuICAgIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIFtcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKClcbiAgICBdKTtcbiAgfVxufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldIF49IGlucHV0LmdldEludDMyKCkpO1xuICAgIH1cbiAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gICAgfVxuXG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG5cbiAgICBpZihwYXJ0aWFsQnl0ZXMgPD0gMCB8fCBmaW5pc2gpIHtcbiAgICAgIC8vIGhhbmRsZSBvdmVyZmxvdyBwcmlvciB0byBoYXNoaW5nXG4gICAgICBpZihmaW5pc2gpIHtcbiAgICAgICAgLy8gZ2V0IGJsb2NrIG92ZXJmbG93XG4gICAgICAgIHZhciBvdmVyZmxvdyA9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSBvdmVyZmxvdztcbiAgICAgICAgLy8gdHJ1bmNhdGUgZm9yIGhhc2ggZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZSAtIG92ZXJmbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IG91dHB1dCBibG9jayBmb3IgaGFzaGluZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9vdXRCbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0SW50MzIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gICAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXIsIGdldCBwYXJ0aWFsIG91dHB1dCxcbiAgICAgIC8vIGFuZCByZXR1cm4gZWFybHlcbiAgICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBoYXNoIGJsb2NrIFNcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0TGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKEdDTSBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG5cbiAgLy8gdXBkYXRlIGhhc2ggYmxvY2sgU1xuICB0aGlzLl9oYXNoQmxvY2tbMF0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMl0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbM10gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCB0aGlzLl9oYXNoQmxvY2spO1xuXG4gIC8vIFhPUiBoYXNoIGlucHV0IHdpdGggb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXiB0aGlzLl9oYXNoQmxvY2tbaV0pO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IGNpcGhlciBkYXRhIGxlbmd0aFxuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmFmdGVyRmluaXNoID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIHZhciBydmFsID0gdHJ1ZTtcblxuICAvLyBoYW5kbGUgb3ZlcmZsb3dcbiAgaWYob3B0aW9ucy5kZWNyeXB0ICYmIG9wdGlvbnMub3ZlcmZsb3cpIHtcbiAgICBvdXRwdXQudHJ1bmNhdGUodGhpcy5ibG9ja1NpemUgLSBvcHRpb25zLm92ZXJmbG93KTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBhdXRoZW50aWNhdGlvbiB0YWdcbiAgdGhpcy50YWcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGNvbmNhdGVuYXRlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggd2l0aCBjaXBoZXIgbGVuZ3RoXG4gIHZhciBsZW5ndGhzID0gdGhpcy5fYURhdGFMZW5ndGguY29uY2F0KGZyb202NFRvMzIodGhpcy5fY2lwaGVyTGVuZ3RoICogOCkpO1xuXG4gIC8vIGluY2x1ZGUgbGVuZ3RocyBpbiBoYXNoXG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIGxlbmd0aHMpO1xuXG4gIC8vIGRvIEdDVFIoSl8wLCBTKVxuICB2YXIgdGFnID0gW107XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5fajAsIHRhZyk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLnRhZy5wdXRJbnQzMih0aGlzLl9zW2ldIF4gdGFnW2ldKTtcbiAgfVxuXG4gIC8vIHRyaW0gdGFnIHRvIGxlbmd0aFxuICB0aGlzLnRhZy50cnVuY2F0ZSh0aGlzLnRhZy5sZW5ndGgoKSAlICh0aGlzLl90YWdMZW5ndGggLyA4KSk7XG5cbiAgLy8gY2hlY2sgYXV0aGVudGljYXRpb24gdGFnXG4gIGlmKG9wdGlvbnMuZGVjcnlwdCAmJiB0aGlzLnRhZy5ieXRlcygpICE9PSB0aGlzLl90YWcpIHtcbiAgICBydmFsID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU2VlIE5JU1QgU1AtODAwLTM4RCA2LjMgKEFsZ29yaXRobSAxKS4gVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBHYWxvaXNcbiAqIGZpZWxkIG11bHRpcGxpY2F0aW9uLiBUaGUgZmllbGQsIEdGKDJeMTI4KSwgaXMgZGVmaW5lZCBieSB0aGUgcG9seW5vbWlhbDpcbiAqXG4gKiB4XjEyOCArIHheNyArIHheMiArIHggKyAxXG4gKlxuICogV2hpY2ggaXMgcmVwcmVzZW50ZWQgaW4gbGl0dGxlLWVuZGlhbiBiaW5hcnkgZm9ybSBhczogMTExMDAwMDEgKDB4ZTEpLiBXaGVuXG4gKiB0aGUgdmFsdWUgb2YgYSBjb2VmZmljaWVudCBpcyAxLCBhIGJpdCBpcyBzZXQuIFRoZSB2YWx1ZSBSLCBpcyB0aGVcbiAqIGNvbmNhdGVuYXRpb24gb2YgdGhpcyB2YWx1ZSBhbmQgMTIwIHplcm8gYml0cywgeWllbGRpbmcgYSAxMjgtYml0IHZhbHVlXG4gKiB3aGljaCBtYXRjaGVzIHRoZSBibG9jayBzaXplLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtdWx0aXBseSB0d28gZWxlbWVudHMgKHZlY3RvcnMgb2YgYnl0ZXMpLCBYIGFuZCBZLCBpblxuICogdGhlIGZpZWxkIEdGKDJeMTI4KS4gVGhlIHJlc3VsdCBpcyBpbml0aWFsaXplZCB0byB6ZXJvLiBGb3IgZWFjaCBiaXQgb2ZcbiAqIFggKG91dCBvZiAxMjgpLCB4X2ksIGlmIHhfaSBpcyBzZXQsIHRoZW4gdGhlIHJlc3VsdCBpcyBtdWx0aXBsaWVkIChYT1InZClcbiAqIGJ5IHRoZSBjdXJyZW50IHZhbHVlIG9mIFkuIEZvciBlYWNoIGJpdCwgdGhlIHZhbHVlIG9mIFkgd2lsbCBiZSByYWlzZWQgYnlcbiAqIGEgcG93ZXIgb2YgeCAobXVsdGlwbGllZCBieSB0aGUgcG9seW5vbWlhbCB4KS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnlcbiAqIHNoaWZ0aW5nIFkgb25jZSB0byB0aGUgcmlnaHQuIElmIHRoZSBjdXJyZW50IHZhbHVlIG9mIFksIHByaW9yIHRvIGJlaW5nXG4gKiBtdWx0aXBsaWVkIGJ5IHgsIGhhcyAwIGFzIGl0cyBMU0IsIHRoZW4gaXQgaXMgYSAxMjd0aCBkZWdyZWUgcG9seW5vbWlhbC5cbiAqIE90aGVyd2lzZSwgd2UgbXVzdCBkaXZpZGUgYnkgUiBhZnRlciBzaGlmdGluZyB0byBmaW5kIHRoZSByZW1haW5kZXIuXG4gKlxuICogQHBhcmFtIHggdGhlIGZpcnN0IGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBzZWNvbmQuXG4gKiBAcGFyYW0geSB0aGUgc2Vjb25kIGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBmaXJzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBibG9jayByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgel9pID0gWzAsIDAsIDAsIDBdO1xuICB2YXIgdl9pID0geS5zbGljZSgwKTtcblxuICAvLyBjYWxjdWxhdGUgWl8xMjggKGJsb2NrIGhhcyAxMjggYml0cylcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgLy8gaWYgeF9pIGlzIDAsIFpfe2krMX0gPSBaX2kgKHVuY2hhbmdlZClcbiAgICAvLyBlbHNlIFpfe2krMX0gPSBaX2kgXiBWX2lcbiAgICAvLyBnZXQgeF9pIGJ5IGZpbmRpbmcgMzItYml0IGludCBwb3NpdGlvbiwgdGhlbiBsZWZ0IHNoaWZ0IDEgYnkgcmVtYWluZGVyXG4gICAgdmFyIHhfaSA9IHhbKGkgLyAzMikgfCAwXSAmICgxIDw8ICgzMSAtIGkgJSAzMikpO1xuICAgIGlmKHhfaSkge1xuICAgICAgel9pWzBdIF49IHZfaVswXTtcbiAgICAgIHpfaVsxXSBePSB2X2lbMV07XG4gICAgICB6X2lbMl0gXj0gdl9pWzJdO1xuICAgICAgel9pWzNdIF49IHZfaVszXTtcbiAgICB9XG5cbiAgICAvLyBpZiBMU0IoVl9pKSBpcyAxLCBWX2kgPSBWX2kgPj4gMVxuICAgIC8vIGVsc2UgVl9pID0gKFZfaSA+PiAxKSBeIFJcbiAgICB0aGlzLnBvdyh2X2ksIHZfaSk7XG4gIH1cblxuICByZXR1cm4gel9pO1xufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbih4LCBvdXQpIHtcbiAgLy8gaWYgTFNCKHgpIGlzIDEsIHggPSB4ID4+PiAxXG4gIC8vIGVsc2UgeCA9ICh4ID4+PiAxKSBeIFJcbiAgdmFyIGxzYiA9IHhbM10gJiAxO1xuXG4gIC8vIGFsd2F5cyBkbyB4ID4+PiAxOlxuICAvLyBzdGFydGluZyB3aXRoIHRoZSByaWdodG1vc3QgaW50ZWdlciwgc2hpZnQgZWFjaCBpbnRlZ2VyIHRvIHRoZSByaWdodFxuICAvLyBvbmUgYml0LCBwdWxsaW5nIGluIHRoZSBiaXQgZnJvbSB0aGUgaW50ZWdlciB0byB0aGUgbGVmdCBhcyBpdHMgdG9wXG4gIC8vIG1vc3QgYml0IChkbyB0aGlzIGZvciB0aGUgbGFzdCAzIGludGVnZXJzKVxuICBmb3IodmFyIGkgPSAzOyBpID4gMDsgLS1pKSB7XG4gICAgb3V0W2ldID0gKHhbaV0gPj4+IDEpIHwgKCh4W2kgLSAxXSAmIDEpIDw8IDMxKTtcbiAgfVxuICAvLyBzaGlmdCB0aGUgZmlyc3QgaW50ZWdlciBub3JtYWxseVxuICBvdXRbMF0gPSB4WzBdID4+PiAxO1xuXG4gIC8vIGlmIGxzYiB3YXMgbm90IHNldCwgdGhlbiBwb2x5bm9taWFsIGhhZCBhIGRlZ3JlZSBvZiAxMjcgYW5kIGRvZXNuJ3RcbiAgLy8gbmVlZCB0byBkaXZpZGVkOyBvdGhlcndpc2UsIFhPUiB3aXRoIFIgdG8gZmluZCB0aGUgcmVtYWluZGVyOyB3ZSBvbmx5XG4gIC8vIG5lZWQgdG8gWE9SIHRoZSBmaXJzdCBpbnRlZ2VyIHNpbmNlIFIgdGVjaG5pY2FsbHkgZW5kcyB3LzEyMCB6ZXJvIGJpdHNcbiAgaWYobHNiKSB7XG4gICAgb3V0WzBdIF49IHRoaXMuX1I7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUudGFibGVNdWx0aXBseSA9IGZ1bmN0aW9uKHgpIHtcbiAgLy8gYXNzdW1lcyA0LWJpdCB0YWJsZXMgYXJlIHVzZWRcbiAgdmFyIHogPSBbMCwgMCwgMCwgMF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChpIC8gOCkgfCAwO1xuICAgIHZhciB4X2kgPSAoeFtpZHhdID4+PiAoKDcgLSAoaSAlIDgpKSAqIDQpKSAmIDB4RjtcbiAgICB2YXIgYWggPSB0aGlzLl9tW2ldW3hfaV07XG4gICAgelswXSBePSBhaFswXTtcbiAgICB6WzFdIF49IGFoWzFdO1xuICAgIHpbMl0gXj0gYWhbMl07XG4gICAgelszXSBePSBhaFszXTtcbiAgfVxuICByZXR1cm4gejtcbn07XG5cbi8qKlxuICogQSBjb250aW51aW5nIHZlcnNpb24gb2YgdGhlIEdIQVNIIGFsZ29yaXRobSB0aGF0IG9wZXJhdGVzIG9uIGEgc2luZ2xlXG4gKiBibG9jay4gVGhlIGhhc2ggYmxvY2ssIGxhc3QgaGFzaCB2YWx1ZSAoWW0pIGFuZCB0aGUgbmV3IGJsb2NrIHRvIGhhc2hcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBibG9jay5cbiAqIEBwYXJhbSB5IHRoZSBwcmV2aW91cyB2YWx1ZSBmb3IgWW0sIHVzZSBbMCwgMCwgMCwgMF0gZm9yIGEgbmV3IGhhc2guXG4gKiBAcGFyYW0geCB0aGUgYmxvY2sgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBoYXNoZWQgdmFsdWUgKFltKS5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uKGgsIHksIHgpIHtcbiAgeVswXSBePSB4WzBdO1xuICB5WzFdIF49IHhbMV07XG4gIHlbMl0gXj0geFsyXTtcbiAgeVszXSBePSB4WzNdO1xuICByZXR1cm4gdGhpcy50YWJsZU11bHRpcGx5KHkpO1xuICAvL3JldHVybiB0aGlzLm11bHRpcGx5KHksIGgpO1xufTtcblxuLyoqXG4gKiBQcmVjb21wdXRlcyBhIHRhYmxlIGZvciBtdWx0aXBseWluZyBhZ2FpbnN0IHRoZSBoYXNoIHN1YmtleS4gVGhpc1xuICogbWVjaGFuaXNtIHByb3ZpZGVzIGEgc3Vic3RhbnRpYWwgc3BlZWQgaW5jcmVhc2Ugb3ZlciBtdWx0aXBsaWNhdGlvblxuICogcGVyZm9ybWVkIHdpdGhvdXQgYSB0YWJsZS4gVGhlIHRhYmxlLWJhc2VkIG11bHRpcGxpY2F0aW9uIHRoaXMgdGFibGUgaXNcbiAqIGZvciBzb2x2ZXMgWCAqIEggYnkgbXVsdGlwbHlpbmcgZWFjaCBjb21wb25lbnQgb2YgWCBieSBIIGFuZCB0aGVuXG4gKiBjb21wb3NpbmcgdGhlIHJlc3VsdHMgdG9nZXRoZXIgdXNpbmcgWE9SLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGFibGVzIHdpdGggZGlmZmVyZW50IGJpdCBzaXplc1xuICogZm9yIHRoZSBjb21wb25lbnRzLCBob3dldmVyLCB0aGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhlcmUgYXJlXG4gKiAzMiBjb21wb25lbnRzIG9mIFggKHdoaWNoIGlzIGEgMTYgYnl0ZSB2ZWN0b3IpLCB0aGVyZWZvcmUgZWFjaCBjb21wb25lbnRcbiAqIHRha2VzIDQtYml0cyAoc28gdGhlIHRhYmxlIGlzIGNvbnN0cnVjdGVkIHdpdGggYml0cz00KS5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBzdWJrZXkuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlSGFzaFRhYmxlID0gZnVuY3Rpb24oaCwgYml0cykge1xuICAvLyBUT0RPOiBUaGVyZSBhcmUgZnVydGhlciBvcHRpbWl6YXRpb25zIHRoYXQgd291bGQgdXNlIG9ubHkgdGhlXG4gIC8vIGZpcnN0IHRhYmxlIE1fMCAob3Igc29tZSB2YXJpYW50KSBhbG9uZyB3aXRoIGEgcmVtYWluZGVyIHRhYmxlO1xuICAvLyB0aGlzIGNhbiBiZSBleHBsb3JlZCBpbiB0aGUgZnV0dXJlXG4gIHZhciBtdWx0aXBsaWVyID0gOCAvIGJpdHM7XG4gIHZhciBwZXJJbnQgPSA0ICogbXVsdGlwbGllcjtcbiAgdmFyIHNpemUgPSAxNiAqIG11bHRpcGxpZXI7XG4gIHZhciBtID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgdmFyIHRtcCA9IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgaWR4ID0gKGkgLyBwZXJJbnQpIHwgMDtcbiAgICB2YXIgc2hmdCA9ICgocGVySW50IC0gMSAtIChpICUgcGVySW50KSkgKiBiaXRzKTtcbiAgICB0bXBbaWR4XSA9ICgxIDw8IChiaXRzIC0gMSkpIDw8IHNoZnQ7XG4gICAgbVtpXSA9IHRoaXMuZ2VuZXJhdGVTdWJIYXNoVGFibGUodGhpcy5tdWx0aXBseSh0bXAsIGgpLCBiaXRzKTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdGFibGUgZm9yIG11bHRpcGx5aW5nIGFnYWluc3QgdGhlIGhhc2ggc3Via2V5IGZvciBvbmVcbiAqIHBhcnRpY3VsYXIgY29tcG9uZW50IChvdXQgb2YgYWxsIHBvc3NpYmxlIGNvbXBvbmVudCB2YWx1ZXMpLlxuICpcbiAqIEBwYXJhbSBtaWQgdGhlIHByZS1tdWx0aXBsaWVkIHZhbHVlIGZvciB0aGUgbWlkZGxlIGtleSBvZiB0aGUgdGFibGUuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlU3ViSGFzaFRhYmxlID0gZnVuY3Rpb24obWlkLCBiaXRzKSB7XG4gIC8vIGNvbXB1dGUgdGhlIHRhYmxlIHF1aWNrbHkgYnkgbWluaW1pemluZyB0aGUgbnVtYmVyIG9mXG4gIC8vIFBPVyBvcGVyYXRpb25zIC0tIHRoZXkgb25seSBuZWVkIHRvIGJlIHBlcmZvcm1lZCBmb3IgcG93ZXJzIG9mIDIsXG4gIC8vIGFsbCBvdGhlciBlbnRyaWVzIGNhbiBiZSBjb21wb3NlZCBmcm9tIHRob3NlIHBvd2VycyB1c2luZyBYT1JcbiAgdmFyIHNpemUgPSAxIDw8IGJpdHM7XG4gIHZhciBoYWxmID0gc2l6ZSA+Pj4gMTtcbiAgdmFyIG0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIG1baGFsZl0gPSBtaWQuc2xpY2UoMCk7XG4gIHZhciBpID0gaGFsZiA+Pj4gMTtcbiAgd2hpbGUoaSA+IDApIHtcbiAgICAvLyByYWlzZSBtMFsyICogaV0gYW5kIHN0b3JlIGluIG0wW2ldXG4gICAgdGhpcy5wb3cobVsyICogaV0sIG1baV0gPSBbXSk7XG4gICAgaSA+Pj0gMTtcbiAgfVxuICBpID0gMjtcbiAgd2hpbGUoaSA8IGhhbGYpIHtcbiAgICBmb3IodmFyIGogPSAxOyBqIDwgaTsgKytqKSB7XG4gICAgICB2YXIgbV9pID0gbVtpXTtcbiAgICAgIHZhciBtX2ogPSBtW2pdO1xuICAgICAgbVtpICsgal0gPSBbXG4gICAgICAgIG1faVswXSBeIG1falswXSxcbiAgICAgICAgbV9pWzFdIF4gbV9qWzFdLFxuICAgICAgICBtX2lbMl0gXiBtX2pbMl0sXG4gICAgICAgIG1faVszXSBeIG1falszXVxuICAgICAgXTtcbiAgICB9XG4gICAgaSAqPSAyO1xuICB9XG4gIG1bMF0gPSBbMCwgMCwgMCwgMF07XG4gIC8qIE5vdGU6IFdlIGNvdWxkIGF2b2lkIHN0b3JpbmcgdGhlc2UgYnkgZG9pbmcgY29tcG9zaXRpb24gZHVyaW5nIG11bHRpcGx5XG4gIGNhbGN1bGF0ZSB0b3AgaGFsZiB1c2luZyBjb21wb3NpdGlvbiBieSBzcGVlZCBpcyBwcmVmZXJyZWQuICovXG4gIGZvcihpID0gaGFsZiArIDE7IGkgPCBzaXplOyArK2kpIHtcbiAgICB2YXIgYyA9IG1baSBeIGhhbGZdO1xuICAgIG1baV0gPSBbbWlkWzBdIF4gY1swXSwgbWlkWzFdIF4gY1sxXSwgbWlkWzJdIF4gY1syXSwgbWlkWzNdIF4gY1szXV07XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtSVYoaXYsIGJsb2NrU2l6ZSkge1xuICBpZih0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gY29udmVydCBpdiBzdHJpbmcgaW50byBieXRlIGJ1ZmZlclxuICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoaXYpO1xuICB9XG5cbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGl2KSAmJiBpdi5sZW5ndGggPiA0KSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICB2YXIgdG1wID0gaXY7XG4gICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgIGl2LnB1dEJ5dGUodG1wW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZihpdi5sZW5ndGgoKSA8IGJsb2NrU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIElWIGxlbmd0aDsgZ290ICcgKyBpdi5sZW5ndGgoKSArXG4gICAgICAnIGJ5dGVzIGFuZCBleHBlY3RlZCAnICsgYmxvY2tTaXplICsgJyBieXRlcy4nKTtcbiAgfVxuXG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoaXYpKSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gICAgdmFyIGludHMgPSBbXTtcbiAgICB2YXIgYmxvY2tzID0gYmxvY2tTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmxvY2tzOyArK2kpIHtcbiAgICAgIGludHMucHVzaChpdi5nZXRJbnQzMigpKTtcbiAgICB9XG4gICAgaXYgPSBpbnRzO1xuICB9XG5cbiAgcmV0dXJuIGl2O1xufVxuXG5mdW5jdGlvbiBpbmMzMihibG9jaykge1xuICAvLyBpbmNyZW1lbnQgbGFzdCAzMiBiaXRzIG9mIGJsb2NrIG9ubHlcbiAgYmxvY2tbYmxvY2subGVuZ3RoIC0gMV0gPSAoYmxvY2tbYmxvY2subGVuZ3RoIC0gMV0gKyAxKSAmIDB4RkZGRkZGRkY7XG59XG5cbmZ1bmN0aW9uIGZyb202NFRvMzIobnVtKSB7XG4gIC8vIGNvbnZlcnQgNjQtYml0IG51bWJlciB0byB0d28gQkUgSW50MzJzXG4gIHJldHVybiBbKG51bSAvIDB4MTAwMDAwMDAwKSB8IDAsIG51bSAmIDB4RkZGRkZGRkZdO1xufVxuIiwgIi8qKlxuICogQWR2YW5jZWQgRW5jcnlwdGlvbiBTdGFuZGFyZCAoQUVTKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBwdWJsaWMgZG9tYWluIGxpYnJhcnkgJ2pzY3J5cHRvJyB3aGljaFxuICogd2FzIHdyaXR0ZW4gYnk6XG4gKlxuICogRW1pbHkgU3RhcmsgKGVzdGFya0BzdGFuZm9yZC5lZHUpXG4gKiBNaWtlIEhhbWJ1cmcgKG1oYW1idXJnQHN0YW5mb3JkLmVkdSlcbiAqIERhbiBCb25laCAoZGFib0Bjcy5zdGFuZm9yZC5lZHUpXG4gKlxuICogUGFydHMgb2YgdGhpcyBjb2RlIGFyZSBiYXNlZCBvbiB0aGUgT3BlblNTTCBpbXBsZW1lbnRhdGlvbiBvZiBBRVM6XG4gKiBodHRwOi8vd3d3Lm9wZW5zc2wub3JnXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2NpcGhlcicpO1xucmVxdWlyZSgnLi9jaXBoZXJNb2RlcycpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qIEFFUyBBUEkgKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYWVzID0gZm9yZ2UuYWVzIHx8IHt9O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZGVjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBRVMgY2lwaGVyIGFsZ29yaXRobSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBtb2RlIGZhY3RvcnkgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybiB0aGUgQUVTIGFsZ29yaXRobSBvYmplY3QuXG4gKi9cbmZvcmdlLmFlcy5BbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lLCBtb2RlKSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5uYW1lID0gbmFtZTtcbiAgc2VsZi5tb2RlID0gbmV3IG1vZGUoe1xuICAgIGJsb2NrU2l6ZTogMTYsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX3csIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl93LCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIEFFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5hZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdG1wO1xuXG4gIC8qIE5vdGU6IFRoZSBrZXkgbWF5IGJlIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYSBieXRlXG4gICAgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuIElmIHRoZSBrZXkgaXMgaW4gYnl0ZXMsIHRoZW5cbiAgICBpdCBtdXN0IGJlIDE2LCAyNCwgb3IgMzIgYnl0ZXMgaW4gbGVuZ3RoLiBJZiBpdCBpcyBpbiAzMi1iaXRcbiAgICBpbnRlZ2VycywgaXQgbXVzdCBiZSA0LCA2LCBvciA4IGludGVnZXJzIGxvbmcuICovXG5cbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgaW50ZWdlciBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdG1wID0ga2V5O1xuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAga2V5LnB1dEJ5dGUodG1wW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb252ZXJ0IGtleSBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSkge1xuICAgIHRtcCA9IGtleTtcbiAgICBrZXkgPSBbXTtcblxuICAgIC8vIGtleSBsZW5ndGhzIG9mIDE2LCAyNCwgMzIgYnl0ZXMgYWxsb3dlZFxuICAgIHZhciBsZW4gPSB0bXAubGVuZ3RoKCk7XG4gICAgaWYobGVuID09PSAxNiB8fCBsZW4gPT09IDI0IHx8IGxlbiA9PT0gMzIpIHtcbiAgICAgIGxlbiA9IGxlbiA+Pj4gMjtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXkucHVzaCh0bXAuZ2V0SW50MzIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2V5IG11c3QgYmUgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzIGJ5IG5vd1xuICBpZighZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgfHxcbiAgICAhKGtleS5sZW5ndGggPT09IDQgfHwga2V5Lmxlbmd0aCA9PT0gNiB8fCBrZXkubGVuZ3RoID09PSA4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgLy8gZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYWx3YXlzIHVzZWQgZm9yIHRoZXNlIG1vZGVzXG4gIHZhciBtb2RlID0gdGhpcy5tb2RlLm5hbWU7XG4gIHZhciBlbmNyeXB0T3AgPSAoWydDRkInLCAnT0ZCJywgJ0NUUicsICdHQ00nXS5pbmRleE9mKG1vZGUpICE9PSAtMSk7XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvblxuICB0aGlzLl93ID0gX2V4cGFuZEtleShrZXksIG9wdGlvbnMuZGVjcnlwdCAmJiAhZW5jcnlwdE9wKTtcbiAgdGhpcy5faW5pdCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBrZXkuIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byBleHBhbmQsIGFzIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZXhwYW5kIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXkuXG4gKi9cbmZvcmdlLmFlcy5fZXhwYW5kS2V5ID0gZnVuY3Rpb24oa2V5LCBkZWNyeXB0KSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2suIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIHcgdGhlIGV4cGFuZGVkIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaW5wdXQgYW4gYXJyYXkgb2YgYmxvY2stc2l6ZSAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gb3V0cHV0IGFuIGFycmF5IG9mIGJsb2NrLXNpemUgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0LCBmYWxzZSB0byBlbmNyeXB0LlxuICovXG5mb3JnZS5hZXMuX3VwZGF0ZUJsb2NrID0gX3VwZGF0ZUJsb2NrO1xuXG4vKiogUmVnaXN0ZXIgQUVTIGFsZ29yaXRobXMgKiovXG5cbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNCQycsIGZvcmdlLmNpcGhlci5tb2Rlcy5jYmMpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1DRkInLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNUUicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jdHIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1HQ00nLCBmb3JnZS5jaXBoZXIubW9kZXMuZ2NtKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuYWVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogQUVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgaW5pdCA9IGZhbHNlOyAvLyBub3QgeWV0IGluaXRpYWxpemVkXG52YXIgTmIgPSA0OyAgICAgICAvLyBudW1iZXIgb2Ygd29yZHMgY29tcHJpc2luZyB0aGUgc3RhdGUgKEFFUyA9IDQpXG52YXIgc2JveDsgICAgICAgICAvLyBub24tbGluZWFyIHN1YnN0aXR1dGlvbiB0YWJsZSB1c2VkIGluIGtleSBleHBhbnNpb25cbnZhciBpc2JveDsgICAgICAgIC8vIGludmVyc2lvbiBvZiBzYm94XG52YXIgcmNvbjsgICAgICAgICAvLyByb3VuZCBjb25zdGFudCB3b3JkIGFycmF5XG52YXIgbWl4OyAgICAgICAgICAvLyBtaXgtY29sdW1ucyB0YWJsZVxudmFyIGltaXg7ICAgICAgICAgLy8gaW52ZXJzZSBtaXgtY29sdW1ucyB0YWJsZVxuXG4vKipcbiAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uLCBpZTogcHJlY29tcHV0ZXMgdGFibGVzIHRvIG9wdGltaXplIGZvciBzcGVlZC5cbiAqXG4gKiBPbmUgd2F5IHRvIHVuZGVyc3RhbmQgaG93IEFFUyB3b3JrcyBpcyB0byBpbWFnaW5lIHRoYXQgJ2FkZGl0aW9uJyBhbmRcbiAqICdtdWx0aXBsaWNhdGlvbicgYXJlIGludGVyZmFjZXMgdGhhdCByZXF1aXJlIGNlcnRhaW4gbWF0aGVtYXRpY2FsXG4gKiBwcm9wZXJ0aWVzIHRvIGhvbGQgdHJ1ZSAoaWU6IHRoZXkgYXJlIGFzc29jaWF0aXZlKSBidXQgdGhleSBtaWdodCBoYXZlXG4gKiBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIGFuZCBwcm9kdWNlIGRpZmZlcmVudCBraW5kcyBvZiByZXN1bHRzIC4uLlxuICogcHJvdmlkZWQgdGhhdCB0aGVpciBtYXRoZW1hdGljYWwgcHJvcGVydGllcyByZW1haW4gdHJ1ZS4gQUVTIGRlZmluZXNcbiAqIGl0cyBvd24gbWV0aG9kcyBvZiBhZGRpdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gYnV0IGtlZXBzIHNvbWUgaW1wb3J0YW50XG4gKiBwcm9wZXJ0aWVzIHRoZSBzYW1lLCBpZTogYXNzb2NpYXRpdml0eSBhbmQgZGlzdHJpYnV0aXZpdHkuIFRoZVxuICogZXhwbGFuYXRpb24gYmVsb3cgdHJpZXMgdG8gc2hlZCBzb21lIGxpZ2h0IG9uIGhvdyBBRVMgZGVmaW5lcyBhZGRpdGlvblxuICogYW5kIG11bHRpcGxpY2F0aW9uIG9mIGJ5dGVzIGFuZCAzMi1iaXQgd29yZHMgaW4gb3JkZXIgdG8gcGVyZm9ybSBpdHNcbiAqIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24gYWxnb3JpdGhtcy5cbiAqXG4gKiBUaGUgYmFzaWNzOlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHZpZXdzIGJ5dGVzIGFzIGJpbmFyeSByZXByZXNlbnRhdGlvbnMgb2YgcG9seW5vbWlhbHNcbiAqIHRoYXQgaGF2ZSBlaXRoZXIgMSBvciAwIGFzIHRoZSBjb2VmZmljaWVudHMuIEl0IGRlZmluZXMgdGhlIGFkZGl0aW9uXG4gKiBvciBzdWJ0cmFjdGlvbiBvZiB0d28gYnl0ZXMgYXMgdGhlIFhPUiBvcGVyYXRpb24uIEl0IGFsc28gZGVmaW5lcyB0aGVcbiAqIG11bHRpcGxpY2F0aW9uIG9mIHR3byBieXRlcyBhcyBhIGZpbml0ZSBmaWVsZCByZWZlcnJlZCB0byBhcyBHRigyXjgpXG4gKiAoTm90ZTogJ0dGJyBtZWFucyBcIkdhbG9pcyBGaWVsZFwiIHdoaWNoIGlzIGEgZmllbGQgdGhhdCBjb250YWlucyBhIGZpbml0ZVxuICogbnVtYmVyIG9mIGVsZW1lbnRzIHNvIEdGKDJeOCkgaGFzIDI1NiBlbGVtZW50cykuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IGFueSB0d28gYnl0ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGJpbmFyeSBwb2x5bm9taWFscztcbiAqIHdoZW4gdGhleSBtdWx0aXBsaWVkIHRvZ2V0aGVyIGFuZCBtb2R1bGFybHkgcmVkdWNlZCBieSBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiB0aGUgOHRoIGRlZ3JlZSwgdGhlIHJlc3VsdHMgYXJlIHRoZSBmaWVsZCBHRigyXjgpLiBUaGVcbiAqIHNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgdGhhdCBBRVMgdXNlcyBpbiBoZXhhZGVjaW1hbCBpcyAweDExYi5cbiAqIFRoaXMgbXVsdGlwbGljYXRpb24gaXMgYXNzb2NpYXRpdmUgd2l0aCAweDAxIGFzIHRoZSBpZGVudGl0eTpcbiAqXG4gKiAoYiAqIDB4MDEgPSBHRihiLCAweDAxKSA9IGIpLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gR0YoYiwgMHgwMikgY2FuIGJlIHBlcmZvcm1lZCBhdCB0aGUgYnl0ZSBsZXZlbCBieSBsZWZ0XG4gKiBzaGlmdGluZyBiIG9uY2UgYW5kIHRoZW4gWE9SJ2luZyBpdCAodG8gcGVyZm9ybSB0aGUgbW9kdWxhciByZWR1Y3Rpb24pXG4gKiB3aXRoIDB4MTFiIGlmIGIgaXMgPj0gMTI4LiBSZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB0aGUgbXVsdGlwbGljYXRpb25cbiAqIG9mIDB4MDIgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBhbnkgdHdvIGJ5dGVzLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgbXVsdGlwbHlpbmcgMHg1NyBhbmQgMHgxMywgZGVub3RlZCBhcyBHRigweDU3LCAweDEzKSwgY2FuXG4gKiBiZSBwZXJmb3JtZWQgYnkgZmFjdG9yaW5nIDB4MTMgaW50byAweDAxLCAweDAyLCBhbmQgMHgxMC4gVGhlbiB0aGVzZVxuICogZmFjdG9ycyBjYW4gZWFjaCBiZSBtdWx0aXBsaWVkIGJ5IDB4NTcgYW5kIHRoZW4gYWRkZWQgdG9nZXRoZXIuIFRvIGRvXG4gKiB0aGUgbXVsdGlwbGljYXRpb24sIHZhbHVlcyBmb3IgMHg1NyBtdWx0aXBsaWVkIGJ5IGVhY2ggb2YgdGhlc2UgMyBmYWN0b3JzXG4gKiBjYW4gYmUgcHJlY29tcHV0ZWQgYW5kIHN0b3JlZCBpbiBhIHRhYmxlLiBUbyBhZGQgdGhlbSwgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgdGFibGUgYXJlIFhPUidkIHRvZ2V0aGVyLlxuICpcbiAqIEFFUyBhbHNvIGRlZmluZXMgYWRkaXRpb24gYW5kIG11bHRpcGxpY2F0aW9uIG9mIHdvcmRzLCB0aGF0IGlzIDQtYnl0ZVxuICogbnVtYmVycyByZXByZXNlbnRlZCBhcyBwb2x5bm9taWFscyBvZiAzIGRlZ3JlZXMgd2hlcmUgdGhlIGNvZWZmaWNpZW50c1xuICogYXJlIHRoZSB2YWx1ZXMgb2YgdGhlIGJ5dGVzLlxuICpcbiAqIFRoZSB3b3JkIFthMCwgYTEsIGEyLCBhM10gaXMgYSBwb2x5bm9taWFsIGEzeF4zICsgYTJ4XjIgKyBhMXggKyBhMC5cbiAqXG4gKiBBZGRpdGlvbiBpcyBwZXJmb3JtZWQgYnkgWE9SJ2luZyBsaWtlIHBvd2VycyBvZiB4LiBNdWx0aXBsaWNhdGlvblxuICogaXMgcGVyZm9ybWVkIGluIHR3byBzdGVwcywgdGhlIGZpcnN0IGlzIGFuIGFsZ2VicmlhYyBleHBhbnNpb24gYXNcbiAqIHlvdSB3b3VsZCBkbyBub3JtYWxseSAod2hlcmUgYWRkaXRpb24gaXMgWE9SKS4gQnV0IHRoZSByZXN1bHQgaXNcbiAqIGEgcG9seW5vbWlhbCBsYXJnZXIgdGhhbiAzIGRlZ3JlZXMgYW5kIHRodXMgaXQgY2Fubm90IGZpdCBpbiBhIHdvcmQuIFNvXG4gKiBuZXh0IHRoZSByZXN1bHQgaXMgbW9kdWxhcmx5IHJlZHVjZWQgYnkgYW4gQUVTLXNwZWNpZmljIHBvbHlub21pYWwgb2ZcbiAqIGRlZ3JlZSA0IHdoaWNoIHdpbGwgYWx3YXlzIHByb2R1Y2UgYSBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiA0IGRlZ3JlZXNcbiAqIHN1Y2ggdGhhdCBpdCB3aWxsIGZpdCBpbiBhIHdvcmQuIEluIEFFUywgdGhpcyBwb2x5bm9taWFsIGlzIHheNCArIDEuXG4gKlxuICogVGhlIG1vZHVsYXIgcHJvZHVjdCBvZiB0d28gcG9seW5vbWlhbHMgJ2EnIGFuZCAnYicgaXMgdGh1czpcbiAqXG4gKiBkKHgpID0gZDN4XjMgKyBkMnheMiArIGQxeCArIGQwXG4gKiB3aXRoXG4gKiBkMCA9IEdGKGEwLCBiMCkgXiBHRihhMywgYjEpIF4gR0YoYTIsIGIyKSBeIEdGKGExLCBiMylcbiAqIGQxID0gR0YoYTEsIGIwKSBeIEdGKGEwLCBiMSkgXiBHRihhMywgYjIpIF4gR0YoYTIsIGIzKVxuICogZDIgPSBHRihhMiwgYjApIF4gR0YoYTEsIGIxKSBeIEdGKGEwLCBiMikgXiBHRihhMywgYjMpXG4gKiBkMyA9IEdGKGEzLCBiMCkgXiBHRihhMiwgYjEpIF4gR0YoYTEsIGIyKSBeIEdGKGEwLCBiMylcbiAqXG4gKiBBcyBhIG1hdHJpeDpcbiAqXG4gKiBbZDBdID0gW2EwIGEzIGEyIGExXVtiMF1cbiAqIFtkMV0gICBbYTEgYTAgYTMgYTJdW2IxXVxuICogW2QyXSAgIFthMiBhMSBhMCBhM11bYjJdXG4gKiBbZDNdICAgW2EzIGEyIGExIGEwXVtiM11cbiAqXG4gKiBTcGVjaWFsIHBvbHlub21pYWxzIGRlZmluZWQgYnkgQUVTICgweDAyID09IHswMn0pOlxuICogYSh4KSAgICA9IHswM314XjMgKyB7MDF9eF4yICsgezAxfXggKyB7MDJ9XG4gKiBhXi0xKHgpID0gezBifXheMyArIHswZH14XjIgKyB7MDl9eCArIHswZX0uXG4gKlxuICogVGhlc2UgcG9seW5vbWlhbHMgYXJlIHVzZWQgaW4gdGhlIE1peENvbHVtbnMoKSBhbmQgSW52ZXJzZU1peENvbHVtbnMoKVxuICogb3BlcmF0aW9ucywgcmVzcGVjdGl2ZWx5LCB0byBjYXVzZSBlYWNoIGVsZW1lbnQgaW4gdGhlIHN0YXRlIHRvIGFmZmVjdFxuICogdGhlIG91dHB1dCAocmVmZXJyZWQgdG8gYXMgZGlmZnVzaW5nKS5cbiAqXG4gKiBSb3RXb3JkKCkgdXNlczogYTAgPSBhMSA9IGEyID0gezAwfSBhbmQgYTMgPSB7MDF9LCB3aGljaCBpcyB0aGVcbiAqIHBvbHlub21pYWwgeDMuXG4gKlxuICogVGhlIFNoaWZ0Um93cygpIG1ldGhvZCBtb2RpZmllcyB0aGUgbGFzdCAzIHJvd3MgaW4gdGhlIHN0YXRlICh3aGVyZVxuICogdGhlIHN0YXRlIGlzIDQgd29yZHMgd2l0aCA0IGJ5dGVzIHBlciB3b3JkKSBieSBzaGlmdGluZyBieXRlcyBjeWNsaWNhbGx5LlxuICogVGhlIDFzdCBieXRlIGluIHRoZSBzZWNvbmQgcm93IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHJvdy4gVGhlIDFzdFxuICogYW5kIDJuZCBieXRlcyBpbiB0aGUgdGhpcmQgcm93IGFyZSBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoZSByb3cuIFRoZSAxc3QsXG4gKiAybmQsIGFuZCAzcmQgYnl0ZXMgYXJlIG1vdmVkIGluIHRoZSBmb3VydGggcm93LlxuICpcbiAqIE1vcmUgZGV0YWlscyBvbiBob3cgQUVTIGFyaXRobWV0aWMgd29ya3M6XG4gKlxuICogSW4gdGhlIHBvbHlub21pYWwgcmVwcmVzZW50YXRpb24gb2YgYmluYXJ5IG51bWJlcnMsIFhPUiBwZXJmb3JtcyBhZGRpdGlvblxuICogYW5kIHN1YnRyYWN0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBpbiBHRigyXjgpIGRlbm90ZWQgYXMgR0YoYSwgYilcbiAqIGNvcnJlc3BvbmRzIHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIG9mIHBvbHlub21pYWxzIG1vZHVsbyBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiBkZWdyZWUgOC4gSW4gb3RoZXIgd29yZHMsIGZvciBBRVMsIEdGKGEsIGIpIHdpbGwgbXVsdGlwbHlcbiAqIHBvbHlub21pYWwgJ2EnIHdpdGggcG9seW5vbWlhbCAnYicgYW5kIHRoZW4gZG8gYSBtb2R1bGFyIHJlZHVjdGlvbiBieVxuICogYW4gQUVTLXNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgb2YgZGVncmVlIDguXG4gKlxuICogQSBwb2x5bm9taWFsIGlzIGlycmVkdWNpYmxlIGlmIGl0cyBvbmx5IGRpdmlzb3JzIGFyZSBvbmUgYW5kIGl0c2VsZi4gRm9yXG4gKiB0aGUgQUVTIGFsZ29yaXRobSwgdGhpcyBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIGlzOlxuICpcbiAqIG0oeCkgPSB4XjggKyB4XjQgKyB4XjMgKyB4ICsgMSxcbiAqXG4gKiBvciB7MDF9ezFifSBpbiBoZXhhZGVjaW1hbCBub3RhdGlvbiwgd2hlcmUgZWFjaCBjb2VmZmljaWVudCBpcyBhIGJpdDpcbiAqIDEwMDAxMTAxMSA9IDI4MyA9IDB4MTFiLlxuICpcbiAqIEZvciBleGFtcGxlLCBHRigweDU3LCAweDgzKSA9IDB4YzEgYmVjYXVzZVxuICpcbiAqIDB4NTcgPSA4NyAgPSAwMTAxMDExMSA9IHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiAweDg1ID0gMTMxID0gMTAwMDAxMDEgPSB4XjcgKyB4ICsgMVxuICpcbiAqICh4XjYgKyB4XjQgKyB4XjIgKyB4ICsgMSkgKiAoeF43ICsgeCArIDEpXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNyArXG4gKiAgICB4XjcgKyB4XjUgKyB4XjMgKyB4XjIgKyB4ICtcbiAqICAgIHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNiArIHheNSArIHheNCArIHheMyArIDEgPSB5XG4gKiAgICB5IG1vZHVsbyAoeF44ICsgeF40ICsgeF4zICsgeCArIDEpXG4gKiA9ICB4XjcgKyB4XjYgKyAxLlxuICpcbiAqIFRoZSBtb2R1bGFyIHJlZHVjdGlvbiBieSBtKHgpIGd1YXJhbnRlZXMgdGhlIHJlc3VsdCB3aWxsIGJlIGEgYmluYXJ5XG4gKiBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiBkZWdyZWUgOCwgc28gdGhhdCBpdCBjYW4gZml0IGluIGEgYnl0ZS5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIHRvIG11bHRpcGx5IGEgYmluYXJ5IHBvbHlub21pYWwgYiB3aXRoIHggKHRoZSBwb2x5bm9taWFsXG4gKiB4IGluIGJpbmFyeSByZXByZXNlbnRhdGlvbiBpcyAwMDAwMDAxMCkgaXM6XG4gKlxuICogYl83eF44ICsgYl82eF43ICsgYl81eF42ICsgYl80eF41ICsgYl8zeF40ICsgYl8yeF4zICsgYl8xeF4yICsgYl8weF4xXG4gKlxuICogVG8gZ2V0IEdGKGIsIHgpIHdlIG11c3QgcmVkdWNlIHRoYXQgYnkgbSh4KS4gSWYgYl83IGlzIDAgKHRoYXQgaXMgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBpcyAwIGluIGIpIHRoZW4gdGhlIHJlc3VsdCBpcyBhbHJlYWR5IHJlZHVjZWQuIElmXG4gKiBpdCBpcyAxLCB0aGVuIHdlIGNhbiByZWR1Y2UgaXQgYnkgc3VidHJhY3RpbmcgbSh4KSB2aWEgYW4gWE9SLlxuICpcbiAqIEl0IGZvbGxvd3MgdGhhdCBtdWx0aXBsaWNhdGlvbiBieSB4ICgwMDAwMDAxMCBvciAweDAyKSBjYW4gYmUgaW1wbGVtZW50ZWRcbiAqIGJ5IHBlcmZvcm1pbmcgYSBsZWZ0IHNoaWZ0IGZvbGxvd2VkIGJ5IGEgY29uZGl0aW9uYWwgYml0d2lzZSBYT1Igd2l0aFxuICogMHgxYi4gVGhpcyBvcGVyYXRpb24gb24gYnl0ZXMgaXMgZGVub3RlZCBieSB4dGltZSgpLiBNdWx0aXBsaWNhdGlvbiBieVxuICogaGlnaGVyIHBvd2VycyBvZiB4IGNhbiBiZSBpbXBsZW1lbnRlZCBieSByZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB4dGltZSgpLlxuICpcbiAqIEJ5IGFkZGluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cywgbXVsdGlwbGljYXRpb24gYnkgYW55IGNvbnN0YW50IGNhbiBiZVxuICogaW1wbGVtZW50ZWQuIEZvciBpbnN0YW5jZTpcbiAqXG4gKiBHRigweDU3LCAweDEzKSA9IDB4ZmUgYmVjYXVzZTpcbiAqXG4gKiB4dGltZShiKSA9IChiICYgMTI4KSA/IChiIDw8IDEgXiAweDExYikgOiAoYiA8PCAxKVxuICpcbiAqIE5vdGU6IFdlIFhPUiB3aXRoIDB4MTFiIGluc3RlYWQgb2YgMHgxYiBiZWNhdXNlIGluIGphdmFzY3JpcHQgb3VyXG4gKiBkYXRhdHlwZSBmb3IgYiBjYW4gYmUgbGFyZ2VyIHRoYW4gMSBieXRlLCBzbyBhIGxlZnQgc2hpZnQgd2lsbCBub3RcbiAqIGF1dG9tYXRpY2FsbHkgZWxpbWluYXRlIGJpdHMgdGhhdCBvdmVyZmxvdyBhIGJ5dGUgLi4uIGJ5IFhPUidpbmcgdGhlXG4gKiBvdmVyZmxvdyBiaXQgd2l0aCAxICh0aGUgZXh0cmEgb25lIGZyb20gMHgxMWIpIHdlIHplcm8gaXQgb3V0LlxuICpcbiAqIEdGKDB4NTcsIDB4MDIpID0geHRpbWUoMHg1NykgPSAweGFlXG4gKiBHRigweDU3LCAweDA0KSA9IHh0aW1lKDB4YWUpID0gMHg0N1xuICogR0YoMHg1NywgMHgwOCkgPSB4dGltZSgweDQ3KSA9IDB4OGVcbiAqIEdGKDB4NTcsIDB4MTApID0geHRpbWUoMHg4ZSkgPSAweDA3XG4gKlxuICogR0YoMHg1NywgMHgxMykgPSBHRigweDU3LCAoMHgwMSBeIDB4MDIgXiAweDEwKSlcbiAqXG4gKiBBbmQgYnkgdGhlIGRpc3RyaWJ1dGl2ZSBwcm9wZXJ0eSAoc2luY2UgWE9SIGlzIGFkZGl0aW9uIGFuZCBHRigpIGlzXG4gKiBtdWx0aXBsaWNhdGlvbik6XG4gKlxuICogPSBHRigweDU3LCAweDAxKSBeIEdGKDB4NTcsIDB4MDIpIF4gR0YoMHg1NywgMHgxMClcbiAqID0gMHg1NyBeIDB4YWUgXiAweDA3XG4gKiA9IDB4ZmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gIGluaXQgPSB0cnVlO1xuXG4gIC8qIFBvcHVsYXRlIHRoZSBSY29uIHRhYmxlLiBUaGVzZSBhcmUgdGhlIHZhbHVlcyBnaXZlbiBieVxuICAgIFt4XihpLTEpLHswMH0sezAwfSx7MDB9XSB3aGVyZSB4XihpLTEpIGFyZSBwb3dlcnMgb2YgeCAoYW5kIHggPSAweDAyKVxuICAgIGluIHRoZSBmaWVsZCBvZiBHRigyXjgpLCB3aGVyZSBpIHN0YXJ0cyBhdCAxLlxuXG4gICAgcmNvblswXSA9IFsweDAwLCAweDAwLCAweDAwLCAweDAwXVxuICAgIHJjb25bMV0gPSBbMHgwMSwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMS0xKSA9IDJeMCA9IDFcbiAgICByY29uWzJdID0gWzB4MDIsIDB4MDAsIDB4MDAsIDB4MDBdIDJeKDItMSkgPSAyXjEgPSAyXG4gICAgLi4uXG4gICAgcmNvbls5XSAgPSBbMHgxQiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oOS0xKSAgPSAyXjggPSAweDFCXG4gICAgcmNvblsxMF0gPSBbMHgzNiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMTAtMSkgPSAyXjkgPSAweDM2XG5cbiAgICBXZSBvbmx5IHN0b3JlIHRoZSBmaXJzdCBieXRlIGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgb25lIHVzZWQuXG4gICovXG4gIHJjb24gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxQiwgMHgzNl07XG5cbiAgLy8gY29tcHV0ZSB4dGltZSB0YWJsZSB3aGljaCBtYXBzIGkgb250byBHRihpLCAweDAyKVxuICB2YXIgeHRpbWUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgeHRpbWVbaV0gPSBpIDw8IDE7XG4gICAgeHRpbWVbaSArIDEyOF0gPSAoaSArIDEyOCkgPDwgMSBeIDB4MTFCO1xuICB9XG5cbiAgLy8gY29tcHV0ZSBhbGwgb3RoZXIgdGFibGVzXG4gIHNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgaXNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgbWl4ID0gbmV3IEFycmF5KDQpO1xuICBpbWl4ID0gbmV3IEFycmF5KDQpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gICAgaW1peFtpXSA9IG5ldyBBcnJheSgyNTYpO1xuICB9XG4gIHZhciBlID0gMCwgZWkgPSAwLCBlMiwgZTQsIGU4LCBzeCwgc3gyLCBtZSwgaW1lO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAvKiBXZSBuZWVkIHRvIGdlbmVyYXRlIHRoZSBTdWJCeXRlcygpIHNib3ggYW5kIGlzYm94IHRhYmxlcyBzbyB0aGF0XG4gICAgICB3ZSBjYW4gcGVyZm9ybSBieXRlIHN1YnN0aXR1dGlvbnMuIFRoaXMgcmVxdWlyZXMgdXMgdG8gdHJhdmVyc2VcbiAgICAgIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gR0YsIGZpbmQgdGhlaXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZXMsXG4gICAgICBhbmQgYXBwbHkgdG8gZWFjaCB0aGUgZm9sbG93aW5nIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjpcblxuICAgICAgYmknID0gYmkgXiBiKGkgKyA0KSBtb2QgOCBeIGIoaSArIDUpIG1vZCA4IF4gYihpICsgNikgbW9kIDggXlxuICAgICAgICAgICAgYihpICsgNykgbW9kIDggXiBjaVxuICAgICAgZm9yIDAgPD0gaSA8IDgsIHdoZXJlIGJpIGlzIHRoZSBpdGggYml0IG9mIHRoZSBieXRlLCBhbmQgY2kgaXMgdGhlXG4gICAgICBpdGggYml0IG9mIGEgYnl0ZSBjIHdpdGggdGhlIHZhbHVlIHs2M30gb3IgezAxMTAwMDExfS5cblxuICAgICAgSXQgaXMgcG9zc2libGUgdG8gdHJhdmVyc2UgZXZlcnkgcG9zc2libGUgdmFsdWUgaW4gYSBHYWxvaXMgZmllbGRcbiAgICAgIHVzaW5nIHdoYXQgaXMgcmVmZXJyZWQgdG8gYXMgYSAnZ2VuZXJhdG9yJy4gVGhlcmUgYXJlIG1hbnlcbiAgICAgIGdlbmVyYXRvcnMgKDEyOCBvdXQgb2YgMjU2KTogMyw1LDYsOSwxMSw4MiB0byBuYW1lIGEgZmV3LiBUbyBmdWxseVxuICAgICAgdHJhdmVyc2UgR0Ygd2UgaXRlcmF0ZSAyNTUgdGltZXMsIG11bHRpcGx5aW5nIGJ5IG91ciBnZW5lcmF0b3JcbiAgICAgIGVhY2ggdGltZS5cblxuICAgICAgT24gZWFjaCBpdGVyYXRpb24gd2UgY2FuIGRldGVybWluZSB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBmb3JcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQuXG5cbiAgICAgIFN1cHBvc2UgdGhlcmUgaXMgYW4gZWxlbWVudCBpbiBHRiAnZScuIEZvciBhIGdpdmVuIGdlbmVyYXRvciAnZycsXG4gICAgICBlID0gZ154LiBUaGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBlIGlzIGdeKDI1NSAtIHgpLiBJdCB0dXJuc1xuICAgICAgb3V0IHRoYXQgaWYgdXNlIHRoZSBpbnZlcnNlIG9mIGEgZ2VuZXJhdG9yIGFzIGFub3RoZXIgZ2VuZXJhdG9yXG4gICAgICBpdCB3aWxsIHByb2R1Y2UgYWxsIG9mIHRoZSBjb3JyZXNwb25kaW5nIG11bHRpcGxpY2F0aXZlIGludmVyc2VzXG4gICAgICBhdCB0aGUgc2FtZSB0aW1lLiBGb3IgdGhpcyByZWFzb24sIHdlIGNob29zZSA1IGFzIG91ciBpbnZlcnNlXG4gICAgICBnZW5lcmF0b3IgYmVjYXVzZSBpdCBvbmx5IHJlcXVpcmVzIDIgbXVsdGlwbGllcyBhbmQgMSBhZGQgYW5kIGl0c1xuICAgICAgaW52ZXJzZSwgODIsIHJlcXVpcmVzIHJlbGF0aXZlbHkgZmV3IG9wZXJhdGlvbnMgYXMgd2VsbC5cblxuICAgICAgSW4gb3JkZXIgdG8gYXBwbHkgdGhlIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiwgdGhlIG11bHRpcGxpY2F0aXZlXG4gICAgICBpbnZlcnNlICdlaScgb2YgJ2UnIGNhbiBiZSByZXBlYXRlZGx5IFhPUidkICg0IHRpbWVzKSB3aXRoIGFcbiAgICAgIGJpdC1jeWNsaW5nIG9mICdlaScuIFRvIGRvIHRoaXMgJ2VpJyBpcyBmaXJzdCBzdG9yZWQgaW4gJ3MnIGFuZFxuICAgICAgJ3gnLiBUaGVuICdzJyBpcyBsZWZ0IHNoaWZ0ZWQgYW5kIHRoZSBoaWdoIGJpdCBvZiAncycgaXMgbWFkZSB0aGVcbiAgICAgIGxvdyBiaXQuIFRoZSByZXN1bHRpbmcgdmFsdWUgaXMgc3RvcmVkIGluICdzJy4gVGhlbiAneCcgaXMgWE9SJ2RcbiAgICAgIHdpdGggJ3MnIGFuZCBzdG9yZWQgaW4gJ3gnLiBPbiBlYWNoIHN1YnNlcXVlbnQgaXRlcmF0aW9uIHRoZSBzYW1lXG4gICAgICBvcGVyYXRpb24gaXMgcGVyZm9ybWVkLiBXaGVuIDQgaXRlcmF0aW9ucyBhcmUgY29tcGxldGUsICd4JyBpc1xuICAgICAgWE9SJ2Qgd2l0aCAnYycgKDB4NjMpIGFuZCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgaXMgc3RvcmVkIGluICd4Jy5cbiAgICAgIEZvciBleGFtcGxlOlxuXG4gICAgICBzID0gMDEwMDAwMDFcbiAgICAgIHggPSAwMTAwMDAwMVxuXG4gICAgICBpdGVyYXRpb24gMTogcyA9IDEwMDAwMDEwLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiAyOiBzID0gMDAwMDAxMDEsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDM6IHMgPSAwMDAwMTAxMCwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gNDogcyA9IDAwMDEwMTAwLCB4IF49IHNcbiAgICAgIHggXj0gMHg2M1xuXG4gICAgICBUaGlzIGNhbiBiZSBkb25lIHdpdGggYSBsb29wIHdoZXJlIHMgPSAocyA8PCAxKSB8IChzID4+IDcpLiBIb3dldmVyLFxuICAgICAgaXQgY2FuIGFsc28gYmUgZG9uZSBieSB1c2luZyBhIHNpbmdsZSAxNi1iaXQgKGluIHRoaXMgY2FzZSAzMi1iaXQpXG4gICAgICBudW1iZXIgJ3N4Jy4gU2luY2UgWE9SIGlzIGFuIGFzc29jaWF0aXZlIG9wZXJhdGlvbiwgd2UgY2FuIHNldCAnc3gnXG4gICAgICB0byAnZWknIGFuZCB0aGVuIFhPUiBpdCB3aXRoICdzeCcgbGVmdC1zaGlmdGVkIDEsMiwzLCBhbmQgNCB0aW1lcy5cbiAgICAgIFRoZSBtb3N0IHNpZ25pZmljYW50IGJpdHMgd2lsbCBmbG93IGludG8gdGhlIGhpZ2ggOCBiaXQgcG9zaXRpb25zXG4gICAgICBhbmQgYmUgY29ycmVjdGx5IFhPUidkIHdpdGggb25lIGFub3RoZXIuIEFsbCB0aGF0IHJlbWFpbnMgd2lsbCBiZVxuICAgICAgdG8gY3ljbGUgdGhlIGhpZ2ggOCBiaXRzIGJ5IFhPUidpbmcgdGhlbSBhbGwgd2l0aCB0aGUgbG93ZXIgOCBiaXRzXG4gICAgICBhZnRlcndhcmRzLlxuXG4gICAgICBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIHBvcHVsYXRpbmcgc2JveCBhbmQgaXNib3ggd2UgY2FuIHByZWNvbXB1dGVcbiAgICAgIHRoZSBtdWx0aXBsaWNhdGlvbiB3ZSdsbCBuZWVkIHRvIGRvIHRvIGRvIE1peENvbHVtbnMoKSBsYXRlci5cbiAgICAqL1xuXG4gICAgLy8gYXBwbHkgYWZmaW5lIHRyYW5zZm9ybWF0aW9uXG4gICAgc3ggPSBlaSBeIChlaSA8PCAxKSBeIChlaSA8PCAyKSBeIChlaSA8PCAzKSBeIChlaSA8PCA0KTtcbiAgICBzeCA9IChzeCA+PiA4KSBeIChzeCAmIDI1NSkgXiAweDYzO1xuXG4gICAgLy8gdXBkYXRlIHRhYmxlc1xuICAgIHNib3hbZV0gPSBzeDtcbiAgICBpc2JveFtzeF0gPSBlO1xuXG4gICAgLyogTWl4aW5nIGNvbHVtbnMgaXMgZG9uZSB1c2luZyBtYXRyaXggbXVsdGlwbGljYXRpb24uIFRoZSBjb2x1bW5zXG4gICAgICB0aGF0IGFyZSB0byBiZSBtaXhlZCBhcmUgZWFjaCBhIHNpbmdsZSB3b3JkIGluIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgVGhlIHN0YXRlIGhhcyBOYiBjb2x1bW5zICg0IGNvbHVtbnMpLiBUaGVyZWZvcmUgZWFjaCBjb2x1bW4gaXMgYVxuICAgICAgNCBieXRlIHdvcmQuIFNvIHRvIG1peCB0aGUgY29sdW1ucyBpbiBhIHNpbmdsZSBjb2x1bW4gJ2MnIHdoZXJlXG4gICAgICBpdHMgcm93cyBhcmUgcjAsIHIxLCByMiwgYW5kIHIzLCB3ZSB1c2UgdGhlIGZvbGxvd2luZyBtYXRyaXhcbiAgICAgIG11bHRpcGxpY2F0aW9uOlxuXG4gICAgICBbMiAzIDEgMV0qW3IwLGNdPVtyJzAsY11cbiAgICAgIFsxIDIgMyAxXSBbcjEsY10gW3InMSxjXVxuICAgICAgWzEgMSAyIDNdIFtyMixjXSBbcicyLGNdXG4gICAgICBbMyAxIDEgMl0gW3IzLGNdIFtyJzMsY11cblxuICAgICAgcjAsIHIxLCByMiwgYW5kIHIzIGFyZSBlYWNoIDEgYnl0ZSBvZiBvbmUgb2YgdGhlIHdvcmRzIGluIHRoZVxuICAgICAgc3RhdGUgKGEgY29sdW1uKS4gVG8gZG8gbWF0cml4IG11bHRpcGxpY2F0aW9uIGZvciBlYWNoIG1peGVkXG4gICAgICBjb2x1bW4gYycgd2UgbXVsdGlwbHkgdGhlIGNvcnJlc3BvbmRpbmcgcm93IGZyb20gdGhlIGxlZnQgbWF0cml4XG4gICAgICB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBmcm9tIHRoZSByaWdodCBtYXRyaXguIEluIHRvdGFsLCB3ZVxuICAgICAgZ2V0IDQgZXF1YXRpb25zOlxuXG4gICAgICByMCxjJyA9IDIqcjAsYyArIDMqcjEsYyArIDEqcjIsYyArIDEqcjMsY1xuICAgICAgcjEsYycgPSAxKnIwLGMgKyAyKnIxLGMgKyAzKnIyLGMgKyAxKnIzLGNcbiAgICAgIHIyLGMnID0gMSpyMCxjICsgMSpyMSxjICsgMipyMixjICsgMypyMyxjXG4gICAgICByMyxjJyA9IDMqcjAsYyArIDEqcjEsYyArIDEqcjIsYyArIDIqcjMsY1xuXG4gICAgICBBcyB1c3VhbCwgdGhlIG11bHRpcGxpY2F0aW9uIGlzIGFzIHByZXZpb3VzbHkgZGVmaW5lZCBhbmQgdGhlXG4gICAgICBhZGRpdGlvbiBpcyBYT1IuIEluIG9yZGVyIHRvIG9wdGltaXplIG1peGluZyBjb2x1bW5zIHdlIGNhbiBzdG9yZVxuICAgICAgdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdHMgaW4gdGFibGVzLiBJZiB5b3UgdGhpbmsgb2YgdGhlIHdob2xlXG4gICAgICBjb2x1bW4gYXMgYSB3b3JkIChpdCBtaWdodCBoZWxwIHRvIHZpc3VhbGl6ZSBieSBtZW50YWxseSByb3RhdGluZ1xuICAgICAgdGhlIGVxdWF0aW9ucyBhYm92ZSBieSBjb3VudGVyY2xvY2t3aXNlIDkwIGRlZ3JlZXMpIHRoZW4geW91IGNhblxuICAgICAgc2VlIHRoYXQgaXQgd291bGQgYmUgdXNlZnVsIHRvIG1hcCB0aGUgbXVsdGlwbGljYXRpb25zIHBlcmZvcm1lZCBvblxuICAgICAgZWFjaCBieXRlIChyMCwgcjEsIHIyLCByMykgb250byBhIHdvcmQgYXMgd2VsbC4gRm9yIGluc3RhbmNlLCB3ZVxuICAgICAgY291bGQgbWFwIDIqcjAsMSpyMCwxKnIwLDMqcjAgb250byBhIHdvcmQgYnkgc3RvcmluZyAyKnIwIGluIHRoZVxuICAgICAgaGlnaGVzdCA4IGJpdHMgYW5kIDMqcjAgaW4gdGhlIGxvd2VzdCA4IGJpdHMgKHdpdGggdGhlIG90aGVyIHR3b1xuICAgICAgcmVzcGVjdGl2ZWx5IGluIHRoZSBtaWRkbGUpLiBUaGlzIG1lYW5zIHRoYXQgYSB0YWJsZSBjYW4gYmVcbiAgICAgIGNvbnN0cnVjdGVkIHRoYXQgdXNlcyByMCBhcyBhbiBpbmRleCB0byB0aGUgd29yZC4gV2UgY2FuIGRvIHRoZVxuICAgICAgc2FtZSB3aXRoIHIxLCByMiwgYW5kIHIzLCBjcmVhdGluZyBhIHRvdGFsIG9mIDQgdGFibGVzLlxuXG4gICAgICBUbyBjb25zdHJ1Y3QgYSBmdWxsIGMnLCB3ZSBjYW4ganVzdCBsb29rIHVwIGVhY2ggYnl0ZSBvZiBjIGluXG4gICAgICB0aGVpciByZXNwZWN0aXZlIHRhYmxlcyBhbmQgWE9SIHRoZSByZXN1bHRzIHRvZ2V0aGVyLlxuXG4gICAgICBBbHNvLCB0byBidWlsZCBlYWNoIHRhYmxlIHdlIG9ubHkgaGF2ZSB0byBjYWxjdWxhdGUgdGhlIHdvcmRcbiAgICAgIGZvciAyLDEsMSwzIGZvciBldmVyeSBieXRlIC4uLiB3aGljaCB3ZSBjYW4gZG8gb24gZWFjaCBpdGVyYXRpb25cbiAgICAgIG9mIHRoaXMgbG9vcCBzaW5jZSB3ZSB3aWxsIGl0ZXJhdGUgb3ZlciBldmVyeSBieXRlLiBBZnRlciB3ZSBoYXZlXG4gICAgICBjYWxjdWxhdGVkIDIsMSwxLDMgd2UgY2FuIGdldCB0aGUgcmVzdWx0cyBmb3IgdGhlIG90aGVyIHRhYmxlc1xuICAgICAgYnkgY3ljbGluZyB0aGUgYnl0ZSBhdCB0aGUgZW5kIHRvIHRoZSBiZWdpbm5pbmcuIEZvciBpbnN0YW5jZVxuICAgICAgd2UgY2FuIHRha2UgdGhlIHJlc3VsdCBvZiB0YWJsZSAyLDEsMSwzIGFuZCBwcm9kdWNlIHRhYmxlIDMsMiwxLDFcbiAgICAgIGJ5IG1vdmluZyB0aGUgcmlnaHQgbW9zdCBieXRlIHRvIHRoZSBsZWZ0IG1vc3QgcG9zaXRpb24ganVzdCBsaWtlXG4gICAgICBob3cgeW91IGNhbiBpbWFnaW5lIHRoZSAzIG1vdmVkIG91dCBvZiAyLDEsMSwzIGFuZCB0byB0aGUgZnJvbnRcbiAgICAgIHRvIHByb2R1Y2UgMywyLDEsMS5cblxuICAgICAgVGhlcmUgaXMgYW5vdGhlciBvcHRpbWl6YXRpb24gaW4gdGhhdCB0aGUgc2FtZSBtdWx0aXBsZXMgb2ZcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQgd2UgbmVlZCBpbiBvcmRlciB0byBhZHZhbmNlIG91ciBnZW5lcmF0b3JcbiAgICAgIHRvIHRoZSBuZXh0IGl0ZXJhdGlvbiBjYW4gYmUgcmV1c2VkIGluIHBlcmZvcm1pbmcgdGhlIDIsMSwxLDNcbiAgICAgIGNhbGN1bGF0aW9uLiBXZSBhbHNvIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtaXggY29sdW1uIHRhYmxlcyxcbiAgICAgIHdpdGggZSw5LGQsYiBiZWluZyB0aGUgaW52ZXJzZSBvZiAyLDEsMSwzLlxuXG4gICAgICBXaGVuIHdlJ3JlIGRvbmUsIGFuZCB3ZSBuZWVkIHRvIGFjdHVhbGx5IG1peCBjb2x1bW5zLCB0aGUgZmlyc3RcbiAgICAgIGJ5dGUgb2YgZWFjaCBzdGF0ZSB3b3JkIHNob3VsZCBiZSBwdXQgdGhyb3VnaCBtaXhbMF0gKDIsMSwxLDMpLFxuICAgICAgdGhlIHNlY29uZCB0aHJvdWdoIG1peFsxXSAoMywyLDEsMSkgYW5kIHNvIGZvcnRoLiBUaGVuIHRoZXkgc2hvdWxkXG4gICAgICBiZSBYT1InZCB0b2dldGhlciB0byBwcm9kdWNlIHRoZSBmdWxseSBtaXhlZCBjb2x1bW4uXG4gICAgKi9cblxuICAgIC8vIGNhbGN1bGF0ZSBtaXggYW5kIGltaXggdGFibGUgdmFsdWVzXG4gICAgc3gyID0geHRpbWVbc3hdO1xuICAgIGUyID0geHRpbWVbZV07XG4gICAgZTQgPSB4dGltZVtlMl07XG4gICAgZTggPSB4dGltZVtlNF07XG4gICAgbWUgPVxuICAgICAgKHN4MiA8PCAyNCkgXiAgLy8gMlxuICAgICAgKHN4IDw8IDE2KSBeICAgLy8gMVxuICAgICAgKHN4IDw8IDgpIF4gICAgLy8gMVxuICAgICAgKHN4IF4gc3gyKTsgICAgLy8gM1xuICAgIGltZSA9XG4gICAgICAoZTIgXiBlNCBeIGU4KSA8PCAyNCBeICAvLyBFICgxNClcbiAgICAgIChlIF4gZTgpIDw8IDE2IF4gICAgICAgIC8vIDlcbiAgICAgIChlIF4gZTQgXiBlOCkgPDwgOCBeICAgIC8vIEQgKDEzKVxuICAgICAgKGUgXiBlMiBeIGU4KTsgICAgICAgICAgLy8gQiAoMTEpXG4gICAgLy8gcHJvZHVjZSBlYWNoIG9mIHRoZSBtaXggdGFibGVzIGJ5IHJvdGF0aW5nIHRoZSAyLDEsMSwzIHZhbHVlXG4gICAgZm9yKHZhciBuID0gMDsgbiA8IDQ7ICsrbikge1xuICAgICAgbWl4W25dW2VdID0gbWU7XG4gICAgICBpbWl4W25dW3N4XSA9IGltZTtcbiAgICAgIC8vIGN5Y2xlIHRoZSByaWdodCBtb3N0IGJ5dGUgdG8gdGhlIGxlZnQgbW9zdCBwb3NpdGlvblxuICAgICAgLy8gaWU6IDIsMSwxLDMgYmVjb21lcyAzLDIsMSwxXG4gICAgICBtZSA9IG1lIDw8IDI0IHwgbWUgPj4+IDg7XG4gICAgICBpbWUgPSBpbWUgPDwgMjQgfCBpbWUgPj4+IDg7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG5leHQgZWxlbWVudCBhbmQgaW52ZXJzZVxuICAgIGlmKGUgPT09IDApIHtcbiAgICAgIC8vIDEgaXMgdGhlIGludmVyc2Ugb2YgMVxuICAgICAgZSA9IGVpID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZSA9IDJlICsgMioyKjIqKDEwZSkpID0gbXVsdGlwbHkgZSBieSA4MiAoY2hvc2VuIGdlbmVyYXRvcilcbiAgICAgIC8vIGVpID0gZWkgKyAyKjIqZWkgPSBtdWx0aXBseSBlaSBieSA1IChpbnZlcnNlIGdlbmVyYXRvcilcbiAgICAgIGUgPSBlMiBeIHh0aW1lW3h0aW1lW3h0aW1lW2UyIF4gZThdXV07XG4gICAgICBlaSBePSB4dGltZVt4dGltZVtlaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBzY2hlZHVsZSB1c2luZyB0aGUgQUVTIGtleSBleHBhbnNpb24gYWxnb3JpdGhtLlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHRha2VzIHRoZSBDaXBoZXIgS2V5LCBLLCBhbmQgcGVyZm9ybXMgYSBLZXkgRXhwYW5zaW9uXG4gKiByb3V0aW5lIHRvIGdlbmVyYXRlIGEga2V5IHNjaGVkdWxlLiBUaGUgS2V5IEV4cGFuc2lvbiBnZW5lcmF0ZXMgYSB0b3RhbFxuICogb2YgTmIqKE5yICsgMSkgd29yZHM6IHRoZSBhbGdvcml0aG0gcmVxdWlyZXMgYW4gaW5pdGlhbCBzZXQgb2YgTmIgd29yZHMsXG4gKiBhbmQgZWFjaCBvZiB0aGUgTnIgcm91bmRzIHJlcXVpcmVzIE5iIHdvcmRzIG9mIGtleSBkYXRhLiBUaGUgcmVzdWx0aW5nXG4gKiBrZXkgc2NoZWR1bGUgY29uc2lzdHMgb2YgYSBsaW5lYXIgYXJyYXkgb2YgNC1ieXRlIHdvcmRzLCBkZW5vdGVkIFt3aSBdLFxuICogd2l0aCBpIGluIHRoZSByYW5nZSAwIDw9IGkgPCBOYihOciArIDEpLlxuICpcbiAqIEtleUV4cGFuc2lvbihieXRlIGtleVs0Kk5rXSwgd29yZCB3W05iKihOcisxKV0sIE5rKVxuICogQUVTLTEyOCAoTmI9NCwgTms9NCwgTnI9MTApXG4gKiBBRVMtMTkyIChOYj00LCBOaz02LCBOcj0xMilcbiAqIEFFUy0yNTYgKE5iPTQsIE5rPTgsIE5yPTE0KVxuICogTm90ZTogTnI9TmsrNi5cbiAqXG4gKiBOYiBpcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgKDMyLWJpdCB3b3JkcykgY29tcHJpc2luZyB0aGUgU3RhdGUgKG9yXG4gKiBudW1iZXIgb2YgYnl0ZXMgaW4gYSBibG9jaykuIEZvciBBRVMsIE5iPTQuXG4gKlxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHNjaGVkdWxlIChhcyBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMpLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBtb2RpZnkgdGhlIGtleSBzY2hlZHVsZSB0byBkZWNyeXB0LCBmYWxzZSBub3QgdG8uXG4gKlxuICogQHJldHVybiB0aGUgZ2VuZXJhdGVkIGtleSBzY2hlZHVsZS5cbiAqL1xuZnVuY3Rpb24gX2V4cGFuZEtleShrZXksIGRlY3J5cHQpIHtcbiAgLy8gY29weSB0aGUga2V5J3Mgd29yZHMgdG8gaW5pdGlhbGl6ZSB0aGUga2V5IHNjaGVkdWxlXG4gIHZhciB3ID0ga2V5LnNsaWNlKDApO1xuXG4gIC8qIFJvdFdvcmQoKSB3aWxsIHJvdGF0ZSBhIHdvcmQsIG1vdmluZyB0aGUgZmlyc3QgYnl0ZSB0byB0aGUgbGFzdFxuICAgIGJ5dGUncyBwb3NpdGlvbiAoc2hpZnRpbmcgdGhlIG90aGVyIGJ5dGVzIGxlZnQpLlxuXG4gICAgV2Ugd2lsbCBiZSBnZXR0aW5nIHRoZSB2YWx1ZSBvZiBSY29uIGF0IGkgLyBOay4gJ2knIHdpbGwgaXRlcmF0ZVxuICAgIGZyb20gTmsgdG8gKE5iICogTnIrMSkuIE5rID0gNCAoNCBieXRlIGtleSksIE5iID0gNCAoNCB3b3JkcyBpblxuICAgIGEgYmxvY2spLCBOciA9IE5rICsgNiAoMTApLiBUaGVyZWZvcmUgJ2knIHdpbGwgaXRlcmF0ZSBmcm9tXG4gICAgNCB0byA0NCAoZXhjbHVzaXZlKS4gRWFjaCB0aW1lIHdlIGl0ZXJhdGUgNCB0aW1lcywgaSAvIE5rIHdpbGxcbiAgICBpbmNyZWFzZSBieSAxLiBXZSB1c2UgYSBjb3VudGVyIGlOayB0byBrZWVwIHRyYWNrIG9mIHRoaXMuXG4gICAqL1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIHJvdW5kcyBleHBhbmRpbmcgdGhlIGtleVxuICB2YXIgdGVtcCwgaU5rID0gMTtcbiAgdmFyIE5rID0gdy5sZW5ndGg7XG4gIHZhciBOcjEgPSBOayArIDYgKyAxO1xuICB2YXIgZW5kID0gTmIgKiBOcjE7XG4gIGZvcih2YXIgaSA9IE5rOyBpIDwgZW5kOyArK2kpIHtcbiAgICB0ZW1wID0gd1tpIC0gMV07XG4gICAgaWYoaSAlIE5rID09PSAwKSB7XG4gICAgICAvLyB0ZW1wID0gU3ViV29yZChSb3RXb3JkKHRlbXApKSBeIFJjb25baSAvIE5rXVxuICAgICAgdGVtcCA9XG4gICAgICAgIHNib3hbdGVtcCA+Pj4gMTYgJiAyNTVdIDw8IDI0IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiA4ICYgMjU1XSA8PCAxNiBeXG4gICAgICAgIHNib3hbdGVtcCAmIDI1NV0gPDwgOCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gMjRdIF4gKHJjb25baU5rXSA8PCAyNCk7XG4gICAgICBpTmsrKztcbiAgICB9IGVsc2UgaWYoTmsgPiA2ICYmIChpICUgTmsgPT09IDQpKSB7XG4gICAgICAvLyB0ZW1wID0gU3ViV29yZCh0ZW1wKVxuICAgICAgdGVtcCA9XG4gICAgICAgIHNib3hbdGVtcCA+Pj4gMjRdIDw8IDI0IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiAxNiAmIDI1NV0gPDwgMTYgXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDggJiAyNTVdIDw8IDggXlxuICAgICAgICBzYm94W3RlbXAgJiAyNTVdO1xuICAgIH1cbiAgICB3W2ldID0gd1tpIC0gTmtdIF4gdGVtcDtcbiAgfVxuXG4gIC8qIFdoZW4gd2UgYXJlIHVwZGF0aW5nIGEgY2lwaGVyIGJsb2NrIHdlIGFsd2F5cyB1c2UgdGhlIGNvZGUgcGF0aCBmb3JcbiAgICAgZW5jcnlwdGlvbiB3aGV0aGVyIHdlIGFyZSBkZWNyeXB0aW5nIG9yIG5vdCAodG8gc2hvcnRlbiBjb2RlIGFuZFxuICAgICBzaW1wbGlmeSB0aGUgZ2VuZXJhdGlvbiBvZiBsb29rIHVwIHRhYmxlcykuIEhvd2V2ZXIsIGJlY2F1c2UgdGhlcmVcbiAgICAgYXJlIGRpZmZlcmVuY2VzIGluIHRoZSBkZWNyeXB0aW9uIGFsZ29yaXRobSwgb3RoZXIgdGhhbiBqdXN0IHN3YXBwaW5nXG4gICAgIGluIGRpZmZlcmVudCBsb29rIHVwIHRhYmxlcywgd2UgbXVzdCB0cmFuc2Zvcm0gb3VyIGtleSBzY2hlZHVsZSB0b1xuICAgICBhY2NvdW50IGZvciB0aGVzZSBjaGFuZ2VzOlxuXG4gICAgIDEuIFRoZSBkZWNyeXB0aW9uIGFsZ29yaXRobSBnZXRzIGl0cyBrZXkgcm91bmRzIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgIDIuIFRoZSBkZWNyeXB0aW9uIGFsZ29yaXRobSBhZGRzIHRoZSByb3VuZCBrZXkgYmVmb3JlIG1peGluZyBjb2x1bW5zXG4gICAgICAgaW5zdGVhZCBvZiBhZnRlcndhcmRzLlxuXG4gICAgIFdlIGRvbid0IG5lZWQgdG8gbW9kaWZ5IG91ciBrZXkgc2NoZWR1bGUgdG8gaGFuZGxlIHRoZSBmaXJzdCBjYXNlLFxuICAgICB3ZSBjYW4ganVzdCB0cmF2ZXJzZSB0aGUga2V5IHNjaGVkdWxlIGluIHJldmVyc2Ugb3JkZXIgd2hlbiBkZWNyeXB0aW5nLlxuXG4gICAgIFRoZSBzZWNvbmQgY2FzZSByZXF1aXJlcyBhIGxpdHRsZSB3b3JrLlxuXG4gICAgIFRoZSB0YWJsZXMgd2UgYnVpbHQgZm9yIHBlcmZvcm1pbmcgcm91bmRzIHdpbGwgdGFrZSBhbiBpbnB1dCBhbmQgdGhlblxuICAgICBwZXJmb3JtIFN1YkJ5dGVzKCkgYW5kIE1peENvbHVtbnMoKSBvciwgZm9yIHRoZSBkZWNyeXB0IHZlcnNpb24sXG4gICAgIEludlN1YkJ5dGVzKCkgYW5kIEludk1peENvbHVtbnMoKS4gQnV0IHRoZSBkZWNyeXB0IGFsZ29yaXRobSByZXF1aXJlc1xuICAgICB1cyB0byBBZGRSb3VuZEtleSgpIGJlZm9yZSBJbnZNaXhDb2x1bW5zKCkuIFRoaXMgbWVhbnMgd2UnbGwgbmVlZCB0b1xuICAgICBhcHBseSBzb21lIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgcm91bmQga2V5IHRvIGludmVyc2UtbWl4IGl0cyBjb2x1bW5zXG4gICAgIHNvIHRoZXknbGwgYmUgY29ycmVjdCBmb3IgbW92aW5nIEFkZFJvdW5kS2V5KCkgdG8gYWZ0ZXIgdGhlIHN0YXRlIGhhc1xuICAgICBoYWQgaXRzIGNvbHVtbnMgaW52ZXJzZS1taXhlZC5cblxuICAgICBUbyBpbnZlcnNlLW1peCB0aGUgY29sdW1ucyBvZiB0aGUgc3RhdGUgd2hlbiB3ZSdyZSBkZWNyeXB0aW5nIHdlIHVzZSBhXG4gICAgIGxvb2t1cCB0YWJsZSB0aGF0IHdpbGwgYXBwbHkgSW52U3ViQnl0ZXMoKSBhbmQgSW52TWl4Q29sdW1ucygpIGF0IHRoZVxuICAgICBzYW1lIHRpbWUuIEhvd2V2ZXIsIHRoZSByb3VuZCBrZXkncyBieXRlcyBhcmUgbm90IGludmVyc2Utc3Vic3RpdHV0ZWRcbiAgICAgaW4gdGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLiBUbyBnZXQgYXJvdW5kIHRoaXMgcHJvYmxlbSwgd2UgY2FuIGZpcnN0XG4gICAgIHN1YnN0aXR1dGUgdGhlIGJ5dGVzIGluIHRoZSByb3VuZCBrZXkgc28gdGhhdCB3aGVuIHdlIGFwcGx5IHRoZVxuICAgICB0cmFuc2Zvcm1hdGlvbiB2aWEgdGhlIEludlN1YkJ5dGVzKCkrSW52TWl4Q29sdW1ucygpIHRhYmxlLCBpdCB3aWxsXG4gICAgIHVuZG8gb3VyIHN1YnN0aXR1dGlvbiBsZWF2aW5nIHVzIHdpdGggdGhlIG9yaWdpbmFsIHZhbHVlIHRoYXQgd2VcbiAgICAgd2FudCAtLSBhbmQgdGhlbiBpbnZlcnNlLW1peCB0aGF0IHZhbHVlLlxuXG4gICAgIFRoaXMgY2hhbmdlIHdpbGwgY29ycmVjdGx5IGFsdGVyIG91ciBrZXkgc2NoZWR1bGUgc28gdGhhdCB3ZSBjYW4gWE9SXG4gICAgIGVhY2ggcm91bmQga2V5IHdpdGggb3VyIGFscmVhZHkgdHJhbnNmb3JtZWQgZGVjcnlwdGlvbiBzdGF0ZS4gVGhpc1xuICAgICBhbGxvd3MgdXMgdG8gdXNlIHRoZSBzYW1lIGNvZGUgcGF0aCBhcyB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0uXG5cbiAgICAgV2UgbWFrZSBvbmUgbW9yZSBjaGFuZ2UgdG8gdGhlIGRlY3J5cHRpb24ga2V5LiBTaW5jZSB0aGUgZGVjcnlwdGlvblxuICAgICBhbGdvcml0aG0gcnVucyBpbiByZXZlcnNlIGZyb20gdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtLCB3ZSByZXZlcnNlXG4gICAgIHRoZSBvcmRlciBvZiB0aGUgcm91bmQga2V5cyB0byBhdm9pZCBoYXZpbmcgdG8gaXRlcmF0ZSBvdmVyIHRoZSBrZXlcbiAgICAgc2NoZWR1bGUgYmFja3dhcmRzIHdoZW4gcnVubmluZyB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gbGF0ZXIgaW5cbiAgICAgZGVjcnlwdGlvbiBtb2RlLiBJbiBhZGRpdGlvbiB0byByZXZlcnNpbmcgdGhlIG9yZGVyIG9mIHRoZSByb3VuZCBrZXlzLFxuICAgICB3ZSBhbHNvIHN3YXAgZWFjaCByb3VuZCBrZXkncyAybmQgYW5kIDR0aCByb3dzLiBTZWUgdGhlIGNvbW1lbnRzXG4gICAgIHNlY3Rpb24gd2hlcmUgcm91bmRzIGFyZSBwZXJmb3JtZWQgZm9yIG1vcmUgZGV0YWlscyBhYm91dCB3aHkgdGhpcyBpc1xuICAgICBkb25lLiBUaGVzZSBjaGFuZ2VzIGFyZSBkb25lIGlubGluZSB3aXRoIHRoZSBvdGhlciBzdWJzdGl0dXRpb25cbiAgICAgZGVzY3JpYmVkIGFib3ZlLlxuICAqL1xuICBpZihkZWNyeXB0KSB7XG4gICAgdmFyIHRtcDtcbiAgICB2YXIgbTAgPSBpbWl4WzBdO1xuICAgIHZhciBtMSA9IGltaXhbMV07XG4gICAgdmFyIG0yID0gaW1peFsyXTtcbiAgICB2YXIgbTMgPSBpbWl4WzNdO1xuICAgIHZhciB3bmV3ID0gdy5zbGljZSgwKTtcbiAgICBlbmQgPSB3Lmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCB3aSA9IGVuZCAtIE5iOyBpIDwgZW5kOyBpICs9IE5iLCB3aSAtPSBOYikge1xuICAgICAgLy8gZG8gbm90IHN1YiB0aGUgZmlyc3Qgb3IgbGFzdCByb3VuZCBrZXkgKHJvdW5kIGtleXMgYXJlIE5iXG4gICAgICAvLyB3b3JkcykgYXMgbm8gY29sdW1uIG1peGluZyBpcyBwZXJmb3JtZWQgYmVmb3JlIHRoZXkgYXJlIGFkZGVkLFxuICAgICAgLy8gYnV0IGRvIGNoYW5nZSB0aGUga2V5IG9yZGVyXG4gICAgICBpZihpID09PSAwIHx8IGkgPT09IChlbmQgLSBOYikpIHtcbiAgICAgICAgd25ld1tpXSA9IHdbd2ldO1xuICAgICAgICB3bmV3W2kgKyAxXSA9IHdbd2kgKyAzXTtcbiAgICAgICAgd25ld1tpICsgMl0gPSB3W3dpICsgMl07XG4gICAgICAgIHduZXdbaSArIDNdID0gd1t3aSArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3Vic3RpdHV0ZSBlYWNoIHJvdW5kIGtleSBieXRlIGJlY2F1c2UgdGhlIGludmVyc2UtbWl4XG4gICAgICAgIC8vIHRhYmxlIHdpbGwgaW52ZXJzZS1zdWJzdGl0dXRlIGl0IChlZmZlY3RpdmVseSBjYW5jZWwgdGhlXG4gICAgICAgIC8vIHN1YnN0aXR1dGlvbiBiZWNhdXNlIHJvdW5kIGtleSBieXRlcyBhcmVuJ3Qgc3ViJ2QgaW5cbiAgICAgICAgLy8gZGVjcnlwdGlvbiBtb2RlKSBhbmQgc3dhcCBpbmRleGVzIDMgYW5kIDFcbiAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IE5iOyArK24pIHtcbiAgICAgICAgICB0bXAgPSB3W3dpICsgbl07XG4gICAgICAgICAgd25ld1tpICsgKDMmLW4pXSA9XG4gICAgICAgICAgICBtMFtzYm94W3RtcCA+Pj4gMjRdXSBeXG4gICAgICAgICAgICBtMVtzYm94W3RtcCA+Pj4gMTYgJiAyNTVdXSBeXG4gICAgICAgICAgICBtMltzYm94W3RtcCA+Pj4gOCAmIDI1NV1dIF5cbiAgICAgICAgICAgIG0zW3Nib3hbdG1wICYgMjU1XV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdyA9IHduZXc7XG4gIH1cblxuICByZXR1cm4gdztcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgc2luZ2xlIGJsb2NrICgxNiBieXRlcykgdXNpbmcgQUVTLiBUaGUgdXBkYXRlIHdpbGwgZWl0aGVyXG4gKiBlbmNyeXB0IG9yIGRlY3J5cHQgdGhlIGJsb2NrLlxuICpcbiAqIEBwYXJhbSB3IHRoZSBrZXkgc2NoZWR1bGUuXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGlucHV0IGJsb2NrIChhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMpLlxuICogQHBhcmFtIG91dHB1dCB0aGUgdXBkYXRlZCBvdXRwdXQgYmxvY2suXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIGRlY3J5cHQgdGhlIGJsb2NrLCBmYWxzZSB0byBlbmNyeXB0IGl0LlxuICovXG5mdW5jdGlvbiBfdXBkYXRlQmxvY2sodywgaW5wdXQsIG91dHB1dCwgZGVjcnlwdCkge1xuICAvKlxuICBDaXBoZXIoYnl0ZSBpbls0Kk5iXSwgYnl0ZSBvdXRbNCpOYl0sIHdvcmQgd1tOYiooTnIrMSldKVxuICBiZWdpblxuICAgIGJ5dGUgc3RhdGVbNCxOYl1cbiAgICBzdGF0ZSA9IGluXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbMCwgTmItMV0pXG4gICAgZm9yIHJvdW5kID0gMSBzdGVwIDEgdG8gTnItMVxuICAgICAgU3ViQnl0ZXMoc3RhdGUpXG4gICAgICBTaGlmdFJvd3Moc3RhdGUpXG4gICAgICBNaXhDb2x1bW5zKHN0YXRlKVxuICAgICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbcm91bmQqTmIsIChyb3VuZCsxKSpOYi0xXSlcbiAgICBlbmQgZm9yXG4gICAgU3ViQnl0ZXMoc3RhdGUpXG4gICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W05yKk5iLCAoTnIrMSkqTmItMV0pXG4gICAgb3V0ID0gc3RhdGVcbiAgZW5kXG5cbiAgSW52Q2lwaGVyKGJ5dGUgaW5bNCpOYl0sIGJ5dGUgb3V0WzQqTmJdLCB3b3JkIHdbTmIqKE5yKzEpXSlcbiAgYmVnaW5cbiAgICBieXRlIHN0YXRlWzQsTmJdXG4gICAgc3RhdGUgPSBpblxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W05yKk5iLCAoTnIrMSkqTmItMV0pXG4gICAgZm9yIHJvdW5kID0gTnItMSBzdGVwIC0xIGRvd250byAxXG4gICAgICBJbnZTaGlmdFJvd3Moc3RhdGUpXG4gICAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W3JvdW5kKk5iLCAocm91bmQrMSkqTmItMV0pXG4gICAgICBJbnZNaXhDb2x1bW5zKHN0YXRlKVxuICAgIGVuZCBmb3JcbiAgICBJbnZTaGlmdFJvd3Moc3RhdGUpXG4gICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbMCwgTmItMV0pXG4gICAgb3V0ID0gc3RhdGVcbiAgZW5kXG4gICovXG5cbiAgLy8gRW5jcnlwdDogQWRkUm91bmRLZXkoc3RhdGUsIHdbMCwgTmItMV0pXG4gIC8vIERlY3J5cHQ6IEFkZFJvdW5kS2V5KHN0YXRlLCB3W05yKk5iLCAoTnIrMSkqTmItMV0pXG4gIHZhciBOciA9IHcubGVuZ3RoIC8gNCAtIDE7XG4gIHZhciBtMCwgbTEsIG0yLCBtMywgc3ViO1xuICBpZihkZWNyeXB0KSB7XG4gICAgbTAgPSBpbWl4WzBdO1xuICAgIG0xID0gaW1peFsxXTtcbiAgICBtMiA9IGltaXhbMl07XG4gICAgbTMgPSBpbWl4WzNdO1xuICAgIHN1YiA9IGlzYm94O1xuICB9IGVsc2Uge1xuICAgIG0wID0gbWl4WzBdO1xuICAgIG0xID0gbWl4WzFdO1xuICAgIG0yID0gbWl4WzJdO1xuICAgIG0zID0gbWl4WzNdO1xuICAgIHN1YiA9IHNib3g7XG4gIH1cbiAgdmFyIGEsIGIsIGMsIGQsIGEyLCBiMiwgYzI7XG4gIGEgPSBpbnB1dFswXSBeIHdbMF07XG4gIGIgPSBpbnB1dFtkZWNyeXB0ID8gMyA6IDFdIF4gd1sxXTtcbiAgYyA9IGlucHV0WzJdIF4gd1syXTtcbiAgZCA9IGlucHV0W2RlY3J5cHQgPyAxIDogM10gXiB3WzNdO1xuICB2YXIgaSA9IDM7XG5cbiAgLyogSW4gb3JkZXIgdG8gc2hhcmUgY29kZSB3ZSBmb2xsb3cgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHdoZW4gYm90aFxuICAgIGVuY3J5cHRpbmcgYW5kIGRlY3J5cHRpbmcuIFRvIGFjY291bnQgZm9yIHRoZSBjaGFuZ2VzIHJlcXVpcmVkIGluIHRoZVxuICAgIGRlY3J5cHRpb24gYWxnb3JpdGhtLCB3ZSB1c2UgZGlmZmVyZW50IGxvb2t1cCB0YWJsZXMgd2hlbiBkZWNyeXB0aW5nXG4gICAgYW5kIHVzZSBhIG1vZGlmaWVkIGtleSBzY2hlZHVsZSB0byBhY2NvdW50IGZvciB0aGUgZGlmZmVyZW5jZSBpbiB0aGVcbiAgICBvcmRlciBvZiB0cmFuc2Zvcm1hdGlvbnMgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgcm91bmRzLiBXZSBhbHNvIGdldFxuICAgIGtleSByb3VuZHMgaW4gcmV2ZXJzZSBvcmRlciAocmVsYXRpdmUgdG8gZW5jcnlwdGlvbikuICovXG4gIGZvcih2YXIgcm91bmQgPSAxOyByb3VuZCA8IE5yOyArK3JvdW5kKSB7XG4gICAgLyogQXMgZGVzY3JpYmVkIGFib3ZlLCB3ZSdsbCBiZSB1c2luZyB0YWJsZSBsb29rdXBzIHRvIHBlcmZvcm0gdGhlXG4gICAgICBjb2x1bW4gbWl4aW5nLiBFYWNoIGNvbHVtbiBpcyBzdG9yZWQgYXMgYSB3b3JkIGluIHRoZSBzdGF0ZSAodGhlXG4gICAgICBhcnJheSAnaW5wdXQnIGhhcyBvbmUgY29sdW1uIGFzIGEgd29yZCBhdCBlYWNoIGluZGV4KS4gSW4gb3JkZXIgdG9cbiAgICAgIG1peCBhIGNvbHVtbiwgd2UgcGVyZm9ybSB0aGVzZSB0cmFuc2Zvcm1hdGlvbnMgb24gZWFjaCByb3cgaW4gYyxcbiAgICAgIHdoaWNoIGlzIDEgYnl0ZSBpbiBlYWNoIHdvcmQuIFRoZSBuZXcgY29sdW1uIGZvciBjMCBpcyBjJzA6XG5cbiAgICAgICAgICAgICAgIG0wICAgICAgbTEgICAgICBtMiAgICAgIG0zXG4gICAgICByMCxjJzAgPSAyKnIwLGMwICsgMypyMSxjMCArIDEqcjIsYzAgKyAxKnIzLGMwXG4gICAgICByMSxjJzAgPSAxKnIwLGMwICsgMipyMSxjMCArIDMqcjIsYzAgKyAxKnIzLGMwXG4gICAgICByMixjJzAgPSAxKnIwLGMwICsgMSpyMSxjMCArIDIqcjIsYzAgKyAzKnIzLGMwXG4gICAgICByMyxjJzAgPSAzKnIwLGMwICsgMSpyMSxjMCArIDEqcjIsYzAgKyAyKnIzLGMwXG5cbiAgICAgIFNvIHVzaW5nIG1peCB0YWJsZXMgd2hlcmUgYzAgaXMgYSB3b3JkIHdpdGggcjAgYmVpbmcgaXRzIHVwcGVyXG4gICAgICA4IGJpdHMgYW5kIHIzIGJlaW5nIGl0cyBsb3dlciA4IGJpdHM6XG5cbiAgICAgIG0wW2MwID4+IDI0XSB3aWxsIHlpZWxkIHRoaXMgd29yZDogWzIqcjAsMSpyMCwxKnIwLDMqcjBdXG4gICAgICAuLi5cbiAgICAgIG0zW2MwICYgMjU1XSB3aWxsIHlpZWxkIHRoaXMgd29yZDogWzEqcjMsMSpyMywzKnIzLDIqcjNdXG5cbiAgICAgIFRoZXJlZm9yZSB0byBtaXggdGhlIGNvbHVtbnMgaW4gZWFjaCB3b3JkIGluIHRoZSBzdGF0ZSB3ZVxuICAgICAgZG8gdGhlIGZvbGxvd2luZyAoJiAyNTUgb21pdHRlZCBmb3IgYnJldml0eSk6XG4gICAgICBjJzAscjAgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIxID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMiA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjMgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuXG4gICAgICBIb3dldmVyLCBiZWZvcmUgbWl4aW5nLCB0aGUgYWxnb3JpdGhtIHJlcXVpcmVzIHVzIHRvIHBlcmZvcm1cbiAgICAgIFNoaWZ0Um93cygpLiBUaGUgU2hpZnRSb3dzKCkgdHJhbnNmb3JtYXRpb24gY3ljbGljYWxseSBzaGlmdHMgdGhlXG4gICAgICBsYXN0IDMgcm93cyBvZiB0aGUgc3RhdGUgb3ZlciBkaWZmZXJlbnQgb2Zmc2V0cy4gVGhlIGZpcnN0IHJvd1xuICAgICAgKHIgPSAwKSBpcyBub3Qgc2hpZnRlZC5cblxuICAgICAgcydfcixjID0gc19yLChjICsgc2hpZnQociwgTmIpIG1vZCBOYlxuICAgICAgZm9yIDAgPCByIDwgNCBhbmQgMCA8PSBjIDwgTmIgYW5kXG4gICAgICBzaGlmdCgxLCA0KSA9IDFcbiAgICAgIHNoaWZ0KDIsIDQpID0gMlxuICAgICAgc2hpZnQoMywgNCkgPSAzLlxuXG4gICAgICBUaGlzIGNhdXNlcyB0aGUgZmlyc3QgYnl0ZSBpbiByID0gMSB0byBiZSBtb3ZlZCB0byB0aGUgZW5kIG9mXG4gICAgICB0aGUgcm93LCB0aGUgZmlyc3QgMiBieXRlcyBpbiByID0gMiB0byBiZSBtb3ZlZCB0byB0aGUgZW5kIG9mXG4gICAgICB0aGUgcm93LCB0aGUgZmlyc3QgMyBieXRlcyBpbiByID0gMyB0byBiZSBtb3ZlZCB0byB0aGUgZW5kIG9mXG4gICAgICB0aGUgcm93OlxuXG4gICAgICByMTogW2MwIGMxIGMyIGMzXSA9PiBbYzEgYzIgYzMgYzBdXG4gICAgICByMjogW2MwIGMxIGMyIGMzXSAgICBbYzIgYzMgYzAgYzFdXG4gICAgICByMzogW2MwIGMxIGMyIGMzXSAgICBbYzMgYzAgYzEgYzJdXG5cbiAgICAgIFdlIGNhbiBtYWtlIHRoZXNlIHN1YnN0aXR1dGlvbnMgaW5saW5lIHdpdGggb3VyIGNvbHVtbiBtaXhpbmcgdG9cbiAgICAgIGdlbmVyYXRlIGFuIHVwZGF0ZWQgc2V0IG9mIGVxdWF0aW9ucyB0byBwcm9kdWNlIGVhY2ggd29yZCBpbiB0aGVcbiAgICAgIHN0YXRlIChub3RlIHRoZSBjb2x1bW5zIGhhdmUgY2hhbmdlZCBwb3NpdGlvbnMpOlxuXG4gICAgICBjMCBjMSBjMiBjMyA9PiBjMCBjMSBjMiBjM1xuICAgICAgYzAgYzEgYzIgYzMgICAgYzEgYzIgYzMgYzAgIChjeWNsZWQgMSBieXRlKVxuICAgICAgYzAgYzEgYzIgYzMgICAgYzIgYzMgYzAgYzEgIChjeWNsZWQgMiBieXRlcylcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMzIGMwIGMxIGMyICAoY3ljbGVkIDMgYnl0ZXMpXG5cbiAgICAgIFRoZXJlZm9yZTpcblxuICAgICAgYycwID0gMipyMCxjMCArIDMqcjEsYzEgKyAxKnIyLGMyICsgMSpyMyxjM1xuICAgICAgYycwID0gMSpyMCxjMCArIDIqcjEsYzEgKyAzKnIyLGMyICsgMSpyMyxjM1xuICAgICAgYycwID0gMSpyMCxjMCArIDEqcjEsYzEgKyAyKnIyLGMyICsgMypyMyxjM1xuICAgICAgYycwID0gMypyMCxjMCArIDEqcjEsYzEgKyAxKnIyLGMyICsgMipyMyxjM1xuXG4gICAgICBjJzEgPSAyKnIwLGMxICsgMypyMSxjMiArIDEqcjIsYzMgKyAxKnIzLGMwXG4gICAgICBjJzEgPSAxKnIwLGMxICsgMipyMSxjMiArIDMqcjIsYzMgKyAxKnIzLGMwXG4gICAgICBjJzEgPSAxKnIwLGMxICsgMSpyMSxjMiArIDIqcjIsYzMgKyAzKnIzLGMwXG4gICAgICBjJzEgPSAzKnIwLGMxICsgMSpyMSxjMiArIDEqcjIsYzMgKyAyKnIzLGMwXG5cbiAgICAgIC4uLiBhbmQgc28gZm9ydGggZm9yIGMnMiBhbmQgYyczLiBUaGUgaW1wb3J0YW50IGRpc3RpbmN0aW9uIGlzXG4gICAgICB0aGF0IHRoZSBjb2x1bW5zIGFyZSBjeWNsaW5nLCB3aXRoIGMwIGJlaW5nIHVzZWQgd2l0aCB0aGUgbTBcbiAgICAgIG1hcCB3aGVuIGNhbGN1bGF0aW5nIGMwLCBidXQgYzEgYmVpbmcgdXNlZCB3aXRoIHRoZSBtMCBtYXAgd2hlblxuICAgICAgY2FsY3VsYXRpbmcgYzEgLi4uIGFuZCBzbyBmb3J0aC5cblxuICAgICAgV2hlbiBwZXJmb3JtaW5nIHRoZSBpbnZlcnNlIHdlIHRyYW5zZm9ybSB0aGUgbWlycm9yIGltYWdlIGFuZFxuICAgICAgc2tpcCB0aGUgYm90dG9tIHJvdywgaW5zdGVhZCBvZiB0aGUgdG9wIG9uZSwgYW5kIG1vdmUgdXB3YXJkczpcblxuICAgICAgYzMgYzIgYzEgYzAgPT4gYzAgYzMgYzIgYzEgIChjeWNsZWQgMyBieXRlcykgKnNhbWUgYXMgZW5jcnlwdGlvblxuICAgICAgYzMgYzIgYzEgYzAgICAgYzEgYzAgYzMgYzIgIChjeWNsZWQgMiBieXRlcylcbiAgICAgIGMzIGMyIGMxIGMwICAgIGMyIGMxIGMwIGMzICAoY3ljbGVkIDEgYnl0ZSkgICpzYW1lIGFzIGVuY3J5cHRpb25cbiAgICAgIGMzIGMyIGMxIGMwICAgIGMzIGMyIGMxIGMwXG5cbiAgICAgIElmIHlvdSBjb21wYXJlIHRoZSByZXN1bHRpbmcgbWF0cmljZXMgZm9yIFNoaWZ0Um93cygpK01peENvbHVtbnMoKVxuICAgICAgYW5kIGZvciBJbnZTaGlmdFJvd3MoKStJbnZNaXhDb2x1bW5zKCkgdGhlIDJuZCBhbmQgNHRoIGNvbHVtbnMgYXJlXG4gICAgICBkaWZmZXJlbnQgKGluIGVuY3J5cHQgbW9kZSB2cy4gZGVjcnlwdCBtb2RlKS4gU28gaW4gb3JkZXIgdG8gdXNlXG4gICAgICB0aGUgc2FtZSBjb2RlIHRvIGhhbmRsZSBib3RoIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24sIHdlIHdpbGxcbiAgICAgIG5lZWQgdG8gZG8gc29tZSBtYXBwaW5nLlxuXG4gICAgICBJZiBpbiBlbmNyeXB0aW9uIG1vZGUgd2UgbGV0IGE9YzAsIGI9YzEsIGM9YzIsIGQ9YzMsIGFuZCByPE4+IGJlXG4gICAgICBhIHJvdyBudW1iZXIgaW4gdGhlIHN0YXRlLCB0aGVuIHRoZSByZXN1bHRpbmcgbWF0cml4IGluIGVuY3J5cHRpb25cbiAgICAgIG1vZGUgZm9yIGFwcGx5aW5nIHRoZSBhYm92ZSB0cmFuc2Zvcm1hdGlvbnMgd291bGQgYmU6XG5cbiAgICAgIHIxOiBhIGIgYyBkXG4gICAgICByMjogYiBjIGQgYVxuICAgICAgcjM6IGMgZCBhIGJcbiAgICAgIHI0OiBkIGEgYiBjXG5cbiAgICAgIElmIHdlIGRpZCB0aGUgc2FtZSBpbiBkZWNyeXB0aW9uIG1vZGUgd2Ugd291bGQgZ2V0OlxuXG4gICAgICByMTogYSBkIGMgYlxuICAgICAgcjI6IGIgYSBkIGNcbiAgICAgIHIzOiBjIGIgYSBkXG4gICAgICByNDogZCBjIGIgYVxuXG4gICAgICBJZiBpbnN0ZWFkIHdlIHN3YXAgZCBhbmQgYiAoc2V0IGI9YzMgYW5kIGQ9YzEpLCB0aGVuIHdlIGdldDpcblxuICAgICAgcjE6IGEgYiBjIGRcbiAgICAgIHIyOiBkIGEgYiBjXG4gICAgICByMzogYyBkIGEgYlxuICAgICAgcjQ6IGIgYyBkIGFcblxuICAgICAgTm93IHRoZSAxc3QgYW5kIDNyZCByb3dzIGFyZSB0aGUgc2FtZSBhcyB0aGUgZW5jcnlwdGlvbiBtYXRyaXguIEFsbFxuICAgICAgd2UgbmVlZCB0byBkbyB0aGVuIHRvIG1ha2UgdGhlIG1hcHBpbmcgZXhhY3RseSB0aGUgc2FtZSBpcyB0byBzd2FwXG4gICAgICB0aGUgMm5kIGFuZCA0dGggcm93cyB3aGVuIGluIGRlY3J5cHRpb24gbW9kZS4gVG8gZG8gdGhpcyB3aXRob3V0XG4gICAgICBoYXZpbmcgdG8gZG8gaXQgb24gZWFjaCBpdGVyYXRpb24sIHdlIHN3YXBwZWQgdGhlIDJuZCBhbmQgNHRoIHJvd3NcbiAgICAgIGluIHRoZSBkZWNyeXB0aW9uIGtleSBzY2hlZHVsZS4gV2UgYWxzbyBoYXZlIHRvIGRvIHRoZSBzd2FwIGFib3ZlXG4gICAgICB3aGVuIHdlIGZpcnN0IHB1bGwgaW4gdGhlIGlucHV0IGFuZCB3aGVuIHdlIHNldCB0aGUgZmluYWwgb3V0cHV0LiAqL1xuICAgIGEyID1cbiAgICAgIG0wW2EgPj4+IDI0XSBeXG4gICAgICBtMVtiID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYyA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbZCAmIDI1NV0gXiB3WysraV07XG4gICAgYjIgPVxuICAgICAgbTBbYiA+Pj4gMjRdIF5cbiAgICAgIG0xW2MgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMltkID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1thICYgMjU1XSBeIHdbKytpXTtcbiAgICBjMiA9XG4gICAgICBtMFtjID4+PiAyNF0gXlxuICAgICAgbTFbZCA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2EgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2IgJiAyNTVdIF4gd1srK2ldO1xuICAgIGQgPVxuICAgICAgbTBbZCA+Pj4gMjRdIF5cbiAgICAgIG0xW2EgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMltiID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tjICYgMjU1XSBeIHdbKytpXTtcbiAgICBhID0gYTI7XG4gICAgYiA9IGIyO1xuICAgIGMgPSBjMjtcbiAgfVxuXG4gIC8qXG4gICAgRW5jcnlwdDpcbiAgICBTdWJCeXRlcyhzdGF0ZSlcbiAgICBTaGlmdFJvd3Moc3RhdGUpXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcblxuICAgIERlY3J5cHQ6XG4gICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAgKi9cbiAgLy8gTm90ZTogcm93cyBhcmUgc2hpZnRlZCBpbmxpbmVcbiAgb3V0cHV0WzBdID1cbiAgICAoc3ViW2EgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYiA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltjID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltkICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFtkZWNyeXB0ID8gMyA6IDFdID1cbiAgICAoc3ViW2IgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYyA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltkID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YlthICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFsyXSA9XG4gICAgKHN1YltjID4+PiAyNF0gPDwgMjQpIF5cbiAgICAoc3ViW2QgPj4+IDE2ICYgMjU1XSA8PCAxNikgXlxuICAgIChzdWJbYSA+Pj4gOCAmIDI1NV0gPDwgOCkgXlxuICAgIChzdWJbYiAmIDI1NV0pIF4gd1srK2ldO1xuICBvdXRwdXRbZGVjcnlwdCA/IDEgOiAzXSA9XG4gICAgKHN1YltkID4+PiAyNF0gPDwgMjQpIF5cbiAgICAoc3ViW2EgPj4+IDE2ICYgMjU1XSA8PCAxNikgXlxuICAgIChzdWJbYiA+Pj4gOCAmIDI1NV0gPDwgOCkgXlxuICAgIChzdWJbYyAmIDI1NV0pIF4gd1srK2ldO1xufVxuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhIGRlcHJlY2F0ZWQgQUVTIGNpcGhlciBvYmplY3QuIFRoaXMgb2JqZWN0J3MgbW9kZSB3aWxsIGRlZmF1bHQgdG9cbiAqIENCQyAoY2lwaGVyLWJsb2NrLWNoYWluaW5nKS5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLCBhXG4gKiBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiAgICAgICAgICBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0by5cbiAqICAgICAgICAgIGRlY3J5cHQgdHJ1ZSBmb3IgZGVjcnlwdGlvbiwgZmFsc2UgZm9yIGVuY3J5cHRpb24uXG4gKiAgICAgICAgICBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVDaXBoZXIob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG1vZGUgPSAob3B0aW9ucy5tb2RlIHx8ICdDQkMnKS50b1VwcGVyQ2FzZSgpO1xuICB2YXIgYWxnb3JpdGhtID0gJ0FFUy0nICsgbW9kZTtcblxuICB2YXIgY2lwaGVyO1xuICBpZihvcHRpb25zLmRlY3J5cHQpIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH0gZWxzZSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfVxuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIHN0YXJ0IEFQSVxuICB2YXIgc3RhcnQgPSBjaXBoZXIuc3RhcnQ7XG4gIGNpcGhlci5zdGFydCA9IGZ1bmN0aW9uKGl2LCBvcHRpb25zKSB7XG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IHN1cHBvcnQgc2Vjb25kIGFyZyBhcyBvdXRwdXQgYnVmZmVyXG4gICAgdmFyIG91dHB1dCA9IG51bGw7XG4gICAgaWYob3B0aW9ucyBpbnN0YW5jZW9mIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcikge1xuICAgICAgb3V0cHV0ID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgb3B0aW9ucy5pdiA9IGl2O1xuICAgIHN0YXJ0LmNhbGwoY2lwaGVyLCBvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gY2lwaGVyO1xufVxuIiwgIi8qKlxuICogREVTIChEYXRhIEVuY3J5cHRpb24gU3RhbmRhcmQpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gc3VwcG9ydHMgREVTIGFzIHdlbGwgYXMgM0RFUy1FREUgaW4gRUNCIGFuZCBDQkMgbW9kZS5cbiAqIEl0IGlzIGJhc2VkIG9uIHRoZSBCU0QtbGljZW5zZWQgaW1wbGVtZW50YXRpb24gYnkgUGF1bCBUZXJvOlxuICpcbiAqIFBhdWwgVGVybywgSnVseSAyMDAxXG4gKiBodHRwOi8vd3d3LnRlcm8uY28udWsvZGVzL1xuICpcbiAqIE9wdGltaXNlZCBmb3IgcGVyZm9ybWFuY2Ugd2l0aCBsYXJnZSBibG9ja3MgYnlcbiAqIE1pY2hhZWwgSGF5d29ydGgsIE5vdmVtYmVyIDIwMDFcbiAqIGh0dHA6Ly93d3cubmV0ZGVhbGluZy5jb21cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1RcbiAqIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVlcbiAqIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAqIFNVQ0ggREFNQUdFLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9jaXBoZXInKTtcbnJlcXVpcmUoJy4vY2lwaGVyTW9kZXMnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKiBERVMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmRlcyA9IGZvcmdlLmRlcyB8fCB7fTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gJ0VDQicgOiAnQ0JDJylcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGRlY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZSB8fCAoaXYgPT09IG51bGwgPyAnRUNCJyA6ICdDQkMnKVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgREVTIGNpcGhlciBhbGdvcml0aG0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gbW9kZSB0aGUgbW9kZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIERFUyBhbGdvcml0aG0gb2JqZWN0LlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYubW9kZSA9IG5ldyBtb2RlKHtcbiAgICBibG9ja1NpemU6IDgsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl9rZXlzLCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIERFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMua2V5KTtcbiAgaWYodGhpcy5uYW1lLmluZGV4T2YoJzNERVMnKSA9PT0gMCkge1xuICAgIGlmKGtleS5sZW5ndGgoKSAhPT0gMjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiAnICsga2V5Lmxlbmd0aCgpICogOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvbiB0byAxNiBvciA0OCBzdWJrZXlzIChzaW5nbGUgb3IgdHJpcGxlIERFUylcbiAgdGhpcy5fa2V5cyA9IF9jcmVhdGVLZXlzKGtleSk7XG4gIHRoaXMuX2luaXQgPSB0cnVlO1xufTtcblxuLyoqIFJlZ2lzdGVyIERFUyBhbGdvcml0aG1zICoqL1xuXG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuZGVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogREVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgc3BmdW5jdGlvbjEgPSBbMHgxMDEwNDAwLDAsMHgxMDAwMCwweDEwMTA0MDQsMHgxMDEwMDA0LDB4MTA0MDQsMHg0LDB4MTAwMDAsMHg0MDAsMHgxMDEwNDAwLDB4MTAxMDQwNCwweDQwMCwweDEwMDA0MDQsMHgxMDEwMDA0LDB4MTAwMDAwMCwweDQsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwweDEwNDAwLDB4MTA0MDAsMHgxMDEwMDAwLDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwNCwweDEwMDAwMDQsMHgxMDAwMDA0LDB4MTAwMDQsMCwweDQwNCwweDEwNDA0LDB4MTAwMDAwMCwweDEwMDAwLDB4MTAxMDQwNCwweDQsMHgxMDEwMDAwLDB4MTAxMDQwMCwweDEwMDAwMDAsMHgxMDAwMDAwLDB4NDAwLDB4MTAxMDAwNCwweDEwMDAwLDB4MTA0MDAsMHgxMDAwMDA0LDB4NDAwLDB4NCwweDEwMDA0MDQsMHgxMDQwNCwweDEwMTA0MDQsMHgxMDAwNCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDAwNCwweDQwNCwweDEwNDA0LDB4MTAxMDQwMCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDAsMHgxMDAwNCwweDEwNDAwLDAsMHgxMDEwMDA0XTtcbnZhciBzcGZ1bmN0aW9uMiA9IFstMHg3ZmVmN2ZlMCwtMHg3ZmZmODAwMCwweDgwMDAsMHgxMDgwMjAsMHgxMDAwMDAsMHgyMCwtMHg3ZmVmZmZlMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwtMHg3ZmVmN2ZlMCwtMHg3ZmVmODAwMCwtMHg4MDAwMDAwMCwtMHg3ZmZmODAwMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLDB4MTA4MDAwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLDAsLTB4ODAwMDAwMDAsMHg4MDAwLDB4MTA4MDIwLC0weDdmZjAwMDAwLDB4MTAwMDIwLC0weDdmZmZmZmUwLDAsMHgxMDgwMDAsMHg4MDIwLC0weDdmZWY4MDAwLC0weDdmZjAwMDAwLDB4ODAyMCwwLDB4MTA4MDIwLC0weDdmZWZmZmUwLDB4MTAwMDAwLC0weDdmZmY3ZmUwLC0weDdmZjAwMDAwLC0weDdmZWY4MDAwLDB4ODAwMCwtMHg3ZmYwMDAwMCwtMHg3ZmZmODAwMCwweDIwLC0weDdmZWY3ZmUwLDB4MTA4MDIwLDB4MjAsMHg4MDAwLC0weDgwMDAwMDAwLDB4ODAyMCwtMHg3ZmVmODAwMCwweDEwMDAwMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwweDEwODAwMCwwLC0weDdmZmY4MDAwLDB4ODAyMCwtMHg4MDAwMDAwMCwtMHg3ZmVmZmZlMCwtMHg3ZmVmN2ZlMCwweDEwODAwMF07XG52YXIgc3BmdW5jdGlvbjMgPSBbMHgyMDgsMHg4MDIwMjAwLDAsMHg4MDIwMDA4LDB4ODAwMDIwMCwwLDB4MjAyMDgsMHg4MDAwMjAwLDB4MjAwMDgsMHg4MDAwMDA4LDB4ODAwMDAwOCwweDIwMDAwLDB4ODAyMDIwOCwweDIwMDA4LDB4ODAyMDAwMCwweDIwOCwweDgwMDAwMDAsMHg4LDB4ODAyMDIwMCwweDIwMCwweDIwMjAwLDB4ODAyMDAwMCwweDgwMjAwMDgsMHgyMDIwOCwweDgwMDAyMDgsMHgyMDIwMCwweDIwMDAwLDB4ODAwMDIwOCwweDgsMHg4MDIwMjA4LDB4MjAwLDB4ODAwMDAwMCwweDgwMjAyMDAsMHg4MDAwMDAwLDB4MjAwMDgsMHgyMDgsMHgyMDAwMCwweDgwMjAyMDAsMHg4MDAwMjAwLDAsMHgyMDAsMHgyMDAwOCwweDgwMjAyMDgsMHg4MDAwMjAwLDB4ODAwMDAwOCwweDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDgsMHgyMDAwMCwweDgwMDAwMDAsMHg4MDIwMjA4LDB4OCwweDIwMjA4LDB4MjAyMDAsMHg4MDAwMDA4LDB4ODAyMDAwMCwweDgwMDAyMDgsMHgyMDgsMHg4MDIwMDAwLDB4MjAyMDgsMHg4LDB4ODAyMDAwOCwweDIwMjAwXTtcbnZhciBzcGZ1bmN0aW9uNCA9IFsweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODAsMHg4MDAwODEsMHg4MDAwMDEsMHgyMDAxLDAsMHg4MDIwMDAsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDB4ODAwMDgwLDB4ODAwMDAxLDB4MSwweDIwMDAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDEsMHgyMDgwLDB4ODAwMDgxLDB4MSwweDIwODAsMHg4MDAwODAsMHgyMDAwLDB4ODAyMDgwLDB4ODAyMDgxLDB4ODEsMHg4MDAwODAsMHg4MDAwMDEsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDAsMHg4MDIwMDAsMHgyMDgwLDB4ODAwMDgwLDB4ODAwMDgxLDB4MSwweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODEsMHg4MSwweDEsMHgyMDAwLDB4ODAwMDAxLDB4MjAwMSwweDgwMjA4MCwweDgwMDA4MSwweDIwMDEsMHgyMDgwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAwLDB4ODAyMDgwXTtcbnZhciBzcGZ1bmN0aW9uNSA9IFsweDEwMCwweDIwODAxMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg4MDAwMCwweDEwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQwMDgwMTAwLDB4ODAwMDAsMHgyMDAwMTAwLDB4NDAwODAxMDAsMHg0MjAwMDEwMCwweDQyMDgwMDAwLDB4ODAxMDAsMHg0MDAwMDAwMCwweDIwMDAwMDAsMHg0MDA4MDAwMCwweDQwMDgwMDAwLDAsMHg0MDAwMDEwMCwweDQyMDgwMTAwLDB4NDIwODAxMDAsMHgyMDAwMTAwLDB4NDIwODAwMDAsMHg0MDAwMDEwMCwwLDB4NDIwMDAwMDAsMHgyMDgwMTAwLDB4MjAwMDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHg4MDAwMCwweDQyMDAwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQyMDAwMTAwLDB4NDAwODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAwMDAsMHg0MjA4MDAwMCwweDIwODAxMDAsMHg0MDA4MDEwMCwweDEwMCwweDIwMDAwMDAsMHg0MjA4MDAwMCwweDQyMDgwMTAwLDB4ODAxMDAsMHg0MjAwMDAwMCwweDQyMDgwMTAwLDB4MjA4MDAwMCwwLDB4NDAwODAwMDAsMHg0MjAwMDAwMCwweDgwMTAwLDB4MjAwMDEwMCwweDQwMDAwMTAwLDB4ODAwMDAsMCwweDQwMDgwMDAwLDB4MjA4MDEwMCwweDQwMDAwMTAwXTtcbnZhciBzcGZ1bmN0aW9uNiA9IFsweDIwMDAwMDEwLDB4MjA0MDAwMDAsMHg0MDAwLDB4MjA0MDQwMTAsMHgyMDQwMDAwMCwweDEwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDQwNDAxMCwweDQwMDAwMCwweDIwMDAwMDEwLDB4NDAwMDEwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMCwweDQwMDAxMCwweDIwMDA0MDEwLDB4NDAwMCwweDQwNDAwMCwweDIwMDA0MDEwLDB4MTAsMHgyMDQwMDAxMCwweDIwNDAwMDEwLDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwweDQwMTAsMHg0MDQwMDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4MjAwMDQwMDAsMHgxMCwweDIwNDAwMDEwLDB4NDA0MDAwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHg0MDEwLDB4MjAwMDAwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDIwMDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4MjA0MDQwMTAsMHg0MDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDIwNDA0MDAwLDAsMHgyMDQwMDAxMCwweDEwLDB4NDAwMCwweDIwNDAwMDAwLDB4NDA0MDEwLDB4NDAwMCwweDQwMDAxMCwweDIwMDA0MDEwLDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4NDAwMDEwLDB4MjAwMDQwMTBdO1xudmFyIHNwZnVuY3Rpb243ID0gWzB4MjAwMDAwLDB4NDIwMDAwMiwweDQwMDA4MDIsMCwweDgwMCwweDQwMDA4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4NDIwMDgwMiwweDIwMDAwMCwwLDB4NDAwMDAwMiwweDIsMHg0MDAwMDAwLDB4NDIwMDAwMiwweDgwMiwweDQwMDA4MDAsMHgyMDA4MDIsMHgyMDAwMDIsMHg0MDAwODAwLDB4NDAwMDAwMiwweDQyMDAwMDAsMHg0MjAwODAwLDB4MjAwMDAyLDB4NDIwMDAwMCwweDgwMCwweDgwMiwweDQyMDA4MDIsMHgyMDA4MDAsMHgyLDB4NDAwMDAwMCwweDIwMDgwMCwweDQwMDAwMDAsMHgyMDA4MDAsMHgyMDAwMDAsMHg0MDAwODAyLDB4NDAwMDgwMiwweDQyMDAwMDIsMHg0MjAwMDAyLDB4MiwweDIwMDAwMiwweDQwMDAwMDAsMHg0MDAwODAwLDB4MjAwMDAwLDB4NDIwMDgwMCwweDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg4MDIsMHg0MDAwMDAyLDB4NDIwMDgwMiwweDQyMDAwMDAsMHgyMDA4MDAsMCwweDIsMHg0MjAwODAyLDAsMHgyMDA4MDIsMHg0MjAwMDAwLDB4ODAwLDB4NDAwMDAwMiwweDQwMDA4MDAsMHg4MDAsMHgyMDAwMDJdO1xudmFyIHNwZnVuY3Rpb244ID0gWzB4MTAwMDEwNDAsMHgxMDAwLDB4NDAwMDAsMHgxMDA0MTA0MCwweDEwMDAwMDAwLDB4MTAwMDEwNDAsMHg0MCwweDEwMDAwMDAwLDB4NDAwNDAsMHgxMDA0MDAwMCwweDEwMDQxMDQwLDB4NDEwMDAsMHgxMDA0MTAwMCwweDQxMDQwLDB4MTAwMCwweDQwLDB4MTAwNDAwMDAsMHgxMDAwMDA0MCwweDEwMDAxMDAwLDB4MTA0MCwweDQxMDAwLDB4NDAwNDAsMHgxMDA0MDA0MCwweDEwMDQxMDAwLDB4MTA0MCwwLDAsMHgxMDA0MDA0MCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHg0MTA0MCwweDQwMDAwLDB4NDEwNDAsMHg0MDAwMCwweDEwMDQxMDAwLDB4MTAwMCwweDQwLDB4MTAwNDAwNDAsMHgxMDAwLDB4NDEwNDAsMHgxMDAwMTAwMCwweDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDQwMDQwLDB4MTAwMDAwMDAsMHg0MDAwMCwweDEwMDAxMDQwLDAsMHgxMDA0MTA0MCwweDQwMDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDAxMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDEwMDAsMHg0MTAwMCwweDEwNDAsMHgxMDQwLDB4NDAwNDAsMHgxMDAwMDAwMCwweDEwMDQxMDAwXTtcblxuLyoqXG4gKiBDcmVhdGUgbmVjZXNzYXJ5IHN1YiBrZXlzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIDY0LWJpdCBvciAxOTItYml0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlzLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlS2V5cyhrZXkpIHtcbiAgdmFyIHBjMmJ5dGVzMCAgPSBbMCwweDQsMHgyMDAwMDAwMCwweDIwMDAwMDA0LDB4MTAwMDAsMHgxMDAwNCwweDIwMDEwMDAwLDB4MjAwMTAwMDQsMHgyMDAsMHgyMDQsMHgyMDAwMDIwMCwweDIwMDAwMjA0LDB4MTAyMDAsMHgxMDIwNCwweDIwMDEwMjAwLDB4MjAwMTAyMDRdLFxuICAgICAgcGMyYnl0ZXMxICA9IFswLDB4MSwweDEwMDAwMCwweDEwMDAwMSwweDQwMDAwMDAsMHg0MDAwMDAxLDB4NDEwMDAwMCwweDQxMDAwMDEsMHgxMDAsMHgxMDEsMHgxMDAxMDAsMHgxMDAxMDEsMHg0MDAwMTAwLDB4NDAwMDEwMSwweDQxMDAxMDAsMHg0MTAwMTAxXSxcbiAgICAgIHBjMmJ5dGVzMiAgPSBbMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4LDAsMHg4LDB4ODAwLDB4ODA4LDB4MTAwMDAwMCwweDEwMDAwMDgsMHgxMDAwODAwLDB4MTAwMDgwOF0sXG4gICAgICBwYzJieXRlczMgID0gWzAsMHgyMDAwMDAsMHg4MDAwMDAwLDB4ODIwMDAwMCwweDIwMDAsMHgyMDIwMDAsMHg4MDAyMDAwLDB4ODIwMjAwMCwweDIwMDAwLDB4MjIwMDAwLDB4ODAyMDAwMCwweDgyMjAwMDAsMHgyMjAwMCwweDIyMjAwMCwweDgwMjIwMDAsMHg4MjIyMDAwXSxcbiAgICAgIHBjMmJ5dGVzNCAgPSBbMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwwLDB4NDAwMDAsMHgxMCwweDQwMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwXSxcbiAgICAgIHBjMmJ5dGVzNSAgPSBbMCwweDQwMCwweDIwLDB4NDIwLDAsMHg0MDAsMHgyMCwweDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjAsMHgyMDAwMDAwLDB4MjAwMDQwMCwweDIwMDAwMjAsMHgyMDAwNDIwXSxcbiAgICAgIHBjMmJ5dGVzNiAgPSBbMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDIsMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDJdLFxuICAgICAgcGMyYnl0ZXM3ICA9IFswLDB4MTAwMDAsMHg4MDAsMHgxMDgwMCwweDIwMDAwMDAwLDB4MjAwMTAwMDAsMHgyMDAwMDgwMCwweDIwMDEwODAwLDB4MjAwMDAsMHgzMDAwMCwweDIwODAwLDB4MzA4MDAsMHgyMDAyMDAwMCwweDIwMDMwMDAwLDB4MjAwMjA4MDAsMHgyMDAzMDgwMF0sXG4gICAgICBwYzJieXRlczggID0gWzAsMHg0MDAwMCwwLDB4NDAwMDAsMHgyLDB4NDAwMDIsMHgyLDB4NDAwMDIsMHgyMDAwMDAwLDB4MjA0MDAwMCwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMiwweDIwNDAwMDIsMHgyMDAwMDAyLDB4MjA0MDAwMl0sXG4gICAgICBwYzJieXRlczkgID0gWzAsMHgxMDAwMDAwMCwweDgsMHgxMDAwMDAwOCwwLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMHg0MDAsMHgxMDAwMDQwMCwweDQwOCwweDEwMDAwNDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOF0sXG4gICAgICBwYzJieXRlczEwID0gWzAsMHgyMCwwLDB4MjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgyMDAwLDB4MjAyMCwweDIwMDAsMHgyMDIwLDB4MTAyMDAwLDB4MTAyMDIwLDB4MTAyMDAwLDB4MTAyMDIwXSxcbiAgICAgIHBjMmJ5dGVzMTEgPSBbMCwweDEwMDAwMDAsMHgyMDAsMHgxMDAwMjAwLDB4MjAwMDAwLDB4MTIwMDAwMCwweDIwMDIwMCwweDEyMDAyMDAsMHg0MDAwMDAwLDB4NTAwMDAwMCwweDQwMDAyMDAsMHg1MDAwMjAwLDB4NDIwMDAwMCwweDUyMDAwMDAsMHg0MjAwMjAwLDB4NTIwMDIwMF0sXG4gICAgICBwYzJieXRlczEyID0gWzAsMHgxMDAwLDB4ODAwMDAwMCwweDgwMDEwMDAsMHg4MDAwMCwweDgxMDAwLDB4ODA4MDAwMCwweDgwODEwMDAsMHgxMCwweDEwMTAsMHg4MDAwMDEwLDB4ODAwMTAxMCwweDgwMDEwLDB4ODEwMTAsMHg4MDgwMDEwLDB4ODA4MTAxMF0sXG4gICAgICBwYzJieXRlczEzID0gWzAsMHg0LDB4MTAwLDB4MTA0LDAsMHg0LDB4MTAwLDB4MTA0LDB4MSwweDUsMHgxMDEsMHgxMDUsMHgxLDB4NSwweDEwMSwweDEwNV07XG5cbiAgLy8gaG93IG1hbnkgaXRlcmF0aW9ucyAoMSBmb3IgZGVzLCAzIGZvciB0cmlwbGUgZGVzKVxuICAvLyBjaGFuZ2VkIGJ5IFBhdWwgMTYvNi8yMDA3IHRvIHVzZSBUcmlwbGUgREVTIGZvciA5KyBieXRlIGtleXNcbiAgdmFyIGl0ZXJhdGlvbnMgPSBrZXkubGVuZ3RoKCkgPiA4ID8gMyA6IDE7XG5cbiAgLy8gc3RvcmVzIHRoZSByZXR1cm4ga2V5c1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIC8vIG5vdyBkZWZpbmUgdGhlIGxlZnQgc2hpZnRzIHdoaWNoIG5lZWQgdG8gYmUgZG9uZVxuICB2YXIgc2hpZnRzID0gWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDBdO1xuXG4gIHZhciBuID0gMCwgdG1wO1xuICBmb3IodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgdmFyIGxlZnQgPSBrZXkuZ2V0SW50MzIoKTtcbiAgICB2YXIgcmlnaHQgPSBrZXkuZ2V0SW50MzIoKTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMikgXiByaWdodCkgJiAweDMzMzMzMzMzO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMik7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAgIC8vIHJpZ2h0IG5lZWRzIHRvIGJlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBsYXN0IGZvdXIgYml0cyBvZiBsZWZ0XG4gICAgdG1wID0gKGxlZnQgPDwgOCkgfCAoKHJpZ2h0ID4+PiAyMCkgJiAweDAwMDAwMGYwKTtcblxuICAgIC8vIGxlZnQgbmVlZHMgdG8gYmUgcHV0IHVwc2lkZSBkb3duXG4gICAgbGVmdCA9ICgocmlnaHQgPDwgMjQpIHwgKChyaWdodCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAoKHJpZ2h0ID4+PiA4KSAmIDB4ZmYwMCkgfCAoKHJpZ2h0ID4+PiAyNCkgJiAweGYwKSk7XG4gICAgcmlnaHQgPSB0bXA7XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGVzZSBzaGlmdHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IGtleXNcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2hpZnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvL3NoaWZ0IHRoZSBrZXlzIGVpdGhlciBvbmUgb3IgdHdvIGJpdHMgdG8gdGhlIGxlZnRcbiAgICAgIGlmKHNoaWZ0c1tpXSkge1xuICAgICAgICBsZWZ0ID0gKGxlZnQgPDwgMikgfCAobGVmdCA+Pj4gMjYpO1xuICAgICAgICByaWdodCA9IChyaWdodCA8PCAyKSB8IChyaWdodCA+Pj4gMjYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IChsZWZ0IDw8IDEpIHwgKGxlZnQgPj4+IDI3KTtcbiAgICAgICAgcmlnaHQgPSAocmlnaHQgPDwgMSkgfCAocmlnaHQgPj4+IDI3KTtcbiAgICAgIH1cbiAgICAgIGxlZnQgJj0gLTB4ZjtcbiAgICAgIHJpZ2h0ICY9IC0weGY7XG5cbiAgICAgIC8vIG5vdyBhcHBseSBQQy0yLCBpbiBzdWNoIGEgd2F5IHRoYXQgRSBpcyBlYXNpZXIgd2hlbiBlbmNyeXB0aW5nIG9yXG4gICAgICAvLyBkZWNyeXB0aW5nIHRoaXMgY29udmVyc2lvbiB3aWxsIGxvb2sgbGlrZSBQQy0yIGV4Y2VwdCBvbmx5IHRoZSBsYXN0IDZcbiAgICAgIC8vIGJpdHMgb2YgZWFjaCBieXRlIGFyZSB1c2VkIHJhdGhlciB0aGFuIDQ4IGNvbnNlY3V0aXZlIGJpdHMgYW5kIHRoZVxuICAgICAgLy8gb3JkZXIgb2YgbGluZXMgd2lsbCBiZSBhY2NvcmRpbmcgdG8gaG93IHRoZSBTIHNlbGVjdGlvbiBmdW5jdGlvbnMgd2lsbFxuICAgICAgLy8gYmUgYXBwbGllZDogUzIsIFM0LCBTNiwgUzgsIFMxLCBTMywgUzUsIFM3XG4gICAgICB2YXIgbGVmdHRtcCA9IChcbiAgICAgICAgcGMyYnl0ZXMwW2xlZnQgPj4+IDI4XSB8IHBjMmJ5dGVzMVsobGVmdCA+Pj4gMjQpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMlsobGVmdCA+Pj4gMjApICYgMHhmXSB8IHBjMmJ5dGVzM1sobGVmdCA+Pj4gMTYpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzNFsobGVmdCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzNVsobGVmdCA+Pj4gOCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM2WyhsZWZ0ID4+PiA0KSAmIDB4Zl0pO1xuICAgICAgdmFyIHJpZ2h0dG1wID0gKFxuICAgICAgICBwYzJieXRlczdbcmlnaHQgPj4+IDI4XSB8IHBjMmJ5dGVzOFsocmlnaHQgPj4+IDI0KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczlbKHJpZ2h0ID4+PiAyMCkgJiAweGZdIHwgcGMyYnl0ZXMxMFsocmlnaHQgPj4+IDE2KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczExWyhyaWdodCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzMTJbKHJpZ2h0ID4+PiA4KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczEzWyhyaWdodCA+Pj4gNCkgJiAweGZdKTtcbiAgICAgIHRtcCA9ICgocmlnaHR0bXAgPj4+IDE2KSBeIGxlZnR0bXApICYgMHgwMDAwZmZmZjtcbiAgICAgIGtleXNbbisrXSA9IGxlZnR0bXAgXiB0bXA7XG4gICAgICBrZXlzW24rK10gPSByaWdodHRtcCBeICh0bXAgPDwgMTYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDEgYnl0ZSkgdXNpbmcgREVTLiBUaGUgdXBkYXRlIHdpbGwgZWl0aGVyXG4gKiBlbmNyeXB0IG9yIGRlY3J5cHQgdGhlIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBrZXlzIHRoZSBleHBhbmRlZCBrZXlzLlxuICogQHBhcmFtIGlucHV0IHRoZSBpbnB1dCBibG9jayAoYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIHVwZGF0ZWQgb3V0cHV0IGJsb2NrLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0IHRoZSBibG9jaywgZmFsc2UgdG8gZW5jcnlwdCBpdC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKGtleXMsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgLy8gc2V0IHVwIGxvb3BzIGZvciBzaW5nbGUgb3IgdHJpcGxlIERFU1xuICB2YXIgaXRlcmF0aW9ucyA9IGtleXMubGVuZ3RoID09PSAzMiA/IDMgOiA5O1xuICB2YXIgbG9vcGluZztcbiAgaWYoaXRlcmF0aW9ucyA9PT0gMykge1xuICAgIGxvb3BpbmcgPSBkZWNyeXB0ID8gWzMwLCAtMiwgLTJdIDogWzAsIDMyLCAyXTtcbiAgfSBlbHNlIHtcbiAgICBsb29waW5nID0gKGRlY3J5cHQgP1xuICAgICAgWzk0LCA2MiwgLTIsIDMyLCA2NCwgMiwgMzAsIC0yLCAtMl0gOlxuICAgICAgWzAsIDMyLCAyLCA2MiwgMzAsIC0yLCA2NCwgOTYsIDJdKTtcbiAgfVxuXG4gIHZhciB0bXA7XG5cbiAgdmFyIGxlZnQgPSBpbnB1dFswXTtcbiAgdmFyIHJpZ2h0ID0gaW5wdXRbMV07XG5cbiAgLy8gZmlyc3QgZWFjaCA2NCBiaXQgY2h1bmsgb2YgdGhlIG1lc3NhZ2UgbXVzdCBiZSBwZXJtdXRlZCBhY2NvcmRpbmcgdG8gSVBcbiAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMTYpIF4gcmlnaHQpICYgMHgwMDAwZmZmZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMTYpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gIC8vIHJvdGF0ZSBsZWZ0IDEgYml0XG4gIGxlZnQgPSAoKGxlZnQgPDwgMSkgfCAobGVmdCA+Pj4gMzEpKTtcbiAgcmlnaHQgPSAoKHJpZ2h0IDw8IDEpIHwgKHJpZ2h0ID4+PiAzMSkpO1xuXG4gIGZvcih2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqICs9IDMpIHtcbiAgICB2YXIgZW5kbG9vcCA9IGxvb3BpbmdbaiArIDFdO1xuICAgIHZhciBsb29waW5jID0gbG9vcGluZ1tqICsgMl07XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uXG4gICAgZm9yKHZhciBpID0gbG9vcGluZ1tqXTsgaSAhPSBlbmRsb29wOyBpICs9IGxvb3BpbmMpIHtcbiAgICAgIHZhciByaWdodDEgPSByaWdodCBeIGtleXNbaV07XG4gICAgICB2YXIgcmlnaHQyID0gKChyaWdodCA+Pj4gNCkgfCAocmlnaHQgPDwgMjgpKSBeIGtleXNbaSArIDFdO1xuXG4gICAgICAvLyBwYXNzaW5nIHRoZXNlIGJ5dGVzIHRocm91Z2ggdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xuICAgICAgdG1wID0gbGVmdDtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gdG1wIF4gKFxuICAgICAgICBzcGZ1bmN0aW9uMlsocmlnaHQxID4+PiAyNCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb240WyhyaWdodDEgPj4+IDE2KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjZbKHJpZ2h0MSA+Pj4gIDgpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uOFtyaWdodDEgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb24xWyhyaWdodDIgPj4+IDI0KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjNbKHJpZ2h0MiA+Pj4gMTYpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNVsocmlnaHQyID4+PiAgOCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb243W3JpZ2h0MiAmIDB4M2ZdKTtcbiAgICB9XG4gICAgLy8gdW5yZXZlcnNlIGxlZnQgYW5kIHJpZ2h0XG4gICAgdG1wID0gbGVmdDtcbiAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgcmlnaHQgPSB0bXA7XG4gIH1cblxuICAvLyByb3RhdGUgcmlnaHQgMSBiaXRcbiAgbGVmdCA9ICgobGVmdCA+Pj4gMSkgfCAobGVmdCA8PCAzMSkpO1xuICByaWdodCA9ICgocmlnaHQgPj4+IDEpIHwgKHJpZ2h0IDw8IDMxKSk7XG5cbiAgLy8gbm93IHBlcmZvcm0gSVAtMSwgd2hpY2ggaXMgSVAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDE2KSBeIHJpZ2h0KSAmIDB4MDAwMGZmZmY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDE2KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgb3V0cHV0WzBdID0gbGVmdDtcbiAgb3V0cHV0WzFdID0gcmlnaHQ7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBERVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICogICAgICAgICAgbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlQ2lwaGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCAnQ0JDJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGFsZ29yaXRobSA9ICdERVMtJyArIG1vZGU7XG5cbiAgdmFyIGNpcGhlcjtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdGFydCBBUElcbiAgdmFyIHN0YXJ0ID0gY2lwaGVyLnN0YXJ0O1xuICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9ucykge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBzdXBwb3J0IHNlY29uZCBhcmcgYXMgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciBvdXRwdXQgPSBudWxsO1xuICAgIGlmKG9wdGlvbnMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIG91dHB1dCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdGlvbnMuaXYgPSBpdjtcbiAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn1cbiIsICIvKipcbiAqIE5vZGUuanMgbW9kdWxlIGZvciBGb3JnZSBtZXNzYWdlIGRpZ2VzdHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZCA9IGZvcmdlLm1kIHx8IHt9O1xuZm9yZ2UubWQuYWxnb3JpdGhtcyA9IGZvcmdlLm1kLmFsZ29yaXRobXMgfHwge307XG4iLCAiLyoqXG4gKiBIYXNoLWJhc2VkIE1lc3NhZ2UgQXV0aGVudGljYXRpb24gQ29kZSBpbXBsZW1lbnRhdGlvbi4gUmVxdWlyZXMgYSBtZXNzYWdlXG4gKiBkaWdlc3Qgb2JqZWN0IHRoYXQgY2FuIGJlIG9idGFpbmVkLCBmb3IgZXhhbXBsZSwgZnJvbSBmb3JnZS5tZC5zaGExIG9yXG4gKiBmb3JnZS5tZC5tZDUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLyogSE1BQyBBUEkgKi9cbnZhciBobWFjID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5obWFjID0gZm9yZ2UuaG1hYyB8fCB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhNQUMgb2JqZWN0IHRoYXQgdXNlcyB0aGUgZ2l2ZW4gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gYW4gSE1BQyBvYmplY3QuXG4gKi9cbmhtYWMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHRoZSBobWFjIGtleSB0byB1c2VcbiAgdmFyIF9rZXkgPSBudWxsO1xuXG4gIC8vIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2VcbiAgdmFyIF9tZCA9IG51bGw7XG5cbiAgLy8gdGhlIGlubmVyIHBhZGRpbmdcbiAgdmFyIF9pcGFkZGluZyA9IG51bGw7XG5cbiAgLy8gdGhlIG91dGVyIHBhZGRpbmdcbiAgdmFyIF9vcGFkZGluZyA9IG51bGw7XG5cbiAgLy8gaG1hYyBjb250ZXh0XG4gIHZhciBjdHggPSB7fTtcblxuICAvKipcbiAgICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBITUFDIHdpdGggdGhlIGdpdmVuIGtleSBhbmQgbWVzc2FnZSBkaWdlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3QgdG8gdXNlLCBudWxsIHRvIHJldXNlIHRoZSBwcmV2aW91cyBvbmUsXG4gICAqICAgICAgICAgICBhIHN0cmluZyB0byB1c2UgYnVpbHRpbiAnc2hhMScsICdtZDUnLCAnc2hhMjU2Jy5cbiAgICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZSBhcyBhIHN0cmluZywgYXJyYXkgb2YgYnl0ZXMsIGJ5dGUgYnVmZmVyLFxuICAgKiAgICAgICAgICAgb3IgbnVsbCB0byByZXVzZSB0aGUgcHJldmlvdXMga2V5LlxuICAgKi9cbiAgY3R4LnN0YXJ0ID0gZnVuY3Rpb24obWQsIGtleSkge1xuICAgIGlmKG1kICE9PSBudWxsKSB7XG4gICAgICBpZih0eXBlb2YgbWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBidWlsdGluIG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIG1kID0gbWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYobWQgaW4gZm9yZ2UubWQuYWxnb3JpdGhtcykge1xuICAgICAgICAgIF9tZCA9IGZvcmdlLm1kLmFsZ29yaXRobXNbbWRdLmNyZWF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobSBcIicgKyBtZCArICdcIicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdG9yZSBtZXNzYWdlIGRpZ2VzdFxuICAgICAgICBfbWQgPSBtZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihrZXkgPT09IG51bGwpIHtcbiAgICAgIC8vIHJldXNlIHByZXZpb3VzIGtleVxuICAgICAga2V5ID0gX2tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY29udmVydCBzdHJpbmcgaW50byBieXRlIGJ1ZmZlclxuICAgICAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICAgICAgfSBlbHNlIGlmKGZvcmdlLnV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgYnl0ZSBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgICAgIHZhciB0bXAgPSBrZXk7XG4gICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkucHV0Qnl0ZSh0bXBbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGtleSBpcyBsb25nZXIgdGhhbiBibG9ja3NpemUsIGhhc2ggaXRcbiAgICAgIHZhciBrZXlsZW4gPSBrZXkubGVuZ3RoKCk7XG4gICAgICBpZihrZXlsZW4gPiBfbWQuYmxvY2tMZW5ndGgpIHtcbiAgICAgICAgX21kLnN0YXJ0KCk7XG4gICAgICAgIF9tZC51cGRhdGUoa2V5LmJ5dGVzKCkpO1xuICAgICAgICBrZXkgPSBfbWQuZGlnZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1peCBrZXkgaW50byBpbm5lciBhbmQgb3V0ZXIgcGFkZGluZ1xuICAgICAgLy8gaXBhZGRpbmcgPSBbMHgzNiAqIGJsb2Nrc2l6ZV0gXiBrZXlcbiAgICAgIC8vIG9wYWRkaW5nID0gWzB4NUMgKiBibG9ja3NpemVdIF4ga2V5XG4gICAgICBfaXBhZGRpbmcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgX29wYWRkaW5nID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGtleWxlbiA9IGtleS5sZW5ndGgoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBrZXlsZW47ICsraSkge1xuICAgICAgICB2YXIgdG1wID0ga2V5LmF0KGkpO1xuICAgICAgICBfaXBhZGRpbmcucHV0Qnl0ZSgweDM2IF4gdG1wKTtcbiAgICAgICAgX29wYWRkaW5nLnB1dEJ5dGUoMHg1QyBeIHRtcCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGtleSBpcyBzaG9ydGVyIHRoYW4gYmxvY2tzaXplLCBhZGQgYWRkaXRpb25hbCBwYWRkaW5nXG4gICAgICBpZihrZXlsZW4gPCBfbWQuYmxvY2tMZW5ndGgpIHtcbiAgICAgICAgdmFyIHRtcCA9IF9tZC5ibG9ja0xlbmd0aCAtIGtleWxlbjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcDsgKytpKSB7XG4gICAgICAgICAgX2lwYWRkaW5nLnB1dEJ5dGUoMHgzNik7XG4gICAgICAgICAgX29wYWRkaW5nLnB1dEJ5dGUoMHg1Qyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9rZXkgPSBrZXk7XG4gICAgICBfaXBhZGRpbmcgPSBfaXBhZGRpbmcuYnl0ZXMoKTtcbiAgICAgIF9vcGFkZGluZyA9IF9vcGFkZGluZy5ieXRlcygpO1xuICAgIH1cblxuICAgIC8vIGRpZ2VzdCBpcyBkb25lIGxpa2Ugc286IGhhc2gob3BhZGRpbmcgfCBoYXNoKGlwYWRkaW5nIHwgbWVzc2FnZSkpXG5cbiAgICAvLyBwcmVwYXJlIHRvIGRvIGlubmVyIGhhc2hcbiAgICAvLyBoYXNoKGlwYWRkaW5nIHwgbWVzc2FnZSlcbiAgICBfbWQuc3RhcnQoKTtcbiAgICBfbWQudXBkYXRlKF9pcGFkZGluZyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIEhNQUMgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byB1cGRhdGUgd2l0aC5cbiAgICovXG4gIGN0eC51cGRhdGUgPSBmdW5jdGlvbihieXRlcykge1xuICAgIF9tZC51cGRhdGUoYnl0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgTWVzc2FnZSBBdXRoZW50aWNhdGlvbiBDb2RlIChNQUMpLlxuICAgKlxuICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgKi9cbiAgY3R4LmdldE1hYyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRpZ2VzdCBpcyBkb25lIGxpa2Ugc286IGhhc2gob3BhZGRpbmcgfCBoYXNoKGlwYWRkaW5nIHwgbWVzc2FnZSkpXG4gICAgLy8gaGVyZSB3ZSBkbyB0aGUgb3V0ZXIgaGFzaGluZ1xuICAgIHZhciBpbm5lciA9IF9tZC5kaWdlc3QoKS5ieXRlcygpO1xuICAgIF9tZC5zdGFydCgpO1xuICAgIF9tZC51cGRhdGUoX29wYWRkaW5nKTtcbiAgICBfbWQudXBkYXRlKGlubmVyKTtcbiAgICByZXR1cm4gX21kLmRpZ2VzdCgpO1xuICB9O1xuICAvLyBhbGlhcyBmb3IgZ2V0TWFjXG4gIGN0eC5kaWdlc3QgPSBjdHguZ2V0TWFjO1xuXG4gIHJldHVybiBjdHg7XG59O1xuIiwgIi8qKlxuICogUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24gIzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU2VlIFJGQyAyODk4IGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9obWFjJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHBrY3M1ID0gZm9yZ2UucGtjczUgPSBmb3JnZS5wa2NzNSB8fCB7fTtcblxudmFyIGNyeXB0bztcbmlmKGZvcmdlLnV0aWwuaXNOb2RlanMgJiYgIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQpIHtcbiAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG59XG5cbi8qKlxuICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIHAgdGhlIHBhc3N3b3JkIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIHMgdGhlIHNhbHQgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gYyB0aGUgaXRlcmF0aW9uIGNvdW50LCBhIHBvc2l0aXZlIGludGVnZXIuXG4gKiBAcGFyYW0gZGtMZW4gdGhlIGludGVuZGVkIGxlbmd0aCwgaW4gYnl0ZXMsIG9mIHRoZSBkZXJpdmVkIGtleSxcbiAqICAgICAgICAgIChtYXg6IDJeMzIgLSAxKSAqIGhhc2ggbGVuZ3RoIG9mIHRoZSBQUkYuXG4gKiBAcGFyYW0gW21kXSB0aGUgbWVzc2FnZSBkaWdlc3QgKG9yIGFsZ29yaXRobSBpZGVudGlmaWVyIGFzIGEgc3RyaW5nKSB0byB1c2VcbiAqICAgICAgICAgIGluIHRoZSBQUkYsIGRlZmF1bHRzIHRvIFNIQS0xLlxuICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGtleSldIHByZXNlbmNlIHRyaWdnZXJzIGFzeW5jaHJvbm91cyB2ZXJzaW9uLCBjYWxsZWRcbiAqICAgICAgICAgIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgZGVyaXZlZCBrZXksIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLCBmb3IgdGhlXG4gKiAgICAgICAgICAgc3luY2hyb25vdXMgdmVyc2lvbiAoaWYgbm8gY2FsbGJhY2sgaXMgc3BlY2lmaWVkKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wYmtkZjIgPSBwa2NzNS5wYmtkZjIgPSBmdW5jdGlvbihcbiAgcCwgcywgYywgZGtMZW4sIG1kLCBjYWxsYmFjaykge1xuICBpZih0eXBlb2YgbWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG1kO1xuICAgIG1kID0gbnVsbDtcbiAgfVxuXG4gIC8vIHVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gaWYgcG9zc2libGUgYW5kIG5vdCBkaXNhYmxlZCwgbm90ZSB0aGF0XG4gIC8vIHNvbWUgbm9kZSB2ZXJzaW9ucyBvbmx5IHN1cHBvcnQgU0hBLTEsIG90aGVycyBhbGxvdyBkaWdlc3QgdG8gYmUgY2hhbmdlZFxuICBpZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0ICYmXG4gICAgY3J5cHRvLnBia2RmMiAmJiAobWQgPT09IG51bGwgfHwgdHlwZW9mIG1kICE9PSAnb2JqZWN0JykgJiZcbiAgICAoY3J5cHRvLnBia2RmMlN5bmMubGVuZ3RoID4gNCB8fCAoIW1kIHx8IG1kID09PSAnc2hhMScpKSkge1xuICAgIGlmKHR5cGVvZiBtZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGRlZmF1bHQgcHJmIHRvIFNIQS0xXG4gICAgICBtZCA9ICdzaGExJztcbiAgICB9XG4gICAgcCA9IEJ1ZmZlci5mcm9tKHAsICdiaW5hcnknKTtcbiAgICBzID0gQnVmZmVyLmZyb20ocywgJ2JpbmFyeScpO1xuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgaWYoY3J5cHRvLnBia2RmMlN5bmMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyU3luYyhwLCBzLCBjLCBka0xlbikudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjJTeW5jKHAsIHMsIGMsIGRrTGVuLCBtZCkudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH1cbiAgICBpZihjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBjcnlwdG8ucGJrZGYyKHAsIHMsIGMsIGRrTGVuLCBmdW5jdGlvbihlcnIsIGtleSkge1xuICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBrZXkudG9TdHJpbmcoJ2JpbmFyeScpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3J5cHRvLnBia2RmMihwLCBzLCBjLCBka0xlbiwgbWQsIGZ1bmN0aW9uKGVyciwga2V5KSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBrZXkudG9TdHJpbmcoJ2JpbmFyeScpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBtZCA9PT0gJ3VuZGVmaW5lZCcgfHwgbWQgPT09IG51bGwpIHtcbiAgICAvLyBkZWZhdWx0IHByZiB0byBTSEEtMVxuICAgIG1kID0gJ3NoYTEnO1xuICB9XG4gIGlmKHR5cGVvZiBtZCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZighKG1kIGluIGZvcmdlLm1kLmFsZ29yaXRobXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGFzaCBhbGdvcml0aG06ICcgKyBtZCk7XG4gICAgfVxuICAgIG1kID0gZm9yZ2UubWRbbWRdLmNyZWF0ZSgpO1xuICB9XG5cbiAgdmFyIGhMZW4gPSBtZC5kaWdlc3RMZW5ndGg7XG5cbiAgLyogMS4gSWYgZGtMZW4gPiAoMl4zMiAtIDEpICogaExlbiwgb3V0cHV0IFwiZGVyaXZlZCBrZXkgdG9vIGxvbmdcIiBhbmRcbiAgICBzdG9wLiAqL1xuICBpZihka0xlbiA+ICgweEZGRkZGRkZGICogaExlbikpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdEZXJpdmVkIGtleSBpcyB0b28gbG9uZy4nKTtcbiAgICBpZihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIC8qIDIuIExldCBsZW4gYmUgdGhlIG51bWJlciBvZiBoTGVuLW9jdGV0IGJsb2NrcyBpbiB0aGUgZGVyaXZlZCBrZXksXG4gICAgcm91bmRpbmcgdXAsIGFuZCBsZXQgciBiZSB0aGUgbnVtYmVyIG9mIG9jdGV0cyBpbiB0aGUgbGFzdFxuICAgIGJsb2NrOlxuXG4gICAgbGVuID0gQ0VJTChka0xlbiAvIGhMZW4pLFxuICAgIHIgPSBka0xlbiAtIChsZW4gLSAxKSAqIGhMZW4uICovXG4gIHZhciBsZW4gPSBNYXRoLmNlaWwoZGtMZW4gLyBoTGVuKTtcbiAgdmFyIHIgPSBka0xlbiAtIChsZW4gLSAxKSAqIGhMZW47XG5cbiAgLyogMy4gRm9yIGVhY2ggYmxvY2sgb2YgdGhlIGRlcml2ZWQga2V5IGFwcGx5IHRoZSBmdW5jdGlvbiBGIGRlZmluZWRcbiAgICBiZWxvdyB0byB0aGUgcGFzc3dvcmQgUCwgdGhlIHNhbHQgUywgdGhlIGl0ZXJhdGlvbiBjb3VudCBjLCBhbmRcbiAgICB0aGUgYmxvY2sgaW5kZXggdG8gY29tcHV0ZSB0aGUgYmxvY2s6XG5cbiAgICBUXzEgPSBGKFAsIFMsIGMsIDEpLFxuICAgIFRfMiA9IEYoUCwgUywgYywgMiksXG4gICAgLi4uXG4gICAgVF9sZW4gPSBGKFAsIFMsIGMsIGxlbiksXG5cbiAgICB3aGVyZSB0aGUgZnVuY3Rpb24gRiBpcyBkZWZpbmVkIGFzIHRoZSBleGNsdXNpdmUtb3Igc3VtIG9mIHRoZVxuICAgIGZpcnN0IGMgaXRlcmF0ZXMgb2YgdGhlIHVuZGVybHlpbmcgcHNldWRvcmFuZG9tIGZ1bmN0aW9uIFBSRlxuICAgIGFwcGxpZWQgdG8gdGhlIHBhc3N3b3JkIFAgYW5kIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSBzYWx0IFNcbiAgICBhbmQgdGhlIGJsb2NrIGluZGV4IGk6XG5cbiAgICBGKFAsIFMsIGMsIGkpID0gdV8xIFhPUiB1XzIgWE9SIC4uLiBYT1IgdV9jXG5cbiAgICB3aGVyZVxuXG4gICAgdV8xID0gUFJGKFAsIFMgfHwgSU5UKGkpKSxcbiAgICB1XzIgPSBQUkYoUCwgdV8xKSxcbiAgICAuLi5cbiAgICB1X2MgPSBQUkYoUCwgdV97Yy0xfSkuXG5cbiAgICBIZXJlLCBJTlQoaSkgaXMgYSBmb3VyLW9jdGV0IGVuY29kaW5nIG9mIHRoZSBpbnRlZ2VyIGksIG1vc3RcbiAgICBzaWduaWZpY2FudCBvY3RldCBmaXJzdC4gKi9cbiAgdmFyIHByZiA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG4gIHByZi5zdGFydChtZCwgcCk7XG4gIHZhciBkayA9ICcnO1xuICB2YXIgeG9yLCB1X2MsIHVfYzE7XG5cbiAgLy8gc3luYyB2ZXJzaW9uXG4gIGlmKCFjYWxsYmFjaykge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPD0gbGVuOyArK2kpIHtcbiAgICAgIC8vIFBSRihQLCBTIHx8IElOVChpKSkgKGZpcnN0IGl0ZXJhdGlvbilcbiAgICAgIHByZi5zdGFydChudWxsLCBudWxsKTtcbiAgICAgIHByZi51cGRhdGUocyk7XG4gICAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICAgIHhvciA9IHVfYzEgPSBwcmYuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgICAgLy8gUFJGKFAsIHVfe2MtMX0pIChvdGhlciBpdGVyYXRpb25zKVxuICAgICAgZm9yKHZhciBqID0gMjsgaiA8PSBjOyArK2opIHtcbiAgICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgICBwcmYudXBkYXRlKHVfYzEpO1xuICAgICAgICB1X2MgPSBwcmYuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgLy8gRihwLCBzLCBjLCBpKVxuICAgICAgICB4b3IgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHhvciwgdV9jLCBoTGVuKTtcbiAgICAgICAgdV9jMSA9IHVfYztcbiAgICAgIH1cblxuICAgICAgLyogNC4gQ29uY2F0ZW5hdGUgdGhlIGJsb2NrcyBhbmQgZXh0cmFjdCB0aGUgZmlyc3QgZGtMZW4gb2N0ZXRzIHRvXG4gICAgICAgIHByb2R1Y2UgYSBkZXJpdmVkIGtleSBESzpcblxuICAgICAgICBESyA9IFRfMSB8fCBUXzIgfHwgIC4uLiAgfHwgVF9sZW48MC4uci0xPiAqL1xuICAgICAgZGsgKz0gKGkgPCBsZW4pID8geG9yIDogeG9yLnN1YnN0cigwLCByKTtcbiAgICB9XG4gICAgLyogNS4gT3V0cHV0IHRoZSBkZXJpdmVkIGtleSBESy4gKi9cbiAgICByZXR1cm4gZGs7XG4gIH1cblxuICAvLyBhc3luYyB2ZXJzaW9uXG4gIHZhciBpID0gMSwgajtcbiAgZnVuY3Rpb24gb3V0ZXIoKSB7XG4gICAgaWYoaSA+IGxlbikge1xuICAgICAgLy8gZG9uZVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRrKTtcbiAgICB9XG5cbiAgICAvLyBQUkYoUCwgUyB8fCBJTlQoaSkpIChmaXJzdCBpdGVyYXRpb24pXG4gICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgIHByZi51cGRhdGUocyk7XG4gICAgcHJmLnVwZGF0ZShmb3JnZS51dGlsLmludDMyVG9CeXRlcyhpKSk7XG4gICAgeG9yID0gdV9jMSA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLy8gUFJGKFAsIHVfe2MtMX0pIChvdGhlciBpdGVyYXRpb25zKVxuICAgIGogPSAyO1xuICAgIGlubmVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbm5lcigpIHtcbiAgICBpZihqIDw9IGMpIHtcbiAgICAgIHByZi5zdGFydChudWxsLCBudWxsKTtcbiAgICAgIHByZi51cGRhdGUodV9jMSk7XG4gICAgICB1X2MgPSBwcmYuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICAgIC8vIEYocCwgcywgYywgaSlcbiAgICAgIHhvciA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoeG9yLCB1X2MsIGhMZW4pO1xuICAgICAgdV9jMSA9IHVfYztcbiAgICAgICsrajtcbiAgICAgIHJldHVybiBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShpbm5lcik7XG4gICAgfVxuXG4gICAgLyogNC4gQ29uY2F0ZW5hdGUgdGhlIGJsb2NrcyBhbmQgZXh0cmFjdCB0aGUgZmlyc3QgZGtMZW4gb2N0ZXRzIHRvXG4gICAgICBwcm9kdWNlIGEgZGVyaXZlZCBrZXkgREs6XG5cbiAgICAgIERLID0gVF8xIHx8IFRfMiB8fCAgLi4uICB8fCBUX2xlbjwwLi5yLTE+ICovXG4gICAgZGsgKz0gKGkgPCBsZW4pID8geG9yIDogeG9yLnN1YnN0cigwLCByKTtcblxuICAgICsraTtcbiAgICBvdXRlcigpO1xuICB9XG5cbiAgb3V0ZXIoKTtcbn07XG4iLCAiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGJhc2ljIFBFTSAoUHJpdmFjeSBFbmhhbmNlZCBNYWlsKSBhbGdvcml0aG1zLlxuICpcbiAqIFNlZTogUkZDIDE0MjEuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIEEgRm9yZ2UgUEVNIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gKlxuICogdHlwZTogaWRlbnRpZmllcyB0aGUgdHlwZSBvZiBtZXNzYWdlIChlZzogXCJSU0EgUFJJVkFURSBLRVlcIikuXG4gKlxuICogcHJvY1R5cGU6IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgcHJvY2Vzc2luZyBwZXJmb3JtZWQgb24gdGhlIG1lc3NhZ2UsXG4gKiAgIGl0IGhhcyB0d28gc3ViZmllbGRzOiB2ZXJzaW9uIGFuZCB0eXBlLCBlZzogNCxFTkNSWVBURUQuXG4gKlxuICogY29udGVudERvbWFpbjogaWRlbnRpZmllcyB0aGUgdHlwZSBvZiBjb250ZW50IGluIHRoZSBtZXNzYWdlLCB0eXBpY2FsbHlcbiAqICAgb25seSB1c2VzIHRoZSB2YWx1ZTogXCJSRkM4MjJcIi5cbiAqXG4gKiBkZWtJbmZvOiBpZGVudGlmaWVzIHRoZSBtZXNzYWdlIGVuY3J5cHRpb24gYWxnb3JpdGhtIGFuZCBtb2RlIGFuZCBpbmNsdWRlc1xuICogICBhbnkgcGFyYW1ldGVycyBmb3IgdGhlIGFsZ29yaXRobSwgaXQgaGFzIHR3byBzdWJmaWVsZHM6IGFsZ29yaXRobSBhbmRcbiAqICAgcGFyYW1ldGVycywgZWc6IERFUy1DQkMsRjgxNDNFREU1OTYwQzU5Ny5cbiAqXG4gKiBoZWFkZXJzOiBjb250YWlucyBhbGwgb3RoZXIgUEVNIGVuY2Fwc3VsYXRlZCBoZWFkZXJzIC0tIHdoZXJlIG9yZGVyIGlzXG4gKiAgIHNpZ25pZmljYW50IChmb3IgcGFpcmluZyBkYXRhIGxpa2UgcmVjaXBpZW50IElEICsga2V5IGluZm8pLlxuICpcbiAqIGJvZHk6IHRoZSBiaW5hcnktZW5jb2RlZCBib2R5LlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gc2hvcnRjdXQgZm9yIHBlbSBBUElcbnZhciBwZW0gPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBlbSA9IGZvcmdlLnBlbSB8fCB7fTtcblxuLyoqXG4gKiBFbmNvZGVzIChzZXJpYWxpemVzKSB0aGUgZ2l2ZW4gUEVNIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbXNnIHRoZSBQRU0gbWVzc2FnZSBvYmplY3QgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lIGZvciB0aGUgYm9keSwgKGRlZmF1bHQ6IDY0KS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHN0cmluZy5cbiAqL1xucGVtLmVuY29kZSA9IGZ1bmN0aW9uKG1zZywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJ2YWwgPSAnLS0tLS1CRUdJTiAnICsgbXNnLnR5cGUgKyAnLS0tLS1cXHJcXG4nO1xuXG4gIC8vIGVuY29kZSBzcGVjaWFsIGhlYWRlcnNcbiAgdmFyIGhlYWRlcjtcbiAgaWYobXNnLnByb2NUeXBlKSB7XG4gICAgaGVhZGVyID0ge1xuICAgICAgbmFtZTogJ1Byb2MtVHlwZScsXG4gICAgICB2YWx1ZXM6IFtTdHJpbmcobXNnLnByb2NUeXBlLnZlcnNpb24pLCBtc2cucHJvY1R5cGUudHlwZV1cbiAgICB9O1xuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG4gIGlmKG1zZy5jb250ZW50RG9tYWluKSB7XG4gICAgaGVhZGVyID0ge25hbWU6ICdDb250ZW50LURvbWFpbicsIHZhbHVlczogW21zZy5jb250ZW50RG9tYWluXX07XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cbiAgaWYobXNnLmRla0luZm8pIHtcbiAgICBoZWFkZXIgPSB7bmFtZTogJ0RFSy1JbmZvJywgdmFsdWVzOiBbbXNnLmRla0luZm8uYWxnb3JpdGhtXX07XG4gICAgaWYobXNnLmRla0luZm8ucGFyYW1ldGVycykge1xuICAgICAgaGVhZGVyLnZhbHVlcy5wdXNoKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuXG4gIGlmKG1zZy5oZWFkZXJzKSB7XG4gICAgLy8gZW5jb2RlIGFsbCBvdGhlciBoZWFkZXJzXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5oZWFkZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBydmFsICs9IGZvbGRIZWFkZXIobXNnLmhlYWRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRlcm1pbmF0ZSBoZWFkZXJcbiAgaWYobXNnLnByb2NUeXBlKSB7XG4gICAgcnZhbCArPSAnXFxyXFxuJztcbiAgfVxuXG4gIC8vIGFkZCBib2R5XG4gIHJ2YWwgKz0gZm9yZ2UudXRpbC5lbmNvZGU2NChtc2cuYm9keSwgb3B0aW9ucy5tYXhsaW5lIHx8IDY0KSArICdcXHJcXG4nO1xuXG4gIHJ2YWwgKz0gJy0tLS0tRU5EICcgKyBtc2cudHlwZSArICctLS0tLVxcclxcbic7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIChkZXNlcmlhbGl6ZXMpIGFsbCBQRU0gbWVzc2FnZXMgZm91bmQgaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBQRU0tZm9ybWF0dGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgUEVNIG1lc3NhZ2Ugb2JqZWN0cyBpbiBhbiBhcnJheS5cbiAqL1xucGVtLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIHNwbGl0IHN0cmluZyBpbnRvIFBFTSBtZXNzYWdlcyAoYmUgbGVuaWVudCB3L0VPRiBvbiBCRUdJTiBsaW5lKVxuICB2YXIgck1lc3NhZ2UgPSAvXFxzKi0tLS0tQkVHSU4gKFtBLVowLTktIF0rKS0tLS0tXFxyP1xcbj8oW1xceDIxLVxceDdlXFxzXSs/KD86XFxyP1xcblxccj9cXG4pKT8oWzpBLVphLXowLTkrXFwvPVxcc10rPyktLS0tLUVORCBcXDEtLS0tLS9nO1xuICB2YXIgckhlYWRlciA9IC8oW1xceDIxLVxceDdlXSspOlxccyooW1xceDIxLVxceDdlXFxzXjpdKykvO1xuICB2YXIgckNSTEYgPSAvXFxyP1xcbi87XG4gIHZhciBtYXRjaDtcbiAgd2hpbGUodHJ1ZSkge1xuICAgIG1hdGNoID0gck1lc3NhZ2UuZXhlYyhzdHIpO1xuICAgIGlmKCFtYXRjaCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYWNjZXB0IFwiTkVXIENFUlRJRklDQVRFIFJFUVVFU1RcIiBhcyBcIkNFUlRJRklDQVRFIFJFUVVFU1RcIlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzQ2OCNzZWN0aW9uLTdcbiAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgIGlmKHR5cGUgPT09ICdORVcgQ0VSVElGSUNBVEUgUkVRVUVTVCcpIHtcbiAgICAgIHR5cGUgPSAnQ0VSVElGSUNBVEUgUkVRVUVTVCc7XG4gICAgfVxuXG4gICAgdmFyIG1zZyA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwcm9jVHlwZTogbnVsbCxcbiAgICAgIGNvbnRlbnREb21haW46IG51bGwsXG4gICAgICBkZWtJbmZvOiBudWxsLFxuICAgICAgaGVhZGVyczogW10sXG4gICAgICBib2R5OiBmb3JnZS51dGlsLmRlY29kZTY0KG1hdGNoWzNdKVxuICAgIH07XG4gICAgcnZhbC5wdXNoKG1zZyk7XG5cbiAgICAvLyBubyBoZWFkZXJzXG4gICAgaWYoIW1hdGNoWzJdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBoZWFkZXJzXG4gICAgdmFyIGxpbmVzID0gbWF0Y2hbMl0uc3BsaXQockNSTEYpO1xuICAgIHZhciBsaSA9IDA7XG4gICAgd2hpbGUobWF0Y2ggJiYgbGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgIC8vIGdldCBsaW5lLCB0cmltIGFueSByaHMgd2hpdGVzcGFjZVxuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaV0ucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG5cbiAgICAgIC8vIFJGQzI4MjIgdW5mb2xkIGFueSBmb2xsb3dpbmcgZm9sZGVkIGxpbmVzXG4gICAgICBmb3IodmFyIG5sID0gbGkgKyAxOyBubCA8IGxpbmVzLmxlbmd0aDsgKytubCkge1xuICAgICAgICB2YXIgbmV4dCA9IGxpbmVzW25sXTtcbiAgICAgICAgaWYoIS9cXHMvLnRlc3QobmV4dFswXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsaW5lICs9IG5leHQ7XG4gICAgICAgIGxpID0gbmw7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIGhlYWRlclxuICAgICAgbWF0Y2ggPSBsaW5lLm1hdGNoKHJIZWFkZXIpO1xuICAgICAgaWYobWF0Y2gpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHtuYW1lOiBtYXRjaFsxXSwgdmFsdWVzOiBbXX07XG4gICAgICAgIHZhciB2YWx1ZXMgPSBtYXRjaFsyXS5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCB2YWx1ZXMubGVuZ3RoOyArK3ZpKSB7XG4gICAgICAgICAgaGVhZGVyLnZhbHVlcy5wdXNoKGx0cmltKHZhbHVlc1t2aV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2MtVHlwZSBtdXN0IGJlIHRoZSBmaXJzdCBoZWFkZXJcbiAgICAgICAgaWYoIW1zZy5wcm9jVHlwZSkge1xuICAgICAgICAgIGlmKGhlYWRlci5uYW1lICE9PSAnUHJvYy1UeXBlJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIGZpcnN0ICcgK1xuICAgICAgICAgICAgICAnZW5jYXBzdWxhdGVkIGhlYWRlciBtdXN0IGJlIFwiUHJvYy1UeXBlXCIuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmKGhlYWRlci52YWx1ZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJQcm9jLVR5cGVcIiAnICtcbiAgICAgICAgICAgICAgJ2hlYWRlciBtdXN0IGhhdmUgdHdvIHN1YmZpZWxkcy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbXNnLnByb2NUeXBlID0ge3ZlcnNpb246IHZhbHVlc1swXSwgdHlwZTogdmFsdWVzWzFdfTtcbiAgICAgICAgfSBlbHNlIGlmKCFtc2cuY29udGVudERvbWFpbiAmJiBoZWFkZXIubmFtZSA9PT0gJ0NvbnRlbnQtRG9tYWluJykge1xuICAgICAgICAgIC8vIHNwZWNpYWwtY2FzZSBDb250ZW50LURvbWFpblxuICAgICAgICAgIG1zZy5jb250ZW50RG9tYWluID0gdmFsdWVzWzBdIHx8ICcnO1xuICAgICAgICB9IGVsc2UgaWYoIW1zZy5kZWtJbmZvICYmIGhlYWRlci5uYW1lID09PSAnREVLLUluZm8nKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIERFSy1JbmZvXG4gICAgICAgICAgaWYoaGVhZGVyLnZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIkRFSy1JbmZvXCIgJyArXG4gICAgICAgICAgICAgICdoZWFkZXIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdWJmaWVsZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbXNnLmRla0luZm8gPSB7YWxnb3JpdGhtOiB2YWx1ZXNbMF0sIHBhcmFtZXRlcnM6IHZhbHVlc1sxXSB8fCBudWxsfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtc2cuaGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKytsaTtcbiAgICB9XG5cbiAgICBpZihtc2cucHJvY1R5cGUgPT09ICdFTkNSWVBURUQnICYmICFtc2cuZGVrSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiAnICtcbiAgICAgICAgJ2hlYWRlciBtdXN0IGJlIHByZXNlbnQgaWYgXCJQcm9jLVR5cGVcIiBpcyBcIkVOQ1JZUFRFRFwiLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmKHJ2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4nKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuZnVuY3Rpb24gZm9sZEhlYWRlcihoZWFkZXIpIHtcbiAgdmFyIHJ2YWwgPSBoZWFkZXIubmFtZSArICc6ICc7XG5cbiAgLy8gZW5zdXJlIHZhbHVlcyB3aXRoIENSTEYgYXJlIGZvbGRlZFxuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBpbnNlcnRTcGFjZSA9IGZ1bmN0aW9uKG1hdGNoLCAkMSkge1xuICAgIHJldHVybiAnICcgKyAkMTtcbiAgfTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGhlYWRlci52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YWx1ZXMucHVzaChoZWFkZXIudmFsdWVzW2ldLnJlcGxhY2UoL14oXFxTK1xcclxcbikvLCBpbnNlcnRTcGFjZSkpO1xuICB9XG4gIHJ2YWwgKz0gdmFsdWVzLmpvaW4oJywnKSArICdcXHJcXG4nO1xuXG4gIC8vIGRvIGZvbGRpbmdcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBjYW5kaWRhdGUgPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHJ2YWwubGVuZ3RoOyArK2ksICsrbGVuZ3RoKSB7XG4gICAgaWYobGVuZ3RoID4gNjUgJiYgY2FuZGlkYXRlICE9PSAtMSkge1xuICAgICAgdmFyIGluc2VydCA9IHJ2YWxbY2FuZGlkYXRlXTtcbiAgICAgIGlmKGluc2VydCA9PT0gJywnKSB7XG4gICAgICAgICsrY2FuZGlkYXRlO1xuICAgICAgICBydmFsID0gcnZhbC5zdWJzdHIoMCwgY2FuZGlkYXRlKSArICdcXHJcXG4gJyArIHJ2YWwuc3Vic3RyKGNhbmRpZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsID0gcnZhbC5zdWJzdHIoMCwgY2FuZGlkYXRlKSArXG4gICAgICAgICAgJ1xcclxcbicgKyBpbnNlcnQgKyBydmFsLnN1YnN0cihjYW5kaWRhdGUgKyAxKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IChpIC0gY2FuZGlkYXRlIC0gMSk7XG4gICAgICBjYW5kaWRhdGUgPSAtMTtcbiAgICAgICsraTtcbiAgICB9IGVsc2UgaWYocnZhbFtpXSA9PT0gJyAnIHx8IHJ2YWxbaV0gPT09ICdcXHQnIHx8IHJ2YWxbaV0gPT09ICcsJykge1xuICAgICAgY2FuZGlkYXRlID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuZnVuY3Rpb24gbHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJyk7XG59XG4iLCAiLyoqXG4gKiBTZWN1cmUgSGFzaCBBbGdvcml0aG0gd2l0aCAyNTYtYml0IGRpZ2VzdCAoU0hBLTI1NikgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU2VlIEZJUFMgMTgwLTIgZm9yIGRldGFpbHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNoYTI1NiA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2Uuc2hhMjU2ID0gZm9yZ2Uuc2hhMjU2IHx8IHt9O1xuZm9yZ2UubWQuc2hhMjU2ID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5zaGEyNTYgPSBzaGEyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0yNTYgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gYSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKi9cbnNoYTI1Ni5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gaW5pdGlhbGl6YXRpb24gYXMgbmVjZXNzYXJ5XG4gIGlmKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICBfaW5pdCgpO1xuICB9XG5cbiAgLy8gU0hBLTI1NiBzdGF0ZSBjb250YWlucyBlaWdodCAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIF9zdGF0ZSA9IG51bGw7XG5cbiAgLy8gaW5wdXQgYnVmZmVyXG4gIHZhciBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZWQgZm9yIHdvcmQgc3RvcmFnZVxuICB2YXIgX3cgPSBuZXcgQXJyYXkoNjQpO1xuXG4gIC8vIG1lc3NhZ2UgZGlnZXN0IG9iamVjdFxuICB2YXIgbWQgPSB7XG4gICAgYWxnb3JpdGhtOiAnc2hhMjU2JyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAzMixcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDZBMDlFNjY3LFxuICAgICAgaDE6IDB4QkI2N0FFODUsXG4gICAgICBoMjogMHgzQzZFRjM3MixcbiAgICAgIGgzOiAweEE1NEZGNTNBLFxuICAgICAgaDQ6IDB4NTEwRTUyN0YsXG4gICAgICBoNTogMHg5QjA1Njg4QyxcbiAgICAgIGg2OiAweDFGODNEOUFCLFxuICAgICAgaDc6IDB4NUJFMENEMTlcbiAgICB9O1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTI1NiBwYWRkaW5nLiBUaGVuIHdlIGRvIHRoZSBmaW5hbCB1cGRhdGVcbiAgICBvbiBhIGNvcHkgb2YgdGhlIHN0YXRlIHNvIHRoYXQgaWYgdGhlIHVzZXIgd2FudHMgdG8gZ2V0XG4gICAgaW50ZXJtZWRpYXRlIGRpZ2VzdHMgdGhleSBjYW4gZG8gc28uICovXG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBieXRlcyB0aGF0IG11c3QgYmUgYWRkZWQgdG8gdGhlIG1lc3NhZ2VcbiAgICB0byBlbnN1cmUgaXRzIGxlbmd0aCBpcyBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIuIEluIG90aGVyIHdvcmRzLFxuICAgIHRoZSBkYXRhIHRvIGJlIGRpZ2VzdGVkIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA1MTIgYml0cyAob3IgMTI4IGJ5dGVzKS5cbiAgICBUaGlzIGRhdGEgaW5jbHVkZXMgdGhlIG1lc3NhZ2UsIHNvbWUgcGFkZGluZywgYW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgbWVzc2FnZS4gU2luY2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSB3aWxsIGJlIGVuY29kZWQgYXMgOCBieXRlcyAoNjRcbiAgICBiaXRzKSwgdGhhdCBtZWFucyB0aGF0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGRhdGEgbXVzdCBoYXZlIDU2IGJ5dGVzXG4gICAgKDQ0OCBiaXRzKSBvZiBtZXNzYWdlIGFuZCBwYWRkaW5nLiBUaGVyZWZvcmUsIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2VcbiAgICBwbHVzIHRoZSBwYWRkaW5nIG11c3QgYmUgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyIGJlY2F1c2VcbiAgICA1MTIgLSAxMjggPSA0NDguXG5cbiAgICBJbiBvcmRlciB0byBmaWxsIHVwIHRoZSBtZXNzYWdlIGxlbmd0aCBpdCBtdXN0IGJlIGZpbGxlZCB3aXRoXG4gICAgcGFkZGluZyB0aGF0IGJlZ2lucyB3aXRoIDEgYml0IGZvbGxvd2VkIGJ5IGFsbCAwIGJpdHMuIFBhZGRpbmdcbiAgICBtdXN0ICphbHdheXMqIGJlIHByZXNlbnQsIHNvIGlmIHRoZSBtZXNzYWdlIGxlbmd0aCBpcyBhbHJlYWR5XG4gICAgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLCB0aGVuIDUxMiBwYWRkaW5nIGJpdHMgbXVzdCBiZSBhZGRlZC4gKi9cblxuICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9pbnB1dC5ieXRlcygpKTtcblxuICAgIC8vIGNvbXB1dGUgcmVtYWluaW5nIHNpemUgdG8gYmUgZGlnZXN0ZWQgKGluY2x1ZGUgbWVzc2FnZSBsZW5ndGggc2l6ZSlcbiAgICB2YXIgcmVtYWluaW5nID0gKFxuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMV0gK1xuICAgICAgbWQubWVzc2FnZUxlbmd0aFNpemUpO1xuXG4gICAgLy8gYWRkIHBhZGRpbmcgZm9yIG92ZXJmbG93IGJsb2NrU2l6ZSAtIG92ZXJmbG93XG4gICAgLy8gX3BhZGRpbmcgc3RhcnRzIHdpdGggMSBieXRlIHdpdGggZmlyc3QgYml0IGlzIHNldCAoYnl0ZSB2YWx1ZSAxMjgpLCB0aGVuXG4gICAgLy8gdGhlcmUgbWF5IGJlIHVwIHRvIChibG9ja1NpemUgLSAxKSBvdGhlciBwYWQgYnl0ZXNcbiAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiAobWQuYmxvY2tMZW5ndGggLSAxKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9wYWRkaW5nLnN1YnN0cigwLCBtZC5ibG9ja0xlbmd0aCAtIG92ZXJmbG93KSk7XG5cbiAgICAvLyBzZXJpYWxpemUgbWVzc2FnZSBsZW5ndGggaW4gYml0cyBpbiBiaWctZW5kaWFuIG9yZGVyOyBzaW5jZSBsZW5ndGhcbiAgICAvLyBpcyBzdG9yZWQgaW4gYnl0ZXMgd2UgbXVsdGlwbHkgYnkgOCBhbmQgYWRkIGNhcnJ5IGZyb20gbmV4dCBpbnRcbiAgICB2YXIgbmV4dCwgY2Fycnk7XG4gICAgdmFyIGJpdHMgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFswXSAqIDg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgbmV4dCA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2kgKyAxXSAqIDg7XG4gICAgICBjYXJyeSA9IChuZXh0IC8gMHgxMDAwMDAwMDApID4+PiAwO1xuICAgICAgYml0cyArPSBjYXJyeTtcbiAgICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyA+Pj4gMCk7XG4gICAgICBiaXRzID0gbmV4dCA+Pj4gMDtcbiAgICB9XG4gICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzKTtcblxuICAgIHZhciBzMiA9IHtcbiAgICAgIGgwOiBfc3RhdGUuaDAsXG4gICAgICBoMTogX3N0YXRlLmgxLFxuICAgICAgaDI6IF9zdGF0ZS5oMixcbiAgICAgIGgzOiBfc3RhdGUuaDMsXG4gICAgICBoNDogX3N0YXRlLmg0LFxuICAgICAgaDU6IF9zdGF0ZS5oNSxcbiAgICAgIGg2OiBfc3RhdGUuaDYsXG4gICAgICBoNzogX3N0YXRlLmg3XG4gICAgfTtcbiAgICBfdXBkYXRlKHMyLCBfdywgZmluYWxCbG9jayk7XG4gICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDApO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDEpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDIpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDMpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDQpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDUpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDYpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDcpO1xuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIHJldHVybiBtZDtcbn07XG5cbi8vIHNoYS0yNTYgcGFkZGluZyBieXRlcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG52YXIgX3BhZGRpbmcgPSBudWxsO1xudmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vLyB0YWJsZSBvZiBjb25zdGFudHNcbnZhciBfayA9IG51bGw7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgNjQpO1xuXG4gIC8vIGNyZWF0ZSBLIHRhYmxlIGZvciBTSEEtMjU2XG4gIF9rID0gW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gICAgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAgIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcbiAgICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gICAgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuICAgIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMyxcbiAgICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gICAgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuICAgIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJdO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtMjU2IHN0YXRlIHdpdGggdGhlIGdpdmVuIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzIHRoZSBTSEEtMjU2IHN0YXRlIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB3IHRoZSBhcnJheSB0byB1c2UgdG8gc3RvcmUgd29yZHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHVwZGF0ZSB3aXRoLlxuICovXG5mdW5jdGlvbiBfdXBkYXRlKHMsIHcsIGJ5dGVzKSB7XG4gIC8vIGNvbnN1bWUgNTEyIGJpdCAoNjQgYnl0ZSkgY2h1bmtzXG4gIHZhciB0MSwgdDIsIHMwLCBzMSwgY2gsIG1haiwgaSwgYSwgYiwgYywgZCwgZSwgZiwgZywgaDtcbiAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aCgpO1xuICB3aGlsZShsZW4gPj0gNjQpIHtcbiAgICAvLyB0aGUgdyBhcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHNpeHRlZW4gMzItYml0IGJpZy1lbmRpYW4gd29yZHNcbiAgICAvLyBhbmQgdGhlbiBleHRlbmRlZCBpbnRvIDY0IDMyLWJpdCB3b3JkcyBhY2NvcmRpbmcgdG8gU0hBLTI1NlxuICAgIGZvcihpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHdbaV0gPSBieXRlcy5nZXRJbnQzMigpO1xuICAgIH1cbiAgICBmb3IoOyBpIDwgNjQ7ICsraSkge1xuICAgICAgLy8gWE9SIHdvcmQgMiB3b3JkcyBhZ28gcm90IHJpZ2h0IDE3LCByb3QgcmlnaHQgMTksIHNoZnQgcmlnaHQgMTBcbiAgICAgIHQxID0gd1tpIC0gMl07XG4gICAgICB0MSA9XG4gICAgICAgICgodDEgPj4+IDE3KSB8ICh0MSA8PCAxNSkpIF5cbiAgICAgICAgKCh0MSA+Pj4gMTkpIHwgKHQxIDw8IDEzKSkgXlxuICAgICAgICAodDEgPj4+IDEwKTtcbiAgICAgIC8vIFhPUiB3b3JkIDE1IHdvcmRzIGFnbyByb3QgcmlnaHQgNywgcm90IHJpZ2h0IDE4LCBzaGZ0IHJpZ2h0IDNcbiAgICAgIHQyID0gd1tpIC0gMTVdO1xuICAgICAgdDIgPVxuICAgICAgICAoKHQyID4+PiA3KSB8ICh0MiA8PCAyNSkpIF5cbiAgICAgICAgKCh0MiA+Pj4gMTgpIHwgKHQyIDw8IDE0KSkgXlxuICAgICAgICAodDIgPj4+IDMpO1xuICAgICAgLy8gc3VtKHQxLCB3b3JkIDcgYWdvLCB0Miwgd29yZCAxNiBhZ28pIG1vZHVsbyAyXjMyXG4gICAgICB3W2ldID0gKHQxICsgd1tpIC0gN10gKyB0MiArIHdbaSAtIDE2XSkgfCAwO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgaGFzaCB2YWx1ZSBmb3IgdGhpcyBjaHVua1xuICAgIGEgPSBzLmgwO1xuICAgIGIgPSBzLmgxO1xuICAgIGMgPSBzLmgyO1xuICAgIGQgPSBzLmgzO1xuICAgIGUgPSBzLmg0O1xuICAgIGYgPSBzLmg1O1xuICAgIGcgPSBzLmg2O1xuICAgIGggPSBzLmg3O1xuXG4gICAgLy8gcm91bmQgZnVuY3Rpb25cbiAgICBmb3IoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBTdW0xKGUpXG4gICAgICBzMSA9XG4gICAgICAgICgoZSA+Pj4gNikgfCAoZSA8PCAyNikpIF5cbiAgICAgICAgKChlID4+PiAxMSkgfCAoZSA8PCAyMSkpIF5cbiAgICAgICAgKChlID4+PiAyNSkgfCAoZSA8PCA3KSk7XG4gICAgICAvLyBDaChlLCBmLCBnKSAob3B0aW1pemVkIHRoZSBzYW1lIHdheSBhcyBTSEEtMSlcbiAgICAgIGNoID0gZyBeIChlICYgKGYgXiBnKSk7XG4gICAgICAvLyBTdW0wKGEpXG4gICAgICBzMCA9XG4gICAgICAgICgoYSA+Pj4gMikgfCAoYSA8PCAzMCkpIF5cbiAgICAgICAgKChhID4+PiAxMykgfCAoYSA8PCAxOSkpIF5cbiAgICAgICAgKChhID4+PiAyMikgfCAoYSA8PCAxMCkpO1xuICAgICAgLy8gTWFqKGEsIGIsIGMpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgbWFqID0gKGEgJiBiKSB8IChjICYgKGEgXiBiKSk7XG5cbiAgICAgIC8vIG1haW4gYWxnb3JpdGhtXG4gICAgICB0MSA9IGggKyBzMSArIGNoICsgX2tbaV0gKyB3W2ldO1xuICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgIGggPSBnO1xuICAgICAgZyA9IGY7XG4gICAgICBmID0gZTtcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgLy8gY2FuJ3QgdHJ1bmNhdGUgd2l0aCBgfCAwYFxuICAgICAgZSA9IChkICsgdDEpID4+PiAwO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gYjtcbiAgICAgIGIgPSBhO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBhID0gKHQxICsgdDIpID4+PiAwO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBoYXNoIHN0YXRlXG4gICAgcy5oMCA9IChzLmgwICsgYSkgfCAwO1xuICAgIHMuaDEgPSAocy5oMSArIGIpIHwgMDtcbiAgICBzLmgyID0gKHMuaDIgKyBjKSB8IDA7XG4gICAgcy5oMyA9IChzLmgzICsgZCkgfCAwO1xuICAgIHMuaDQgPSAocy5oNCArIGUpIHwgMDtcbiAgICBzLmg1ID0gKHMuaDUgKyBmKSB8IDA7XG4gICAgcy5oNiA9IChzLmg2ICsgZykgfCAwO1xuICAgIHMuaDcgPSAocy5oNyArIGgpIHwgMDtcbiAgICBsZW4gLT0gNjQ7XG4gIH1cbn1cbiIsICIvKipcbiAqIEEgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZVxuICogUHNldWRvIFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yIChQUk5HKS4gVGhlIEZvcnR1bmEgYWxnb3JpdGhtIGlzIGZvbGxvd2VkXG4gKiBoZXJlIHRob3VnaCB0aGUgdXNlIG9mIFNIQS0yNTYgaXMgbm90IGVuZm9yY2VkOyB3aGVuIGdlbmVyYXRpbmcgYW5cbiAqIGEgUFJORyBjb250ZXh0LCB0aGUgaGFzaGluZyBhbGdvcml0aG0gYW5kIGJsb2NrIGNpcGhlciB1c2VkIGZvclxuICogdGhlIGdlbmVyYXRvciBhcmUgc3BlY2lmaWVkIHZpYSBhIHBsdWdpbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX2NyeXB0byA9IG51bGw7XG5pZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0ICYmXG4gICFwcm9jZXNzLnZlcnNpb25zWydub2RlLXdlYmtpdCddKSB7XG4gIF9jcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbn1cblxuLyogUFJORyBBUEkgKi9cbnZhciBwcm5nID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcm5nID0gZm9yZ2UucHJuZyB8fCB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBSTkcgY29udGV4dC5cbiAqXG4gKiBBIFBSTkcgcGx1Z2luIG11c3QgYmUgcGFzc2VkIGluIHRoYXQgd2lsbCBwcm92aWRlOlxuICpcbiAqIDEuIEEgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUga2V5IGFuZCBzZWVkIG9mIGEgUFJORyBjb250ZXh0LiBJdFxuICogICB3aWxsIGJlIGdpdmVuIGEgMTYgYnl0ZSBrZXkgYW5kIGEgMTYgYnl0ZSBzZWVkLiBBbnkga2V5IGV4cGFuc2lvblxuICogICBvciB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgc2VlZCBmcm9tIGEgYnl0ZSBzdHJpbmcgaW50byBhbiBhcnJheSBvZlxuICogICBpbnRlZ2VycyAob3Igc2ltaWxhcikgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAqIDIuIFRoZSBjcnlwdG9ncmFwaGljIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGdlbmVyYXRvci4gSXQgdGFrZXMgYSBrZXkgYW5kXG4gKiAgIGEgc2VlZC5cbiAqIDMuIEEgc2VlZCBpbmNyZW1lbnQgZnVuY3Rpb24uIEl0IHRha2VzIHRoZSBzZWVkIGFuZCByZXR1cm5zIHNlZWQgKyAxLlxuICogNC4gQW4gYXBpIHRvIGNyZWF0ZSBhIG1lc3NhZ2UgZGlnZXN0LlxuICpcbiAqIEZvciBhbiBleGFtcGxlLCBzZWUgcmFuZG9tLmpzLlxuICpcbiAqIEBwYXJhbSBwbHVnaW4gdGhlIFBSTkcgcGx1Z2luIHRvIHVzZS5cbiAqL1xucHJuZy5jcmVhdGUgPSBmdW5jdGlvbihwbHVnaW4pIHtcbiAgdmFyIGN0eCA9IHtcbiAgICBwbHVnaW46IHBsdWdpbixcbiAgICBrZXk6IG51bGwsXG4gICAgc2VlZDogbnVsbCxcbiAgICB0aW1lOiBudWxsLFxuICAgIC8vIG51bWJlciBvZiByZXNlZWRzIHNvIGZhclxuICAgIHJlc2VlZHM6IDAsXG4gICAgLy8gYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIHNvIGZhclxuICAgIGdlbmVyYXRlZDogMCxcbiAgICAvLyBubyBpbml0aWFsIGtleSBieXRlc1xuICAgIGtleUJ5dGVzOiAnJ1xuICB9O1xuXG4gIC8vIGNyZWF0ZSAzMiBlbnRyb3B5IHBvb2xzIChlYWNoIGlzIGEgbWVzc2FnZSBkaWdlc3QpXG4gIHZhciBtZCA9IHBsdWdpbi5tZDtcbiAgdmFyIHBvb2xzID0gbmV3IEFycmF5KDMyKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICBwb29sc1tpXSA9IG1kLmNyZWF0ZSgpO1xuICB9XG4gIGN0eC5wb29scyA9IHBvb2xzO1xuXG4gIC8vIGVudHJvcHkgcG9vbHMgYXJlIHdyaXR0ZW4gdG8gY3ljbGljYWxseSwgc3RhcnRpbmcgYXQgaW5kZXggMFxuICBjdHgucG9vbCA9IDA7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMuIFRoZSBieXRlcyBtYXkgYmUgZ2VuZXJhdGVkIHN5bmNocm9ub3VzbHkgb3JcbiAgICogYXN5bmNocm9ub3VzbHkuIFdlYiB3b3JrZXJzIG11c3QgdXNlIHRoZSBhc3luY2hyb25vdXMgaW50ZXJmYWNlIG9yXG4gICAqIGVsc2UgdGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwgYnl0ZXMpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHJldHVybiBjb3VudCByYW5kb20gYnl0ZXMgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2VuZXJhdGUgPSBmdW5jdGlvbihjb3VudCwgY2FsbGJhY2spIHtcbiAgICAvLyBkbyBzeW5jaHJvbm91c2x5XG4gICAgaWYoIWNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY3R4LmdlbmVyYXRlU3luYyhjb3VudCk7XG4gICAgfVxuXG4gICAgLy8gc2ltcGxlIGdlbmVyYXRvciB1c2luZyBjb3VudGVyLWJhc2VkIENCQ1xuICAgIHZhciBjaXBoZXIgPSBjdHgucGx1Z2luLmNpcGhlcjtcbiAgICB2YXIgaW5jcmVtZW50ID0gY3R4LnBsdWdpbi5pbmNyZW1lbnQ7XG4gICAgdmFyIGZvcm1hdEtleSA9IGN0eC5wbHVnaW4uZm9ybWF0S2V5O1xuICAgIHZhciBmb3JtYXRTZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkO1xuICAgIHZhciBiID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlYCBjYWxsXG4gICAgY3R4LmtleSA9IG51bGw7XG5cbiAgICBnZW5lcmF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUoZXJyKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIHN1ZmZpY2llbnQgYnl0ZXMgZ2VuZXJhdGVkXG4gICAgICBpZihiLmxlbmd0aCgpID49IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBiLmdldEJ5dGVzKGNvdW50KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBpcyBncmVhdGVyIHRoYW4gMSBNaUIsIHRyaWdnZXIgcmVzZWVkXG4gICAgICBpZihjdHguZ2VuZXJhdGVkID4gMHhmZmZmZikge1xuICAgICAgICBjdHgua2V5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYoY3R4LmtleSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBwcmV2ZW50IHN0YWNrIG92ZXJmbG93XG4gICAgICAgIHJldHVybiBmb3JnZS51dGlsLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9yZXNlZWQoZ2VuZXJhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2VuZXJhdGUgdGhlIHJhbmRvbSBieXRlc1xuICAgICAgdmFyIGJ5dGVzID0gY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKTtcbiAgICAgIGN0eC5nZW5lcmF0ZWQgKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgYi5wdXRCeXRlcyhieXRlcyk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGJ5dGVzIGZvciBhIG5ldyBrZXkgYW5kIHNlZWRcbiAgICAgIGN0eC5rZXkgPSBmb3JtYXRLZXkoY2lwaGVyKGN0eC5rZXksIGluY3JlbWVudChjdHguc2VlZCkpKTtcbiAgICAgIGN0eC5zZWVkID0gZm9ybWF0U2VlZChjaXBoZXIoY3R4LmtleSwgY3R4LnNlZWQpKTtcblxuICAgICAgZm9yZ2UudXRpbC5zZXRJbW1lZGlhdGUoZ2VuZXJhdGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJhbmRvbSBieXRlcyBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlU3luYyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gc2ltcGxlIGdlbmVyYXRvciB1c2luZyBjb3VudGVyLWJhc2VkIENCQ1xuICAgIHZhciBjaXBoZXIgPSBjdHgucGx1Z2luLmNpcGhlcjtcbiAgICB2YXIgaW5jcmVtZW50ID0gY3R4LnBsdWdpbi5pbmNyZW1lbnQ7XG4gICAgdmFyIGZvcm1hdEtleSA9IGN0eC5wbHVnaW4uZm9ybWF0S2V5O1xuICAgIHZhciBmb3JtYXRTZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkO1xuXG4gICAgLy8gcGFyYW5vaWQgZGV2aWF0aW9uIGZyb20gRm9ydHVuYTpcbiAgICAvLyByZXNldCBrZXkgZm9yIGV2ZXJ5IHJlcXVlc3QgdG8gcHJvdGVjdCBwcmV2aW91c2x5XG4gICAgLy8gZ2VuZXJhdGVkIHJhbmRvbSBieXRlcyBzaG91bGQgdGhlIGtleSBiZSBkaXNjb3ZlcmVkO1xuICAgIC8vIHRoZXJlIGlzIG5vIDEwMG1zIGJhc2VkIHJlc2VlZGluZyBiZWNhdXNlIG9mIHRoaXNcbiAgICAvLyBmb3JjZWQgcmVzZWVkIGZvciBldmVyeSBgZ2VuZXJhdGVTeW5jYCBjYWxsXG4gICAgY3R4LmtleSA9IG51bGw7XG5cbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgd2hpbGUoYi5sZW5ndGgoKSA8IGNvdW50KSB7XG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgX3Jlc2VlZFN5bmMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2VuZXJhdGUgdGhlIHJhbmRvbSBieXRlc1xuICAgICAgdmFyIGJ5dGVzID0gY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKTtcbiAgICAgIGN0eC5nZW5lcmF0ZWQgKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgYi5wdXRCeXRlcyhieXRlcyk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGJ5dGVzIGZvciBhIG5ldyBrZXkgYW5kIHNlZWRcbiAgICAgIGN0eC5rZXkgPSBmb3JtYXRLZXkoY2lwaGVyKGN0eC5rZXksIGluY3JlbWVudChjdHguc2VlZCkpKTtcbiAgICAgIGN0eC5zZWVkID0gZm9ybWF0U2VlZChjaXBoZXIoY3R4LmtleSwgY3R4LnNlZWQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYi5nZXRCeXRlcyhjb3VudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBhc3luY2hyb25vdXNseSByZXNlZWRzIGEgZ2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2soZXJyKSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWQoY2FsbGJhY2spIHtcbiAgICBpZihjdHgucG9vbHNbMF0ubWVzc2FnZUxlbmd0aCA+PSAzMikge1xuICAgICAgX3NlZWQoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHNlZWQgZGF0YS4uLlxuICAgIHZhciBuZWVkZWQgPSAoMzIgLSBjdHgucG9vbHNbMF0ubWVzc2FnZUxlbmd0aCkgPDwgNTtcbiAgICBjdHguc2VlZEZpbGUobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBjdHguY29sbGVjdChieXRlcyk7XG4gICAgICBfc2VlZCgpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgc3luY2hyb25vdXNseSByZXNlZWRzIGEgZ2VuZXJhdG9yLlxuICAgKi9cbiAgZnVuY3Rpb24gX3Jlc2VlZFN5bmMoKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIHJldHVybiBfc2VlZCgpO1xuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHNlZWQgZGF0YS4uLlxuICAgIHZhciBuZWVkZWQgPSAoMzIgLSBjdHgucG9vbHNbMF0ubWVzc2FnZUxlbmd0aCkgPDwgNTtcbiAgICBjdHguY29sbGVjdChjdHguc2VlZEZpbGVTeW5jKG5lZWRlZCkpO1xuICAgIF9zZWVkKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHNlZWRzIGEgZ2VuZXJhdG9yIG9uY2UgZW5vdWdoIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBmdW5jdGlvbiBfc2VlZCgpIHtcbiAgICAvLyB1cGRhdGUgcmVzZWVkIGNvdW50XG4gICAgY3R4LnJlc2VlZHMgPSAoY3R4LnJlc2VlZHMgPT09IDB4ZmZmZmZmZmYpID8gMCA6IGN0eC5yZXNlZWRzICsgMTtcblxuICAgIC8vIGdvYWwgaXMgdG8gdXBkYXRlIGBrZXlgIHZpYTpcbiAgICAvLyBrZXkgPSBoYXNoKGtleSArIHMpXG4gICAgLy8gICB3aGVyZSAncycgaXMgYWxsIGNvbGxlY3RlZCBlbnRyb3B5IGZyb20gc2VsZWN0ZWQgcG9vbHMsIHRoZW4uLi5cblxuICAgIC8vIGNyZWF0ZSBhIHBsdWdpbi1iYXNlZCBtZXNzYWdlIGRpZ2VzdFxuICAgIHZhciBtZCA9IGN0eC5wbHVnaW4ubWQuY3JlYXRlKCk7XG5cbiAgICAvLyBjb25zdW1lIGN1cnJlbnQga2V5IGJ5dGVzXG4gICAgbWQudXBkYXRlKGN0eC5rZXlCeXRlcyk7XG5cbiAgICAvLyBkaWdlc3QgdGhlIGVudHJvcHkgb2YgcG9vbHMgd2hvc2UgaW5kZXggayBtZWV0IHRoZVxuICAgIC8vIGNvbmRpdGlvbiAnbiBtb2QgMl5rID09IDAnIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiByZXNlZWRzXG4gICAgdmFyIF8ycG93SyA9IDE7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IDMyOyArK2spIHtcbiAgICAgIGlmKGN0eC5yZXNlZWRzICUgXzJwb3dLID09PSAwKSB7XG4gICAgICAgIG1kLnVwZGF0ZShjdHgucG9vbHNba10uZGlnZXN0KCkuZ2V0Qnl0ZXMoKSk7XG4gICAgICAgIGN0eC5wb29sc1trXS5zdGFydCgpO1xuICAgICAgfVxuICAgICAgXzJwb3dLID0gXzJwb3dLIDw8IDE7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGRpZ2VzdCBmb3Iga2V5IGJ5dGVzXG4gICAgY3R4LmtleUJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gdXBkYXRlIGBzZWVkYCB2aWEgYHNlZWQgPSBoYXNoKGtleSlgXG4gICAgLy8gaW5zdGVhZCBvZiBpbml0aWFsaXppbmcgdG8gemVybyBvbmNlIGFuZCBvbmx5XG4gICAgLy8gZXZlciBpbmNyZW1lbnRpbmcgaXRcbiAgICBtZC5zdGFydCgpO1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuICAgIHZhciBzZWVkQnl0ZXMgPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLy8gdXBkYXRlIHN0YXRlXG4gICAgY3R4LmtleSA9IGN0eC5wbHVnaW4uZm9ybWF0S2V5KGN0eC5rZXlCeXRlcyk7XG4gICAgY3R4LnNlZWQgPSBjdHgucGx1Z2luLmZvcm1hdFNlZWQoc2VlZEJ5dGVzKTtcbiAgICBjdHguZ2VuZXJhdGVkID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYnVpbHQtaW4gZGVmYXVsdCBzZWVkRmlsZS4gVGhpcyBzZWVkRmlsZSBpcyB1c2VkIHdoZW4gZW50cm9weVxuICAgKiBpcyBuZWVkZWQgaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBuZWVkZWQgdGhlIG51bWJlciBvZiBieXRlcyB0aGF0IGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJhbmRvbSBieXRlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZmF1bHRTZWVkRmlsZShuZWVkZWQpIHtcbiAgICAvLyB1c2Ugd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgc3Ryb25nIHNvdXJjZSBvZiBlbnRyb3B5IGlmIGF2YWlsYWJsZVxuICAgIHZhciBnZXRSYW5kb21WYWx1ZXMgPSBudWxsO1xuICAgIHZhciBnbG9iYWxTY29wZSA9IGZvcmdlLnV0aWwuZ2xvYmFsU2NvcGU7XG4gICAgdmFyIF9jcnlwdG8gPSBnbG9iYWxTY29wZS5jcnlwdG8gfHwgZ2xvYmFsU2NvcGUubXNDcnlwdG87XG4gICAgaWYoX2NyeXB0byAmJiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHJldHVybiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgaWYoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIC8vIG1heCBieXRlIGxlbmd0aCBpcyA2NTUzNiBiZWZvcmUgUXVvdGFFeGNlZWRlZEVycm9yIGlzIHRocm93blxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XZWJDcnlwdG9BUEkvI1JhbmRvbVNvdXJjZS1tZXRob2QtZ2V0UmFuZG9tVmFsdWVzXG4gICAgICAgIHZhciBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGgubWluKG5lZWRlZCAtIGIubGVuZ3RoKCksIDY1NTM2KSAvIDQpO1xuICAgICAgICB2YXIgZW50cm9weSA9IG5ldyBVaW50MzJBcnJheShNYXRoLmZsb29yKGNvdW50KSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2V0UmFuZG9tVmFsdWVzKGVudHJvcHkpO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyb3B5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBiLnB1dEludDMyKGVudHJvcHlbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgLyogb25seSBpZ25vcmUgUXVvdGFFeGNlZWRlZEVycm9yICovXG4gICAgICAgICAgaWYoISh0eXBlb2YgUXVvdGFFeGNlZWRlZEVycm9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZSBpbnN0YW5jZW9mIFF1b3RhRXhjZWVkZWRFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmUgc2FkIGFuZCBhZGQgc29tZSB3ZWFrIHJhbmRvbSBkYXRhXG4gICAgaWYoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgLyogRHJhd3MgZnJvbSBQYXJrLU1pbGxlciBcIm1pbmltYWwgc3RhbmRhcmRcIiAzMSBiaXQgUFJORyxcbiAgICAgIGltcGxlbWVudGVkIHdpdGggRGF2aWQgRy4gQ2FydGEncyBvcHRpbWl6YXRpb246IHdpdGggMzIgYml0IG1hdGhcbiAgICAgIGFuZCB3aXRob3V0IGRpdmlzaW9uIChQdWJsaWMgRG9tYWluKS4gKi9cbiAgICAgIHZhciBoaSwgbG8sIG5leHQ7XG4gICAgICB2YXIgc2VlZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMDAwKTtcbiAgICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgICAgbG8gPSAxNjgwNyAqIChzZWVkICYgMHhGRkZGKTtcbiAgICAgICAgaGkgPSAxNjgwNyAqIChzZWVkID4+IDE2KTtcbiAgICAgICAgbG8gKz0gKGhpICYgMHg3RkZGKSA8PCAxNjtcbiAgICAgICAgbG8gKz0gaGkgPj4gMTU7XG4gICAgICAgIGxvID0gKGxvICYgMHg3RkZGRkZGRikgKyAobG8gPj4gMzEpO1xuICAgICAgICBzZWVkID0gbG8gJiAweEZGRkZGRkZGO1xuXG4gICAgICAgIC8vIGNvbnN1bWUgbG93ZXIgMyBieXRlcyBvZiBzZWVkXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAvLyB0aHJvdyBpbiBtb3JlIHBzZXVkbyByYW5kb21cbiAgICAgICAgICBuZXh0ID0gc2VlZCA+Pj4gKGkgPDwgMyk7XG4gICAgICAgICAgbmV4dCBePSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDApO1xuICAgICAgICAgIGIucHV0Qnl0ZShuZXh0ICYgMHhGRik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYi5nZXRCeXRlcyhuZWVkZWQpO1xuICB9XG4gIC8vIGluaXRpYWxpemUgc2VlZCBmaWxlIEFQSXNcbiAgaWYoX2NyeXB0bykge1xuICAgIC8vIHVzZSBub2RlanMgYXN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgX2NyeXB0by5yYW5kb21CeXRlcyhuZWVkZWQsIGZ1bmN0aW9uKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgYnl0ZXMudG9TdHJpbmcoKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHVzZSBub2RlanMgc3luYyBBUElcbiAgICBjdHguc2VlZEZpbGVTeW5jID0gZnVuY3Rpb24obmVlZGVkKSB7XG4gICAgICByZXR1cm4gX2NyeXB0by5yYW5kb21CeXRlcyhuZWVkZWQpLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjdHguc2VlZEZpbGVTeW5jID0gZGVmYXVsdFNlZWRGaWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZW50cm9weSB0byBhIHBybmcgY3R4J3MgYWNjdW11bGF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgb2YgZW50cm9weSBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5jb2xsZWN0ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAvLyBpdGVyYXRlIG92ZXIgcG9vbHMgZGlzdHJpYnV0aW5nIGVudHJvcHkgY3ljbGljYWxseVxuICAgIHZhciBjb3VudCA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgY3R4LnBvb2xzW2N0eC5wb29sXS51cGRhdGUoYnl0ZXMuc3Vic3RyKGksIDEpKTtcbiAgICAgIGN0eC5wb29sID0gKGN0eC5wb29sID09PSAzMSkgPyAwIDogY3R4LnBvb2wgKyAxO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29sbGVjdHMgYW4gaW50ZWdlciBvZiBuIGJpdHMuXG4gICAqXG4gICAqIEBwYXJhbSBpIHRoZSBpbnRlZ2VyIGVudHJvcHkuXG4gICAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlci5cbiAgICovXG4gIGN0eC5jb2xsZWN0SW50ID0gZnVuY3Rpb24oaSwgbikge1xuICAgIHZhciBieXRlcyA9ICcnO1xuICAgIGZvcih2YXIgeCA9IDA7IHggPCBuOyB4ICs9IDgpIHtcbiAgICAgIGJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGkgPj4geCkgJiAweEZGKTtcbiAgICB9XG4gICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBXZWIgV29ya2VyIHRvIHJlY2VpdmUgaW1tZWRpYXRlIGVudHJvcHkgZnJvbSB0aGUgbWFpbiB0aHJlYWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIHJlcXVpcmVkIHVudGlsIFdlYiBXb3JrZXJzIGNhbiBhY2Nlc3MgdGhlIG5hdGl2ZSBjcnlwdG9cbiAgICogQVBJLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHR3aWNlIGZvciBlYWNoIGNyZWF0ZWQgd29ya2VyLCBvbmNlIGluXG4gICAqIHRoZSBtYWluIHRocmVhZCwgYW5kIG9uY2UgaW4gdGhlIHdvcmtlciBpdHNlbGYuXG4gICAqXG4gICAqIEBwYXJhbSB3b3JrZXIgdGhlIHdvcmtlciB0byByZWdpc3Rlci5cbiAgICovXG4gIGN0eC5yZWdpc3RlcldvcmtlciA9IGZ1bmN0aW9uKHdvcmtlcikge1xuICAgIC8vIHdvcmtlciByZWNlaXZlcyByYW5kb20gYnl0ZXNcbiAgICBpZih3b3JrZXIgPT09IHNlbGYpIHtcbiAgICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgICAgZnVuY3Rpb24gbGlzdGVuZXIoZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICAgIGlmKGRhdGEuZm9yZ2UgJiYgZGF0YS5mb3JnZS5wcm5nKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhLmZvcmdlLnBybmcuZXJyLCBkYXRhLmZvcmdlLnBybmcuYnl0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge25lZWRlZDogbmVlZGVkfX19KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1haW4gdGhyZWFkIHNlbmRzIHJhbmRvbSBieXRlcyB1cG9uIHJlcXVlc3RcbiAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgIGlmKGRhdGEuZm9yZ2UgJiYgZGF0YS5mb3JnZS5wcm5nKSB7XG4gICAgICAgICAgY3R4LnNlZWRGaWxlKGRhdGEuZm9yZ2UucHJuZy5uZWVkZWQsIGZ1bmN0aW9uKGVyciwgYnl0ZXMpIHtcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7Zm9yZ2U6IHtwcm5nOiB7ZXJyOiBlcnIsIGJ5dGVzOiBieXRlc319fSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgd2hlbiB0aGUgd29ya2VyIGRpZXM/XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGN0eDtcbn07XG4iLCAiLyoqXG4gKiBBbiBBUEkgZm9yIGdldHRpbmcgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBieXRlcy4gVGhlIGJ5dGVzIGFyZVxuICogZ2VuZXJhdGVkIHVzaW5nIHRoZSBGb3J0dW5hIGFsZ29yaXRobSBkZXZpc2VkIGJ5IEJydWNlIFNjaG5laWVyIGFuZFxuICogTmllbHMgRmVyZ3Vzb24uXG4gKlxuICogR2V0dGluZyBzdHJvbmcgcmFuZG9tIGJ5dGVzIGlzIG5vdCB5ZXQgZWFzeSB0byBkbyBpbiBqYXZhc2NyaXB0LiBUaGUgb25seVxuICogdHJ1aXNoIHJhbmRvbSBlbnRyb3B5IHRoYXQgY2FuIGJlIGNvbGxlY3RlZCBpcyBmcm9tIHRoZSBtb3VzZSwga2V5Ym9hcmQsIG9yXG4gKiBmcm9tIHRpbWluZyB3aXRoIHJlc3BlY3QgdG8gcGFnZSBsb2FkcywgZXRjLiBUaGlzIGdlbmVyYXRvciBtYWtlcyBhIHBvb3JcbiAqIGF0dGVtcHQgYXQgcHJvdmlkaW5nIHJhbmRvbSBieXRlcyB3aGVuIHRob3NlIHNvdXJjZXMgaGF2ZW4ndCB5ZXQgcHJvdmlkZWRcbiAqIGVub3VnaCBlbnRyb3B5IHRvIGluaXRpYWxseSBzZWVkIG9yIHRvIHJlc2VlZCB0aGUgUFJORy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYWVzJyk7XG5yZXF1aXJlKCcuL3NoYTI1NicpO1xucmVxdWlyZSgnLi9wcm5nJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4vLyBmb3JnZS5yYW5kb20gYWxyZWFkeSBkZWZpbmVkXG5pZihmb3JnZS5yYW5kb20gJiYgZm9yZ2UucmFuZG9tLmdldEJ5dGVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucmFuZG9tO1xuICByZXR1cm47XG59XG5cbihmdW5jdGlvbihqUXVlcnkpIHtcblxuLy8gdGhlIGRlZmF1bHQgcHJuZyBwbHVnaW4sIHVzZXMgQUVTLTEyOFxudmFyIHBybmdfYWVzID0ge307XG52YXIgX3BybmdfYWVzX291dHB1dCA9IG5ldyBBcnJheSg0KTtcbnZhciBfcHJuZ19hZXNfYnVmZmVyID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbnBybmdfYWVzLmZvcm1hdEtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIHRtcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gIGtleSA9IG5ldyBBcnJheSg0KTtcbiAga2V5WzBdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVsxXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbMl0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzNdID0gdG1wLmdldEludDMyKCk7XG5cbiAgLy8gcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlcbiAgcmV0dXJuIGZvcmdlLmFlcy5fZXhwYW5kS2V5KGtleSwgZmFsc2UpO1xufTtcbnBybmdfYWVzLmZvcm1hdFNlZWQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIC8vIGNvbnZlcnQgc2VlZCBpbnRvIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgdG1wID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoc2VlZCk7XG4gIHNlZWQgPSBuZXcgQXJyYXkoNCk7XG4gIHNlZWRbMF0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFsxXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzJdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbM10gPSB0bXAuZ2V0SW50MzIoKTtcbiAgcmV0dXJuIHNlZWQ7XG59O1xucHJuZ19hZXMuY2lwaGVyID0gZnVuY3Rpb24oa2V5LCBzZWVkKSB7XG4gIGZvcmdlLmFlcy5fdXBkYXRlQmxvY2soa2V5LCBzZWVkLCBfcHJuZ19hZXNfb3V0cHV0LCBmYWxzZSk7XG4gIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFswXSk7XG4gIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFsxXSk7XG4gIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFsyXSk7XG4gIF9wcm5nX2Flc19idWZmZXIucHV0SW50MzIoX3BybmdfYWVzX291dHB1dFszXSk7XG4gIHJldHVybiBfcHJuZ19hZXNfYnVmZmVyLmdldEJ5dGVzKCk7XG59O1xucHJuZ19hZXMuaW5jcmVtZW50ID0gZnVuY3Rpb24oc2VlZCkge1xuICAvLyBGSVhNRTogZG8gd2UgY2FyZSBhYm91dCBjYXJyeSBvciBzaWduZWQgaXNzdWVzP1xuICArK3NlZWRbM107XG4gIHJldHVybiBzZWVkO1xufTtcbnBybmdfYWVzLm1kID0gZm9yZ2UubWQuc2hhMjU2O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUFJORy5cbiAqL1xuZnVuY3Rpb24gc3Bhd25Qcm5nKCkge1xuICB2YXIgY3R4ID0gZm9yZ2UucHJuZy5jcmVhdGUocHJuZ19hZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHJhbmRvbSBieXRlcy4gSWYgYSBuYXRpdmUgc2VjdXJlIGNyeXB0byBBUEkgaXMgdW5hdmFpbGFibGUsIHRoaXNcbiAgICogbWV0aG9kIHRyaWVzIHRvIG1ha2UgdGhlIGJ5dGVzIG1vcmUgdW5wcmVkaWN0YWJsZSBieSBkcmF3aW5nIGZyb20gZGF0YSB0aGF0XG4gICAqIGNhbiBiZSBjb2xsZWN0ZWQgZnJvbSB0aGUgdXNlciBvZiB0aGUgYnJvd3NlciwgZWc6IG1vdXNlIG1vdmVtZW50LlxuICAgKlxuICAgKiBJZiBhIGNhbGxiYWNrIGlzIGdpdmVuLCB0aGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdldC5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJhbmRvbSBieXRlcyBpbiBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjdHguZ2VuZXJhdGUoY291bnQsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyByYW5kb20gYnl0ZXMgYXN5bmNocm9ub3VzbHkuIElmIGEgbmF0aXZlIHNlY3VyZSBjcnlwdG8gQVBJIGlzXG4gICAqIHVuYXZhaWxhYmxlLCB0aGlzIG1ldGhvZCB0cmllcyB0byBtYWtlIHRoZSBieXRlcyBtb3JlIHVucHJlZGljdGFibGUgYnlcbiAgICogZHJhd2luZyBmcm9tIGRhdGEgdGhhdCBjYW4gYmUgY29sbGVjdGVkIGZyb20gdGhlIHVzZXIgb2YgdGhlIGJyb3dzZXIsXG4gICAqIGVnOiBtb3VzZSBtb3ZlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmFuZG9tIGJ5dGVzIGluIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdldEJ5dGVzU3luYyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgcmV0dXJuIGN0eC5nZW5lcmF0ZShjb3VudCk7XG4gIH07XG5cbiAgcmV0dXJuIGN0eDtcbn1cblxuLy8gY3JlYXRlIGRlZmF1bHQgcHJuZyBjb250ZXh0XG52YXIgX2N0eCA9IHNwYXduUHJuZygpO1xuXG4vLyBhZGQgb3RoZXIgc291cmNlcyBvZiBlbnRyb3B5IG9ubHkgaWYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgaXMgbm90XG4vLyBhdmFpbGFibGUgLS0gb3RoZXJ3aXNlIHRoaXMgc291cmNlIHdpbGwgYmUgYXV0b21hdGljYWxseSB1c2VkIGJ5IHRoZSBwcm5nXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbnZhciBnbG9iYWxTY29wZSA9IGZvcmdlLnV0aWwuZ2xvYmFsU2NvcGU7XG52YXIgX2NyeXB0byA9IGdsb2JhbFNjb3BlLmNyeXB0byB8fCBnbG9iYWxTY29wZS5tc0NyeXB0bztcbmlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gIH07XG59XG5cbmlmKGZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgfHxcbiAgKCFmb3JnZS51dGlsLmlzTm9kZWpzICYmICFnZXRSYW5kb21WYWx1ZXMpKSB7XG4gIC8vIGlmIHRoaXMgaXMgYSB3ZWIgd29ya2VyLCBkbyBub3QgdXNlIHdlYWsgZW50cm9weSwgaW5zdGVhZCByZWdpc3RlciB0b1xuICAvLyByZWNlaXZlIHN0cm9uZyBlbnRyb3B5IGFzeW5jaHJvbm91c2x5IGZyb20gdGhlIG1haW4gdGhyZWFkXG4gIGlmKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHdpbmRvdy5kb2N1bWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRklYTUU6XG4gIH1cblxuICAvLyBnZXQgbG9hZCB0aW1lIGVudHJvcHlcbiAgX2N0eC5jb2xsZWN0SW50KCtuZXcgRGF0ZSgpLCAzMik7XG5cbiAgLy8gYWRkIHNvbWUgZW50cm9weSBmcm9tIG5hdmlnYXRvciBvYmplY3RcbiAgaWYodHlwZW9mKG5hdmlnYXRvcikgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF9uYXZCeXRlcyA9ICcnO1xuICAgIGZvcih2YXIga2V5IGluIG5hdmlnYXRvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYodHlwZW9mKG5hdmlnYXRvcltrZXldKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIF9uYXZCeXRlcyArPSBuYXZpZ2F0b3Jba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8qIFNvbWUgbmF2aWdhdG9yIGtleXMgbWlnaHQgbm90IGJlIGFjY2Vzc2libGUsIGUuZy4gdGhlIGdlb2xvY2F0aW9uXG4gICAgICAgICAgYXR0cmlidXRlIHRocm93cyBhbiBleGNlcHRpb24gaWYgdG91Y2hlZCBpbiBNb3ppbGxhIGNocm9tZTovL1xuICAgICAgICAgIGNvbnRleHQuXG5cbiAgICAgICAgICBTaWxlbnRseSBpZ25vcmUgdGhpcyBhbmQganVzdCBkb24ndCB1c2UgdGhpcyBhcyBhIHNvdXJjZSBvZlxuICAgICAgICAgIGVudHJvcHkuICovXG4gICAgICB9XG4gICAgfVxuICAgIF9jdHguY29sbGVjdChfbmF2Qnl0ZXMpO1xuICAgIF9uYXZCeXRlcyA9IG51bGw7XG4gIH1cblxuICAvLyBhZGQgbW91c2UgYW5kIGtleWJvYXJkIGNvbGxlY3RvcnMgaWYganF1ZXJ5IGlzIGF2YWlsYWJsZVxuICBpZihqUXVlcnkpIHtcbiAgICAvLyBzZXQgdXAgbW91c2UgZW50cm9weSBjYXB0dXJlXG4gICAgalF1ZXJ5KCkubW91c2Vtb3ZlKGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIGFkZCBtb3VzZSBjb29yZHNcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNsaWVudFgsIDE2KTtcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNsaWVudFksIDE2KTtcbiAgICB9KTtcblxuICAgIC8vIHNldCB1cCBrZXlib2FyZCBlbnRyb3B5IGNhcHR1cmVcbiAgICBqUXVlcnkoKS5rZXlwcmVzcyhmdW5jdGlvbihlKSB7XG4gICAgICBfY3R4LmNvbGxlY3RJbnQoZS5jaGFyQ29kZSwgOCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyogUmFuZG9tIEFQSSAqL1xuaWYoIWZvcmdlLnJhbmRvbSkge1xuICBmb3JnZS5yYW5kb20gPSBfY3R4O1xufSBlbHNlIHtcbiAgLy8gZXh0ZW5kIGZvcmdlLnJhbmRvbSB3aXRoIF9jdHhcbiAgZm9yKHZhciBrZXkgaW4gX2N0eCkge1xuICAgIGZvcmdlLnJhbmRvbVtrZXldID0gX2N0eFtrZXldO1xuICB9XG59XG5cbi8vIGV4cG9zZSBzcGF3biBQUk5HXG5mb3JnZS5yYW5kb20uY3JlYXRlSW5zdGFuY2UgPSBzcGF3blBybmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucmFuZG9tO1xuXG59KSh0eXBlb2YoalF1ZXJ5KSAhPT0gJ3VuZGVmaW5lZCcgPyBqUXVlcnkgOiBudWxsKTtcblxufSkoKTtcbiIsICIvKipcbiAqIFJDMiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIEluZm9ybWF0aW9uIG9uIHRoZSBSQzIgY2lwaGVyIGlzIGF2YWlsYWJsZSBmcm9tIFJGQyAjMjI2OCxcbiAqIGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNjgudHh0XG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgcGlUYWJsZSA9IFtcbiAgMHhkOSwgMHg3OCwgMHhmOSwgMHhjNCwgMHgxOSwgMHhkZCwgMHhiNSwgMHhlZCwgMHgyOCwgMHhlOSwgMHhmZCwgMHg3OSwgMHg0YSwgMHhhMCwgMHhkOCwgMHg5ZCxcbiAgMHhjNiwgMHg3ZSwgMHgzNywgMHg4MywgMHgyYiwgMHg3NiwgMHg1MywgMHg4ZSwgMHg2MiwgMHg0YywgMHg2NCwgMHg4OCwgMHg0NCwgMHg4YiwgMHhmYiwgMHhhMixcbiAgMHgxNywgMHg5YSwgMHg1OSwgMHhmNSwgMHg4NywgMHhiMywgMHg0ZiwgMHgxMywgMHg2MSwgMHg0NSwgMHg2ZCwgMHg4ZCwgMHgwOSwgMHg4MSwgMHg3ZCwgMHgzMixcbiAgMHhiZCwgMHg4ZiwgMHg0MCwgMHhlYiwgMHg4NiwgMHhiNywgMHg3YiwgMHgwYiwgMHhmMCwgMHg5NSwgMHgyMSwgMHgyMiwgMHg1YywgMHg2YiwgMHg0ZSwgMHg4MixcbiAgMHg1NCwgMHhkNiwgMHg2NSwgMHg5MywgMHhjZSwgMHg2MCwgMHhiMiwgMHgxYywgMHg3MywgMHg1NiwgMHhjMCwgMHgxNCwgMHhhNywgMHg4YywgMHhmMSwgMHhkYyxcbiAgMHgxMiwgMHg3NSwgMHhjYSwgMHgxZiwgMHgzYiwgMHhiZSwgMHhlNCwgMHhkMSwgMHg0MiwgMHgzZCwgMHhkNCwgMHgzMCwgMHhhMywgMHgzYywgMHhiNiwgMHgyNixcbiAgMHg2ZiwgMHhiZiwgMHgwZSwgMHhkYSwgMHg0NiwgMHg2OSwgMHgwNywgMHg1NywgMHgyNywgMHhmMiwgMHgxZCwgMHg5YiwgMHhiYywgMHg5NCwgMHg0MywgMHgwMyxcbiAgMHhmOCwgMHgxMSwgMHhjNywgMHhmNiwgMHg5MCwgMHhlZiwgMHgzZSwgMHhlNywgMHgwNiwgMHhjMywgMHhkNSwgMHgyZiwgMHhjOCwgMHg2NiwgMHgxZSwgMHhkNyxcbiAgMHgwOCwgMHhlOCwgMHhlYSwgMHhkZSwgMHg4MCwgMHg1MiwgMHhlZSwgMHhmNywgMHg4NCwgMHhhYSwgMHg3MiwgMHhhYywgMHgzNSwgMHg0ZCwgMHg2YSwgMHgyYSxcbiAgMHg5NiwgMHgxYSwgMHhkMiwgMHg3MSwgMHg1YSwgMHgxNSwgMHg0OSwgMHg3NCwgMHg0YiwgMHg5ZiwgMHhkMCwgMHg1ZSwgMHgwNCwgMHgxOCwgMHhhNCwgMHhlYyxcbiAgMHhjMiwgMHhlMCwgMHg0MSwgMHg2ZSwgMHgwZiwgMHg1MSwgMHhjYiwgMHhjYywgMHgyNCwgMHg5MSwgMHhhZiwgMHg1MCwgMHhhMSwgMHhmNCwgMHg3MCwgMHgzOSxcbiAgMHg5OSwgMHg3YywgMHgzYSwgMHg4NSwgMHgyMywgMHhiOCwgMHhiNCwgMHg3YSwgMHhmYywgMHgwMiwgMHgzNiwgMHg1YiwgMHgyNSwgMHg1NSwgMHg5NywgMHgzMSxcbiAgMHgyZCwgMHg1ZCwgMHhmYSwgMHg5OCwgMHhlMywgMHg4YSwgMHg5MiwgMHhhZSwgMHgwNSwgMHhkZiwgMHgyOSwgMHgxMCwgMHg2NywgMHg2YywgMHhiYSwgMHhjOSxcbiAgMHhkMywgMHgwMCwgMHhlNiwgMHhjZiwgMHhlMSwgMHg5ZSwgMHhhOCwgMHgyYywgMHg2MywgMHgxNiwgMHgwMSwgMHgzZiwgMHg1OCwgMHhlMiwgMHg4OSwgMHhhOSxcbiAgMHgwZCwgMHgzOCwgMHgzNCwgMHgxYiwgMHhhYiwgMHgzMywgMHhmZiwgMHhiMCwgMHhiYiwgMHg0OCwgMHgwYywgMHg1ZiwgMHhiOSwgMHhiMSwgMHhjZCwgMHgyZSxcbiAgMHhjNSwgMHhmMywgMHhkYiwgMHg0NywgMHhlNSwgMHhhNSwgMHg5YywgMHg3NywgMHgwYSwgMHhhNiwgMHgyMCwgMHg2OCwgMHhmZSwgMHg3ZiwgMHhjMSwgMHhhZFxuXTtcblxudmFyIHMgPSBbMSwgMiwgMywgNV07XG5cbi8qKlxuICogUm90YXRlIGEgd29yZCBsZWZ0IGJ5IGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIEJpdHMgdGhhdCBhcmUgc2hpZnRlZCBvdXQgb24gdGhlIGxlZnQgYXJlIHB1dCBiYWNrIGluIG9uIHRoZSByaWdodFxuICogaGFuZCBzaWRlLlxuICpcbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIHRvIHNoaWZ0IGxlZnQuXG4gKiBAcGFyYW0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQgYnkuXG4gKiBAcmV0dXJuIFRoZSByb3RhdGVkIHdvcmQuXG4gKi9cbnZhciByb2wgPSBmdW5jdGlvbih3b3JkLCBiaXRzKSB7XG4gIHJldHVybiAoKHdvcmQgPDwgYml0cykgJiAweGZmZmYpIHwgKCh3b3JkICYgMHhmZmZmKSA+PiAoMTYgLSBiaXRzKSk7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHdvcmQgcmlnaHQgYnkgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQml0cyB0aGF0IGFyZSBzaGlmdGVkIG91dCBvbiB0aGUgcmlnaHQgYXJlIHB1dCBiYWNrIGluIG9uIHRoZSBsZWZ0XG4gKiBoYW5kIHNpZGUuXG4gKlxuICogQHBhcmFtIHdvcmQgVGhlIHdvcmQgdG8gc2hpZnQgcmlnaHQuXG4gKiBAcGFyYW0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQgYnkuXG4gKiBAcmV0dXJuIFRoZSByb3RhdGVkIHdvcmQuXG4gKi9cbnZhciByb3IgPSBmdW5jdGlvbih3b3JkLCBiaXRzKSB7XG4gIHJldHVybiAoKHdvcmQgJiAweGZmZmYpID4+IGJpdHMpIHwgKCh3b3JkIDw8ICgxNiAtIGJpdHMpKSAmIDB4ZmZmZik7XG59O1xuXG4vKiBSQzIgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnJjMiA9IGZvcmdlLnJjMiB8fCB7fTtcblxuLyoqXG4gKiBQZXJmb3JtIFJDMiBrZXkgZXhwYW5zaW9uIGFzIHBlciBSRkMgIzIyNjgsIHNlY3Rpb24gMi5cbiAqXG4gKiBAcGFyYW0ga2V5IHZhcmlhYmxlLWxlbmd0aCB1c2VyIGtleSAoYmV0d2VlbiAxIGFuZCAxMjggYnl0ZXMpXG4gKiBAcGFyYW0gZWZmS2V5Qml0cyBudW1iZXIgb2YgZWZmZWN0aXZlIGtleSBiaXRzIChkZWZhdWx0OiAxMjgpXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBSQzIga2V5IChCeXRlQnVmZmVyIG9mIDEyOCBieXRlcylcbiAqL1xuZm9yZ2UucmMyLmV4cGFuZEtleSA9IGZ1bmN0aW9uKGtleSwgZWZmS2V5Qml0cykge1xuICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gIH1cbiAgZWZmS2V5Qml0cyA9IGVmZktleUJpdHMgfHwgMTI4O1xuXG4gIC8qIGludHJvZHVjZSB2YXJpYWJsZXMgdGhhdCBtYXRjaCB0aGUgbmFtZXMgdXNlZCBpbiBSRkMgIzIyNjggKi9cbiAgdmFyIEwgPSBrZXk7XG4gIHZhciBUID0ga2V5Lmxlbmd0aCgpO1xuICB2YXIgVDEgPSBlZmZLZXlCaXRzO1xuICB2YXIgVDggPSBNYXRoLmNlaWwoVDEgLyA4KTtcbiAgdmFyIFRNID0gMHhmZiA+PiAoVDEgJiAweDA3KTtcbiAgdmFyIGk7XG5cbiAgZm9yKGkgPSBUOyBpIDwgMTI4OyBpKyspIHtcbiAgICBMLnB1dEJ5dGUocGlUYWJsZVsoTC5hdChpIC0gMSkgKyBMLmF0KGkgLSBUKSkgJiAweGZmXSk7XG4gIH1cblxuICBMLnNldEF0KDEyOCAtIFQ4LCBwaVRhYmxlW0wuYXQoMTI4IC0gVDgpICYgVE1dKTtcblxuICBmb3IoaSA9IDEyNyAtIFQ4OyBpID49IDA7IGktLSkge1xuICAgIEwuc2V0QXQoaSwgcGlUYWJsZVtMLmF0KGkgKyAxKSBeIEwuYXQoaSArIFQ4KV0pO1xuICB9XG5cbiAgcmV0dXJuIEw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSQzIgY2lwaGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoYXMgYmFzZSBmb3Iga2V5IGdlbmVyYXRpb24pLlxuICogQHBhcmFtIGJpdHMgdGhlIG51bWJlciBvZiBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKiBAcGFyYW0gZW5jcnlwdCBmYWxzZSBmb3IgZGVjcnlwdGlvbiwgdHJ1ZSBmb3IgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbnZhciBjcmVhdGVDaXBoZXIgPSBmdW5jdGlvbihrZXksIGJpdHMsIGVuY3J5cHQpIHtcbiAgdmFyIF9maW5pc2ggPSBmYWxzZSwgX2lucHV0ID0gbnVsbCwgX291dHB1dCA9IG51bGwsIF9pdiA9IG51bGw7XG4gIHZhciBtaXhSb3VuZCwgbWFzaFJvdW5kO1xuICB2YXIgaSwgaiwgSyA9IFtdO1xuXG4gIC8qIEV4cGFuZCBrZXkgYW5kIGZpbGwgaW50byBLW10gQXJyYXkgKi9cbiAga2V5ID0gZm9yZ2UucmMyLmV4cGFuZEtleShrZXksIGJpdHMpO1xuICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgSy5wdXNoKGtleS5nZXRJbnQxNkxlKCkpO1xuICB9XG5cbiAgaWYoZW5jcnlwdCkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIG1peGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWl4aW5nIG9uLlxuICAgICAqL1xuICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIFJbaV0gKz0gS1tqXSArIChSWyhpICsgMykgJSA0XSAmIFJbKGkgKyAyKSAlIDRdKSArXG4gICAgICAgICAgKCh+UlsoaSArIDMpICUgNF0pICYgUlsoaSArIDEpICUgNF0pO1xuICAgICAgICBSW2ldID0gcm9sKFJbaV0sIHNbaV0pO1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIG1hc2hpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1hc2hpbmcgb24uXG4gICAgICovXG4gICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIFJbaV0gKz0gS1tSWyhpICsgMykgJSA0XSAmIDYzXTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIHItbWl4aW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtaXhpbmcgb24uXG4gICAgICovXG4gICAgbWl4Um91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICBmb3IoaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIFJbaV0gPSByb3IoUltpXSwgc1tpXSk7XG4gICAgICAgIFJbaV0gLT0gS1tqXSArIChSWyhpICsgMykgJSA0XSAmIFJbKGkgKyAyKSAlIDRdKSArXG4gICAgICAgICAgKCh+UlsoaSArIDMpICUgNF0pICYgUlsoaSArIDEpICUgNF0pO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIHItbWFzaGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWFzaGluZyBvbi5cbiAgICAgKi9cbiAgICBtYXNoUm91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICBmb3IoaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIFJbaV0gLT0gS1tSWyhpICsgMykgJSA0XSAmIDYzXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgc3BlY2lmaWVkIGNpcGhlciBleGVjdXRpb24gcGxhbi5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBmb3VyIHdvcmRzIGZyb20gdGhlIGlucHV0IGJ1ZmZlciwgYXBwbGllcyB0aGUgSVYgb25cbiAgICogaXQgKGlmIHJlcXVlc3RlZCkgYW5kIHJ1bnMgdGhlIHByb3ZpZGVkIGV4ZWN1dGlvbiBwbGFuLlxuICAgKlxuICAgKiBUaGUgcGxhbiBtdXN0IGJlIHB1dCB0b2dldGhlciBpbiBmb3JtIG9mIGEgYXJyYXkgb2YgYXJyYXlzLiAgV2hlcmUgdGhlXG4gICAqIG91dGVyIG9uZSBpcyBzaW1wbHkgYSBsaXN0IG9mIHN0ZXBzIHRvIHBlcmZvcm0gYW5kIHRoZSBpbm5lciBvbmUgbmVlZHNcbiAgICogdG8gaGF2ZSB0d28gZWxlbWVudHM6IHRoZSBmaXJzdCBvbmUgdGVsbGluZyBob3cgbWFueSByb3VuZHMgdG8gcGVyZm9ybSxcbiAgICogdGhlIHNlY29uZCBvbmUgdGVsbGluZyB3aGF0IHRvIGRvIChpLmUuIHRoZSBmdW5jdGlvbiB0byBjYWxsKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGxhbiBUaGUgcGxhbiB0byBleGVjdXRlLlxuICAgKi9cbiAgdmFyIHJ1blBsYW4gPSBmdW5jdGlvbihwbGFuKSB7XG4gICAgdmFyIFIgPSBbXTtcblxuICAgIC8qIEdldCBkYXRhIGZyb20gaW5wdXQgYnVmZmVyIGFuZCBmaWxsIHRoZSBmb3VyIHdvcmRzIGludG8gUiAqL1xuICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IF9pbnB1dC5nZXRJbnQxNkxlKCk7XG5cbiAgICAgIGlmKF9pdiAhPT0gbnVsbCkge1xuICAgICAgICBpZihlbmNyeXB0KSB7XG4gICAgICAgICAgLyogV2UncmUgZW5jcnlwdGluZywgYXBwbHkgdGhlIElWIGZpcnN0LiAqL1xuICAgICAgICAgIHZhbCBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIFdlJ3JlIGRlY3J5cHRpb24sIGtlZXAgY2lwaGVyIHRleHQgZm9yIG5leHQgYmxvY2suICovXG4gICAgICAgICAgX2l2LnB1dEludDE2TGUodmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSLnB1c2godmFsICYgMHhmZmZmKTtcbiAgICB9XG5cbiAgICAvKiBSZXNldCBnbG9iYWwgXCJqXCIgdmFyaWFibGUgYXMgcGVyIHNwZWMuICovXG4gICAgaiA9IGVuY3J5cHQgPyAwIDogNjM7XG5cbiAgICAvKiBSdW4gZXhlY3V0aW9uIHBsYW4uICovXG4gICAgZm9yKHZhciBwdHIgPSAwOyBwdHIgPCBwbGFuLmxlbmd0aDsgcHRyKyspIHtcbiAgICAgIGZvcih2YXIgY3RyID0gMDsgY3RyIDwgcGxhbltwdHJdWzBdOyBjdHIrKykge1xuICAgICAgICBwbGFuW3B0cl1bMV0oUik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogV3JpdGUgYmFjayByZXN1bHQgdG8gb3V0cHV0IGJ1ZmZlci4gKi9cbiAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGlmKF9pdiAhPT0gbnVsbCkge1xuICAgICAgICBpZihlbmNyeXB0KSB7XG4gICAgICAgICAgLyogV2UncmUgZW5jcnlwdGluZyBpbiBDQkMtbW9kZSwgZmVlZCBiYWNrIGVuY3J5cHRlZCBieXRlcyBpbnRvXG4gICAgICAgICAgICAgSVYgYnVmZmVyIHRvIGNhcnJ5IGl0IGZvcndhcmQgdG8gbmV4dCBibG9jay4gKi9cbiAgICAgICAgICBfaXYucHV0SW50MTZMZShSW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSW2ldIF49IF9pdi5nZXRJbnQxNkxlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX291dHB1dC5wdXRJbnQxNkxlKFJbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKiBDcmVhdGUgY2lwaGVyIG9iamVjdCAqL1xuICB2YXIgY2lwaGVyID0gbnVsbDtcbiAgY2lwaGVyID0ge1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBvciByZXN0YXJ0cyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MsIHdoaWNoZXZlclxuICAgICAqIHdhcyBwcmV2aW91c2x5IGNvbmZpZ3VyZWQuXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIGNpcGhlciBpbiBDQkMgbW9kZSwgaXYgbWF5IGJlIGdpdmVuIGVpdGhlciBhcyBhIHN0cmluZ1xuICAgICAqIG9mIGJ5dGVzLCBvciBhcyBhIGJ5dGUgYnVmZmVyLiAgRm9yIEVDQiBtb2RlLCBnaXZlIG51bGwgYXMgaXYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UsIG51bGwgZm9yIEVDQiBtb2RlLlxuICAgICAqIEBwYXJhbSBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKGl2LCBvdXRwdXQpIHtcbiAgICAgIGlmKGl2KSB7XG4gICAgICAgIC8qIENCQyBtb2RlICovXG4gICAgICAgIGlmKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZmluaXNoID0gZmFsc2U7XG4gICAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgX291dHB1dCA9IG91dHB1dCB8fCBuZXcgZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9pdiA9IGl2O1xuXG4gICAgICBjaXBoZXIub3V0cHV0ID0gX291dHB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbmV4dCBibG9jay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZighX2ZpbmlzaCkge1xuICAgICAgICAvLyBub3QgZmluaXNoaW5nLCBzbyBmaWxsIHRoZSBpbnB1dCBidWZmZXIgd2l0aCBtb3JlIGlucHV0XG4gICAgICAgIF9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShfaW5wdXQubGVuZ3RoKCkgPj0gOCkge1xuICAgICAgICBydW5QbGFuKFtcbiAgICAgICAgICAgIFsgNSwgbWl4Um91bmQgXSxcbiAgICAgICAgICAgIFsgMSwgbWFzaFJvdW5kIF0sXG4gICAgICAgICAgICBbIDYsIG1peFJvdW5kIF0sXG4gICAgICAgICAgICBbIDEsIG1hc2hSb3VuZCBdLFxuICAgICAgICAgICAgWyA1LCBtaXhSb3VuZCBdXG4gICAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaGVzIGVuY3J5cHRpbmcgb3IgZGVjcnlwdGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWQgYSBwYWRkaW5nIGZ1bmN0aW9uIHRvIHVzZSwgbnVsbCBmb3IgUEtDUyM3IHBhZGRpbmcsXG4gICAgICogICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb24gZXJyb3IuXG4gICAgICovXG4gICAgZmluaXNoOiBmdW5jdGlvbihwYWQpIHtcbiAgICAgIHZhciBydmFsID0gdHJ1ZTtcblxuICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICBpZihwYWQpIHtcbiAgICAgICAgICBydmFsID0gcGFkKDgsIF9pbnB1dCwgIWVuY3J5cHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgICAgICAgICAvLyB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHBhZCBieXRlcylcbiAgICAgICAgICB2YXIgcGFkZGluZyA9IChfaW5wdXQubGVuZ3RoKCkgPT09IDgpID8gOCA6ICg4IC0gX2lucHV0Lmxlbmd0aCgpKTtcbiAgICAgICAgICBfaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgLy8gZG8gZmluYWwgdXBkYXRlXG4gICAgICAgIF9maW5pc2ggPSB0cnVlO1xuICAgICAgICBjaXBoZXIudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCFlbmNyeXB0KSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBlcnJvcjogaW5wdXQgZGF0YSBub3QgYSBtdWx0aXBsZSBvZiBibG9jayBzaXplXG4gICAgICAgIHJ2YWwgPSAoX2lucHV0Lmxlbmd0aCgpID09PSAwKTtcbiAgICAgICAgaWYocnZhbCkge1xuICAgICAgICAgIGlmKHBhZCkge1xuICAgICAgICAgICAgcnZhbCA9IHBhZCg4LCBfb3V0cHV0LCAhZW5jcnlwdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgICAgICAgICAgIHZhciBsZW4gPSBfb3V0cHV0Lmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gX291dHB1dC5hdChsZW4gLSAxKTtcblxuICAgICAgICAgICAgaWYoY291bnQgPiBsZW4pIHtcbiAgICAgICAgICAgICAgcnZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICAgICAgICAgICAgICBfb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlclxuICogb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqIFRoZSBjaXBoZXIgaXMgaW5pdGlhbGl6ZWQgdG8gdXNlIDEyOCBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQpIHtcbiAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgY2lwaGVyLnN0YXJ0KGl2LCBvdXRwdXQpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVG8gc3RhcnQgZW5jcnlwdGluZyBjYWxsIHN0YXJ0KCkgb24gdGhlIGNpcGhlciB3aXRoIGFuIGl2IGFuZCBvcHRpb25hbFxuICogb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzKSB7XG4gIHJldHVybiBjcmVhdGVDaXBoZXIoa2V5LCBiaXRzLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS4gVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyXG4gKiBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICogVGhlIGNpcGhlciBpcyBpbml0aWFsaXplZCB0byB1c2UgMTI4IGVmZmVjdGl2ZSBrZXkgYml0cy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UucmMyLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCkge1xuICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCAxMjgpO1xuICBjaXBoZXIuc3RhcnQoaXYsIG91dHB1dCk7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUbyBzdGFydCBkZWNyeXB0aW5nIGNhbGwgc3RhcnQoKSBvbiB0aGUgY2lwaGVyIHdpdGggYW4gaXYgYW5kIG9wdGlvbmFsXG4gKiBvdXRwdXQgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIGJpdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcihrZXksIGJpdHMsIGZhbHNlKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSAyMDA1ICBUb20gV3Vcbi8vIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgXCJMSUNFTlNFXCIgZm9yIGRldGFpbHMuXG5cbi8vIEJhc2ljIEphdmFTY3JpcHQgQk4gbGlicmFyeSAtIHN1YnNldCB1c2VmdWwgZm9yIFJTQSBlbmNyeXB0aW9uLlxuXG4vKlxuTGljZW5zaW5nIChMSUNFTlNFKVxuLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5UaGlzIHNvZnR3YXJlIGlzIGNvdmVyZWQgdW5kZXIgdGhlIGZvbGxvd2luZyBjb3B5cmlnaHQ6XG4qL1xuLypcbiAqIENvcHlyaWdodCAoYykgMjAwMy0yMDA1ICBUb20gV3VcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMtSVNcIiBBTkQgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MsIElNUExJRUQgT1IgT1RIRVJXSVNFLCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OLCBBTllcbiAqIFdBUlJBTlRZIE9GIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cbiAqXG4gKiBJTiBOTyBFVkVOVCBTSEFMTCBUT00gV1UgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgSU5DSURFTlRBTCxcbiAqIElORElSRUNUIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPRiBBTlkgS0lORCwgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUlxuICogUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBPUiBOT1QgQURWSVNFRCBPRlxuICogVEhFIFBPU1NJQklMSVRZIE9GIERBTUFHRSwgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBBUklTSU5HIE9VVFxuICogT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gYXBwbGllczpcbiAqXG4gKiBBbGwgcmVkaXN0cmlidXRpb25zIG11c3QgcmV0YWluIGFuIGludGFjdCBjb3B5IG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZVxuICogYW5kIGRpc2NsYWltZXIuXG4gKi9cbi8qXG5BZGRyZXNzIGFsbCBxdWVzdGlvbnMgcmVnYXJkaW5nIHRoaXMgbGljZW5zZSB0bzpcblxuICBUb20gV3VcbiAgdGp3QGNzLlN0YW5mb3JkLkVEVVxuKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5qc2JuID0gZm9yZ2UuanNibiB8fCB7fTtcblxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0cztcblxuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKSB7XG4gIHRoaXMuZGF0YSA9IFtdO1xuICBpZihhICE9IG51bGwpXG4gICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG59XG5mb3JnZS5qc2JuLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuXG4vLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuXG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIHYgPSB4KnRoaXMuZGF0YVtpKytdK3cuZGF0YVtqXStjO1xuICAgIGMgPSBNYXRoLmZsb29yKHYvMHg0MDAwMDAwKTtcbiAgICB3LmRhdGFbaisrXSA9IHYmMHgzZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4N2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNTtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHg3ZmZmKTw8MTUpK3cuZGF0YVtqXSsoYyYweDNmZmZmZmZmKTtcbiAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4M2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNDtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHgzZmZmKTw8MTQpK3cuZGF0YVtqXStjO1xuICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHhmZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBub2RlLmpzIChubyBicm93c2VyKVxuaWYodHlwZW9mKG5hdmlnYXRvcikgPT09ICd1bmRlZmluZWQnKVxue1xuICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICBkYml0cyA9IDI4O1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICBkYml0cyA9IDMwO1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gIGRiaXRzID0gMjY7XG59IGVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gIGRiaXRzID0gMjg7XG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMTw8ZGJpdHMpLTEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMTw8ZGJpdHMpO1xuXG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMixCSV9GUCk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQLWRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbnZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xudmFyIHJyLHZ2O1xucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHsgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTsgfVxuZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgcmV0dXJuIChjPT1udWxsKT8tMTpjO1xufVxuXG4vLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gIHIudCA9IHRoaXMudDtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxO1xuICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICBpZih4ID4gMCkgdGhpcy5kYXRhWzBdID0geDtcbiAgZWxzZSBpZih4IDwgLTEpIHRoaXMuZGF0YVswXSA9IHgrdGhpcy5EVjtcbiAgZWxzZSB0aGlzLnQgPSAwO1xufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkgeyB2YXIgciA9IG5iaSgpOyByLmZyb21JbnQoaSk7IHJldHVybiByOyB9XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKSB7XG4gIHZhciBrO1xuICBpZihiID09IDE2KSBrID0gNDtcbiAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICBlbHNlIGlmKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICB0aGlzLnQgPSAwO1xuICB0aGlzLnMgPSAwO1xuICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoaz09OCk/c1tpXSYweGZmOmludEF0KHMsaSk7XG4gICAgaWYoeCA8IDApIHtcbiAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWkgPSBmYWxzZTtcbiAgICBpZihzaCA9PSAwKVxuICAgICAgdGhpcy5kYXRhW3RoaXMudCsrXSA9IHg7XG4gICAgZWxzZSBpZihzaCtrID4gdGhpcy5EQikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgc2ggKz0gaztcbiAgICBpZihzaCA+PSB0aGlzLkRCKSBzaCAtPSB0aGlzLkRCO1xuICB9XG4gIGlmKGsgPT0gOCAmJiAoc1swXSYweDgwKSAhPSAwKSB7XG4gICAgdGhpcy5zID0gLTE7XG4gICAgaWYoc2ggPiAwKSB0aGlzLmRhdGFbdGhpcy50LTFdIHw9ICgoMTw8KHRoaXMuREItc2gpKS0xKTw8c2g7XG4gIH1cbiAgdGhpcy5jbGFtcCgpO1xuICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zJnRoaXMuRE07XG4gIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpcy5kYXRhW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICBpZihpLS0gPiAwKSB7XG4gICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzLmRhdGFbaV0+PnApID4gMCkgeyBtID0gdHJ1ZTsgciA9IGludDJjaGFyKGQpOyB9XG4gICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICBpZihwIDwgaykge1xuICAgICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT1rKSkma207XG4gICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgfVxuICAgICAgaWYoZCA+IDApIG0gPSB0cnVlO1xuICAgICAgaWYobSkgciArPSBpbnQyY2hhcihkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0/cjpcIjBcIjtcbn1cblxuLy8gKHB1YmxpYykgLXRoaXNcbmZ1bmN0aW9uIGJuTmVnYXRlKCkgeyB2YXIgciA9IG5iaSgpOyBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTsgcmV0dXJuIHI7IH1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHsgcmV0dXJuICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzOyB9XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zLWEucztcbiAgaWYociAhPSAwKSByZXR1cm4gcjtcbiAgdmFyIGkgPSB0aGlzLnQ7XG4gIHIgPSBpLWEudDtcbiAgaWYociAhPSAwKSByZXR1cm4gKHRoaXMuczwwKT8tcjpyO1xuICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpcy5kYXRhW2ldLWEuZGF0YVtpXSkgIT0gMCkgcmV0dXJuIHI7XG4gIHJldHVybiAwO1xufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsIHQ7XG4gIGlmKCh0PXg+Pj4xNikgIT0gMCkgeyB4ID0gdDsgciArPSAxNjsgfVxuICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgaWYoKHQ9eD4+NCkgIT0gMCkgeyB4ID0gdDsgciArPSA0OyB9XG4gIGlmKCh0PXg+PjIpICE9IDApIHsgeCA9IHQ7IHIgKz0gMjsgfVxuICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICBpZih0aGlzLnQgPD0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpcy5kYXRhW3RoaXMudC0xXV4odGhpcy5zJnRoaXMuRE0pKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scikge1xuICB2YXIgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpK25dID0gdGhpcy5kYXRhW2ldO1xuICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IDA7XG4gIHIudCA9IHRoaXMudCtuO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgZm9yKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaS1uXSA9IHRoaXMuZGF0YVtpXTtcbiAgci50ID0gTWF0aC5tYXgodGhpcy50LW4sMCk7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKSB7XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxjYnMpLTE7XG4gIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkge1xuICAgIHIuZGF0YVtpK2RzKzFdID0gKHRoaXMuZGF0YVtpXT4+Y2JzKXxjO1xuICAgIGMgPSAodGhpcy5kYXRhW2ldJmJtKTw8YnM7XG4gIH1cbiAgZm9yKGkgPSBkcy0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gMDtcbiAgci5kYXRhW2RzXSA9IGM7XG4gIHIudCA9IHRoaXMudCtkcysxO1xuICByLnMgPSB0aGlzLnM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gIHIucyA9IHRoaXMucztcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxicyktMTtcbiAgci5kYXRhWzBdID0gdGhpcy5kYXRhW2RzXT4+YnM7XG4gIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgIHIuZGF0YVtpLWRzLTFdIHw9ICh0aGlzLmRhdGFbaV0mYm0pPDxjYnM7XG4gICAgci5kYXRhW2ktZHNdID0gdGhpcy5kYXRhW2ldPj5icztcbiAgfVxuICBpZihicyA+IDApIHIuZGF0YVt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgci50ID0gdGhpcy50LWRzO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSxyKSB7XG4gIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgd2hpbGUoaSA8IG0pIHtcbiAgICBjICs9IHRoaXMuZGF0YVtpXS1hLmRhdGFbaV07XG4gICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgYyA+Pj0gdGhpcy5EQjtcbiAgfVxuICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICBjIC09IGEucztcbiAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyArPSB0aGlzLnM7XG4gIH0gZWxzZSB7XG4gICAgYyArPSB0aGlzLnM7XG4gICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgYyAtPSBhLmRhdGFbaV07XG4gICAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgfVxuICAgIGMgLT0gYS5zO1xuICB9XG4gIHIucyA9IChjPDApPy0xOjA7XG4gIGlmKGMgPCAtMSkgci5kYXRhW2krK10gPSB0aGlzLkRWK2M7XG4gIGVsc2UgaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbiAgci50ID0gaTtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICB2YXIgaSA9IHgudDtcbiAgci50ID0gaSt5LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuICBmb3IoaSA9IDA7IGkgPCB5LnQ7ICsraSkgci5kYXRhW2kreC50XSA9IHguYW0oMCx5LmRhdGFbaV0scixpLDAseC50KTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xuICBpZih0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgd2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICB2YXIgYyA9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgICBpZigoci5kYXRhW2kreC50XSs9eC5hbShpKzEsMip4LmRhdGFbaV0sciwyKmkrMSxjLHgudC1pLTEpKSA+PSB4LkRWKSB7XG4gICAgICByLmRhdGFbaSt4LnRdIC09IHguRFY7XG4gICAgICByLmRhdGFbaSt4LnQrMV0gPSAxO1xuICAgIH1cbiAgfVxuICBpZihyLnQgPiAwKSByLmRhdGFbci50LTFdICs9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgdmFyIHBtID0gbS5hYnMoKTtcbiAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG0uZGF0YVtwbS50LTFdKTtcdC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmKG5zaCA+IDApIHsgcG0ubFNoaWZ0VG8obnNoLHkpOyBwdC5sU2hpZnRUbyhuc2gscik7IH0gZWxzZSB7IHBtLmNvcHlUbyh5KTsgcHQuY29weVRvKHIpOyB9XG4gIHZhciB5cyA9IHkudDtcbiAgdmFyIHkwID0geS5kYXRhW3lzLTFdO1xuICBpZih5MCA9PSAwKSByZXR1cm47XG4gIHZhciB5dCA9IHkwKigxPDx0aGlzLkYxKSsoKHlzPjEpP3kuZGF0YVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHIuZGF0YVtyLnQrK10gPSAxO1xuICAgIHIuc3ViVG8odCxyKTtcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7XG4gIHQuc3ViVG8oeSx5KTtcdC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlKHkudCA8IHlzKSB5LmRhdGFbeS50KytdID0gMDtcbiAgd2hpbGUoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyLmRhdGFbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyLmRhdGFbaV0qZDErKHIuZGF0YVtpLTFdK2UpKmQyKTtcbiAgICBpZigoci5kYXRhW2ldKz15LmFtKDAscWQscixqLDAseXMpKSA8IHFkKSB7XHQvLyBUcnkgaXQgb3V0XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgd2hpbGUoci5kYXRhW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgIH1cbiAgfVxuICBpZihxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gIH1cbiAgci50ID0geXM7XG4gIHIuY2xhbXAoKTtcbiAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7XHQvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5iaSgpO1xuICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG5mdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5mdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICB2YXIgeCA9IHRoaXMuZGF0YVswXTtcbiAgaWYoKHgmMSkgPT0gMCkgcmV0dXJuIDA7XG4gIHZhciB5ID0geCYzO1x0XHQvLyB5ID09IDEveCBtb2QgMl4yXG4gIHkgPSAoeSooMi0oeCYweGYpKnkpKSYweGY7XHQvLyB5ID09IDEveCBtb2QgMl40XG4gIHkgPSAoeSooMi0oeCYweGZmKSp5KSkmMHhmZjtcdC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmO1x0Ly8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjtcdFx0Ly8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtO1xuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgdGhpcy5tdDIgPSAyKm0udDtcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5jb3B5VG8ocik7XG4gIHRoaXMucmVkdWNlKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlKHgudCA8PSB0aGlzLm10MilcdC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHguZGF0YVt4LnQrK10gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4LmRhdGFbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4LmRhdGFbaV0mMHg3ZmZmO1xuICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHguZGF0YVtpXT4+MTUpKnRoaXMubXBsKSZ0aGlzLnVtKTw8MTUpKSZ4LkRNO1xuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpK3RoaXMubS50O1xuICAgIHguZGF0YVtqXSArPSB0aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7XG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUoeC5kYXRhW2pdID49IHguRFYpIHsgeC5kYXRhW2pdIC09IHguRFY7IHguZGF0YVsrK2pdKys7IH1cbiAgfVxuICB4LmNsYW1wKCk7XG4gIHguZHJTaGlmdFRvKHRoaXMubS50LHgpO1xuICBpZih4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbk1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkgeyByZXR1cm4gKCh0aGlzLnQ+MCk/KHRoaXMuZGF0YVswXSYxKTp0aGlzLnMpID09IDA7IH1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgZy5jb3B5VG8ocik7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLHIyKTtcbiAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgdmFyIHo7XG4gIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG59XG5cbi8vIHByb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuLy8gcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBqc2JuMiBsaWJcblxuLy9Db3B5cmlnaHQgKGMpIDIwMDUtMjAwOSAgVG9tIFd1XG4vL0FsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1NlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscyAoU2VlIGpzYm4uanMgZm9yIExJQ0VOU0UpLlxuXG4vL0V4dGVuZGVkIEphdmFTY3JpcHQgQk4gZnVuY3Rpb25zLCByZXF1aXJlZCBmb3IgUlNBIHByaXZhdGUgb3BzLlxuXG4vL1ZlcnNpb24gMS4xOiBuZXcgQmlnSW50ZWdlcihcIjBcIiwgMTApIHJldHVybnMgXCJwcm9wZXJcIiB6ZXJvXG5cbi8vKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuY29weVRvKHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuaWYodGhpcy5zIDwgMCkge1xuIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdLXRoaXMuRFY7XG4gZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIC0xO1xufSBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdO1xuZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIDA7XG4vLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxucmV0dXJuICgodGhpcy5kYXRhWzFdJigoMTw8KDMyLXRoaXMuREIpKS0xKSk8PHRoaXMuREIpfHRoaXMuZGF0YVswXTtcbn1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MjQpPj4yNDsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MTYpPj4xNjsgfVxuXG4vLyhwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbi8vKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbmZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpcy5kYXRhWzBdIDw9IDApKSByZXR1cm4gMDtcbmVsc2UgcmV0dXJuIDE7XG59XG5cbi8vKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuaWYoYiA9PSBudWxsKSBiID0gMTA7XG5pZih0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCI7XG52YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbnZhciBhID0gTWF0aC5wb3coYixjcyk7XG52YXIgZCA9IG5idihhKSwgeSA9IG5iaSgpLCB6ID0gbmJpKCksIHIgPSBcIlwiO1xudGhpcy5kaXZSZW1UbyhkLHkseik7XG53aGlsZSh5LnNpZ251bSgpID4gMCkge1xuIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4geS5kaXZSZW1UbyhkLHkseik7XG59XG5yZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbn1cblxuLy8ocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKSB7XG50aGlzLmZyb21JbnQoMCk7XG5pZihiID09IG51bGwpIGIgPSAxMDtcbnZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xudmFyIGQgPSBNYXRoLnBvdyhiLGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiB2YXIgeCA9IGludEF0KHMsaSk7XG4gaWYoeCA8IDApIHtcbiAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlO1xuICAgY29udGludWU7XG4gfVxuIHcgPSBiKncreDtcbiBpZigrK2ogPj0gY3MpIHtcbiAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICBqID0gMDtcbiAgIHcgPSAwO1xuIH1cbn1cbmlmKGogPiAwKSB7XG4gdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG59XG5pZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKSB7XG5pZihcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gaWYoYSA8IDIpIHRoaXMuZnJvbUludCgxKTtcbiBlbHNlIHtcbiAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgaWYoIXRoaXMudGVzdEJpdChhLTEpKSAgLy8gZm9yY2UgTVNCIHNldFxuICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcix0aGlzKTtcbiAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgIHdoaWxlKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICB0aGlzLmRBZGRPZmZzZXQoMiwwKTtcbiAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICB9XG4gfVxufSBlbHNlIHtcbiAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuIHZhciB4ID0gbmV3IEFycmF5KCksIHQgPSBhJjc7XG4geC5sZW5ndGggPSAoYT4+MykrMTtcbiBiLm5leHRCeXRlcyh4KTtcbiBpZih0ID4gMCkgeFswXSAmPSAoKDE8PHQpLTEpOyBlbHNlIHhbMF0gPSAwO1xuIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG59XG59XG5cbi8vKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbnZhciBpID0gdGhpcy50LCByID0gbmV3IEFycmF5KCk7XG5yWzBdID0gdGhpcy5zO1xudmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJTgsIGQsIGsgPSAwO1xuaWYoaS0tID4gMCkge1xuIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgcltrKytdID0gZHwodGhpcy5zPDwodGhpcy5EQi1wKSk7XG4gd2hpbGUoaSA+PSAwKSB7XG4gICBpZihwIDwgOCkge1xuICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KDgtcCk7XG4gICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLTgpO1xuICAgfSBlbHNlIHtcbiAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICB9XG4gICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICBpZihrID09IDAgJiYgKHRoaXMucyYweDgwKSAhPSAoZCYweDgwKSkgKytrO1xuICAgaWYoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHJbaysrXSA9IGQ7XG4gfVxufVxucmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPT0wKTsgfVxuZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG5mdW5jdGlvbiBibk1heChhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT4wKT90aGlzOmE7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascikge1xudmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbmZvcihpID0gMDsgaSA8IG07ICsraSkgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLGEuZGF0YVtpXSk7XG5pZihhLnQgPCB0aGlzLnQpIHtcbiBmID0gYS5zJnRoaXMuRE07XG4gZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpXSA9IG9wKHRoaXMuZGF0YVtpXSxmKTtcbiByLnQgPSB0aGlzLnQ7XG59IGVsc2Uge1xuIGYgPSB0aGlzLnMmdGhpcy5ETTtcbiBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgci5kYXRhW2ldID0gb3AoZixhLmRhdGFbaV0pO1xuIHIudCA9IGEudDtcbn1cbnIucyA9IG9wKHRoaXMucyxhLnMpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCx5KSB7IHJldHVybiB4Jnk7IH1cbmZ1bmN0aW9uIGJuQW5kKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgseSkgeyByZXR1cm4geHx5OyB9XG5mdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG5mdW5jdGlvbiBiblhvcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgseSkgeyByZXR1cm4geCZ+eTsgfVxuZnVuY3Rpb24gYm5BbmROb3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB+dGhpc1xuZnVuY3Rpb24gYm5Ob3QoKSB7XG52YXIgciA9IG5iaSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaV0gPSB0aGlzLkRNJn50aGlzLmRhdGFbaV07XG5yLnQgPSB0aGlzLnQ7XG5yLnMgPSB+dGhpcy5zO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG52YXIgciA9IG5iaSgpO1xuaWYobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA+PiBuXG5mdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xudmFyIHIgPSBuYmkoKTtcbmlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbnJldHVybiByO1xufVxuXG4vL3JldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuaWYoeCA9PSAwKSByZXR1cm4gLTE7XG52YXIgciA9IDA7XG5pZigoeCYweGZmZmYpID09IDApIHsgeCA+Pj0gMTY7IHIgKz0gMTY7IH1cbmlmKCh4JjB4ZmYpID09IDApIHsgeCA+Pj0gODsgciArPSA4OyB9XG5pZigoeCYweGYpID09IDApIHsgeCA+Pj0gNDsgciArPSA0OyB9XG5pZigoeCYzKSA9PSAwKSB7IHggPj49IDI7IHIgKz0gMjsgfVxuaWYoKHgmMSkgPT0gMCkgKytyO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiBpZih0aGlzLmRhdGFbaV0gIT0gMCkgcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXMuZGF0YVtpXSk7XG5pZih0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50KnRoaXMuREI7XG5yZXR1cm4gLTE7XG59XG5cbi8vcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG52YXIgciA9IDA7XG53aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbnZhciByID0gMCwgeCA9IHRoaXMucyZ0aGlzLkRNO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpcy5kYXRhW2ldXngpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbmZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG52YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbmlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbnJldHVybigodGhpcy5kYXRhW2pdJigxPDwobiV0aGlzLkRCKSkpIT0wKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3ApIHtcbnZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xudGhpcy5iaXR3aXNlVG8ocixvcCxyKTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgfCAoMTw8bilcbmZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG52YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG53aGlsZShpIDwgbSkge1xuIGMgKz0gdGhpcy5kYXRhW2ldK2EuZGF0YVtpXTtcbiByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiBjID4+PSB0aGlzLkRCO1xufVxuaWYoYS50IDwgdGhpcy50KSB7XG4gYyArPSBhLnM7XG4gd2hpbGUoaSA8IHRoaXMudCkge1xuICAgYyArPSB0aGlzLmRhdGFbaV07XG4gICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgIGMgPj49IHRoaXMuREI7XG4gfVxuIGMgKz0gdGhpcy5zO1xufSBlbHNlIHtcbiBjICs9IHRoaXMucztcbiB3aGlsZShpIDwgYS50KSB7XG4gICBjICs9IGEuZGF0YVtpXTtcbiAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgYyA+Pj0gdGhpcy5EQjtcbiB9XG4gYyArPSBhLnM7XG59XG5yLnMgPSAoYzwwKT8tMTowO1xuaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbmVsc2UgaWYoYyA8IC0xKSByLmRhdGFbaSsrXSA9IHRoaXMuRFYrYztcbnIudCA9IGk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5hZGRUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zdWJUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgKiBhXG5mdW5jdGlvbiBibk11bHRpcGx5KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5tdWx0aXBseVRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG52YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG50aGlzLmRpdlJlbVRvKGEscSxyKTtcbnJldHVybiBuZXcgQXJyYXkocSxyKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbnRoaXMuZGF0YVt0aGlzLnRdID0gdGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpO1xuKyt0aGlzLnQ7XG50aGlzLmNsYW1wKCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbmlmKG4gPT0gMCkgcmV0dXJuO1xud2hpbGUodGhpcy50IDw9IHcpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xudGhpcy5kYXRhW3ddICs9IG47XG53aGlsZSh0aGlzLmRhdGFbd10gPj0gdGhpcy5EVikge1xuIHRoaXMuZGF0YVt3XSAtPSB0aGlzLkRWO1xuIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICsrdGhpcy5kYXRhW3ddO1xufVxufVxuXG4vL0EgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5mdW5jdGlvbiBuTm9wKHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuZnVuY3Rpb24gblNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB9XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbk51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7IHJldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKCkpOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpIHtcbnZhciBpID0gTWF0aC5taW4odGhpcy50K2EudCxuKTtcbnIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbnIudCA9IGk7XG53aGlsZShpID4gMCkgci5kYXRhWy0taV0gPSAwO1xudmFyIGo7XG5mb3IoaiA9IHIudC10aGlzLnQ7IGkgPCBqOyArK2kpIHIuZGF0YVtpK3RoaXMudF0gPSB0aGlzLmFtKDAsYS5kYXRhW2ldLHIsaSwwLHRoaXMudCk7XG5mb3IoaiA9IE1hdGgubWluKGEudCxuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLGEuZGF0YVtpXSxyLGksMCxuLWkpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpIHtcbi0tbjtcbnZhciBpID0gci50ID0gdGhpcy50K2EudC1uO1xuci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxud2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG5mb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gci5kYXRhW3RoaXMudCtpLW5dID0gdGhpcy5hbShuLWksYS5kYXRhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuci5jbGFtcCgpO1xuci5kclNoaWZ0VG8oMSxyKTtcbn1cblxuLy9CYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbi8vIHNldHVwIEJhcnJldHRcbnRoaXMucjIgPSBuYmkoKTtcbnRoaXMucTMgPSBuYmkoKTtcbkJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbnRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbnRoaXMubSA9IG07XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbmlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG5lbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbmVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4vL3ggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbnguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG5pZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxudGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xudGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG53aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xueC5zdWJUbyh0aGlzLnIyLHgpO1xud2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy9yID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy9yID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuZnVuY3Rpb24gYm5Nb2RQb3coZSxtKSB7XG52YXIgaSA9IGUuYml0TGVuZ3RoKCksIGssIHIgPSBuYnYoMSksIHo7XG5pZihpIDw9IDApIHJldHVybiByO1xuZWxzZSBpZihpIDwgMTgpIGsgPSAxO1xuZWxzZSBpZihpIDwgNDgpIGsgPSAzO1xuZWxzZSBpZihpIDwgMTQ0KSBrID0gNDtcbmVsc2UgaWYoaSA8IDc2OCkgayA9IDU7XG5lbHNlIGsgPSA2O1xuaWYoaSA8IDgpXG4geiA9IG5ldyBDbGFzc2ljKG0pO1xuZWxzZSBpZihtLmlzRXZlbigpKVxuIHogPSBuZXcgQmFycmV0dChtKTtcbmVsc2VcbiB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG5cbi8vIHByZWNvbXB1dGF0aW9uXG52YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrLTEsIGttID0gKDE8PGspLTE7XG5nWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuaWYoayA+IDEpIHtcbiB2YXIgZzIgPSBuYmkoKTtcbiB6LnNxclRvKGdbMV0sZzIpO1xuIHdoaWxlKG4gPD0ga20pIHtcbiAgIGdbbl0gPSBuYmkoKTtcbiAgIHoubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO1xuICAgbiArPSAyO1xuIH1cbn1cblxudmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbmkgPSBuYml0cyhlLmRhdGFbal0pLTE7XG53aGlsZShqID49IDApIHtcbiBpZihpID49IGsxKSB3ID0gKGUuZGF0YVtqXT4+KGktazEpKSZrbTtcbiBlbHNlIHtcbiAgIHcgPSAoZS5kYXRhW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgaWYoaiA+IDApIHcgfD0gZS5kYXRhW2otMV0+Pih0aGlzLkRCK2ktazEpO1xuIH1cblxuIG4gPSBrO1xuIHdoaWxlKCh3JjEpID09IDApIHsgdyA+Pj0gMTsgLS1uOyB9XG4gaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gaWYoaXMxKSB7ICAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICBnW3ddLmNvcHlUbyhyKTtcbiAgIGlzMSA9IGZhbHNlO1xuIH0gZWxzZSB7XG4gICB3aGlsZShuID4gMSkgeyB6LnNxclRvKHIscjIpOyB6LnNxclRvKHIyLHIpOyBuIC09IDI7IH1cbiAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICB6Lm11bFRvKHIyLGdbd10scik7XG4gfVxuXG4gd2hpbGUoaiA+PSAwICYmIChlLmRhdGFbal0mKDE8PGkpKSA9PSAwKSB7XG4gICB6LnNxclRvKHIscjIpOyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7XG4gICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuIH1cbn1cbnJldHVybiB6LnJldmVydChyKTtcbn1cblxuLy8ocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xudmFyIHggPSAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO1xudmFyIHkgPSAoYS5zPDApP2EubmVnYXRlKCk6YS5jbG9uZSgpO1xuaWYoeC5jb21wYXJlVG8oeSkgPCAwKSB7IHZhciB0ID0geDsgeCA9IHk7IHkgPSB0OyB9XG52YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuaWYoZyA8IDApIHJldHVybiB4O1xuaWYoaSA8IGcpIGcgPSBpO1xuaWYoZyA+IDApIHtcbiB4LnJTaGlmdFRvKGcseCk7XG4geS5yU2hpZnRUbyhnLHkpO1xufVxud2hpbGUoeC5zaWdudW0oKSA+IDApIHtcbiBpZigoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLHgpO1xuIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gaWYoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgeC5zdWJUbyh5LHgpO1xuICAgeC5yU2hpZnRUbygxLHgpO1xuIH0gZWxzZSB7XG4gICB5LnN1YlRvKHgseSk7XG4gICB5LnJTaGlmdFRvKDEseSk7XG4gfVxufVxuaWYoZyA+IDApIHkubFNoaWZ0VG8oZyx5KTtcbnJldHVybiB5O1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbmlmKG4gPD0gMCkgcmV0dXJuIDA7XG52YXIgZCA9IHRoaXMuRFYlbiwgciA9ICh0aGlzLnM8MCk/bi0xOjA7XG5pZih0aGlzLnQgPiAwKVxuIGlmKGQgPT0gMCkgciA9IHRoaXMuZGF0YVswXSVuO1xuIGVsc2UgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByID0gKGQqcit0aGlzLmRhdGFbaV0pJW47XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xudmFyIGFjID0gbS5pc0V2ZW4oKTtcbmlmKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG52YXIgdSA9IG0uY2xvbmUoKSwgdiA9IHRoaXMuY2xvbmUoKTtcbnZhciBhID0gbmJ2KDEpLCBiID0gbmJ2KDApLCBjID0gbmJ2KDApLCBkID0gbmJ2KDEpO1xud2hpbGUodS5zaWdudW0oKSAhPSAwKSB7XG4gd2hpbGUodS5pc0V2ZW4oKSkge1xuICAgdS5yU2hpZnRUbygxLHUpO1xuICAgaWYoYWMpIHtcbiAgICAgaWYoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHsgYS5hZGRUbyh0aGlzLGEpOyBiLnN1YlRvKG0sYik7IH1cbiAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgfSBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICBiLnJTaGlmdFRvKDEsYik7XG4gfVxuIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgIHYuclNoaWZ0VG8oMSx2KTtcbiAgIGlmKGFjKSB7XG4gICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgIGMuclNoaWZ0VG8oMSxjKTtcbiAgIH0gZWxzZSBpZighZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLGQpO1xuICAgZC5yU2hpZnRUbygxLGQpO1xuIH1cbiBpZih1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICB1LnN1YlRvKHYsdSk7XG4gICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgYi5zdWJUbyhkLGIpO1xuIH0gZWxzZSB7XG4gICB2LnN1YlRvKHUsdik7XG4gICBpZihhYykgYy5zdWJUbyhhLGMpO1xuICAgZC5zdWJUbyhiLGQpO1xuIH1cbn1cbmlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG5pZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbn1cblxudmFyIGxvd3ByaW1lcyA9IFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3LDQxLDQzLDQ3LDUzLDU5LDYxLDY3LDcxLDczLDc5LDgzLDg5LDk3LDEwMSwxMDMsMTA3LDEwOSwxMTMsMTI3LDEzMSwxMzcsMTM5LDE0OSwxNTEsMTU3LDE2MywxNjcsMTczLDE3OSwxODEsMTkxLDE5MywxOTcsMTk5LDIxMSwyMjMsMjI3LDIyOSwyMzMsMjM5LDI0MSwyNTEsMjU3LDI2MywyNjksMjcxLDI3NywyODEsMjgzLDI5MywzMDcsMzExLDMxMywzMTcsMzMxLDMzNywzNDcsMzQ5LDM1MywzNTksMzY3LDM3MywzNzksMzgzLDM4OSwzOTcsNDAxLDQwOSw0MTksNDIxLDQzMSw0MzMsNDM5LDQ0Myw0NDksNDU3LDQ2MSw0NjMsNDY3LDQ3OSw0ODcsNDkxLDQ5OSw1MDMsNTA5XTtcbnZhciBscGxpbSA9ICgxPDwyNikvbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV07XG5cbi8vKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG52YXIgaSwgeCA9IHRoaXMuYWJzKCk7XG5pZih4LnQgPT0gMSAmJiB4LmRhdGFbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiBmb3IoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICBpZih4LmRhdGFbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiByZXR1cm4gZmFsc2U7XG59XG5pZih4LmlzRXZlbigpKSByZXR1cm4gZmFsc2U7XG5pID0gMTtcbndoaWxlKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gdmFyIG0gPSBsb3dwcmltZXNbaV0sIGogPSBpKzE7XG4gd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuIG0gPSB4Lm1vZEludChtKTtcbiB3aGlsZShpIDwgaikgaWYobSVsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2U7XG59XG5yZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xudmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG52YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG52YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG52YXIgcHJuZyA9IGJuR2V0UHJuZygpO1xudmFyIGE7XG5mb3IodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gLy8gc2VsZWN0IHdpdG5lc3MgJ2EnIGF0IHJhbmRvbSBmcm9tIGJldHdlZW4gMSBhbmQgbjFcbiBkbyB7XG4gICBhID0gbmV3IEJpZ0ludGVnZXIodGhpcy5iaXRMZW5ndGgoKSwgcHJuZyk7XG4gfVxuIHdoaWxlKGEuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8PSAwIHx8IGEuY29tcGFyZVRvKG4xKSA+PSAwKTtcbiB2YXIgeSA9IGEubW9kUG93KHIsdGhpcyk7XG4gaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgIHZhciBqID0gMTtcbiAgIHdoaWxlKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgeSA9IHkubW9kUG93SW50KDIsdGhpcyk7XG4gICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBpZih5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlO1xuIH1cbn1cbnJldHVybiB0cnVlO1xufVxuXG4vLyBnZXQgcHNldWRvIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5mdW5jdGlvbiBibkdldFBybmcoKSB7XG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgcmV0dXJuIHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vL3Byb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG5cbi8vcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbi8vQmlnSW50ZWdlciBpbnRlcmZhY2VzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2JuOlxuXG4vL0JpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbi8vZG91YmxlIGRvdWJsZVZhbHVlKClcbi8vZmxvYXQgZmxvYXRWYWx1ZSgpXG4vL2ludCBoYXNoQ29kZSgpXG4vL2xvbmcgbG9uZ1ZhbHVlKClcbi8vc3RhdGljIEJpZ0ludGVnZXIgdmFsdWVPZihsb25nIHZhbClcbiIsICIvKipcbiAqIFNlY3VyZSBIYXNoIEFsZ29yaXRobSB3aXRoIDE2MC1iaXQgZGlnZXN0IChTSEEtMSkgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNoYTEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTEgPSBmb3JnZS5zaGExIHx8IHt9O1xuZm9yZ2UubWQuc2hhMSA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMSA9IHNoYTE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0xIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGExLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMSBzdGF0ZSBjb250YWlucyBmaXZlIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGExJyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAyMCxcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDY3NDUyMzAxLFxuICAgICAgaDE6IDB4RUZDREFCODksXG4gICAgICBoMjogMHg5OEJBRENGRSxcbiAgICAgIGgzOiAweDEwMzI1NDc2LFxuICAgICAgaDQ6IDB4QzNEMkUxRjBcbiAgICB9O1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTEgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgczIgPSB7XG4gICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgaDE6IF9zdGF0ZS5oMSxcbiAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICBoMzogX3N0YXRlLmgzLFxuICAgICAgaDQ6IF9zdGF0ZS5oNFxuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgxKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg0KTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtMSBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgNjQpO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtMSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTEgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQsIGEsIGIsIGMsIGQsIGUsIGYsIGk7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDMyLWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA4MCAzMi1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS0xIGFsZ29yaXRobVxuICAgIC8vIGFuZCBmb3IgMzItNzkgdXNpbmcgTWF4IExvY2t0eXVraGluJ3Mgb3B0aW1pemF0aW9uXG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcbiAgICBlID0gcy5oNDtcblxuICAgIC8vIHJvdW5kIDFcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB0ID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCAyMDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl0pO1xuICAgICAgdCA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDJcbiAgICBmb3IoOyBpIDwgMzI7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDQwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg2RUQ5RUJBMSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAzXG4gICAgZm9yKDsgaSA8IDYwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIF4gYykpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDhGMUJCQ0RDICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDRcbiAgICBmb3IoOyBpIDwgODA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweENBNjJDMUQ2ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuXG4gICAgbGVuIC09IDY0O1xuICB9XG59XG4iLCAiLyoqXG4gKiBQYXJ0aWFsIGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSB2Mi4yOiBSU0EtT0VBUFxuICpcbiAqIE1vZGlmaWVkIGJ1dCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIE1JVCBhbmQgQlNEIGxpY2Vuc2VkIGNvZGU6XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2tqdXIvanNqd3MvYmxvYi9tYXN0ZXIvcnNhLmpzOlxuICpcbiAqIFRoZSAnanNqd3MnKEpTT04gV2ViIFNpZ25hdHVyZSBKYXZhU2NyaXB0IExpYnJhcnkpIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgS2VuamkgVXJ1c2hpbWFcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIGh0dHA6Ly93ZWJyc2EuY3ZzLnNvdXJjZWZvcmdlLm5ldC92aWV3dmMvd2VicnNhL0NsaWVudC9SU0FFUy1PQUVQLmpzP2NvbnRlbnQtdHlwZT10ZXh0JTJGcGxhaW46XG4gKlxuICogUlNBRVMtT0FFUC5qc1xuICogJElkOiBSU0FFUy1PQUVQLmpzLHYgMS4xLjEuMSAyMDAzLzAzLzE5IDE1OjM3OjIwIGVsbGlzcHJpdGNoYXJkIEV4cCAkXG4gKiBKYXZhU2NyaXB0IEltcGxlbWVudGF0aW9uIG9mIFBLQ1MgIzEgdjIuMSBSU0EgQ1JZUFRPR1JBUEhZIFNUQU5EQVJEIChSU0EgTGFib3JhdG9yaWVzLCBKdW5lIDE0LCAyMDAyKVxuICogQ29weXJpZ2h0IChDKSBFbGxpcyBQcml0Y2hhcmQsIEd1YXJkaWFuIFVubGltaXRlZCAyMDAzLlxuICogQ29udGFjdDogZWxsaXNAbnVraW5ldGljcy5jb21cbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqXG4gKiBPZmZpY2lhbCBkb2N1bWVudGF0aW9uOiBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMTI1XG4gKlxuICogQGF1dGhvciBFdmFuIEpvbmVzIChodHRwOi8vZXZhbmpvbmVzLmNhLylcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi9zaGExJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBQS0NTIzEgQVBJXG52YXIgcGtjczEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3MxID0gZm9yZ2UucGtjczEgfHwge307XG5cbi8qKlxuICogRW5jb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIG1lc3NhZ2UgKE0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbCBsYWJlbCAoTClcbiAqIGFuZCBzZWVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGVuY3J5cHRpb24sIGl0IG9ubHkgZW5jb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIHNlZWQgdGhlIHNlZWQgdG8gdXNlLlxuICogICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UsIHVuZGVmaW5lZCBmb3IgU0hBLTEuXG4gKiAgICAgICAgICBtZ2YxIG9wdGlvbmFsIG1nZjEgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE1HRjEuXG4gKlxuICogQHJldHVybiB0aGUgZW5jb2RlZCBtZXNzYWdlIGJ5dGVzLlxuICovXG5wa2NzMS5lbmNvZGVfcnNhX29hZXAgPSBmdW5jdGlvbihrZXksIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgLy8gcGFyc2UgYXJndW1lbnRzXG4gIHZhciBsYWJlbDtcbiAgdmFyIHNlZWQ7XG4gIHZhciBtZDtcbiAgdmFyIG1nZjFNZDtcbiAgLy8gbGVnYWN5IGFyZ3MgKGxhYmVsLCBzZWVkLCBtZClcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zO1xuICAgIHNlZWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gYXJndW1lbnRzWzRdIHx8IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdW5kZWZpbmVkO1xuICAgIHNlZWQgPSBvcHRpb25zLnNlZWQgfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gb3B0aW9ucy5tZCB8fCB1bmRlZmluZWQ7XG4gICAgaWYob3B0aW9ucy5tZ2YxICYmIG9wdGlvbnMubWdmMS5tZCkge1xuICAgICAgbWdmMU1kID0gb3B0aW9ucy5tZ2YxLm1kO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlZmF1bHQgT0FFUCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZighbWQpIHtcbiAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgbWQuc3RhcnQoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgTUdGLTEgdG8gc2FtZSBhcyBPQUVQXG4gIGlmKCFtZ2YxTWQpIHtcbiAgICBtZ2YxTWQgPSBtZDtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIGluIGJ5dGVzIGFuZCBjaGVjayBvdXRwdXRcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB2YXIgbWF4TGVuZ3RoID0ga2V5TGVuZ3RoIC0gMiAqIG1kLmRpZ2VzdExlbmd0aCAtIDI7XG4gIGlmKG1lc3NhZ2UubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGlucHV0IG1lc3NhZ2UgbGVuZ3RoIGlzIHRvbyBsb25nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoO1xuICAgIGVycm9yLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKCFsYWJlbCkge1xuICAgIGxhYmVsID0gJyc7XG4gIH1cbiAgbWQudXBkYXRlKGxhYmVsLCAncmF3Jyk7XG4gIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpO1xuXG4gIHZhciBQUyA9ICcnO1xuICB2YXIgUFNfbGVuZ3RoID0gbWF4TGVuZ3RoIC0gbWVzc2FnZS5sZW5ndGg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBQU19sZW5ndGg7IGkrKykge1xuICAgIFBTICs9ICdcXHgwMCc7XG4gIH1cblxuICB2YXIgREIgPSBsSGFzaC5nZXRCeXRlcygpICsgUFMgKyAnXFx4MDEnICsgbWVzc2FnZTtcblxuICBpZighc2VlZCkge1xuICAgIHNlZWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMobWQuZGlnZXN0TGVuZ3RoKTtcbiAgfSBlbHNlIGlmKHNlZWQubGVuZ3RoICE9PSBtZC5kaWdlc3RMZW5ndGgpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgUlNBRVMtT0FFUCBzZWVkLiBUaGUgc2VlZCBsZW5ndGggbXVzdCAnICtcbiAgICAgICdtYXRjaCB0aGUgZGlnZXN0IGxlbmd0aC4nKTtcbiAgICBlcnJvci5zZWVkTGVuZ3RoID0gc2VlZC5sZW5ndGg7XG4gICAgZXJyb3IuZGlnZXN0TGVuZ3RoID0gbWQuZGlnZXN0TGVuZ3RoO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIGRiTWFzayA9IHJzYV9tZ2YxKHNlZWQsIGtleUxlbmd0aCAtIG1kLmRpZ2VzdExlbmd0aCAtIDEsIG1nZjFNZCk7XG4gIHZhciBtYXNrZWREQiA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoREIsIGRiTWFzaywgREIubGVuZ3RoKTtcblxuICB2YXIgc2VlZE1hc2sgPSByc2FfbWdmMShtYXNrZWREQiwgbWQuZGlnZXN0TGVuZ3RoLCBtZ2YxTWQpO1xuICB2YXIgbWFza2VkU2VlZCA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoc2VlZCwgc2VlZE1hc2ssIHNlZWQubGVuZ3RoKTtcblxuICAvLyByZXR1cm4gZW5jb2RlZCBtZXNzYWdlXG4gIHJldHVybiAnXFx4MDAnICsgbWFza2VkU2VlZCArIG1hc2tlZERCO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIFJTQUVTLU9BRVAgZW5jb2RlZCBtZXNzYWdlIChFTSkgdXNpbmcga2V5LCB3aXRoIG9wdGlvbmFsXG4gKiBsYWJlbCAoTCkuXG4gKlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgcGVyZm9ybSBSU0EgZGVjcnlwdGlvbiwgaXQgb25seSBkZWNvZGVzIHRoZSBtZXNzYWdlXG4gKiB1c2luZyBSU0FFUy1PQUVQLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGVtIHRoZSBlbmNvZGVkIG1lc3NhZ2UgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgbGFiZWwgYW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlLlxuICogICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE9BRVAsIHVuZGVmaW5lZCBmb3IgU0hBLTEuXG4gKiAgICAgICAgICBtZ2YxIG9wdGlvbmFsIG1nZjEgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE1HRjEuXG4gKlxuICogQHJldHVybiB0aGUgZGVjb2RlZCBtZXNzYWdlIGJ5dGVzLlxuICovXG5wa2NzMS5kZWNvZGVfcnNhX29hZXAgPSBmdW5jdGlvbihrZXksIGVtLCBvcHRpb25zKSB7XG4gIC8vIHBhcnNlIGFyZ3NcbiAgdmFyIGxhYmVsO1xuICB2YXIgbWQ7XG4gIHZhciBtZ2YxTWQ7XG4gIC8vIGxlZ2FjeSBhcmdzXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGxhYmVsID0gb3B0aW9ucztcbiAgICBtZCA9IGFyZ3VtZW50c1szXSB8fCB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZihvcHRpb25zKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zLmxhYmVsIHx8IHVuZGVmaW5lZDtcbiAgICBtZCA9IG9wdGlvbnMubWQgfHwgdW5kZWZpbmVkO1xuICAgIGlmKG9wdGlvbnMubWdmMSAmJiBvcHRpb25zLm1nZjEubWQpIHtcbiAgICAgIG1nZjFNZCA9IG9wdGlvbnMubWdmMS5tZDtcbiAgICB9XG4gIH1cblxuICAvLyBjb21wdXRlIGxlbmd0aCBpbiBieXRlc1xuICB2YXIga2V5TGVuZ3RoID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgaWYoZW0ubGVuZ3RoICE9PSBrZXlMZW5ndGgpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAgZW5jb2RlZCBtZXNzYWdlIGxlbmd0aCBpcyBpbnZhbGlkLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IGVtLmxlbmd0aDtcbiAgICBlcnJvci5leHBlY3RlZExlbmd0aCA9IGtleUxlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgT0FFUCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZihtZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9IGVsc2Uge1xuICAgIG1kLnN0YXJ0KCk7XG4gIH1cblxuICAvLyBkZWZhdWx0IE1HRi0xIHRvIHNhbWUgYXMgT0FFUFxuICBpZighbWdmMU1kKSB7XG4gICAgbWdmMU1kID0gbWQ7XG4gIH1cblxuICBpZihrZXlMZW5ndGggPCAyICogbWQuZGlnZXN0TGVuZ3RoICsgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignUlNBRVMtT0FFUCBrZXkgaXMgdG9vIHNob3J0IGZvciB0aGUgaGFzaCBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIGlmKCFsYWJlbCkge1xuICAgIGxhYmVsID0gJyc7XG4gIH1cbiAgbWQudXBkYXRlKGxhYmVsLCAncmF3Jyk7XG4gIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgLy8gc3BsaXQgdGhlIG1lc3NhZ2UgaW50byBpdHMgcGFydHNcbiAgdmFyIHkgPSBlbS5jaGFyQXQoMCk7XG4gIHZhciBtYXNrZWRTZWVkID0gZW0uc3Vic3RyaW5nKDEsIG1kLmRpZ2VzdExlbmd0aCArIDEpO1xuICB2YXIgbWFza2VkREIgPSBlbS5zdWJzdHJpbmcoMSArIG1kLmRpZ2VzdExlbmd0aCk7XG5cbiAgdmFyIHNlZWRNYXNrID0gcnNhX21nZjEobWFza2VkREIsIG1kLmRpZ2VzdExlbmd0aCwgbWdmMU1kKTtcbiAgdmFyIHNlZWQgPSBmb3JnZS51dGlsLnhvckJ5dGVzKG1hc2tlZFNlZWQsIHNlZWRNYXNrLCBtYXNrZWRTZWVkLmxlbmd0aCk7XG5cbiAgdmFyIGRiTWFzayA9IHJzYV9tZ2YxKHNlZWQsIGtleUxlbmd0aCAtIG1kLmRpZ2VzdExlbmd0aCAtIDEsIG1nZjFNZCk7XG4gIHZhciBkYiA9IGZvcmdlLnV0aWwueG9yQnl0ZXMobWFza2VkREIsIGRiTWFzaywgbWFza2VkREIubGVuZ3RoKTtcblxuICB2YXIgbEhhc2hQcmltZSA9IGRiLnN1YnN0cmluZygwLCBtZC5kaWdlc3RMZW5ndGgpO1xuXG4gIC8vIGNvbnN0YW50IHRpbWUgY2hlY2sgdGhhdCBhbGwgdmFsdWVzIG1hdGNoIHdoYXQgaXMgZXhwZWN0ZWRcbiAgdmFyIGVycm9yID0gKHkgIT09ICdcXHgwMCcpO1xuXG4gIC8vIGNvbnN0YW50IHRpbWUgY2hlY2sgbEhhc2ggdnMgbEhhc2hQcmltZVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZGlnZXN0TGVuZ3RoOyArK2kpIHtcbiAgICBlcnJvciB8PSAobEhhc2guY2hhckF0KGkpICE9PSBsSGFzaFByaW1lLmNoYXJBdChpKSk7XG4gIH1cblxuICAvLyBcImNvbnN0YW50IHRpbWVcIiBmaW5kIHRoZSAweDEgYnl0ZSBzZXBhcmF0aW5nIHRoZSBwYWRkaW5nICh6ZXJvcykgZnJvbSB0aGVcbiAgLy8gbWVzc2FnZVxuICAvLyBUT0RPOiBJdCBtdXN0IGJlIHBvc3NpYmxlIHRvIGRvIHRoaXMgaW4gYSBiZXR0ZXIvc21hcnRlciB3YXk/XG4gIHZhciBpbl9wcyA9IDE7XG4gIHZhciBpbmRleCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgZm9yKHZhciBqID0gbWQuZGlnZXN0TGVuZ3RoOyBqIDwgZGIubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgY29kZSA9IGRiLmNoYXJDb2RlQXQoaik7XG5cbiAgICB2YXIgaXNfMCA9IChjb2RlICYgMHgxKSBeIDB4MTtcblxuICAgIC8vIG5vbi16ZXJvIGlmIG5vdCAwIG9yIDEgaW4gdGhlIHBzIHNlY3Rpb25cbiAgICB2YXIgZXJyb3JfbWFzayA9IGluX3BzID8gMHhmZmZlIDogMHgwMDAwO1xuICAgIGVycm9yIHw9IChjb2RlICYgZXJyb3JfbWFzayk7XG5cbiAgICAvLyBsYXRjaCBpbl9wcyB0byB6ZXJvIGFmdGVyIHdlIGZpbmQgMHgxXG4gICAgaW5fcHMgPSBpbl9wcyAmIGlzXzA7XG4gICAgaW5kZXggKz0gaW5fcHM7XG4gIH1cblxuICBpZihlcnJvciB8fCBkYi5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHgxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJTQUVTLU9BRVAgcGFkZGluZy4nKTtcbiAgfVxuXG4gIHJldHVybiBkYi5zdWJzdHJpbmcoaW5kZXggKyAxKTtcbn07XG5cbmZ1bmN0aW9uIHJzYV9tZ2YxKHNlZWQsIG1hc2tMZW5ndGgsIGhhc2gpIHtcbiAgLy8gZGVmYXVsdCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZighaGFzaCkge1xuICAgIGhhc2ggPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9XG4gIHZhciB0ID0gJyc7XG4gIHZhciBjb3VudCA9IE1hdGguY2VpbChtYXNrTGVuZ3RoIC8gaGFzaC5kaWdlc3RMZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgIChpID4+IDI0KSAmIDB4RkYsIChpID4+IDE2KSAmIDB4RkYsIChpID4+IDgpICYgMHhGRiwgaSAmIDB4RkYpO1xuICAgIGhhc2guc3RhcnQoKTtcbiAgICBoYXNoLnVwZGF0ZShzZWVkICsgYyk7XG4gICAgdCArPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gIH1cbiAgcmV0dXJuIHQuc3Vic3RyaW5nKDAsIG1hc2tMZW5ndGgpO1xufVxuIiwgIi8qKlxuICogUHJpbWUgbnVtYmVyIGdlbmVyYXRpb24gQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi9qc2JuJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnByaW1lIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucHJpbWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZTtcbiAgcmV0dXJuO1xufVxuXG4vKiBQUklNRSBBUEkgKi9cbnZhciBwcmltZSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJpbWUgPSBmb3JnZS5wcmltZSB8fCB7fTtcblxudmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG5cbi8vIHByaW1lcyBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xudmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuVEhJUlRZLmZyb21JbnQoMzApO1xudmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4fHk7fTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcHJvYmFibGUgcHJpbWUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQWx0ZXJuYXRpdmUgYWxnb3JpdGhtcyBjYW4gYmUgc3BlY2lmaWVkIGJ5IG5hbWUgYXMgYSBzdHJpbmcgb3IgYXMgYW5cbiAqIG9iamVjdCB3aXRoIGN1c3RvbSBvcHRpb25zIGxpa2Ugc286XG4gKlxuICoge1xuICogICBuYW1lOiAnUFJJTUVJTkMnLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgbWF4QmxvY2tUaW1lOiA8dGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gYmxvY2sgdGhlIG1haW5cbiAqICAgICAgIHRocmVhZCBiZWZvcmUgYWxsb3dpbmcgSS9PIG90aGVyIEpTIHRvIHJ1bj4sXG4gKiAgICAgbWlsbGVyUmFiaW5UZXN0czogPHRoZSBudW1iZXIgb2YgbWlsbGVyLXJhYmluIHRlc3RzIHRvIHJ1bj4sXG4gKiAgICAgd29ya2VyU2NyaXB0OiA8dGhlIHdvcmtlciBzY3JpcHQgVVJMPixcbiAqICAgICB3b3JrZXJzOiA8dGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAtMSB0byB1c2UgZXN0aW1hdGVkIGNvcmVzIG1pbnVzIG9uZT4uXG4gKiAgICAgd29ya0xvYWQ6IHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgbnVtYmVyIG9mIGJpdHMgZm9yIHRoZSBwcmltZSBudW1iZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBbYWxnb3JpdGhtXSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiAgICAgICAgICBbcHJuZ10gYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuXG4gKlxuICogQHJldHVybiBjYWxsYmFjayhlcnIsIG51bSkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBkZWZhdWx0IHRvIFBSSU1FSU5DIGFsZ29yaXRobVxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycpIHtcbiAgICBhbGdvcml0aG0gPSB7bmFtZTogYWxnb3JpdGhtfTtcbiAgfVxuICBhbGdvcml0aG0ub3B0aW9ucyA9IGFsZ29yaXRobS5vcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICB2YXIgcm5nID0ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmKGFsZ29yaXRobS5uYW1lID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgYWxnb3JpdGhtLm9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmltZSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobS5uYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoJ3dvcmtlcnMnIGluIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIGluaXRpYWxpemUgcmFuZG9tIG51bWJlclxuICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcblxuICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybSAzMGsraSBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEuIFRoZVxuICBudW1iZXIgd2UgYXJlIGdpdmVuIGlzIGFsd2F5cyBhbGlnbmVkIGF0IDMwayArIDEuIEVhY2ggdGltZSB0aGUgbnVtYmVyIGlzXG4gIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlclxuICB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgdmFyIGRlbHRhSWR4ID0gMDtcblxuICAvLyBnZXQgcmVxdWlyZWQgbnVtYmVyIG9mIE1SIHRlc3RzXG4gIHZhciBtclRlc3RzID0gZ2V0TWlsbGVyUmFiaW5UZXN0cyhudW0uYml0TGVuZ3RoKCkpO1xuICBpZignbWlsbGVyUmFiaW5UZXN0cycgaW4gb3B0aW9ucykge1xuICAgIG1yVGVzdHMgPSBvcHRpb25zLm1pbGxlclJhYmluVGVzdHM7XG4gIH1cblxuICAvLyBmaW5kIHByaW1lIG5lYXJlc3QgdG8gJ251bScgZm9yIG1heEJsb2NrVGltZSBtc1xuICAvLyAxMCBtcyBnaXZlcyA1bXMgb2YgbGVld2F5IGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYmVmb3JlIGRyb3BwaW5nXG4gIC8vIGJlbG93IDYwZnBzICgxMDAwLzYwID09IDE2LjY3KSwgYnV0IGluIHJlYWxpdHksIHRoZSBudW1iZXIgd2lsbFxuICAvLyBsaWtlbHkgYmUgaGlnaGVyIGR1ZSB0byBhbiAnYXRvbWljJyBiaWcgaW50IG1vZFBvd1xuICB2YXIgbWF4QmxvY2tUaW1lID0gMTA7XG4gIGlmKCdtYXhCbG9ja1RpbWUnIGluIG9wdGlvbnMpIHtcbiAgICBtYXhCbG9ja1RpbWUgPSBvcHRpb25zLm1heEJsb2NrVGltZTtcbiAgfVxuXG4gIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGFydCA9ICtuZXcgRGF0ZSgpO1xuICBkbyB7XG4gICAgLy8gb3ZlcmZsb3csIHJlZ2VuZXJhdGUgcmFuZG9tIG51bWJlclxuICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgfVxuICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgaWYobnVtLmlzUHJvYmFibGVQcmltZShtclRlc3RzKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bSk7XG4gICAgfVxuICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgIG51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICB9IHdoaWxlKG1heEJsb2NrVGltZSA8IDAgfHwgKCtuZXcgRGF0ZSgpIC0gc3RhcnQgPCBtYXhCbG9ja1RpbWUpKTtcblxuICAvLyBrZWVwIHRyeWluZyBsYXRlclxuICBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8vIE5PVEU6IFRoaXMgYWxnb3JpdGhtIGlzIGluZGV0ZXJtaW5hdGUgaW4gbmF0dXJlIGJlY2F1c2Ugd29ya2Vyc1xuLy8gcnVuIGluIHBhcmFsbGVsIGxvb2tpbmcgYXQgZGlmZmVyZW50IHNlZ21lbnRzIG9mIG51bWJlcnMuIEV2ZW4gaWYgdGhpc1xuLy8gYWxnb3JpdGhtIGlzIHJ1biB0d2ljZSB3aXRoIHRoZSBzYW1lIGlucHV0IGZyb20gYSBwcmVkaWN0YWJsZSBSTkcsIGl0XG4vLyBtYXkgcHJvZHVjZSBkaWZmZXJlbnQgb3V0cHV0cy5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyB3ZWIgd29ya2VycyB1bmF2YWlsYWJsZVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8vIHVzZSB3ZWIgd29ya2VycyB0byBnZW5lcmF0ZSBrZXlzXG4gIHZhciBudW1Xb3JrZXJzID0gb3B0aW9ucy53b3JrZXJzO1xuICB2YXIgd29ya0xvYWQgPSBvcHRpb25zLndvcmtMb2FkIHx8IDEwMDtcbiAgdmFyIHJhbmdlID0gd29ya0xvYWQgKiAzMCAvIDg7XG4gIHZhciB3b3JrZXJTY3JpcHQgPSBvcHRpb25zLndvcmtlclNjcmlwdCB8fCAnZm9yZ2UvcHJpbWUud29ya2VyLmpzJztcbiAgaWYobnVtV29ya2VycyA9PT0gLTEpIHtcbiAgICByZXR1cm4gZm9yZ2UudXRpbC5lc3RpbWF0ZUNvcmVzKGZ1bmN0aW9uKGVyciwgY29yZXMpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIDJcbiAgICAgICAgY29yZXMgPSAyO1xuICAgICAgfVxuICAgICAgbnVtV29ya2VycyA9IGNvcmVzIC0gMTtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDEgd29ya2VyXG4gICAgbnVtV29ya2VycyA9IE1hdGgubWF4KDEsIG51bVdvcmtlcnMpO1xuXG4gICAgLy8gVE9ETzogY29uc2lkZXIgb3B0aW1pemluZyBieSBzdGFydGluZyB3b3JrZXJzIG91dHNpZGUgZ2V0UHJpbWUoKSAuLi5cbiAgICAvLyBub3RlIHRoYXQgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhleSB3aWxsIGhhdmUgdG8gYmUgbWFkZSBpbnRlcm5hbGx5XG4gICAgLy8gYXN5bmNocm9ub3VzIHdoaWNoIG1heSBhY3R1YWxseSBiZSBzbG93ZXJcblxuICAgIC8vIHN0YXJ0IHdvcmtlcnMgaW1tZWRpYXRlbHlcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIC8vIEZJWE1FOiBmaXggcGF0aCBvciB1c2UgYmxvYiBVUkxzXG4gICAgICB3b3JrZXJzW2ldID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgcnVubmluZyA9IG51bVdvcmtlcnM7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHJlcXVlc3RzIGZyb20gd29ya2VycyBhbmQgYXNzaWduIHJhbmdlcyB0byBmaW5kIHByaW1lXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyogTm90ZTogVGhlIGRpc3RyaWJ1dGlvbiBvZiByYW5kb20gbnVtYmVycyBpcyB1bmtub3duLiBUaGVyZWZvcmUsIGVhY2hcbiAgICB3ZWIgd29ya2VyIGlzIGNvbnRpbnVvdXNseSBhbGxvY2F0ZWQgYSByYW5nZSBvZiBudW1iZXJzIHRvIGNoZWNrIGZvciBhXG4gICAgcmFuZG9tIG51bWJlciB1bnRpbCBvbmUgaXMgZm91bmQuXG5cbiAgICBFdmVyeSAzMCBudW1iZXJzIHdpbGwgYmUgY2hlY2tlZCBqdXN0IDggdGltZXMsIGJlY2F1c2UgcHJpbWUgbnVtYmVyc1xuICAgIGhhdmUgdGhlIGZvcm06XG5cbiAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xICh0aGVyZSBhcmUgOCB2YWx1ZXMgb2YgaSBmb3IgdGhpcylcblxuICAgIFRoZXJlZm9yZSwgaWYgd2Ugd2FudCBhIHdlYiB3b3JrZXIgdG8gcnVuIE4gY2hlY2tzIGJlZm9yZSBhc2tpbmcgZm9yXG4gICAgYSBuZXcgcmFuZ2Ugb2YgbnVtYmVycywgZWFjaCByYW5nZSBtdXN0IGNvbnRhaW4gTiozMC84IG51bWJlcnMuXG5cbiAgICBGb3IgMTAwIGNoZWNrcyAod29ya0xvYWQpLCB0aGlzIGlzIGEgcmFuZ2Ugb2YgMzc1LiAqL1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gd29ya2VyTWVzc2FnZShlKSB7XG4gICAgICAvLyBpZ25vcmUgbWVzc2FnZSwgcHJpbWUgYWxyZWFkeSBmb3VuZFxuICAgICAgaWYoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAtLXJ1bm5pbmc7XG4gICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgIGlmKGRhdGEuZm91bmQpIHtcbiAgICAgICAgLy8gdGVybWluYXRlIGFsbCB3b3JrZXJzXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3b3JrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQmlnSW50ZWdlcihkYXRhLnByaW1lLCAxNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgICBpZihudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2lnbiBuZXcgcmFuZ2UgdG8gY2hlY2tcbiAgICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAvLyBzdGFydCBwcmltZSBzZWFyY2hcbiAgICAgIGUudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaGV4OiBoZXgsXG4gICAgICAgIHdvcmtMb2FkOiB3b3JrTG9hZFxuICAgICAgfSk7XG5cbiAgICAgIG51bS5kQWRkT2Zmc2V0KHJhbmdlLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIHVzaW5nIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cyBhbmQgUk5HLlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIG51bWJlci5cbiAqIEBwYXJhbSBybmcgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpIHtcbiAgdmFyIG51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHJuZyk7XG4gIC8vIGZvcmNlIE1TQiBzZXRcbiAgdmFyIGJpdHMxID0gYml0cyAtIDE7XG4gIGlmKCFudW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICBudW0uYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBudW0pO1xuICB9XG4gIC8vIGFsaWduIG51bWJlciBvbiAzMGsrMSBib3VuZGFyeVxuICBudW0uZEFkZE9mZnNldCgzMSAtIG51bS5tb2QoVEhJUlRZKS5ieXRlVmFsdWUoKSwgMCk7XG4gIHJldHVybiBudW07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIE1pbGxlci1SYWJpbiB0ZXN0cyB0byBnZW5lcmF0ZSBhXG4gKiBwcmltZSB3aXRoIGFuIGVycm9yIHByb2JhYmlsaXR5IG9mICgxLzIpXjgwLlxuICpcbiAqIFNlZSBIYW5kYm9vayBvZiBBcHBsaWVkIENyeXB0b2dyYXBoeSBDaGFwdGVyIDQsIFRhYmxlIDQuNC5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUuXG4gKlxuICogQHJldHVybiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxufSkoKTtcbiIsICIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgUlNBIGFsZ29yaXRobXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBvbmx5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIEFuIFJTQSBrZXkgaXMgb2Z0ZW4gc3RvcmVkIGluIEFTTi4xIERFUiBmb3JtYXQuIFRoZSBTdWJqZWN0UHVibGljS2V5SW5mb1xuICogQVNOLjEgc3RydWN0dXJlIGlzIGNvbXBvc2VkIG9mIGFuIGFsZ29yaXRobSBvZiB0eXBlIEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIGFuZCBhIHN1YmplY3RQdWJsaWNLZXkgb2YgdHlwZSBiaXQgc3RyaW5nLlxuICpcbiAqIFRoZSBBbGdvcml0aG1JZGVudGlmaWVyIGNvbnRhaW5zIGFuIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIGFuZCBwYXJhbWV0ZXJzXG4gKiBmb3IgdGhlIGFsZ29yaXRobSwgaWYgYW55LiBJbiB0aGUgY2FzZSBvZiBSU0EsIHRoZXJlIGFyZW4ndCBhbnkuXG4gKlxuICogU3ViamVjdFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgYWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgQklUIFNUUklOR1xuICogfVxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRm9yIGFuIFJTQSBwdWJsaWMga2V5LCB0aGUgc3ViamVjdFB1YmxpY0tleSBpczpcbiAqXG4gKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbW9kdWx1cyAgICAgICAgICAgIElOVEVHRVIsICAgIC0tIG5cbiAqICAgcHVibGljRXhwb25lbnQgICAgIElOVEVHRVIgICAgIC0tIGVcbiAqIH1cbiAqXG4gKiBQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIHByaXZhdGVLZXlBbGdvcml0aG0gICAgICAgUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHByaXZhdGVLZXkgICAgICAgICAgICAgICAgUHJpdmF0ZUtleSxcbiAqICAgYXR0cmlidXRlcyAgICAgICAgICAgWzBdICBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICogUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIFByaXZhdGVLZXkgOjo9IE9DVEVUIFNUUklOR1xuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEFuIFJTQSBwcml2YXRlIGtleSBhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiBSU0FQcml2YXRlS2V5IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gVmVyc2lvbixcbiAqICAgbW9kdWx1cyBJTlRFR0VSLCAtLSBuXG4gKiAgIHB1YmxpY0V4cG9uZW50IElOVEVHRVIsIC0tIGVcbiAqICAgcHJpdmF0ZUV4cG9uZW50IElOVEVHRVIsIC0tIGRcbiAqICAgcHJpbWUxIElOVEVHRVIsIC0tIHBcbiAqICAgcHJpbWUyIElOVEVHRVIsIC0tIHFcbiAqICAgZXhwb25lbnQxIElOVEVHRVIsIC0tIGQgbW9kIChwLTEpXG4gKiAgIGV4cG9uZW50MiBJTlRFR0VSLCAtLSBkIG1vZCAocS0xKVxuICogICBjb2VmZmljaWVudCBJTlRFR0VSIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICpcbiAqIFRoZSBPSUQgZm9yIHRoZSBSU0Ega2V5IGFsZ29yaXRobSBpczogMS4yLjg0MC4xMTM1NDkuMS4xLjFcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2pzYm4nKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wa2NzMScpO1xucmVxdWlyZSgnLi9wcmltZScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbnZhciBfY3J5cHRvID0gZm9yZ2UudXRpbC5pc05vZGVqcyA/IHJlcXVpcmUoJ2NyeXB0bycpIDogbnVsbDtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vLyBzaG9ydGN1dCBmb3IgdXRpbCBBUElcbnZhciB1dGlsID0gZm9yZ2UudXRpbDtcblxuLypcbiAqIFJTQSBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLCBzZWUgUkZDIDIzMTMuXG4gKi9cbmZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLnJzYSA9IGZvcmdlLnJzYSA9IGZvcmdlLnJzYSB8fCB7fTtcbnZhciBwa2kgPSBmb3JnZS5wa2k7XG5cbi8vIGZvciBmaW5kaW5nIHByaW1lcywgd2hpY2ggYXJlIDMwaytpIGZvciBpID0gMSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOVxudmFyIEdDRF8zMF9ERUxUQSA9IFs2LCA0LCAyLCA0LCAyLCA0LCA2LCAyXTtcblxuLy8gdmFsaWRhdG9yIGZvciBhIFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxudmFyIHByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIC8vIFByaXZhdGVLZXlJbmZvXG4gIG5hbWU6ICdQcml2YXRlS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVZlcnNpb24nXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBQcml2YXRlS2V5XG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gUlNBIHByaXZhdGUga2V5XG52YXIgcnNhUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgLy8gUlNBUHJpdmF0ZUtleVxuICBuYW1lOiAnUlNBUHJpdmF0ZUtleScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5VmVyc2lvbidcbiAgfSwge1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkubW9kdWx1cycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleU1vZHVsdXMnXG4gIH0sIHtcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wdWJsaWNFeHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVB1YmxpY0V4cG9uZW50J1xuICB9LCB7XG4gICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaXZhdGVFeHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCdcbiAgfSwge1xuICAgIC8vIHByaW1lMSAocClcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcmltZTEnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcmltZTEnXG4gIH0sIHtcbiAgICAvLyBwcmltZTIgKHEpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpbWUyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpbWUyJ1xuICB9LCB7XG4gICAgLy8gZXhwb25lbnQxIChkIG1vZCAocC0xKSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5leHBvbmVudDEnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlFeHBvbmVudDEnXG4gIH0sIHtcbiAgICAvLyBleHBvbmVudDIgKGQgbW9kIChxLTEpKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmV4cG9uZW50MicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUV4cG9uZW50MidcbiAgfSwge1xuICAgIC8vIGNvZWZmaWNpZW50ICgoaW52ZXJzZSBvZiBxKSBtb2QgcClcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5jb2VmZmljaWVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUNvZWZmaWNpZW50J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBSU0EgcHVibGljIGtleVxudmFyIHJzYVB1YmxpY0tleVZhbGlkYXRvciA9IHtcbiAgLy8gUlNBUHVibGljS2V5XG4gIG5hbWU6ICdSU0FQdWJsaWNLZXknLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgbmFtZTogJ1JTQVB1YmxpY0tleS5tb2R1bHVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlNb2R1bHVzJ1xuICB9LCB7XG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgbmFtZTogJ1JTQVB1YmxpY0tleS5leHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHVibGljS2V5RXhwb25lbnQnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFN1YmplY3RQdWJsaWNLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBhbiBSU0EgcHVibGljIGtleVxudmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IGZvcmdlLnBraS5yc2EucHVibGljS2V5VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIGNhcHR1cmVBc24xOiAnc3ViamVjdFB1YmxpY0tleUluZm8nLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3B1YmxpY0tleU9pZCdcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgdmFsdWU6IFt7XG4gICAgICAvLyBSU0FQdWJsaWNLZXlcbiAgICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5LlJTQVB1YmxpY0tleScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdyc2FQdWJsaWNLZXknXG4gICAgfV1cbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBEaWdlc3RJbmZvIHN0cnVjdHVyZVxudmFyIGRpZ2VzdEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdEaWdlc3RJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRGlnZXN0SW5mby5EaWdlc3RBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnRGlnZXN0SW5mby5EaWdlc3RBbGdvcml0aG0uYWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2FsZ29yaXRobUlkZW50aWZpZXInXG4gICAgfSwge1xuICAgICAgLy8gTlVMTCBwYXJhbXRlcnNcbiAgICAgIG5hbWU6ICdEaWdlc3RJbmZvLkRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5OVUxMLFxuICAgICAgLy8gY2FwdHVyZWQgb25seSB0byBjaGVjayBleGlzdGVuY2UgZm9yIG1kMiBhbmQgbWQ1XG4gICAgICBjYXB0dXJlOiAncGFyYW1ldGVycycsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBkaWdlc3RcbiAgICBuYW1lOiAnRGlnZXN0SW5mby5kaWdlc3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdkaWdlc3QnXG4gIH1dXG59O1xuXG4vKipcbiAqIFdyYXAgZGlnZXN0IGluIERpZ2VzdEluZm8gb2JqZWN0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBLQ1MxLXYxXzUtRU5DT0RFIGFzIHBlciBSRkMgMzQ0Ny5cbiAqXG4gKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGRpZ2VzdEFsZ29yaXRobSBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBkaWdlc3QgRGlnZXN0XG4gKiB9XG4gKlxuICogRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAqXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB3aXRoIHRoZSBoYXNoIHRvIHNpZ24uXG4gKlxuICogQHJldHVybiB0aGUgZW5jb2RlZCBtZXNzYWdlIChyZWFkeSBmb3IgUlNBIGVuY3J5dGlvbilcbiAqL1xudmFyIGVtc2FQa2NzMXYxNWVuY29kZSA9IGZ1bmN0aW9uKG1kKSB7XG4gIC8vIGdldCB0aGUgb2lkIGZvciB0aGUgYWxnb3JpdGhtXG4gIHZhciBvaWQ7XG4gIGlmKG1kLmFsZ29yaXRobSBpbiBwa2kub2lkcykge1xuICAgIG9pZCA9IHBraS5vaWRzW21kLmFsZ29yaXRobV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobS4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBtZC5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgdmFyIG9pZEJ5dGVzID0gYXNuMS5vaWRUb0RlcihvaWQpLmdldEJ5dGVzKCk7XG5cbiAgLy8gY3JlYXRlIHRoZSBkaWdlc3QgaW5mb1xuICB2YXIgZGlnZXN0SW5mbyA9IGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgdmFyIGRpZ2VzdEFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgZGlnZXN0QWxnb3JpdGhtLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLCBvaWRCeXRlcykpO1xuICBkaWdlc3RBbGdvcml0aG0udmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJykpO1xuICB2YXIgZGlnZXN0ID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBmYWxzZSwgbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSk7XG4gIGRpZ2VzdEluZm8udmFsdWUucHVzaChkaWdlc3RBbGdvcml0aG0pO1xuICBkaWdlc3RJbmZvLnZhbHVlLnB1c2goZGlnZXN0KTtcblxuICAvLyBlbmNvZGUgZGlnZXN0IGluZm9cbiAgcmV0dXJuIGFzbjEudG9EZXIoZGlnZXN0SW5mbykuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgeF5jIG1vZCBuIChSU0EgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIG9wZXJhdGlvbikuXG4gKlxuICogQHBhcmFtIHggdGhlIG51bWJlciB0byByYWlzZSBhbmQgbW9kLlxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBwdWIgdHJ1ZSBpZiB0aGUga2V5IGlzIHB1YmxpYywgZmFsc2UgaWYgcHJpdmF0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHQgb2YgeF5jIG1vZCBuLlxuICovXG52YXIgX21vZFBvdyA9IGZ1bmN0aW9uKHgsIGtleSwgcHViKSB7XG4gIGlmKHB1Yikge1xuICAgIHJldHVybiB4Lm1vZFBvdyhrZXkuZSwga2V5Lm4pO1xuICB9XG5cbiAgaWYoIWtleS5wIHx8ICFrZXkucSkge1xuICAgIC8vIGFsbG93IGNhbGN1bGF0aW9uIHdpdGhvdXQgQ1JUIHBhcmFtcyAoc2xvdylcbiAgICByZXR1cm4geC5tb2RQb3coa2V5LmQsIGtleS5uKTtcbiAgfVxuXG4gIC8vIHByZS1jb21wdXRlIGRQLCBkUSwgYW5kIHFJbnYgaWYgbmVjZXNzYXJ5XG4gIGlmKCFrZXkuZFApIHtcbiAgICBrZXkuZFAgPSBrZXkuZC5tb2Qoa2V5LnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpKTtcbiAgfVxuICBpZigha2V5LmRRKSB7XG4gICAga2V5LmRRID0ga2V5LmQubW9kKGtleS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSk7XG4gIH1cbiAgaWYoIWtleS5xSW52KSB7XG4gICAga2V5LnFJbnYgPSBrZXkucS5tb2RJbnZlcnNlKGtleS5wKTtcbiAgfVxuXG4gIC8qIENoaW5lc2UgcmVtYWluZGVyIHRoZW9yZW0gKENSVCkgc3RhdGVzOlxuXG4gICAgU3VwcG9zZSBuMSwgbjIsIC4uLiwgbmsgYXJlIHBvc2l0aXZlIGludGVnZXJzIHdoaWNoIGFyZSBwYWlyd2lzZVxuICAgIGNvcHJpbWUgKG4xIGFuZCBuMiBoYXZlIG5vIGNvbW1vbiBmYWN0b3JzIG90aGVyIHRoYW4gMSkuIEZvciBhbnlcbiAgICBpbnRlZ2VycyB4MSwgeDIsIC4uLiwgeGsgdGhlcmUgZXhpc3RzIGFuIGludGVnZXIgeCBzb2x2aW5nIHRoZVxuICAgIHN5c3RlbSBvZiBzaW11bHRhbmVvdXMgY29uZ3J1ZW5jZXMgKHdoZXJlIH49IG1lYW5zIG1vZHVsYXJseVxuICAgIGNvbmdydWVudCBzbyBhIH49IGIgbW9kIG4gbWVhbnMgYSBtb2QgbiA9IGIgbW9kIG4pOlxuXG4gICAgeCB+PSB4MSBtb2QgbjFcbiAgICB4IH49IHgyIG1vZCBuMlxuICAgIC4uLlxuICAgIHggfj0geGsgbW9kIG5rXG5cbiAgICBUaGlzIHN5c3RlbSBvZiBjb25ncnVlbmNlcyBoYXMgYSBzaW5nbGUgc2ltdWx0YW5lb3VzIHNvbHV0aW9uIHhcbiAgICBiZXR3ZWVuIDAgYW5kIG4gLSAxLiBGdXJ0aGVybW9yZSwgZWFjaCB4ayBzb2x1dGlvbiBhbmQgeCBpdHNlbGZcbiAgICBpcyBjb25ncnVlbnQgbW9kdWxvIHRoZSBwcm9kdWN0IG4gPSBuMSpuMiouLi4qbmsuXG4gICAgU28geDEgbW9kIG4gPSB4MiBtb2QgbiA9IHhrIG1vZCBuID0geCBtb2Qgbi5cblxuICAgIFRoZSBzaW5nbGUgc2ltdWx0YW5lb3VzIHNvbHV0aW9uIHggY2FuIGJlIHNvbHZlZCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICBlcXVhdGlvbjpcblxuICAgIHggPSBzdW0oeGkqcmkqc2kpIG1vZCBuIHdoZXJlIHJpID0gbi9uaSBhbmQgc2kgPSByaV4tMSBtb2QgbmkuXG5cbiAgICBXaGVyZSB4IGlzIGxlc3MgdGhhbiBuLCB4aSA9IHggbW9kIG5pLlxuXG4gICAgRm9yIFJTQSB3ZSBhcmUgb25seSBjb25jZXJuZWQgd2l0aCBrID0gMi4gVGhlIG1vZHVsdXMgbiA9IHBxLCB3aGVyZVxuICAgIHAgYW5kIHEgYXJlIGNvcHJpbWUuIFRoZSBSU0EgZGVjcnlwdGlvbiBhbGdvcml0aG0gaXM6XG5cbiAgICB5ID0geF5kIG1vZCBuXG5cbiAgICBHaXZlbiB0aGUgYWJvdmU6XG5cbiAgICB4MSA9IHheZCBtb2QgcFxuICAgIHIxID0gbi9wID0gcVxuICAgIHMxID0gcV4tMSBtb2QgcFxuICAgIHgyID0geF5kIG1vZCBxXG4gICAgcjIgPSBuL3EgPSBwXG4gICAgczIgPSBwXi0xIG1vZCBxXG5cbiAgICBTbyB5ID0gKHgxcjFzMSArIHgycjJzMikgbW9kIG5cbiAgICAgICAgID0gKCh4XmQgbW9kIHApcShxXi0xIG1vZCBwKSArICh4XmQgbW9kIHEpcChwXi0xIG1vZCBxKSkgbW9kIG5cblxuICAgIEFjY29yZGluZyB0byBGZXJtYXQncyBMaXR0bGUgVGhlb3JlbSwgaWYgdGhlIG1vZHVsdXMgUCBpcyBwcmltZSxcbiAgICBmb3IgYW55IGludGVnZXIgQSBub3QgZXZlbmx5IGRpdmlzaWJsZSBieSBQLCBBXihQLTEpIH49IDEgbW9kIFAuXG4gICAgU2luY2UgQSBpcyBub3QgZGl2aXNpYmxlIGJ5IFAgaXQgZm9sbG93cyB0aGF0IGlmOlxuICAgIE4gfj0gTSBtb2QgKFAgLSAxKSwgdGhlbiBBXk4gbW9kIFAgPSBBXk0gbW9kIFAuIFRoZXJlZm9yZTpcblxuICAgIEFeTiBtb2QgUCA9IEFeKE0gbW9kIChQIC0gMSkpIG1vZCBQLiAoVGhlIGxhdHRlciB0YWtlcyBsZXNzIGVmZm9ydFxuICAgIHRvIGNhbGN1bGF0ZSkuIEluIG9yZGVyIHRvIGNhbGN1bGF0ZSB4XmQgbW9kIHAgbW9yZSBxdWlja2x5IHRoZVxuICAgIGV4cG9uZW50IGQgbW9kIChwIC0gMSkgaXMgc3RvcmVkIGluIHRoZSBSU0EgcHJpdmF0ZSBrZXkgKHRoZSBzYW1lXG4gICAgaXMgZG9uZSBmb3IgeF5kIG1vZCBxKS4gVGhlc2UgdmFsdWVzIGFyZSByZWZlcnJlZCB0byBhcyBkUCBhbmQgZFFcbiAgICByZXNwZWN0aXZlbHkuIFRoZXJlZm9yZSB3ZSBub3cgaGF2ZTpcblxuICAgIHkgPSAoKHheZFAgbW9kIHApcShxXi0xIG1vZCBwKSArICh4XmRRIG1vZCBxKXAocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBTaW5jZSB3ZSdsbCBiZSByZWR1Y2luZyB4XmRQIGJ5IG1vZHVsbyBwIChzYW1lIGZvciBxKSB3ZSBjYW4gYWxzb1xuICAgIHJlZHVjZSB4IGJ5IHAgKGFuZCBxIHJlc3BlY3RpdmVseSkgYmVmb3JlIGhhbmQuIFRoZXJlZm9yZSwgbGV0XG5cbiAgICB4cCA9ICgoeCBtb2QgcCleZFAgbW9kIHApLCBhbmRcbiAgICB4cSA9ICgoeCBtb2QgcSleZFEgbW9kIHEpLCB5aWVsZGluZzpcblxuICAgIHkgPSAoeHAqcSoocV4tMSBtb2QgcCkgKyB4cSpwKihwXi0xIG1vZCBxKSkgbW9kIG5cblxuICAgIFRoaXMgY2FuIGJlIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbXBsZSBhbGdvcml0aG0gdGhhdCBvbmx5XG4gICAgcmVxdWlyZXMgMSBpbnZlcnNlICh0aGUgcSBpbnZlcnNlIGlzIHVzZWQpIHRvIGJlIHVzZWQgYW5kIHN0b3JlZC5cbiAgICBUaGUgYWxnb3JpdGhtIGlzIGNhbGxlZCBHYXJuZXIncyBhbGdvcml0aG0uIElmIHFJbnYgaXMgdGhlXG4gICAgaW52ZXJzZSBvZiBxLCB3ZSBzaW1wbHkgY2FsY3VsYXRlOlxuXG4gICAgeSA9IChxSW52Kih4cCAtIHhxKSBtb2QgcCkgKiBxICsgeHFcblxuICAgIEhvd2V2ZXIsIHRoZXJlIGFyZSB0d28gZnVydGhlciBjb21wbGljYXRpb25zLiBGaXJzdCwgd2UgbmVlZCB0b1xuICAgIGVuc3VyZSB0aGF0IHhwID4geHEgdG8gcHJldmVudCBzaWduZWQgQmlnSW50ZWdlcnMgZnJvbSBiZWluZyB1c2VkXG4gICAgc28gd2UgYWRkIHAgdW50aWwgdGhpcyBpcyB0cnVlIChzaW5jZSB3ZSB3aWxsIGJlIG1vZCdpbmcgd2l0aFxuICAgIHAgYW55d2F5KS4gVGhlbiwgdGhlcmUgaXMgYSBrbm93biB0aW1pbmcgYXR0YWNrIG9uIGFsZ29yaXRobXNcbiAgICB1c2luZyB0aGUgQ1JULiBUbyBtaXRpZ2F0ZSB0aGlzIHJpc2ssIFwiY3J5cHRvZ3JhcGhpYyBibGluZGluZ1wiXG4gICAgc2hvdWxkIGJlIHVzZWQuIFRoaXMgcmVxdWlyZXMgc2ltcGx5IGdlbmVyYXRpbmcgYSByYW5kb20gbnVtYmVyIHJcbiAgICBiZXR3ZWVuIDAgYW5kIG4tMSBhbmQgaXRzIGludmVyc2UgYW5kIG11bHRpcGx5aW5nIHggYnkgcl5lIGJlZm9yZVxuICAgIGNhbGN1bGF0aW5nIHkgYW5kIHRoZW4gbXVsdGlwbHlpbmcgeSBieSByXi0xIGFmdGVyd2FyZHMuIE5vdGUgdGhhdFxuICAgIHIgbXVzdCBiZSBjb3ByaW1lIHdpdGggbiAoZ2NkKHIsIG4pID09PSAxKSBpbiBvcmRlciB0byBoYXZlIGFuXG4gICAgaW52ZXJzZS5cbiAgKi9cblxuICAvLyBjcnlwdG9ncmFwaGljIGJsaW5kaW5nXG4gIHZhciByO1xuICBkbyB7XG4gICAgciA9IG5ldyBCaWdJbnRlZ2VyKFxuICAgICAgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhrZXkubi5iaXRMZW5ndGgoKSAvIDgpKSxcbiAgICAgIDE2KTtcbiAgfSB3aGlsZShyLmNvbXBhcmVUbyhrZXkubikgPj0gMCB8fCAhci5nY2Qoa2V5Lm4pLmVxdWFscyhCaWdJbnRlZ2VyLk9ORSkpO1xuICB4ID0geC5tdWx0aXBseShyLm1vZFBvdyhrZXkuZSwga2V5Lm4pKS5tb2Qoa2V5Lm4pO1xuXG4gIC8vIGNhbGN1bGF0ZSB4cCBhbmQgeHFcbiAgdmFyIHhwID0geC5tb2Qoa2V5LnApLm1vZFBvdyhrZXkuZFAsIGtleS5wKTtcbiAgdmFyIHhxID0geC5tb2Qoa2V5LnEpLm1vZFBvdyhrZXkuZFEsIGtleS5xKTtcblxuICAvLyB4cCBtdXN0IGJlIGxhcmdlciB0aGFuIHhxIHRvIGF2b2lkIHNpZ25lZCBiaXQgdXNhZ2VcbiAgd2hpbGUoeHAuY29tcGFyZVRvKHhxKSA8IDApIHtcbiAgICB4cCA9IHhwLmFkZChrZXkucCk7XG4gIH1cblxuICAvLyBkbyBsYXN0IHN0ZXBcbiAgdmFyIHkgPSB4cC5zdWJ0cmFjdCh4cSlcbiAgICAubXVsdGlwbHkoa2V5LnFJbnYpLm1vZChrZXkucClcbiAgICAubXVsdGlwbHkoa2V5LnEpLmFkZCh4cSk7XG5cbiAgLy8gcmVtb3ZlIGVmZmVjdCBvZiByYW5kb20gZm9yIGNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcbiAgeSA9IHkubXVsdGlwbHkoci5tb2RJbnZlcnNlKGtleS5uKSkubW9kKGtleS5uKTtcblxuICByZXR1cm4geTtcbn07XG5cbi8qKlxuICogTk9URTogVEhJUyBNRVRIT0QgSVMgREVQUkVDQVRFRCwgdXNlICdzaWduJyBvbiBhIHByaXZhdGUga2V5IG9iamVjdCBvclxuICogJ2VuY3J5cHQnIG9uIGEgcHVibGljIGtleSBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBQZXJmb3JtcyBSU0EgZW5jcnlwdGlvbi5cbiAqXG4gKiBUaGUgcGFyYW1ldGVyIGJ0IGNvbnRyb2xzIHdoZXRoZXIgdG8gcHV0IHBhZGRpbmcgYnl0ZXMgYmVmb3JlIHRoZVxuICogbWVzc2FnZSBwYXNzZWQgaW4uIFNldCBidCB0byBlaXRoZXIgdHJ1ZSBvciBmYWxzZSB0byBkaXNhYmxlIHBhZGRpbmdcbiAqIGNvbXBsZXRlbHkgKGluIG9yZGVyIHRvIGhhbmRsZSBlLmcuIEVNU0EtUFNTIGVuY29kaW5nIHNlcGVyYXRlbHkgYmVmb3JlKSxcbiAqIHNpZ25hbGluZyB3aGV0aGVyIHRoZSBlbmNyeXB0aW9uIG9wZXJhdGlvbiBpcyBhIHB1YmxpYyBrZXkgb3BlcmF0aW9uXG4gKiAoaS5lLiBlbmNyeXB0aW5nIGRhdGEpIG9yIG5vdCwgaS5lLiBwcml2YXRlIGtleSBvcGVyYXRpb24gKGRhdGEgc2lnbmluZykuXG4gKlxuICogRm9yIFBLQ1MjMSB2MS41IHBhZGRpbmcgcGFzcyBpbiB0aGUgYmxvY2sgdHlwZSB0byB1c2UsIGkuZS4gZWl0aGVyIDB4MDFcbiAqIChmb3Igc2lnbmluZykgb3IgMHgwMiAoZm9yIGVuY3J5cHRpb24pLiBUaGUga2V5IG9wZXJhdGlvbiBtb2RlIChwcml2YXRlXG4gKiBvciBwdWJsaWMpIGlzIGRlcml2ZWQgZnJvbSB0aGlzIGZsYWcgaW4gdGhhdCBjYXNlKS5cbiAqXG4gKiBAcGFyYW0gbSB0aGUgbWVzc2FnZSB0byBlbmNyeXB0IGFzIGEgYnl0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBidCBmb3IgUEtDUyMxIHYxLjUgcGFkZGluZywgdGhlIGJsb2NrIHR5cGUgdG8gdXNlXG4gKiAgICgweDAxIGZvciBwcml2YXRlIGtleSwgMHgwMiBmb3IgcHVibGljKSxcbiAqICAgdG8gZGlzYWJsZSBwYWRkaW5nOiB0cnVlID0gcHVibGljIGtleSwgZmFsc2UgPSBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbmNyeXB0ZWQgYnl0ZXMgYXMgYSBzdHJpbmcuXG4gKi9cbnBraS5yc2EuZW5jcnlwdCA9IGZ1bmN0aW9uKG0sIGtleSwgYnQpIHtcbiAgdmFyIHB1YiA9IGJ0O1xuICB2YXIgZWI7XG5cbiAgLy8gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIG1vZHVsdXMgaW4gYnl0ZXNcbiAgdmFyIGsgPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcblxuICBpZihidCAhPT0gZmFsc2UgJiYgYnQgIT09IHRydWUpIHtcbiAgICAvLyBsZWdhY3ksIGRlZmF1bHQgdG8gUEtDUyMxIHYxLjUgcGFkZGluZ1xuICAgIHB1YiA9IChidCA9PT0gMHgwMik7XG4gICAgZWIgPSBfZW5jb2RlUGtjczFfdjFfNShtLCBrZXksIGJ0KTtcbiAgfSBlbHNlIHtcbiAgICBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZWIucHV0Qnl0ZXMobSk7XG4gIH1cblxuICAvLyBsb2FkIGVuY3J5cHRpb24gYmxvY2sgYXMgYmlnIGludGVnZXIgJ3gnXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHggPSBuZXcgQmlnSW50ZWdlcihlYi50b0hleCgpLCAxNik7XG5cbiAgLy8gZG8gUlNBIGVuY3J5cHRpb25cbiAgdmFyIHkgPSBfbW9kUG93KHgsIGtleSwgcHViKTtcblxuICAvLyBjb252ZXJ0IHkgaW50byB0aGUgZW5jcnlwdGVkIGRhdGEgYnl0ZSBzdHJpbmcsIGlmIHkgaXMgc2hvcnRlciBpblxuICAvLyBieXRlcyB0aGFuIGssIHRoZW4gcHJlcGVuZCB6ZXJvIGJ5dGVzIHRvIGZpbGwgdXAgZWRcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeWhleCA9IHkudG9TdHJpbmcoMTYpO1xuICB2YXIgZWQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB2YXIgemVyb3MgPSBrIC0gTWF0aC5jZWlsKHloZXgubGVuZ3RoIC8gMik7XG4gIHdoaWxlKHplcm9zID4gMCkge1xuICAgIGVkLnB1dEJ5dGUoMHgwMCk7XG4gICAgLS16ZXJvcztcbiAgfVxuICBlZC5wdXRCeXRlcyhmb3JnZS51dGlsLmhleFRvQnl0ZXMoeWhleCkpO1xuICByZXR1cm4gZWQuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogTk9URTogVEhJUyBNRVRIT0QgSVMgREVQUkVDQVRFRCwgdXNlICdkZWNyeXB0JyBvbiBhIHByaXZhdGUga2V5IG9iamVjdCBvclxuICogJ3ZlcmlmeScgb24gYSBwdWJsaWMga2V5IG9iamVjdCBpbnN0ZWFkLlxuICpcbiAqIFBlcmZvcm1zIFJTQSBkZWNyeXB0aW9uLlxuICpcbiAqIFRoZSBwYXJhbWV0ZXIgbWwgY29udHJvbHMgd2hldGhlciB0byBhcHBseSBQS0NTIzEgdjEuNSBwYWRkaW5nXG4gKiBvciBub3QuICBTZXQgbWwgPSBmYWxzZSB0byBkaXNhYmxlIHBhZGRpbmcgcmVtb3ZhbCBjb21wbGV0ZWx5XG4gKiAoaW4gb3JkZXIgdG8gaGFuZGxlIGUuZy4gRU1TQS1QU1MgbGF0ZXIgb24pIGFuZCBzaW1wbHkgcGFzcyBiYWNrXG4gKiB0aGUgUlNBIGVuY3J5cHRpb24gYmxvY2suXG4gKlxuICogQHBhcmFtIGVkIHRoZSBlbmNyeXB0ZWQgZGF0YSB0byBkZWNyeXB0IGluIGFzIGEgYnl0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBwdWIgdHJ1ZSBmb3IgYSBwdWJsaWMga2V5IG9wZXJhdGlvbiwgZmFsc2UgZm9yIHByaXZhdGUuXG4gKiBAcGFyYW0gbWwgdGhlIG1lc3NhZ2UgbGVuZ3RoLCBpZiBrbm93biwgZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY3J5cHRlZCBtZXNzYWdlIGFzIGEgYnl0ZSBzdHJpbmcuXG4gKi9cbnBraS5yc2EuZGVjcnlwdCA9IGZ1bmN0aW9uKGVkLCBrZXksIHB1YiwgbWwpIHtcbiAgLy8gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIG1vZHVsdXMgaW4gYnl0ZXNcbiAgdmFyIGsgPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcblxuICAvLyBlcnJvciBpZiB0aGUgbGVuZ3RoIG9mIHRoZSBlbmNyeXB0ZWQgZGF0YSBFRCBpcyBub3Qga1xuICBpZihlZC5sZW5ndGggIT09IGspIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGxlbmd0aCBpcyBpbnZhbGlkLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IGVkLmxlbmd0aDtcbiAgICBlcnJvci5leHBlY3RlZCA9IGs7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBjb252ZXJ0IGVuY3J5cHRlZCBkYXRhIGludG8gYSBiaWcgaW50ZWdlclxuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB5ID0gbmV3IEJpZ0ludGVnZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZWQpLnRvSGV4KCksIDE2KTtcblxuICAvLyB5IG11c3QgYmUgbGVzcyB0aGFuIHRoZSBtb2R1bHVzIG9yIGl0IHdhc24ndCB0aGUgcmVzdWx0IG9mXG4gIC8vIGEgcHJldmlvdXMgbW9kIG9wZXJhdGlvbiAoZW5jcnlwdGlvbikgdXNpbmcgdGhhdCBtb2R1bHVzXG4gIGlmKHkuY29tcGFyZVRvKGtleS5uKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBpcyBpbnZhbGlkLicpO1xuICB9XG5cbiAgLy8gZG8gUlNBIGRlY3J5cHRpb25cbiAgdmFyIHggPSBfbW9kUG93KHksIGtleSwgcHViKTtcblxuICAvLyBjcmVhdGUgdGhlIGVuY3J5cHRpb24gYmxvY2ssIGlmIHggaXMgc2hvcnRlciBpbiBieXRlcyB0aGFuIGssIHRoZW5cbiAgLy8gcHJlcGVuZCB6ZXJvIGJ5dGVzIHRvIGZpbGwgdXAgZWJcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeGhleCA9IHgudG9TdHJpbmcoMTYpO1xuICB2YXIgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB2YXIgemVyb3MgPSBrIC0gTWF0aC5jZWlsKHhoZXgubGVuZ3RoIC8gMik7XG4gIHdoaWxlKHplcm9zID4gMCkge1xuICAgIGViLnB1dEJ5dGUoMHgwMCk7XG4gICAgLS16ZXJvcztcbiAgfVxuICBlYi5wdXRCeXRlcyhmb3JnZS51dGlsLmhleFRvQnl0ZXMoeGhleCkpO1xuXG4gIGlmKG1sICE9PSBmYWxzZSkge1xuICAgIC8vIGxlZ2FjeSwgZGVmYXVsdCB0byBQS0NTIzEgdjEuNSBwYWRkaW5nXG4gICAgcmV0dXJuIF9kZWNvZGVQa2NzMV92MV81KGViLmdldEJ5dGVzKCksIGtleSwgcHViKTtcbiAgfVxuXG4gIC8vIHJldHVybiBtZXNzYWdlXG4gIHJldHVybiBlYi5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJTQSBrZXktcGFpciBnZW5lcmF0aW9uIHN0YXRlIG9iamVjdC4gSXQgaXMgdXNlZCB0byBhbGxvd1xuICoga2V5LWdlbmVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIGluIHN0ZXBzLiBJdCBhbHNvIGFsbG93cyBmb3IgYSBVSSB0b1xuICogZGlzcGxheSBwcm9ncmVzcyB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBzaXplIGZvciB0aGUgcHJpdmF0ZSBrZXkgaW4gYml0cywgZGVmYXVsdHMgdG8gMjA0OC5cbiAqIEBwYXJhbSBlIHRoZSBwdWJsaWMgZXhwb25lbnQgdG8gdXNlLCBkZWZhdWx0cyB0byA2NTUzNyAoMHgxMDAwMSkuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIHBybmcgYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuXG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UgKGRlZmF1bHQ6ICdQUklNRUlOQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIHN0YXRlIG9iamVjdCB0byB1c2UgdG8gZ2VuZXJhdGUgdGhlIGtleS1wYWlyLlxuICovXG5wa2kucnNhLmNyZWF0ZUtleVBhaXJHZW5lcmF0aW9uU3RhdGUgPSBmdW5jdGlvbihiaXRzLCBlLCBvcHRpb25zKSB7XG4gIC8vIFRPRE86IG1pZ3JhdGUgc3RlcC1iYXNlZCBwcmltZSBnZW5lcmF0aW9uIGNvZGUgdG8gZm9yZ2UucHJpbWVcblxuICAvLyBzZXQgZGVmYXVsdCBiaXRzXG4gIGlmKHR5cGVvZihiaXRzKSA9PT0gJ3N0cmluZycpIHtcbiAgICBiaXRzID0gcGFyc2VJbnQoYml0cywgMTApO1xuICB9XG4gIGJpdHMgPSBiaXRzIHx8IDIwNDg7XG5cbiAgLy8gY3JlYXRlIHBybmcgd2l0aCBhcGkgdGhhdCBtYXRjaGVzIEJpZ0ludGVnZXIgc2VjdXJlIHJhbmRvbVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICB2YXIgcm5nID0ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBhbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnUFJJTUVJTkMnO1xuXG4gIC8vIGNyZWF0ZSBQUklNRUlOQyBhbGdvcml0aG0gc3RhdGVcbiAgdmFyIHJ2YWw7XG4gIGlmKGFsZ29yaXRobSA9PT0gJ1BSSU1FSU5DJykge1xuICAgIHJ2YWwgPSB7XG4gICAgICBhbGdvcml0aG06IGFsZ29yaXRobSxcbiAgICAgIHN0YXRlOiAwLFxuICAgICAgYml0czogYml0cyxcbiAgICAgIHJuZzogcm5nLFxuICAgICAgZUludDogZSB8fCA2NTUzNyxcbiAgICAgIGU6IG5ldyBCaWdJbnRlZ2VyKG51bGwpLFxuICAgICAgcDogbnVsbCxcbiAgICAgIHE6IG51bGwsXG4gICAgICBxQml0czogYml0cyA+PiAxLFxuICAgICAgcEJpdHM6IGJpdHMgLSAoYml0cyA+PiAxKSxcbiAgICAgIHBxU3RhdGU6IDAsXG4gICAgICBudW06IG51bGwsXG4gICAgICBrZXlzOiBudWxsXG4gICAgfTtcbiAgICBydmFsLmUuZnJvbUludChydmFsLmVJbnQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgZ2VuZXJhdGlvbiBhbGdvcml0aG06ICcgKyBhbGdvcml0aG0pO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJ1bnMgdGhlIGtleS1nZW5lcmF0aW9uIGFsZ29yaXRobSBmb3IgYXQgbW9zdCBuIHNlY29uZHNcbiAqIChhcHByb3hpbWF0ZWx5KSB1c2luZyB0aGUgZ2l2ZW4gc3RhdGUuIFdoZW4ga2V5LWdlbmVyYXRpb24gaGFzIGNvbXBsZXRlZCxcbiAqIHRoZSBrZXlzIHdpbGwgYmUgc3RvcmVkIGluIHN0YXRlLmtleXMuXG4gKlxuICogVG8gdXNlIHRoaXMgZnVuY3Rpb24gdG8gdXBkYXRlIGEgVUkgd2hpbGUgZ2VuZXJhdGluZyBhIGtleSBvciB0byBwcmV2ZW50XG4gKiBjYXVzaW5nIGJyb3dzZXIgbG9ja3Vwcy93YXJuaW5ncywgc2V0IFwiblwiIHRvIGEgdmFsdWUgb3RoZXIgdGhhbiAwLiBBXG4gKiBzaW1wbGUgcGF0dGVybiBmb3IgZ2VuZXJhdGluZyBhIGtleSBhbmQgc2hvd2luZyBhIHByb2dyZXNzIGluZGljYXRvciBpczpcbiAqXG4gKiB2YXIgc3RhdGUgPSBwa2kucnNhLmNyZWF0ZUtleVBhaXJHZW5lcmF0aW9uU3RhdGUoMjA0OCk7XG4gKiB2YXIgc3RlcCA9IGZ1bmN0aW9uKCkge1xuICogICAvLyBzdGVwIGtleS1nZW5lcmF0aW9uLCBydW4gYWxnb3JpdGhtIGZvciAxMDAgbXMsIHJlcGVhdFxuICogICBpZighZm9yZ2UucGtpLnJzYS5zdGVwS2V5UGFpckdlbmVyYXRpb25TdGF0ZShzdGF0ZSwgMTAwKSkge1xuICogICAgIHNldFRpbWVvdXQoc3RlcCwgMSk7XG4gKiAgIH0gZWxzZSB7XG4gKiAgICAgLy8ga2V5LWdlbmVyYXRpb24gY29tcGxldGVcbiAqICAgICAvLyBUT0RPOiB0dXJuIG9mZiBwcm9ncmVzcyBpbmRpY2F0b3IgaGVyZVxuICogICAgIC8vIFRPRE86IHVzZSB0aGUgZ2VuZXJhdGVkIGtleS1wYWlyIGluIFwic3RhdGUua2V5c1wiXG4gKiAgIH1cbiAqIH07XG4gKiAvLyBUT0RPOiB0dXJuIG9uIHByb2dyZXNzIGluZGljYXRvciBoZXJlXG4gKiBzZXRUaW1lb3V0KHN0ZXAsIDApO1xuICpcbiAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgdG8gdXNlLlxuICogQHBhcmFtIG4gdGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBydW4gdGhlIGFsZ29yaXRobSBmb3IsIDBcbiAqICAgICAgICAgIHRvIHJ1biB0aGUgYWxnb3JpdGhtIHRvIGNvbXBsZXRpb24uXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBrZXktZ2VuZXJhdGlvbiBjb21wbGV0ZWQsIGZhbHNlIGlmIG5vdC5cbiAqL1xucGtpLnJzYS5zdGVwS2V5UGFpckdlbmVyYXRpb25TdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuKSB7XG4gIC8vIHNldCBkZWZhdWx0IGFsZ29yaXRobSBpZiBub3Qgc2V0XG4gIGlmKCEoJ2FsZ29yaXRobScgaW4gc3RhdGUpKSB7XG4gICAgc3RhdGUuYWxnb3JpdGhtID0gJ1BSSU1FSU5DJztcbiAgfVxuXG4gIC8vIFRPRE86IG1pZ3JhdGUgc3RlcC1iYXNlZCBwcmltZSBnZW5lcmF0aW9uIGNvZGUgdG8gZm9yZ2UucHJpbWVcbiAgLy8gVE9ETzogYWJzdHJhY3QgYXMgUFJJTUVJTkMgYWxnb3JpdGhtXG5cbiAgLy8gZG8ga2V5IGdlbmVyYXRpb24gKGJhc2VkIG9uIFRvbSBXdSdzIHJzYS5qcywgc2VlIGpzYm4uanMgbGljZW5zZSlcbiAgLy8gd2l0aCBzb21lIG1pbm9yIG9wdGltaXphdGlvbnMgYW5kIGRlc2lnbmVkIHRvIHJ1biBpbiBzdGVwc1xuXG4gIC8vIGxvY2FsIHN0YXRlIHZhcnNcbiAgdmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuICBUSElSVFkuZnJvbUludCgzMCk7XG4gIHZhciBkZWx0YUlkeCA9IDA7XG4gIHZhciBvcF9vciA9IGZ1bmN0aW9uKHgsIHkpIHtyZXR1cm4geCB8IHk7fTtcblxuICAvLyBrZWVwIHN0ZXBwaW5nIHVudGlsIHRpbWUgbGltaXQgaXMgcmVhY2hlZCBvciBkb25lXG4gIHZhciB0MSA9ICtuZXcgRGF0ZSgpO1xuICB2YXIgdDI7XG4gIHZhciB0b3RhbCA9IDA7XG4gIHdoaWxlKHN0YXRlLmtleXMgPT09IG51bGwgJiYgKG4gPD0gMCB8fCB0b3RhbCA8IG4pKSB7XG4gICAgLy8gZ2VuZXJhdGUgcCBvciBxXG4gICAgaWYoc3RhdGUuc3RhdGUgPT09IDApIHtcbiAgICAgIC8qIE5vdGU6IEFsbCBwcmltZXMgYXJlIG9mIHRoZSBmb3JtOlxuXG4gICAgICAgIDMwaytpLCBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEsIHdoZXJlIHRoZXJlIGFyZSA4IHZhbHVlcyBmb3IgaVxuXG4gICAgICAgIFdoZW4gd2UgZ2VuZXJhdGUgYSByYW5kb20gbnVtYmVyLCB3ZSBhbHdheXMgYWxpZ24gaXQgYXQgMzBrICsgMS4gRWFjaFxuICAgICAgICB0aW1lIHRoZSBudW1iZXIgaXMgZGV0ZXJtaW5lZCBub3QgdG8gYmUgcHJpbWUgd2UgYWRkIHRvIGdldCB0byB0aGVcbiAgICAgICAgbmV4dCAnaScsIGVnOiBpZiB0aGUgbnVtYmVyIHdhcyBhdCAzMGsgKyAxIHdlIGFkZCA2LiAqL1xuICAgICAgdmFyIGJpdHMgPSAoc3RhdGUucCA9PT0gbnVsbCkgPyBzdGF0ZS5wQml0cyA6IHN0YXRlLnFCaXRzO1xuICAgICAgdmFyIGJpdHMxID0gYml0cyAtIDE7XG5cbiAgICAgIC8vIGdldCBhIHJhbmRvbSBudW1iZXJcbiAgICAgIGlmKHN0YXRlLnBxU3RhdGUgPT09IDApIHtcbiAgICAgICAgc3RhdGUubnVtID0gbmV3IEJpZ0ludGVnZXIoYml0cywgc3RhdGUucm5nKTtcbiAgICAgICAgLy8gZm9yY2UgTVNCIHNldFxuICAgICAgICBpZighc3RhdGUubnVtLnRlc3RCaXQoYml0czEpKSB7XG4gICAgICAgICAgc3RhdGUubnVtLmJpdHdpc2VUbyhcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBzdGF0ZS5udW0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsaWduIG51bWJlciBvbiAzMGsrMSBib3VuZGFyeVxuICAgICAgICBzdGF0ZS5udW0uZEFkZE9mZnNldCgzMSAtIHN0YXRlLm51bS5tb2QoVEhJUlRZKS5ieXRlVmFsdWUoKSwgMCk7XG4gICAgICAgIGRlbHRhSWR4ID0gMDtcblxuICAgICAgICArK3N0YXRlLnBxU3RhdGU7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMSkge1xuICAgICAgICAvLyB0cnkgdG8gbWFrZSB0aGUgbnVtYmVyIGEgcHJpbWVcbiAgICAgICAgaWYoc3RhdGUubnVtLmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgICAgIC8vIG92ZXJmbG93LCB0cnkgYWdhaW5cbiAgICAgICAgICBzdGF0ZS5wcVN0YXRlID0gMDtcbiAgICAgICAgICAvLyBkbyBwcmltYWxpdHkgdGVzdFxuICAgICAgICB9IGVsc2UgaWYoc3RhdGUubnVtLmlzUHJvYmFibGVQcmltZShcbiAgICAgICAgICBfZ2V0TWlsbGVyUmFiaW5UZXN0cyhzdGF0ZS5udW0uYml0TGVuZ3RoKCkpKSkge1xuICAgICAgICAgICsrc3RhdGUucHFTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQgbmV4dCBwb3RlbnRpYWwgcHJpbWVcbiAgICAgICAgICBzdGF0ZS5udW0uZEFkZE9mZnNldChHQ0RfMzBfREVMVEFbZGVsdGFJZHgrKyAlIDhdLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKHN0YXRlLnBxU3RhdGUgPT09IDIpIHtcbiAgICAgICAgLy8gZW5zdXJlIG51bWJlciBpcyBjb3ByaW1lIHdpdGggZVxuICAgICAgICBzdGF0ZS5wcVN0YXRlID1cbiAgICAgICAgICAoc3RhdGUubnVtLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2Qoc3RhdGUuZSlcbiAgICAgICAgICAgIC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09PSAwKSA/IDMgOiAwO1xuICAgICAgfSBlbHNlIGlmKHN0YXRlLnBxU3RhdGUgPT09IDMpIHtcbiAgICAgICAgLy8gc3RvcmUgcCBvciBxXG4gICAgICAgIHN0YXRlLnBxU3RhdGUgPSAwO1xuICAgICAgICBpZihzdGF0ZS5wID09PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUucCA9IHN0YXRlLm51bTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5xID0gc3RhdGUubnVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWR2YW5jZSBzdGF0ZSBpZiBib3RoIHAgYW5kIHEgYXJlIHJlYWR5XG4gICAgICAgIGlmKHN0YXRlLnAgIT09IG51bGwgJiYgc3RhdGUucSAhPT0gbnVsbCkge1xuICAgICAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubnVtID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDEpIHtcbiAgICAgIC8vIGVuc3VyZSBwIGlzIGxhcmdlciB0aGFuIHEgKHN3YXAgdGhlbSBpZiBub3QpXG4gICAgICBpZihzdGF0ZS5wLmNvbXBhcmVUbyhzdGF0ZS5xKSA8IDApIHtcbiAgICAgICAgc3RhdGUubnVtID0gc3RhdGUucDtcbiAgICAgICAgc3RhdGUucCA9IHN0YXRlLnE7XG4gICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICB9XG4gICAgICArK3N0YXRlLnN0YXRlO1xuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMikge1xuICAgICAgLy8gY29tcHV0ZSBwaGk6IChwIC0gMSkocSAtIDEpIChFdWxlcidzIHRvdGllbnQgZnVuY3Rpb24pXG4gICAgICBzdGF0ZS5wMSA9IHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgc3RhdGUucTEgPSBzdGF0ZS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgIHN0YXRlLnBoaSA9IHN0YXRlLnAxLm11bHRpcGx5KHN0YXRlLnExKTtcbiAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAzKSB7XG4gICAgICAvLyBlbnN1cmUgZSBhbmQgcGhpIGFyZSBjb3ByaW1lXG4gICAgICBpZihzdGF0ZS5waGkuZ2NkKHN0YXRlLmUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDApIHtcbiAgICAgICAgLy8gcGhpIGFuZCBlIGFyZSBjb3ByaW1lLCBhZHZhbmNlXG4gICAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwaGkgYW5kIGUgYXJlbid0IGNvcHJpbWUsIHNvIGdlbmVyYXRlIGEgbmV3IHAgYW5kIHFcbiAgICAgICAgc3RhdGUucCA9IG51bGw7XG4gICAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgICBzdGF0ZS5zdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSA0KSB7XG4gICAgICAvLyBjcmVhdGUgbiwgZW5zdXJlIG4gaXMgaGFzIHRoZSByaWdodCBudW1iZXIgb2YgYml0c1xuICAgICAgc3RhdGUubiA9IHN0YXRlLnAubXVsdGlwbHkoc3RhdGUucSk7XG5cbiAgICAgIC8vIGVuc3VyZSBuIGlzIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgICBpZihzdGF0ZS5uLmJpdExlbmd0aCgpID09PSBzdGF0ZS5iaXRzKSB7XG4gICAgICAgIC8vIHN1Y2Nlc3MsIGFkdmFuY2VcbiAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhaWxlZCwgZ2V0IG5ldyBxXG4gICAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgICBzdGF0ZS5zdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSA1KSB7XG4gICAgICAvLyBzZXQga2V5c1xuICAgICAgdmFyIGQgPSBzdGF0ZS5lLm1vZEludmVyc2Uoc3RhdGUucGhpKTtcbiAgICAgIHN0YXRlLmtleXMgPSB7XG4gICAgICAgIHByaXZhdGVLZXk6IHBraS5yc2Euc2V0UHJpdmF0ZUtleShcbiAgICAgICAgICBzdGF0ZS5uLCBzdGF0ZS5lLCBkLCBzdGF0ZS5wLCBzdGF0ZS5xLFxuICAgICAgICAgIGQubW9kKHN0YXRlLnAxKSwgZC5tb2Qoc3RhdGUucTEpLFxuICAgICAgICAgIHN0YXRlLnEubW9kSW52ZXJzZShzdGF0ZS5wKSksXG4gICAgICAgIHB1YmxpY0tleTogcGtpLnJzYS5zZXRQdWJsaWNLZXkoc3RhdGUubiwgc3RhdGUuZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRpbWluZ1xuICAgIHQyID0gK25ldyBEYXRlKCk7XG4gICAgdG90YWwgKz0gdDIgLSB0MTtcbiAgICB0MSA9IHQyO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmtleXMgIT09IG51bGw7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBSU0EgcHVibGljLXByaXZhdGUga2V5IHBhaXIgaW4gYSBzaW5nbGUgY2FsbC5cbiAqXG4gKiBUbyBnZW5lcmF0ZSBhIGtleS1wYWlyIGluIHN0ZXBzICh0byBhbGxvdyBmb3IgcHJvZ3Jlc3MgdXBkYXRlcyBhbmQgdG9cbiAqIHByZXZlbnQgYmxvY2tpbmcgb3Igd2FybmluZ3MgaW4gc2xvdyBicm93c2VycykgdGhlbiB1c2UgdGhlIGtleS1wYWlyXG4gKiBnZW5lcmF0aW9uIHN0YXRlIGZ1bmN0aW9ucy5cbiAqXG4gKiBUbyBnZW5lcmF0ZSBhIGtleS1wYWlyIGFzeW5jaHJvbm91c2x5IChlaXRoZXIgdGhyb3VnaCB3ZWItd29ya2VycywgaWZcbiAqIGF2YWlsYWJsZSwgb3IgYnkgYnJlYWtpbmcgdXAgdGhlIHdvcmsgb24gdGhlIG1haW4gdGhyZWFkKSwgcGFzcyBhXG4gKiBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gW2JpdHNdIHRoZSBzaXplIGZvciB0aGUgcHJpdmF0ZSBrZXkgaW4gYml0cywgZGVmYXVsdHMgdG8gMjA0OC5cbiAqIEBwYXJhbSBbZV0gdGhlIHB1YmxpYyBleHBvbmVudCB0byB1c2UsIGRlZmF1bHRzIHRvIDY1NTM3LlxuICogQHBhcmFtIFtvcHRpb25zXSBvcHRpb25zIGZvciBrZXktcGFpciBnZW5lcmF0aW9uLCBpZiBnaXZlbiB0aGVuICdiaXRzJ1xuICogICAgICAgICAgICBhbmQgJ2UnIG11c3QgKm5vdCogYmUgZ2l2ZW46XG4gKiAgICAgICAgICBiaXRzIHRoZSBzaXplIGZvciB0aGUgcHJpdmF0ZSBrZXkgaW4gYml0cywgKGRlZmF1bHQ6IDIwNDgpLlxuICogICAgICAgICAgZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgKGRlZmF1bHQ6IDY1NTM3ICgweDEwMDAxKSkuXG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIpLlxuICogICAgICAgICAgd29ya0xvYWQgdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgICAgICBudW1iZXJzIGZvciBlYWNoIHdlYiB3b3JrZXIgdG8gY2hlY2sgcGVyIHdvcmsgYXNzaWdubWVudCxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLiBEaXNhYmxlcyB1c2Ugb2YgbmF0aXZlIEFQSXMuXG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UgKGRlZmF1bHQ6ICdQUklNRUlOQycpLlxuICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGtleXBhaXIpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqXG4gKiBAcmV0dXJuIGFuIG9iamVjdCB3aXRoIHByaXZhdGVLZXkgYW5kIHB1YmxpY0tleSBwcm9wZXJ0aWVzLlxuICovXG5wa2kucnNhLmdlbmVyYXRlS2V5UGFpciA9IGZ1bmN0aW9uKGJpdHMsIGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIChiaXRzKSwgKG9wdGlvbnMpLCAoY2FsbGJhY2spXG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZih0eXBlb2YgYml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBiaXRzO1xuICAgICAgYml0cyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYodHlwZW9mIGJpdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYml0cztcbiAgICAgIGJpdHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIChiaXRzLCBlKSwgKGJpdHMsIG9wdGlvbnMpLCAoYml0cywgY2FsbGJhY2spLCAob3B0aW9ucywgY2FsbGJhY2spXG4gICAgaWYodHlwZW9mIGJpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBpZih0eXBlb2YgZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGU7XG4gICAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYodHlwZW9mIGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIG9wdGlvbnMgPSBlO1xuICAgICAgICBlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gYml0cztcbiAgICAgIGNhbGxiYWNrID0gZTtcbiAgICAgIGJpdHMgPSB1bmRlZmluZWQ7XG4gICAgICBlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAvLyAoYml0cywgZSwgb3B0aW9ucyksIChiaXRzLCBlLCBjYWxsYmFjayksIChiaXRzLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICBpZih0eXBlb2YgZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IGU7XG4gICAgICBlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoYml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYml0cyA9IG9wdGlvbnMuYml0cyB8fCAyMDQ4O1xuICB9XG4gIGlmKGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGUgPSBvcHRpb25zLmUgfHwgMHgxMDAwMTtcbiAgfVxuXG4gIC8vIHVzZSBuYXRpdmUgY29kZSBpZiBwZXJtaXR0ZWQsIGF2YWlsYWJsZSwgYW5kIHBhcmFtZXRlcnMgYXJlIGFjY2VwdGFibGVcbiAgaWYoIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgJiYgIW9wdGlvbnMucHJuZyAmJlxuICAgIGJpdHMgPj0gMjU2ICYmIGJpdHMgPD0gMTYzODQgJiYgKGUgPT09IDB4MTAwMDEgfHwgZSA9PT0gMykpIHtcbiAgICBpZihjYWxsYmFjaykge1xuICAgICAgLy8gdHJ5IG5hdGl2ZSBhc3luY1xuICAgICAgaWYoX2RldGVjdE5vZGVDcnlwdG8oJ2dlbmVyYXRlS2V5UGFpcicpKSB7XG4gICAgICAgIHJldHVybiBfY3J5cHRvLmdlbmVyYXRlS2V5UGFpcigncnNhJywge1xuICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgICAgcHVibGljRXhwb25lbnQ6IGUsXG4gICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGtpJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ3BlbSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgdHlwZTogJ3BrY3M4JyxcbiAgICAgICAgICAgIGZvcm1hdDogJ3BlbSdcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgcHViLCBwcml2KSB7XG4gICAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogcGtpLnByaXZhdGVLZXlGcm9tUGVtKHByaXYpLFxuICAgICAgICAgICAgcHVibGljS2V5OiBwa2kucHVibGljS2V5RnJvbVBlbShwdWIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYoX2RldGVjdFN1YnRsZUNyeXB0bygnZ2VuZXJhdGVLZXknKSAmJlxuICAgICAgICBfZGV0ZWN0U3VidGxlQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgICAvLyB1c2Ugc3RhbmRhcmQgbmF0aXZlIGdlbmVyYXRlS2V5XG4gICAgICAgIHJldHVybiB1dGlsLmdsb2JhbFNjb3BlLmNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgICBwdWJsaWNFeHBvbmVudDogX2ludFRvVWludDhBcnJheShlKSxcbiAgICAgICAgICBoYXNoOiB7bmFtZTogJ1NIQS0yNTYnfVxuICAgICAgICB9LCB0cnVlIC8qIGtleSBjYW4gYmUgZXhwb3J0ZWQqLywgWydzaWduJywgJ3ZlcmlmeSddKVxuICAgICAgICAudGhlbihmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXG4gICAgICAgICAgICAncGtjczgnLCBwYWlyLnByaXZhdGVLZXkpO1xuICAgICAgICAvLyBhdm9pZGluZyBjYXRjaChmdW5jdGlvbihlcnIpIHsuLi59KSB0byBzdXBwb3J0IElFIDw9IDhcbiAgICAgICAgfSkudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocGtjczgpIHtcbiAgICAgICAgICBpZihwa2NzOCkge1xuICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKFxuICAgICAgICAgICAgICBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGtjczgpKSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZihfZGV0ZWN0U3VidGxlTXNDcnlwdG8oJ2dlbmVyYXRlS2V5JykgJiZcbiAgICAgICAgX2RldGVjdFN1YnRsZU1zQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgICB2YXIgZ2VuT3AgPSB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBfaW50VG9VaW50OEFycmF5KGUpLFxuICAgICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9XG4gICAgICAgIH0sIHRydWUgLyoga2V5IGNhbiBiZSBleHBvcnRlZCovLCBbJ3NpZ24nLCAndmVyaWZ5J10pO1xuICAgICAgICBnZW5PcC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciBwYWlyID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIHZhciBleHBvcnRPcCA9IHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlLmV4cG9ydEtleShcbiAgICAgICAgICAgICdwa2NzOCcsIHBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAgICAgZXhwb3J0T3Aub25jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBwa2NzOCA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIHZhciBwcml2YXRlS2V5ID0gcGtpLnByaXZhdGVLZXlGcm9tQXNuMShcbiAgICAgICAgICAgICAgYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHBrY3M4KSkpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5zZXRSc2FQdWJsaWNLZXkocHJpdmF0ZUtleS5uLCBwcml2YXRlS2V5LmUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGV4cG9ydE9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2VuT3Aub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdHJ5IG5hdGl2ZSBzeW5jXG4gICAgICBpZihfZGV0ZWN0Tm9kZUNyeXB0bygnZ2VuZXJhdGVLZXlQYWlyU3luYycpKSB7XG4gICAgICAgIHZhciBrZXlwYWlyID0gX2NyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKCdyc2EnLCB7XG4gICAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgICBwdWJsaWNFeHBvbmVudDogZSxcbiAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgdHlwZTogJ3Nwa2knLFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJpdmF0ZUtleUVuY29kaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAncGtjczgnLFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJpdmF0ZUtleTogcGtpLnByaXZhdGVLZXlGcm9tUGVtKGtleXBhaXIucHJpdmF0ZUtleSksXG4gICAgICAgICAgcHVibGljS2V5OiBwa2kucHVibGljS2V5RnJvbVBlbShrZXlwYWlyLnB1YmxpY0tleSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB1c2UgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvblxuICB2YXIgc3RhdGUgPSBwa2kucnNhLmNyZWF0ZUtleVBhaXJHZW5lcmF0aW9uU3RhdGUoYml0cywgZSwgb3B0aW9ucyk7XG4gIGlmKCFjYWxsYmFjaykge1xuICAgIHBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUoc3RhdGUsIDApO1xuICAgIHJldHVybiBzdGF0ZS5rZXlzO1xuICB9XG4gIF9nZW5lcmF0ZUtleVBhaXIoc3RhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBSU0EgcHVibGljIGtleSBmcm9tIEJpZ0ludGVnZXJzIG1vZHVsdXMgYW5kIGV4cG9uZW50LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBtb2R1bHVzLlxuICogQHBhcmFtIGUgdGhlIGV4cG9uZW50LlxuICpcbiAqIEByZXR1cm4gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5zZXRSc2FQdWJsaWNLZXkgPSBwa2kucnNhLnNldFB1YmxpY0tleSA9IGZ1bmN0aW9uKG4sIGUpIHtcbiAgdmFyIGtleSA9IHtcbiAgICBuOiBuLFxuICAgIGU6IGVcbiAgfTtcblxuICAvKipcbiAgICogRW5jcnlwdHMgdGhlIGdpdmVuIGRhdGEgd2l0aCB0aGlzIHB1YmxpYyBrZXkuIE5ld2VyIGFwcGxpY2F0aW9uc1xuICAgKiBzaG91bGQgdXNlIHRoZSAnUlNBLU9BRVAnIGRlY3J5cHRpb24gc2NoZW1lLCAnUlNBRVMtUEtDUzEtVjFfNScgaXMgZm9yXG4gICAqIGxlZ2FjeSBhcHBsaWNhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBieXRlIHN0cmluZyB0byBlbmNyeXB0LlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBlbmNyeXB0aW9uIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FFUy1QS0NTMS1WMV81JyAoZGVmYXVsdCksXG4gICAqICAgICAgICAgICdSU0EtT0FFUCcsXG4gICAqICAgICAgICAgICdSQVcnLCAnTk9ORScsIG9yIG51bGwgdG8gcGVyZm9ybSByYXcgUlNBIGVuY3J5cHRpb24sXG4gICAqICAgICAgICAgIGFuIG9iamVjdCB3aXRoIGFuICdlbmNvZGUnIHByb3BlcnR5IHNldCB0byBhIGZ1bmN0aW9uXG4gICAqICAgICAgICAgIHdpdGggdGhlIHNpZ25hdHVyZSAnZnVuY3Rpb24oZGF0YSwga2V5KScgdGhhdCByZXR1cm5zXG4gICAqICAgICAgICAgIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCBkYXRhLlxuICAgKiBAcGFyYW0gc2NoZW1lT3B0aW9ucyBhbnkgc2NoZW1lLXNwZWNpZmljIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGVuY3J5cHRlZCBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5lbmNyeXB0ID0gZnVuY3Rpb24oZGF0YSwgc2NoZW1lLCBzY2hlbWVPcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NoZW1lID0gJ1JTQUVTLVBLQ1MxLVYxXzUnO1xuICAgIH1cblxuICAgIGlmKHNjaGVtZSA9PT0gJ1JTQUVTLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24obSwga2V5LCBwdWIpIHtcbiAgICAgICAgICByZXR1cm4gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCAweDAyKS5nZXRCeXRlcygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdSU0EtT0FFUCcgfHwgc2NoZW1lID09PSAnUlNBRVMtT0FFUCcpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbihtLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtjczEuZW5jb2RlX3JzYV9vYWVwKGtleSwgbSwgc2NoZW1lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKFsnUkFXJywgJ05PTkUnLCAnTlVMTCcsIG51bGxdLmluZGV4T2Yoc2NoZW1lKSAhPT0gLTEpIHtcbiAgICAgIHNjaGVtZSA9IHtlbmNvZGU6IGZ1bmN0aW9uKGUpIHtyZXR1cm4gZTt9fTtcbiAgICB9IGVsc2UgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWU6IFwiJyArIHNjaGVtZSArICdcIi4nKTtcbiAgICB9XG5cbiAgICAvLyBkbyBzY2hlbWUtYmFzZWQgZW5jb2RpbmcgdGhlbiByc2EgZW5jcnlwdGlvblxuICAgIHZhciBlID0gc2NoZW1lLmVuY29kZShkYXRhLCBrZXksIHRydWUpO1xuICAgIHJldHVybiBwa2kucnNhLmVuY3J5cHQoZSwga2V5LCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIGdpdmVuIHNpZ25hdHVyZSBhZ2FpbnN0IHRoZSBnaXZlbiBkaWdlc3QuXG4gICAqXG4gICAqIFBLQ1MjMSBzdXBwb3J0cyBtdWx0aXBsZSAoY3VycmVudGx5IHR3bykgc2lnbmF0dXJlIHNjaGVtZXM6XG4gICAqIFJTQVNTQS1QS0NTMS1WMV81IGFuZCBSU0FTU0EtUFNTLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgXCJvbGQgc2NoZW1lXCIsIGkuZS5cbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUsIGluIHdoaWNoIGNhc2Ugb25jZSBSU0EtZGVjcnlwdGVkLCB0aGVcbiAgICogc2lnbmF0dXJlIGlzIGFuIE9DVEVUIFNUUklORyB0aGF0IGhvbGRzIGEgRGlnZXN0SW5mby5cbiAgICpcbiAgICogRGlnZXN0SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICAgKiAgIGRpZ2VzdEFsZ29yaXRobSBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyLFxuICAgKiAgIGRpZ2VzdCBEaWdlc3RcbiAgICogfVxuICAgKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAqIERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gICAqXG4gICAqIFRvIHBlcmZvcm0gUFNTIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24sIHByb3ZpZGUgYW4gaW5zdGFuY2VcbiAgICogb2YgRm9yZ2UgUFNTIG9iamVjdCBhcyB0aGUgc2NoZW1lIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIGRpZ2VzdCB0aGUgbWVzc2FnZSBkaWdlc3QgaGFzaCB0byBjb21wYXJlIGFnYWluc3QgdGhlIHNpZ25hdHVyZSxcbiAgICogICAgICAgICAgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byB2ZXJpZnksIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLlxuICAgKiBAcGFyYW0gc2NoZW1lIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQVNTQS1QS0NTMS1WMV81JyBvciB1bmRlZmluZWQgZm9yIFJTQVNTQSBQS0NTIzEgdjEuNSxcbiAgICogICAgICAgICAgYSBGb3JnZSBQU1Mgb2JqZWN0IGZvciBSU0FTU0EtUFNTLFxuICAgKiAgICAgICAgICAnTk9ORScgb3IgbnVsbCBmb3Igbm9uZSwgRGlnZXN0SW5mbyB3aWxsIG5vdCBiZSBleHBlY3RlZCwgYnV0XG4gICAqICAgICAgICAgICAgUEtDUyMxIHYxLjUgcGFkZGluZyB3aWxsIHN0aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbmFsIHZlcmlmeSBvcHRpb25zXG4gICAqICAgICAgICAgIF9wYXJzZUFsbERpZ2VzdEJ5dGVzIHRlc3RpbmcgZmxhZyB0byBjb250cm9sIHBhcnNpbmcgb2YgYWxsXG4gICAqICAgICAgICAgICAgZGlnZXN0IGJ5dGVzLiBVbnN1cHBvcnRlZCBhbmQgbm90IGZvciBnZW5lcmFsIHVzYWdlLlxuICAgKiAgICAgICAgICAgIChkZWZhdWx0OiB0cnVlKVxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHNpZ25hdHVyZSB3YXMgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGtleS52ZXJpZnkgPSBmdW5jdGlvbihkaWdlc3QsIHNpZ25hdHVyZSwgc2NoZW1lLCBvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NoZW1lID0gJ1JTQVNTQS1QS0NTMS1WMV81JztcbiAgICB9XG4gICAgaWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBfcGFyc2VBbGxEaWdlc3RCeXRlczogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYoISgnX3BhcnNlQWxsRGlnZXN0Qnl0ZXMnIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLl9wYXJzZUFsbERpZ2VzdEJ5dGVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FTU0EtUEtDUzEtVjFfNScpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbihkaWdlc3QsIGQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgcGFkZGluZ1xuICAgICAgICAgIGQgPSBfZGVjb2RlUGtjczFfdjFfNShkLCBrZXksIHRydWUpO1xuICAgICAgICAgIC8vIGQgaXMgQVNOLjEgQkVSLWVuY29kZWQgRGlnZXN0SW5mb1xuICAgICAgICAgIHZhciBvYmogPSBhc24xLmZyb21EZXIoZCwge1xuICAgICAgICAgICAgcGFyc2VBbGxCeXRlczogb3B0aW9ucy5fcGFyc2VBbGxEaWdlc3RCeXRlc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gdmFsaWRhdGUgRGlnZXN0SW5mb1xuICAgICAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgZGlnZXN0SW5mb1ZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnQVNOLjEgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCBSU0FTU0EtUEtDUzEtdjFfNSAnICtcbiAgICAgICAgICAgICAgJ0RpZ2VzdEluZm8gdmFsdWUuJyk7XG4gICAgICAgICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgaGFzaCBhbGdvcml0aG0gaWRlbnRpZmllclxuICAgICAgICAgIC8vIHNlZSBQS0NTMS12MS01RGlnZXN0QWxnb3JpdGhtcyBpbiBSRkMgODAxN1xuICAgICAgICAgIC8vIEZJWE1FOiBhZGQgc3VwcG9ydCB0byB2YWlkYXRvciBmb3Igc3RyaWN0IHZhbHVlIGNob2ljZXNcbiAgICAgICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmFsZ29yaXRobUlkZW50aWZpZXIpO1xuICAgICAgICAgIGlmKCEob2lkID09PSBmb3JnZS5vaWRzLm1kMiB8fFxuICAgICAgICAgICAgb2lkID09PSBmb3JnZS5vaWRzLm1kNSB8fFxuICAgICAgICAgICAgb2lkID09PSBmb3JnZS5vaWRzLnNoYTEgfHxcbiAgICAgICAgICAgIG9pZCA9PT0gZm9yZ2Uub2lkcy5zaGEyMjQgfHxcbiAgICAgICAgICAgIG9pZCA9PT0gZm9yZ2Uub2lkcy5zaGEyNTYgfHxcbiAgICAgICAgICAgIG9pZCA9PT0gZm9yZ2Uub2lkcy5zaGEzODQgfHxcbiAgICAgICAgICAgIG9pZCA9PT0gZm9yZ2Uub2lkcy5zaGE1MTIgfHxcbiAgICAgICAgICAgIG9pZCA9PT0gZm9yZ2Uub2lkc1snc2hhNTEyLTIyNCddIHx8XG4gICAgICAgICAgICBvaWQgPT09IGZvcmdlLm9pZHNbJ3NoYTUxMi0yNTYnXSkpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1Vua25vd24gUlNBU1NBLVBLQ1MxLXYxXzUgRGlnZXN0QWxnb3JpdGhtIGlkZW50aWZpZXIuJyk7XG4gICAgICAgICAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzcGVjaWFsIGNoZWNrIGZvciBtZDIgYW5kIG1kNSB0aGF0IE5VTEwgcGFyYW1ldGVycyBleGlzdFxuICAgICAgICAgIGlmKG9pZCA9PT0gZm9yZ2Uub2lkcy5tZDIgfHwgb2lkID09PSBmb3JnZS5vaWRzLm1kNSkge1xuICAgICAgICAgICAgaWYoISgncGFyYW1ldGVycycgaW4gY2FwdHVyZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIFJTQVNTQS1QS0NTMS12MV81ICcgK1xuICAgICAgICAgICAgICAgICdEaWdlc3RJbmZvIHZhbHVlLiAnICtcbiAgICAgICAgICAgICAgICAnTWlzc2luZyBhbGdvcml0aG0gaWRlbnRpZmVyIE5VTEwgcGFyYW1ldGVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjb21wYXJlIHRoZSBnaXZlbiBkaWdlc3QgdG8gdGhlIGRlY3J5cHRlZCBvbmVcbiAgICAgICAgICByZXR1cm4gZGlnZXN0ID09PSBjYXB0dXJlLmRpZ2VzdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnTk9ORScgfHwgc2NoZW1lID09PSAnTlVMTCcgfHwgc2NoZW1lID09PSBudWxsKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICBkID0gX2RlY29kZVBrY3MxX3YxXzUoZCwga2V5LCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gZGlnZXN0ID09PSBkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmcsIHRoZW4gdmVyaWZ5IC0tIHdoaWNoIGRvZXMgZGVjb2RpbmdcbiAgICB2YXIgZCA9IHBraS5yc2EuZGVjcnlwdChzaWduYXR1cmUsIGtleSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHJldHVybiBzY2hlbWUudmVyaWZ5KGRpZ2VzdCwgZCwga2V5Lm4uYml0TGVuZ3RoKCkpO1xuICB9O1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gUlNBIHByaXZhdGUga2V5IGZyb20gQmlnSW50ZWdlcnMgbW9kdWx1cywgZXhwb25lbnQsIHByaW1lcyxcbiAqIHByaW1lIGV4cG9uZW50cywgYW5kIG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbW9kdWx1cy5cbiAqIEBwYXJhbSBlIHRoZSBwdWJsaWMgZXhwb25lbnQuXG4gKiBAcGFyYW0gZCB0aGUgcHJpdmF0ZSBleHBvbmVudCAoKGludmVyc2Ugb2YgZSkgbW9kIG4pLlxuICogQHBhcmFtIHAgdGhlIGZpcnN0IHByaW1lLlxuICogQHBhcmFtIHEgdGhlIHNlY29uZCBwcmltZS5cbiAqIEBwYXJhbSBkUCBleHBvbmVudDEgKGQgbW9kIChwLTEpKS5cbiAqIEBwYXJhbSBkUSBleHBvbmVudDIgKGQgbW9kIChxLTEpKS5cbiAqIEBwYXJhbSBxSW52ICgoaW52ZXJzZSBvZiBxKSBtb2QgcClcbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnNldFJzYVByaXZhdGVLZXkgPSBwa2kucnNhLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbihcbiAgbiwgZSwgZCwgcCwgcSwgZFAsIGRRLCBxSW52KSB7XG4gIHZhciBrZXkgPSB7XG4gICAgbjogbixcbiAgICBlOiBlLFxuICAgIGQ6IGQsXG4gICAgcDogcCxcbiAgICBxOiBxLFxuICAgIGRQOiBkUCxcbiAgICBkUTogZFEsXG4gICAgcUludjogcUludlxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNyeXB0cyB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoaXMgcHJpdmF0ZSBrZXkuIFRoZSBkZWNyeXB0aW9uIHNjaGVtZVxuICAgKiBtdXN0IG1hdGNoIHRoZSBvbmUgdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYnl0ZSBzdHJpbmcgdG8gZGVjcnlwdC5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgZGVjcnlwdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBRVMtUEtDUzEtVjFfNScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAnUlNBLU9BRVAnLFxuICAgKiAgICAgICAgICAnUkFXJywgJ05PTkUnLCBvciBudWxsIHRvIHBlcmZvcm0gcmF3IFJTQSBkZWNyeXB0aW9uLlxuICAgKiBAcGFyYW0gc2NoZW1lT3B0aW9ucyBhbnkgc2NoZW1lLXNwZWNpZmljIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGRlY3J5cHRlZCBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5kZWNyeXB0ID0gZnVuY3Rpb24oZGF0YSwgc2NoZW1lLCBzY2hlbWVPcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NoZW1lID0gJ1JTQUVTLVBLQ1MxLVYxXzUnO1xuICAgIH1cblxuICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmdcbiAgICB2YXIgZCA9IHBraS5yc2EuZGVjcnlwdChkYXRhLCBrZXksIGZhbHNlLCBmYWxzZSk7XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FFUy1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge2RlY29kZTogX2RlY29kZVBrY3MxX3YxXzV9O1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdSU0EtT0FFUCcgfHwgc2NoZW1lID09PSAnUlNBRVMtT0FFUCcpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbihkLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtjczEuZGVjb2RlX3JzYV9vYWVwKGtleSwgZCwgc2NoZW1lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKFsnUkFXJywgJ05PTkUnLCAnTlVMTCcsIG51bGxdLmluZGV4T2Yoc2NoZW1lKSAhPT0gLTEpIHtcbiAgICAgIHNjaGVtZSA9IHtkZWNvZGU6IGZ1bmN0aW9uKGQpIHtyZXR1cm4gZDt9fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRlY29kZSBhY2NvcmRpbmcgdG8gc2NoZW1lXG4gICAgcmV0dXJuIHNjaGVtZS5kZWNvZGUoZCwga2V5LCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBnaXZlbiBkaWdlc3QsIHByb2R1Y2luZyBhIHNpZ25hdHVyZS5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNS4gSW4gb3JkZXIgdG8gZ2VuZXJhdGUgYSBQU1Mgc2lnbmF0dXJlLCBwcm92aWRlXG4gICAqIGFuIGluc3RhbmNlIG9mIEZvcmdlIFBTUyBvYmplY3QgYXMgdGhlIHNjaGVtZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgc2lnbmF0dXJlIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FTU0EtUEtDUzEtVjFfNScgb3IgdW5kZWZpbmVkIGZvciBSU0FTU0EgUEtDUyMxIHYxLjUsXG4gICAqICAgICAgICAgIGEgRm9yZ2UgUFNTIG9iamVjdCBmb3IgUlNBU1NBLVBTUyxcbiAgICogICAgICAgICAgJ05PTkUnIG9yIG51bGwgZm9yIG5vbmUsIERpZ2VzdEluZm8gd2lsbCBub3QgYmUgdXNlZCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgc2lnbmF0dXJlIGFzIGEgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuc2lnbiA9IGZ1bmN0aW9uKG1kLCBzY2hlbWUpIHtcbiAgICAvKiBOb3RlOiBUaGUgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgUlNBIG9wZXJhdGlvbnMgaXMgYmVpbmdcbiAgICAgIHRyYW5zaXRpb25lZCBhd2F5IGZyb20gYSBQS0NTIzEgdjEuNSBoYXJkLWNvZGVkIHNjaGVtZS4gU29tZSBsZWdhY3lcbiAgICAgIGNvZGUgbGlrZSB0aGUgdXNlIG9mIGFuIGVuY29kaW5nIGJsb2NrIGlkZW50aWZpZXIgJ2J0JyB3aWxsIGV2ZW50dWFsbHlcbiAgICAgIGJlIHJlbW92ZWQuICovXG5cbiAgICAvLyBwcml2YXRlIGtleSBvcGVyYXRpb25cbiAgICB2YXIgYnQgPSBmYWxzZTtcblxuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09IHVuZGVmaW5lZCB8fCBzY2hlbWUgPT09ICdSU0FTU0EtUEtDUzEtVjFfNScpIHtcbiAgICAgIHNjaGVtZSA9IHtlbmNvZGU6IGVtc2FQa2NzMXYxNWVuY29kZX07XG4gICAgICBidCA9IDB4MDE7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gJ05PTkUnIHx8IHNjaGVtZSA9PT0gJ05VTEwnIHx8IHNjaGVtZSA9PT0gbnVsbCkge1xuICAgICAgc2NoZW1lID0ge2VuY29kZTogZnVuY3Rpb24oKSB7cmV0dXJuIG1kO319O1xuICAgICAgYnQgPSAweDAxO1xuICAgIH1cblxuICAgIC8vIGVuY29kZSBhbmQgdGhlbiBlbmNyeXB0XG4gICAgdmFyIGQgPSBzY2hlbWUuZW5jb2RlKG1kLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChkLCBrZXksIGJ0KTtcbiAgfTtcblxuICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBXcmFwcyBhbiBSU0FQcml2YXRlS2V5IEFTTi4xIG9iamVjdCBpbiBhbiBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJzYUtleSB0aGUgQVNOLjEgUlNBUHJpdmF0ZUtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLndyYXBSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5KSB7XG4gIC8vIFByaXZhdGVLZXlJbmZvXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gcHJpdmF0ZUtleUFsZ29yaXRobVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICBdKSxcbiAgICAvLyBQcml2YXRlS2V5XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICBhc24xLnRvRGVyKHJzYUtleSkuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJpdmF0ZSBrZXkgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYSBQcml2YXRlS2V5SW5mbyBjb250YWluaW5nIGFuXG4gKiAgICAgICAgICBSU0FQcml2YXRlS2V5IG9yIGFuIFJTQVByaXZhdGVLZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gZ2V0IFByaXZhdGVLZXlJbmZvXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoYXNuMS52YWxpZGF0ZShvYmosIHByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICBvYmogPSBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5KSk7XG4gIH1cblxuICAvLyBnZXQgUlNBUHJpdmF0ZUtleVxuICBjYXB0dXJlID0ge307XG4gIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHJzYVByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQcml2YXRlS2V5LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIE5vdGU6IFZlcnNpb24gaXMgY3VycmVudGx5IGlnbm9yZWQuXG4gIC8vIGNhcHR1cmUucHJpdmF0ZUtleVZlcnNpb25cbiAgLy8gRklYTUU6IGluZWZmaWNpZW50LCBnZXQgYSBCaWdJbnRlZ2VyIHRoYXQgdXNlcyBieXRlIHN0cmluZ3NcbiAgdmFyIG4sIGUsIGQsIHAsIHEsIGRQLCBkUSwgcUludjtcbiAgbiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleU1vZHVsdXMpLnRvSGV4KCk7XG4gIGUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQdWJsaWNFeHBvbmVudCkudG9IZXgoKTtcbiAgZCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCkudG9IZXgoKTtcbiAgcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaW1lMSkudG9IZXgoKTtcbiAgcSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaW1lMikudG9IZXgoKTtcbiAgZFAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlFeHBvbmVudDEpLnRvSGV4KCk7XG4gIGRRID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQyKS50b0hleCgpO1xuICBxSW52ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5Q29lZmZpY2llbnQpLnRvSGV4KCk7XG5cbiAgLy8gc2V0IHByaXZhdGUga2V5XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZSwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGQsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihwLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocSwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGRQLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZFEsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihxSW52LCAxNikpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IHRvIGFuIEFTTi4xIFJTQVByaXZhdGVLZXkuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYW4gUlNBUHJpdmF0ZUtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlUb0FzbjEgPSBwa2kucHJpdmF0ZUtleVRvUlNBUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBSU0FQcml2YXRlS2V5XG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMCA9IG9ubHkgMiBwcmltZXMsIDEgbXVsdGlwbGUgcHJpbWVzKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcigwKS5nZXRCeXRlcygpKSxcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5uKSksXG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmUpKSxcbiAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmQpKSxcbiAgICAvLyBwcml2YXRlS2V5UHJpbWUxIChwKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5wKSksXG4gICAgLy8gcHJpdmF0ZUtleVByaW1lMiAocSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucSkpLFxuICAgIC8vIHByaXZhdGVLZXlFeHBvbmVudDEgKGRQKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kUCkpLFxuICAgIC8vIHByaXZhdGVLZXlFeHBvbmVudDIgKGRRKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kUSkpLFxuICAgIC8vIGNvZWZmaWNpZW50IChxSW52KVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5xSW52KSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSBmcm9tIGFuIEFTTi4xIFN1YmplY3RQdWJsaWNLZXlJbmZvIG9yIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgU3ViamVjdFB1YmxpY0tleUluZm8gb3IgUlNBUHVibGljS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBnZXQgU3ViamVjdFB1YmxpY0tleUluZm9cbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZihhc24xLnZhbGlkYXRlKG9iaiwgcHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgLy8gZ2V0IG9pZFxuICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUucHVibGljS2V5T2lkKTtcbiAgICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgcHVibGljIGtleS4gVW5rbm93biBPSUQuJyk7XG4gICAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgb2JqID0gY2FwdHVyZS5yc2FQdWJsaWNLZXk7XG4gIH1cblxuICAvLyBnZXQgUlNBIHBhcmFtc1xuICBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQdWJsaWNLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGFuIFJTQVB1YmxpY0tleS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBGSVhNRTogaW5lZmZpY2llbnQsIGdldCBhIEJpZ0ludGVnZXIgdGhhdCB1c2VzIGJ5dGUgc3RyaW5nc1xuICB2YXIgbiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHVibGljS2V5TW9kdWx1cykudG9IZXgoKTtcbiAgdmFyIGUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnB1YmxpY0tleUV4cG9uZW50KS50b0hleCgpO1xuXG4gIC8vIHNldCBwdWJsaWMga2V5XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIG5ldyBCaWdJbnRlZ2VyKG4sIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihlLCAxNikpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gYW4gQVNOLjEgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHVibGljIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gKi9cbnBraS5wdWJsaWNLZXlUb0FzbjEgPSBwa2kucHVibGljS2V5VG9TdWJqZWN0UHVibGljS2V5SW5mbyA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBhbGdvcml0aG1cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxcbiAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICBdKSxcbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCBbXG4gICAgICBwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KVxuICAgIF0pXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gYW4gQVNOLjEgUlNBUHVibGljS2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFJTQVB1YmxpY0tleS5cbiAqL1xucGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIFJTQVB1YmxpY0tleVxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5Lm4pKSxcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZSkpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSB1c2luZyBQS0NTIzEgdjEuNSBwYWRkaW5nLlxuICpcbiAqIEBwYXJhbSBtIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGJ0IHRoZSBibG9jayB0eXBlIHRvIHVzZSwgaS5lLiBlaXRoZXIgMHgwMSAoZm9yIHNpZ25pbmcpIG9yIDB4MDJcbiAqICAgICAgICAgIChmb3IgZW5jcnlwdGlvbikuXG4gKlxuICogQHJldHVybiB0aGUgcGFkZGVkIGJ5dGUgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfZW5jb2RlUGtjczFfdjFfNShtLCBrZXksIGJ0KSB7XG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIG1vZHVsdXMgaW4gYnl0ZXNcbiAgdmFyIGsgPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcblxuICAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyAqL1xuICBpZihtLmxlbmd0aCA+IChrIC0gMTEpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdNZXNzYWdlIGlzIHRvbyBsb25nIGZvciBQS0NTIzEgdjEuNSBwYWRkaW5nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG0ubGVuZ3RoO1xuICAgIGVycm9yLm1heCA9IGsgLSAxMTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8qIEEgYmxvY2sgdHlwZSBCVCwgYSBwYWRkaW5nIHN0cmluZyBQUywgYW5kIHRoZSBkYXRhIEQgc2hhbGwgYmVcbiAgICBmb3JtYXR0ZWQgaW50byBhbiBvY3RldCBzdHJpbmcgRUIsIHRoZSBlbmNyeXB0aW9uIGJsb2NrOlxuXG4gICAgRUIgPSAwMCB8fCBCVCB8fCBQUyB8fCAwMCB8fCBEXG5cbiAgICBUaGUgYmxvY2sgdHlwZSBCVCBzaGFsbCBiZSBhIHNpbmdsZSBvY3RldCBpbmRpY2F0aW5nIHRoZSBzdHJ1Y3R1cmUgb2ZcbiAgICB0aGUgZW5jcnlwdGlvbiBibG9jay4gRm9yIHRoaXMgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQgaXQgc2hhbGwgaGF2ZVxuICAgIHZhbHVlIDAwLCAwMSwgb3IgMDIuIEZvciBhIHByaXZhdGUta2V5IG9wZXJhdGlvbiwgdGhlIGJsb2NrIHR5cGVcbiAgICBzaGFsbCBiZSAwMCBvciAwMS4gRm9yIGEgcHVibGljLWtleSBvcGVyYXRpb24sIGl0IHNoYWxsIGJlIDAyLlxuXG4gICAgVGhlIHBhZGRpbmcgc3RyaW5nIFBTIHNoYWxsIGNvbnNpc3Qgb2Ygay0zLXx8RHx8IG9jdGV0cy4gRm9yIGJsb2NrXG4gICAgdHlwZSAwMCwgdGhlIG9jdGV0cyBzaGFsbCBoYXZlIHZhbHVlIDAwOyBmb3IgYmxvY2sgdHlwZSAwMSwgdGhleVxuICAgIHNoYWxsIGhhdmUgdmFsdWUgRkY7IGFuZCBmb3IgYmxvY2sgdHlwZSAwMiwgdGhleSBzaGFsbCBiZVxuICAgIHBzZXVkb3JhbmRvbWx5IGdlbmVyYXRlZCBhbmQgbm9uemVyby4gVGhpcyBtYWtlcyB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIGVuY3J5cHRpb24gYmxvY2sgRUIgZXF1YWwgdG8gay4gKi9cblxuICAvLyBidWlsZCB0aGUgZW5jcnlwdGlvbiBibG9ja1xuICBlYi5wdXRCeXRlKDB4MDApO1xuICBlYi5wdXRCeXRlKGJ0KTtcblxuICAvLyBjcmVhdGUgdGhlIHBhZGRpbmdcbiAgdmFyIHBhZE51bSA9IGsgLSAzIC0gbS5sZW5ndGg7XG4gIHZhciBwYWRCeXRlO1xuICAvLyBwcml2YXRlIGtleSBvcFxuICBpZihidCA9PT0gMHgwMCB8fCBidCA9PT0gMHgwMSkge1xuICAgIHBhZEJ5dGUgPSAoYnQgPT09IDB4MDApID8gMHgwMCA6IDB4RkY7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICBlYi5wdXRCeXRlKHBhZEJ5dGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBwdWJsaWMga2V5IG9wXG4gICAgLy8gcGFkIHdpdGggcmFuZG9tIG5vbi16ZXJvIHZhbHVlc1xuICAgIHdoaWxlKHBhZE51bSA+IDApIHtcbiAgICAgIHZhciBudW1aZXJvcyA9IDA7XG4gICAgICB2YXIgcGFkQnl0ZXMgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMocGFkTnVtKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgICBwYWRCeXRlID0gcGFkQnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYocGFkQnl0ZSA9PT0gMCkge1xuICAgICAgICAgICsrbnVtWmVyb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWIucHV0Qnl0ZShwYWRCeXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFkTnVtID0gbnVtWmVyb3M7XG4gICAgfVxuICB9XG5cbiAgLy8gemVybyBmb2xsb3dlZCBieSBtZXNzYWdlXG4gIGViLnB1dEJ5dGUoMHgwMCk7XG4gIGViLnB1dEJ5dGVzKG0pO1xuXG4gIHJldHVybiBlYjtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSB1c2luZyBQS0NTIzEgdjEuNSBwYWRkaW5nLlxuICpcbiAqIEBwYXJhbSBlbSB0aGUgbWVzc2FnZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBwdWIgdHJ1ZSBpZiB0aGUga2V5IGlzIGEgcHVibGljIGtleSwgZmFsc2UgaWYgaXQgaXMgcHJpdmF0ZS5cbiAqIEBwYXJhbSBtbCB0aGUgbWVzc2FnZSBsZW5ndGgsIGlmIHNwZWNpZmllZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNvZGVkIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBfZGVjb2RlUGtjczFfdjFfNShlbSwga2V5LCBwdWIsIG1sKSB7XG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLyogSXQgaXMgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBvY2N1cnM6XG5cbiAgICAxLiBUaGUgZW5jcnlwdGlvbiBibG9jayBFQiBjYW5ub3QgYmUgcGFyc2VkIHVuYW1iaWd1b3VzbHkuXG4gICAgMi4gVGhlIHBhZGRpbmcgc3RyaW5nIFBTIGNvbnNpc3RzIG9mIGZld2VyIHRoYW4gZWlnaHQgb2N0ZXRzXG4gICAgICBvciBpcyBpbmNvbnNpc2VudCB3aXRoIHRoZSBibG9jayB0eXBlIEJULlxuICAgIDMuIFRoZSBkZWNyeXB0aW9uIHByb2Nlc3MgaXMgYSBwdWJsaWMta2V5IG9wZXJhdGlvbiBhbmQgdGhlIGJsb2NrXG4gICAgICB0eXBlIEJUIGlzIG5vdCAwMCBvciAwMSwgb3IgdGhlIGRlY3J5cHRpb24gcHJvY2VzcyBpcyBhXG4gICAgICBwcml2YXRlLWtleSBvcGVyYXRpb24gYW5kIHRoZSBibG9jayB0eXBlIGlzIG5vdCAwMi5cbiAgICovXG5cbiAgLy8gcGFyc2UgdGhlIGVuY3J5cHRpb24gYmxvY2tcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW0pO1xuICB2YXIgZmlyc3QgPSBlYi5nZXRCeXRlKCk7XG4gIHZhciBidCA9IGViLmdldEJ5dGUoKTtcbiAgaWYoZmlyc3QgIT09IDB4MDAgfHxcbiAgICAocHViICYmIGJ0ICE9PSAweDAwICYmIGJ0ICE9PSAweDAxKSB8fFxuICAgICghcHViICYmIGJ0ICE9IDB4MDIpIHx8XG4gICAgKHB1YiAmJiBidCA9PT0gMHgwMCAmJiB0eXBlb2YobWwpID09PSAndW5kZWZpbmVkJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIHZhciBwYWROdW0gPSAwO1xuICBpZihidCA9PT0gMHgwMCkge1xuICAgIC8vIGNoZWNrIGFsbCBwYWRkaW5nIGJ5dGVzIGZvciAweDAwXG4gICAgcGFkTnVtID0gayAtIDMgLSBtbDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSAhPT0gMHgwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihidCA9PT0gMHgwMSkge1xuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGJ5dGUgdGhhdCBpc24ndCAweEZGLCBzaG91bGQgYmUgYWZ0ZXIgYWxsIHBhZGRpbmdcbiAgICBwYWROdW0gPSAwO1xuICAgIHdoaWxlKGViLmxlbmd0aCgpID4gMSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpICE9PSAweEZGKSB7XG4gICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BhZE51bTtcbiAgICB9XG4gIH0gZWxzZSBpZihidCA9PT0gMHgwMikge1xuICAgIC8vIGxvb2sgZm9yIDB4MDAgYnl0ZVxuICAgIHBhZE51bSA9IDA7XG4gICAgd2hpbGUoZWIubGVuZ3RoKCkgPiAxKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgPT09IDB4MDApIHtcbiAgICAgICAgLS1lYi5yZWFkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICsrcGFkTnVtO1xuICAgIH1cbiAgfVxuXG4gIC8vIHplcm8gbXVzdCBiZSAweDAwIGFuZCBwYWROdW0gbXVzdCBiZSAoayAtIDMgLSBtZXNzYWdlIGxlbmd0aClcbiAgdmFyIHplcm8gPSBlYi5nZXRCeXRlKCk7XG4gIGlmKHplcm8gIT09IDB4MDAgfHwgcGFkTnVtICE9PSAoayAtIDMgLSBlYi5sZW5ndGgoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIHJldHVybiBlYi5nZXRCeXRlcygpO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGtleS1nZW5lcmF0aW9uIGFsZ29yaXRobSBhc3luY2hyb25vdXNseSwgZWl0aGVyIGluIHRoZSBiYWNrZ3JvdW5kXG4gKiB2aWEgV2ViIFdvcmtlcnMsIG9yIHVzaW5nIHRoZSBtYWluIHRocmVhZCBhbmQgc2V0SW1tZWRpYXRlLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSB0aGUga2V5LXBhaXIgZ2VuZXJhdGlvbiBzdGF0ZS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gb3B0aW9ucyBmb3Iga2V5LXBhaXIgZ2VuZXJhdGlvbjpcbiAqICAgICAgICAgIHdvcmtlclNjcmlwdCB0aGUgd29ya2VyIHNjcmlwdCBVUkwuXG4gKiAgICAgICAgICB3b3JrZXJzIHRoZSBudW1iZXIgb2Ygd2ViIHdvcmtlcnMgKGlmIHN1cHBvcnRlZCkgdG8gdXNlLFxuICogICAgICAgICAgICAoZGVmYXVsdDogMiwgLTEgdG8gdXNlIGVzdGltYXRlZCBjb3JlcyBtaW51cyBvbmUpLlxuICogICAgICAgICAgd29ya0xvYWQgdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgICAgICBudW1iZXJzIGZvciBlYWNoIHdlYiB3b3JrZXIgdG8gY2hlY2sgcGVyIHdvcmsgYXNzaWdubWVudCxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiBAcGFyYW0gY2FsbGJhY2soZXJyLCBrZXlwYWlyKSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqL1xuZnVuY3Rpb24gX2dlbmVyYXRlS2V5UGFpcihzdGF0ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBvcHRzID0ge1xuICAgIGFsZ29yaXRobToge1xuICAgICAgbmFtZTogb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgd29ya2Vyczogb3B0aW9ucy53b3JrZXJzIHx8IDIsXG4gICAgICAgIHdvcmtMb2FkOiBvcHRpb25zLndvcmtMb2FkIHx8IDEwMCxcbiAgICAgICAgd29ya2VyU2NyaXB0OiBvcHRpb25zLndvcmtlclNjcmlwdFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYoJ3BybmcnIGluIG9wdGlvbnMpIHtcbiAgICBvcHRzLnBybmcgPSBvcHRpb25zLnBybmc7XG4gIH1cblxuICBnZW5lcmF0ZSgpO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIC8vIGZpbmQgcCBhbmQgdGhlbiBxIChkb25lIGluIHNlcmllcyB0byBzaW1wbGlmeSlcbiAgICBnZXRQcmltZShzdGF0ZS5wQml0cywgZnVuY3Rpb24oZXJyLCBudW0pIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnAgPSBudW07XG4gICAgICBpZihzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goZXJyLCBzdGF0ZS5xKTtcbiAgICAgIH1cbiAgICAgIGdldFByaW1lKHN0YXRlLnFCaXRzLCBmaW5pc2gpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJpbWUoYml0cywgY2FsbGJhY2spIHtcbiAgICBmb3JnZS5wcmltZS5nZW5lcmF0ZVByb2JhYmxlUHJpbWUoYml0cywgb3B0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoKGVyciwgbnVtKSB7XG4gICAgaWYoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcVxuICAgIHN0YXRlLnEgPSBudW07XG5cbiAgICAvLyBlbnN1cmUgcCBpcyBsYXJnZXIgdGhhbiBxIChzd2FwIHRoZW0gaWYgbm90KVxuICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgdmFyIHRtcCA9IHN0YXRlLnA7XG4gICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgIHN0YXRlLnEgPSB0bXA7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHAgaXMgY29wcmltZSB3aXRoIGVcbiAgICBpZihzdGF0ZS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2Qoc3RhdGUuZSlcbiAgICAgIC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHEgaXMgY29wcmltZSB3aXRoIGVcbiAgICBpZihzdGF0ZS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2Qoc3RhdGUuZSlcbiAgICAgIC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICBzdGF0ZS5xID0gbnVsbDtcbiAgICAgIGdldFByaW1lKHN0YXRlLnFCaXRzLCBmaW5pc2gpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgcGhpOiAocCAtIDEpKHEgLSAxKSAoRXVsZXIncyB0b3RpZW50IGZ1bmN0aW9uKVxuICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgc3RhdGUucTEgPSBzdGF0ZS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICBzdGF0ZS5waGkgPSBzdGF0ZS5wMS5tdWx0aXBseShzdGF0ZS5xMSk7XG5cbiAgICAvLyBlbnN1cmUgZSBhbmQgcGhpIGFyZSBjb3ByaW1lXG4gICAgaWYoc3RhdGUucGhpLmdjZChzdGF0ZS5lKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICAvLyBwaGkgYW5kIGUgYXJlbid0IGNvcHJpbWUsIHNvIGdlbmVyYXRlIGEgbmV3IHAgYW5kIHFcbiAgICAgIHN0YXRlLnAgPSBzdGF0ZS5xID0gbnVsbDtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG4sIGVuc3VyZSBuIGlzIGhhcyB0aGUgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcbiAgICBpZihzdGF0ZS5uLmJpdExlbmd0aCgpICE9PSBzdGF0ZS5iaXRzKSB7XG4gICAgICAvLyBmYWlsZWQsIGdldCBuZXcgcVxuICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQga2V5c1xuICAgIHZhciBkID0gc3RhdGUuZS5tb2RJbnZlcnNlKHN0YXRlLnBoaSk7XG4gICAgc3RhdGUua2V5cyA9IHtcbiAgICAgIHByaXZhdGVLZXk6IHBraS5yc2Euc2V0UHJpdmF0ZUtleShcbiAgICAgICAgc3RhdGUubiwgc3RhdGUuZSwgZCwgc3RhdGUucCwgc3RhdGUucSxcbiAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgIHN0YXRlLnEubW9kSW52ZXJzZShzdGF0ZS5wKSksXG4gICAgICBwdWJsaWNLZXk6IHBraS5yc2Euc2V0UHVibGljS2V5KHN0YXRlLm4sIHN0YXRlLmUpXG4gICAgfTtcblxuICAgIGNhbGxiYWNrKG51bGwsIHN0YXRlLmtleXMpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBwb3NpdGl2ZSBCaWdJbnRlZ2VyIGludG8gMidzLWNvbXBsZW1lbnQgYmlnLWVuZGlhbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYmlnIGludGVnZXIgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlcy5cbiAqL1xuZnVuY3Rpb24gX2JuVG9CeXRlcyhiKSB7XG4gIC8vIHByZXBlbmQgMHgwMCBpZiBmaXJzdCBieXRlID49IDB4ODBcbiAgdmFyIGhleCA9IGIudG9TdHJpbmcoMTYpO1xuICBpZihoZXhbMF0gPj0gJzgnKSB7XG4gICAgaGV4ID0gJzAwJyArIGhleDtcbiAgfVxuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoaGV4KTtcblxuICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICBpZihieXRlcy5sZW5ndGggPiAxICYmXG4gICAgLy8gbGVhZGluZyAweDAwIGZvciBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgKChieXRlcy5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMSkgJiAweDgwKSA9PT0gMCkgfHxcbiAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgwKSA9PT0gMHhGRiAmJlxuICAgIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDB4ODApKSkge1xuICAgIHJldHVybiBieXRlcy5zdWJzdHIoMSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBNaWxsZXItUmFiaW4gdGVzdHMgdG8gZ2VuZXJhdGUgYVxuICogcHJpbWUgd2l0aCBhbiBlcnJvciBwcm9iYWJpbGl0eSBvZiAoMS8yKV44MC5cbiAqXG4gKiBTZWUgSGFuZGJvb2sgb2YgQXBwbGllZCBDcnlwdG9ncmFwaHkgQ2hhcHRlciA0LCBUYWJsZSA0LjQuXG4gKlxuICogQHBhcmFtIGJpdHMgdGhlIGJpdCBzaXplLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiBfZ2V0TWlsbGVyUmFiaW5UZXN0cyhiaXRzKSB7XG4gIGlmKGJpdHMgPD0gMTAwKSByZXR1cm4gMjc7XG4gIGlmKGJpdHMgPD0gMTUwKSByZXR1cm4gMTg7XG4gIGlmKGJpdHMgPD0gMjAwKSByZXR1cm4gMTU7XG4gIGlmKGJpdHMgPD0gMjUwKSByZXR1cm4gMTI7XG4gIGlmKGJpdHMgPD0gMzAwKSByZXR1cm4gOTtcbiAgaWYoYml0cyA8PSAzNTApIHJldHVybiA4O1xuICBpZihiaXRzIDw9IDQwMCkgcmV0dXJuIDc7XG4gIGlmKGJpdHMgPD0gNTAwKSByZXR1cm4gNjtcbiAgaWYoYml0cyA8PSA2MDApIHJldHVybiA1O1xuICBpZihiaXRzIDw9IDgwMCkgcmV0dXJuIDQ7XG4gIGlmKGJpdHMgPD0gMTI1MCkgcmV0dXJuIDM7XG4gIHJldHVybiAyO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGZlYXR1cmUgZGV0ZWN0aW9uIG9uIHRoZSBOb2RlIGNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0Tm9kZUNyeXB0byhmbikge1xuICByZXR1cm4gZm9yZ2UudXRpbC5pc05vZGVqcyAmJiB0eXBlb2YgX2NyeXB0b1tmbl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZmVhdHVyZSBkZXRlY3Rpb24gb24gdGhlIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0U3VidGxlQ3J5cHRvKGZuKSB7XG4gIHJldHVybiAodHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLmNyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZVtmbl0gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGZlYXR1cmUgZGV0ZWN0aW9uIG9uIHRoZSBkZXByZWNhdGVkIE1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclxuICogb3V0ZGF0ZWQgU3VidGxlQ3J5cHRvIGludGVyZmFjZS4gVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSB1c2VkIGFmdGVyXG4gKiBjaGVja2luZyBmb3IgdGhlIG1vZGVybiwgc3RhbmRhcmQgU3VidGxlQ3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVNc0NyeXB0byhmbikge1xuICByZXR1cm4gKHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gX2ludFRvVWludDhBcnJheSh4KSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4LnRvU3RyaW5nKDE2KSk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIF9wcml2YXRlS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGFsZ29yaXRobSBcIicgKyBqd2sua3R5ICsgJ1wiOyBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLm4pLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnApLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5xaSkpO1xufVxuXG5mdW5jdGlvbiBfcHVibGljS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2subiksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5lKSk7XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRUb0JpZ0ludChiNjQpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS51dGlsLmRlY29kZTY0KGI2NCkpLCAxNik7XG59XG4iLCAiLyoqXG4gKiBQYXNzd29yZC1iYXNlZCBlbmNyeXB0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICogQGF1dGhvciBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBBbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbzpcbiAqXG4gKiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBlbmNyeXB0aW9uQWxnb3JpdGhtICBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGF0YSAgICAgICAgRW5jcnlwdGVkRGF0YSB9XG4gKlxuICogRW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBPQ1RFVCBTVFJJTkdcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hZXMnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi9kZXMnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wYmtkZjInKTtcbnJlcXVpcmUoJy4vcGVtJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi9yYzInKTtcbnJlcXVpcmUoJy4vcnNhJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuaWYodHlwZW9mIEJpZ0ludGVnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyO1xufVxuXG4vLyBzaG9ydGN1dCBmb3IgYXNuLjEgQVBJXG52YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG5cbi8qIFBhc3N3b3JkLWJhc2VkIGVuY3J5cHRpb24gaW1wbGVtZW50YXRpb24uICovXG52YXIgcGtpID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBwa2kucGJlID0gZm9yZ2UucGJlID0gZm9yZ2UucGJlIHx8IHt9O1xudmFyIG9pZHMgPSBwa2kub2lkcztcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBzdHJ1Y3R1cmVcbi8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHdvcmtzIHcvYWxnb3JpdGhtIHBhcmFtc1xudmFyIGVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvLmVuY3J5cHRpb25BbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNyeXB0aW9uT2lkJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtZXRlcnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2VuY3J5cHRpb25QYXJhbXMnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIGVuY3J5cHRlZERhdGFcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGVkRGF0YScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY3J5cHRlZERhdGEnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgUEJFUzJBbGdvcml0aG1zIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9QQktERjIgKyBBRVMgZW5jcnlwdGlvbiBzY2hlbWVzXG52YXIgUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5rZXlEZXJpdmF0aW9uRnVuYy5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdrZGZPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMuc2FsdCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdrZGZTYWx0J1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5pdGVyYXRpb25Db3VudCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZkl0ZXJhdGlvbkNvdW50J1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5rZXlMZW5ndGgnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAna2V5TGVuZ3RoJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBwcmZcbiAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMucHJmJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMucHJmLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdwcmZPaWQnXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmVuY3J5cHRpb25TY2hlbWUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmVuY3J5cHRpb25TY2hlbWUub2lkJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jT2lkJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5pdicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jSXYnXG4gICAgfV1cbiAgfV1cbn07XG5cbnZhciBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncGtjcy0xMlBiZVBhcmFtcy5zYWx0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnc2FsdCdcbiAgfSwge1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLml0ZXJhdGlvbnMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2l0ZXJhdGlvbnMnXG4gIH1dXG59O1xuXG4vKipcbiAqIEVuY3J5cHRzIGEgQVNOLjEgUHJpdmF0ZUtleUluZm8gb2JqZWN0LCBwcm9kdWNpbmcgYW4gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKlxuICogUEJFUzJBbGdvcml0aG1zIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQkVTMi1wYXJhbXMgSURFTlRJRklFRCBCWSBpZC1QQkVTMn0sIC4uLn1cbiAqXG4gKiBpZC1QQkVTMiBPQkpFQ1QgSURFTlRJRklFUiA6Oj0ge3BrY3MtNSAxM31cbiAqXG4gKiBQQkVTMi1wYXJhbXMgOjo9IFNFUVVFTkNFIHtcbiAqICAga2V5RGVyaXZhdGlvbkZ1bmMgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCRVMyLUtERnN9fSxcbiAqICAgZW5jcnlwdGlvblNjaGVtZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItRW5jc319XG4gKiB9XG4gKlxuICogUEJFUzItS0RGcyBBTEdPUklUSE0tSURFTlRJRklFUiA6Oj1cbiAqICAgeyB7UEJLREYyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCS0RGMn0sIC4uLiB9XG4gKlxuICogUEJFUzItRW5jcyBBTEdPUklUSE0tSURFTlRJRklFUiA6Oj0geyAuLi4gfVxuICpcbiAqIFBCS0RGMi1wYXJhbXMgOjo9IFNFUVVFTkNFIHtcbiAqICAgc2FsdCBDSE9JQ0Uge1xuICogICAgIHNwZWNpZmllZCBPQ1RFVCBTVFJJTkcsXG4gKiAgICAgb3RoZXJTb3VyY2UgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCS0RGMi1TYWx0U291cmNlc319XG4gKiAgIH0sXG4gKiAgIGl0ZXJhdGlvbkNvdW50IElOVEVHRVIgKDEuLk1BWCksXG4gKiAgIGtleUxlbmd0aCBJTlRFR0VSICgxLi5NQVgpIE9QVElPTkFMLFxuICogICBwcmYgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCS0RGMi1QUkZzfX0gREVGQVVMVCBhbGdpZC1obWFjV2l0aFNIQTFcbiAqIH1cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGVuY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdhZXMxMjgnLCAnYWVzMTkyJywgJ2FlczI1NicsICczZGVzJyksIGRlZmF1bHRzIHRvICdhZXMxMjgnLlxuICogICAgICAgICAgY291bnQgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZSB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIHByZkFsZ29yaXRobSB0aGUgUFJGIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdzaGExJywgJ3NoYTIyNCcsICdzaGEyNTYnLCAnc2hhMzg0JywgJ3NoYTUxMicpXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKi9cbnBraS5lbmNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc2FsdFNpemUgPSBvcHRpb25zLnNhbHRTaXplIHx8IDg7XG4gIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ2FlczEyOCc7XG4gIG9wdGlvbnMucHJmQWxnb3JpdGhtID0gb3B0aW9ucy5wcmZBbGdvcml0aG0gfHwgJ3NoYTEnO1xuXG4gIC8vIGdlbmVyYXRlIFBCRSBwYXJhbXNcbiAgdmFyIHNhbHQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKG9wdGlvbnMuc2FsdFNpemUpO1xuICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICB2YXIgY291bnRCeXRlcyA9IGFzbjEuaW50ZWdlclRvRGVyKGNvdW50KTtcbiAgdmFyIGRrTGVuO1xuICB2YXIgZW5jcnlwdGlvbkFsZ29yaXRobTtcbiAgdmFyIGVuY3J5cHRlZERhdGE7XG4gIGlmKG9wdGlvbnMuYWxnb3JpdGhtLmluZGV4T2YoJ2FlcycpID09PSAwIHx8IG9wdGlvbnMuYWxnb3JpdGhtID09PSAnZGVzJykge1xuICAgIC8vIGRvIFBCRVMyXG4gICAgdmFyIGl2TGVuLCBlbmNPaWQsIGNpcGhlckZuO1xuICAgIHN3aXRjaChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgIGNhc2UgJ2FlczEyOCc6XG4gICAgICBka0xlbiA9IDE2O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczEyOC1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMxOTInOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMxOTItQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWVzMjU2JzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMjU2LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rlcyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBpdkxlbiA9IDg7XG4gICAgICBlbmNPaWQgPSBvaWRzWydkZXNDQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCBwcml2YXRlIGtleS4gVW5rbm93biBlbmNyeXB0aW9uIGFsZ29yaXRobS4nKTtcbiAgICAgIGVycm9yLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gZ2V0IFBSRiBtZXNzYWdlIGRpZ2VzdFxuICAgIHZhciBwcmZBbGdvcml0aG0gPSAnaG1hY1dpdGgnICsgb3B0aW9ucy5wcmZBbGdvcml0aG0udG9VcHBlckNhc2UoKTtcbiAgICB2YXIgbWQgPSBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKTtcblxuICAgIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgcGJlIFNIQS0xIGFuZCBBRVMvREVTXG4gICAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgICB2YXIgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKGl2TGVuKTtcbiAgICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgLy8gZ2V0IFBCS0RGMi1wYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BrY3M1UEJFUzInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGtleURlcml2YXRpb25GdW5jXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BrY3M1UEJLREYyJ10pLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIFBCS0RGMi1wYXJhbXNcbiAgICAgICAgICBwYXJhbXNcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGVuY3J5cHRpb25TY2hlbWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIoZW5jT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAvLyBpdlxuICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGl2KVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuYWxnb3JpdGhtID09PSAnM2RlcycpIHtcbiAgICAvLyBEbyBQS0NTMTIgUEJFXG4gICAgZGtMZW4gPSAyNDtcblxuICAgIHZhciBzYWx0Qnl0ZXMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKHNhbHQpO1xuICAgIHZhciBkayA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMSwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgaXYgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0Qnl0ZXMsIDIsIGNvdW50LCBka0xlbik7XG4gICAgdmFyIGNpcGhlciA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyKGRrKTtcbiAgICBjaXBoZXIuc3RhcnQoaXYpO1xuICAgIGNpcGhlci51cGRhdGUoYXNuMS50b0RlcihvYmopKTtcbiAgICBjaXBoZXIuZmluaXNoKCk7XG4gICAgZW5jcnlwdGVkRGF0YSA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcblxuICAgIGVuY3J5cHRpb25BbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihvaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ10pLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGtjcy0xMlBiZVBhcmFtc1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBzYWx0XG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLCBzYWx0KSxcbiAgICAgICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgICAgY291bnRCeXRlcy5nZXRCeXRlcygpKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgIGVycm9yLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gZW5jcnlwdGlvbkFsZ29yaXRobVxuICAgIGVuY3J5cHRpb25BbGdvcml0aG0sXG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGVuY3J5cHRlZERhdGEpXG4gIF0pO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUHJpdmF0ZUtleUluZm8gb24gc3VjY2VzcywgbnVsbCBvbiBmYWlsdXJlLlxuICovXG5wa2kuZGVjcnlwdFByaXZhdGVLZXlJbmZvID0gZnVuY3Rpb24ob2JqLCBwYXNzd29yZCkge1xuICB2YXIgcnZhbCA9IG51bGw7XG5cbiAgLy8gZ2V0IFBCRSBwYXJhbXNcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGlzIG5vdCBhIHN1cHBvcnRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgY2lwaGVyXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuZW5jcnlwdGlvbk9pZCk7XG4gIHZhciBjaXBoZXIgPSBwa2kucGJlLmdldENpcGhlcihvaWQsIGNhcHR1cmUuZW5jcnlwdGlvblBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIC8vIGdldCBlbmNyeXB0ZWQgZGF0YVxuICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5lbmNyeXB0ZWREYXRhKTtcblxuICBjaXBoZXIudXBkYXRlKGVuY3J5cHRlZCk7XG4gIGlmKGNpcGhlci5maW5pc2goKSkge1xuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIoY2lwaGVyLm91dHB1dCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBlcGtpIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtID0gZnVuY3Rpb24oZXBraSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScsXG4gICAgYm9keTogYXNuMS50b0RlcihlcGtpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQRU0tZW5jb2RlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBBU04uMSBmb3JtYXQuIERlY3J5cHRpb25cbiAqIGlzIG5vdCBwZXJmb3JtZWQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gaW4gUEVNLWZvcm1hdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRlZFByaXZhdGVLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBoZWFkZXIgdHlwZSBpcyBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgcmV0dXJuIGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG59O1xuXG4vKipcbiAqIEVuY3J5cHRzIGFuIFJTQSBwcml2YXRlIGtleS4gQnkgZGVmYXVsdCwgdGhlIGtleSB3aWxsIGJlIHdyYXBwZWQgaW5cbiAqIGEgUHJpdmF0ZUtleUluZm8gYW5kIGVuY3J5cHRlZCB0byBwcm9kdWNlIGEgUEtDUyM4IEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogVGhpcyBpcyB0aGUgc3RhbmRhcmQsIHByZWZlcnJlZCB3YXkgdG8gZW5jcnlwdCBhIHByaXZhdGUga2V5LlxuICpcbiAqIFRvIHByb2R1Y2UgYSBub24tc3RhbmRhcmQgUEVNLWVuY3J5cHRlZCBwcml2YXRlIGtleSB0aGF0IHVzZXMgZW5jYXBzdWxhdGVkXG4gKiBoZWFkZXJzIHRvIGluZGljYXRlIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSAob2xkLXN0eWxlIG5vbi1QS0NTIzggT3BlblNTTFxuICogcHJpdmF0ZSBrZXkgZW5jcnlwdGlvbiksIHNldCB0aGUgJ2xlZ2FjeScgb3B0aW9uIHRvIHRydWUuIE5vdGU6IFVzaW5nIHRoaXNcbiAqIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBpdGVyYXRpb24gY291bnQgdG8gYmUgZm9yY2VkIHRvIDEuXG4gKlxuICogTm90ZTogVGhlICdkZXMnIGFsZ29yaXRobSBpcyBzdXBwb3J0ZWQsIGJ1dCBpdCBpcyBub3QgY29uc2lkZXJlZCB0byBiZVxuICogc2VjdXJlIGJlY2F1c2UgaXQgb25seSB1c2VzIGEgc2luZ2xlIDU2LWJpdCBrZXkuIElmIHBvc3NpYmxlLCBpdCBpcyBoaWdobHlcbiAqIHJlY29tbWVuZGVkIHRoYXQgYSBkaWZmZXJlbnQgYWxnb3JpdGhtIGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIHJzYUtleSB0aGUgUlNBIGtleSB0byBlbmNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKiBAcGFyYW0gb3B0aW9uczpcbiAqICAgICAgICAgIGFsZ29yaXRobTogdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnLCAnZGVzJykuXG4gKiAgICAgICAgICBjb3VudDogdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZTogdGhlIHNhbHQgc2l6ZSB0byB1c2UuXG4gKiAgICAgICAgICBsZWdhY3k6IG91dHB1dCBhbiBvbGQgbm9uLVBLQ1MjOCBQRU0tZW5jcnlwdGVkK2VuY2Fwc3VsYXRlZFxuICogICAgICAgICAgICBoZWFkZXJzIChERUstSW5mbykgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWVuY29kZWQgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKi9cbnBraS5lbmNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHJzYUtleSwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc3RhbmRhcmQgUEtDUyM4XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZighb3B0aW9ucy5sZWdhY3kpIHtcbiAgICAvLyBlbmNyeXB0IFByaXZhdGVLZXlJbmZvXG4gICAgdmFyIHJ2YWwgPSBwa2kud3JhcFJzYVByaXZhdGVLZXkocGtpLnByaXZhdGVLZXlUb0FzbjEocnNhS2V5KSk7XG4gICAgcnZhbCA9IHBraS5lbmNyeXB0UHJpdmF0ZUtleUluZm8ocnZhbCwgcGFzc3dvcmQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBwa2kuZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtKHJ2YWwpO1xuICB9XG5cbiAgLy8gbGVnYWN5IG5vbi1QS0NTIzhcbiAgdmFyIGFsZ29yaXRobTtcbiAgdmFyIGl2O1xuICB2YXIgZGtMZW47XG4gIHZhciBjaXBoZXJGbjtcbiAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gIGNhc2UgJ2FlczEyOCc6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0xMjgtQ0JDJztcbiAgICBka0xlbiA9IDE2O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMTkyJzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTE5Mi1DQkMnO1xuICAgIGRrTGVuID0gMjQ7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMyNTYnOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMjU2LUNCQyc7XG4gICAgZGtMZW4gPSAzMjtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJzNkZXMnOlxuICAgIGFsZ29yaXRobSA9ICdERVMtRURFMy1DQkMnO1xuICAgIGRrTGVuID0gMjQ7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDgpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1DQkMnO1xuICAgIGRrTGVuID0gODtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBlbmNyeXB0IFJTQSBwcml2YXRlIGtleTsgdW5zdXBwb3J0ZWQgJyArXG4gICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgb3B0aW9ucy5hbGdvcml0aG0gKyAnXCIuJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBlbmNyeXB0IHByaXZhdGUga2V5IHVzaW5nIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIocGtpLnByaXZhdGVLZXlUb0FzbjEocnNhS2V5KSkpO1xuICBjaXBoZXIuZmluaXNoKCk7XG5cbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBSSVZBVEUgS0VZJyxcbiAgICBwcm9jVHlwZToge1xuICAgICAgdmVyc2lvbjogJzQnLFxuICAgICAgdHlwZTogJ0VOQ1JZUFRFRCdcbiAgICB9LFxuICAgIGRla0luZm86IHtcbiAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtLFxuICAgICAgcGFyYW1ldGVyczogZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGl2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSxcbiAgICBib2R5OiBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnKTtcbn07XG5cbi8qKlxuICogRGVjcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gdG8gZGVjcnlwdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIFJTQSBrZXkgb24gc3VjY2VzcywgbnVsbCBvbiBmYWlsdXJlLlxuICovXG5wa2kuZGVjcnlwdFJzYVByaXZhdGVLZXkgPSBmdW5jdGlvbihwZW0sIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyAmJlxuICAgIG1zZy50eXBlICE9PSAnUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdSU0EgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlICcgK1xuICAgICAgJ2lzIG5vdCBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLCBcIlBSSVZBVEUgS0VZXCIsIG9yIFwiUlNBIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IGVycm9yO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHZhciBka0xlbjtcbiAgICB2YXIgY2lwaGVyRm47XG4gICAgc3dpdGNoKG1zZy5kZWtJbmZvLmFsZ29yaXRobSkge1xuICAgIGNhc2UgJ0RFUy1DQkMnOlxuICAgICAgZGtMZW4gPSA4O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0RFUy1FREUzLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0xMjgtQ0JDJzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTE5Mi1DQkMnOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMjU2LUNCQyc6XG4gICAgICBka0xlbiA9IDMyO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi00MC1DQkMnOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgY2lwaGVyRm4gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNDApO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi02NC1DQkMnOlxuICAgICAgZGtMZW4gPSA4O1xuICAgICAgY2lwaGVyRm4gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNjQpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi0xMjgtQ0JDJzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCAxMjgpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNyeXB0IHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICAgJ2VuY3J5cHRpb24gYWxnb3JpdGhtIFwiJyArIG1zZy5kZWtJbmZvLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICAgIGVycm9yLmFsZ29yaXRobSA9IG1zZy5kZWtJbmZvLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHVzZSBPcGVuU1NMIGxlZ2FjeSBrZXkgZGVyaXZhdGlvblxuICAgIHZhciBpdiA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB2YXIgZGsgPSBmb3JnZS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzKHBhc3N3b3JkLCBpdi5zdWJzdHIoMCwgOCksIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSkpO1xuICAgIGlmKGNpcGhlci5maW5pc2goKSkge1xuICAgICAgcnZhbCA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJ2YWwgPSBtc2cuYm9keTtcbiAgfVxuXG4gIGlmKG1zZy50eXBlID09PSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJykge1xuICAgIHJ2YWwgPSBwa2kuZGVjcnlwdFByaXZhdGVLZXlJbmZvKGFzbjEuZnJvbURlcihydmFsKSwgcGFzc3dvcmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlY3J5cHRpb24gYWxyZWFkeSBwZXJmb3JtZWQgYWJvdmVcbiAgICBydmFsID0gYXNuMS5mcm9tRGVyKHJ2YWwpO1xuICB9XG5cbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIHJ2YWwgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKHJ2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIERlcml2ZXMgYSBQS0NTIzEyIGtleS5cbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlcml2ZSB0aGUga2V5IG1hdGVyaWFsIGZyb20sIG51bGwgb3JcbiAqICAgICAgICAgIHVuZGVmaW5lZCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0LCBhcyBhIEJ5dGVCdWZmZXIsIHRvIHVzZS5cbiAqIEBwYXJhbSBpZCB0aGUgUEtDUyMxMiBJRCBieXRlICgxID0ga2V5IG1hdGVyaWFsLCAyID0gSVYsIDMgPSBNQUMpLlxuICogQHBhcmFtIGl0ZXIgdGhlIGl0ZXJhdGlvbiBjb3VudC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZGVyaXZlIGZyb20gdGhlIHBhc3N3b3JkLlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIGRlZmF1bHRzIHRvIFNIQS0xLlxuICpcbiAqIEByZXR1cm4gYSBCeXRlQnVmZmVyIHdpdGggdGhlIGJ5dGVzIGRlcml2ZWQgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKi9cbnBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkgPSBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgaWQsIGl0ZXIsIG4sIG1kKSB7XG4gIHZhciBqLCBsO1xuXG4gIGlmKHR5cGVvZiBtZCA9PT0gJ3VuZGVmaW5lZCcgfHwgbWQgPT09IG51bGwpIHtcbiAgICBpZighKCdzaGExJyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJzaGExXCIgaGFzaCBhbGdvcml0aG0gdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuXG4gIHZhciB1ID0gbWQuZGlnZXN0TGVuZ3RoO1xuICB2YXIgdiA9IG1kLmJsb2NrTGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuXG4gIC8qIENvbnZlcnQgcGFzc3dvcmQgdG8gVW5pY29kZSBieXRlIGJ1ZmZlciArIHRyYWlsaW5nIDAtYnl0ZS4gKi9cbiAgdmFyIHBhc3NCdWYgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGlmKHBhc3N3b3JkICE9PSBudWxsICYmIHBhc3N3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IobCA9IDA7IGwgPCBwYXNzd29yZC5sZW5ndGg7IGwrKykge1xuICAgICAgcGFzc0J1Zi5wdXRJbnQxNihwYXNzd29yZC5jaGFyQ29kZUF0KGwpKTtcbiAgICB9XG4gICAgcGFzc0J1Zi5wdXRJbnQxNigwKTtcbiAgfVxuXG4gIC8qIExlbmd0aCBvZiBzYWx0IGFuZCBwYXNzd29yZCBpbiBCWVRFUy4gKi9cbiAgdmFyIHAgPSBwYXNzQnVmLmxlbmd0aCgpO1xuICB2YXIgcyA9IHNhbHQubGVuZ3RoKCk7XG5cbiAgLyogMS4gQ29uc3RydWN0IGEgc3RyaW5nLCBEICh0aGUgXCJkaXZlcnNpZmllclwiKSwgYnkgY29uY2F0ZW5hdGluZ1xuICAgICAgICB2IGNvcGllcyBvZiBJRC4gKi9cbiAgdmFyIEQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIEQuZmlsbFdpdGhCeXRlKGlkLCB2KTtcblxuICAvKiAyLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHNhbHQgdG9nZXRoZXIgdG8gY3JlYXRlIGEgc3RyaW5nIFMgb2YgbGVuZ3RoXG4gICAgICAgIHYgKiBjZWlsKHMgLyB2KSBieXRlcyAodGhlIGZpbmFsIGNvcHkgb2YgdGhlIHNhbHQgbWF5IGJlIHRydW5hY3RlZFxuICAgICAgICB0byBjcmVhdGUgUykuXG4gICAgICAgIE5vdGUgdGhhdCBpZiB0aGUgc2FsdCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFMuICovXG4gIHZhciBTbGVuID0gdiAqIE1hdGguY2VpbChzIC8gdik7XG4gIHZhciBTID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBTbGVuOyBsKyspIHtcbiAgICBTLnB1dEJ5dGUoc2FsdC5hdChsICUgcykpO1xuICB9XG5cbiAgLyogMy4gQ29uY2F0ZW5hdGUgY29waWVzIG9mIHRoZSBwYXNzd29yZCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUCBvZlxuICAgICAgICBsZW5ndGggdiAqIGNlaWwocCAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgcGFzc3dvcmQgbWF5IGJlXG4gICAgICAgIHRydW5jYXRlZCB0byBjcmVhdGUgUCkuXG4gICAgICAgIE5vdGUgdGhhdCBpZiB0aGUgcGFzc3dvcmQgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzbyBpcyBQLiAqL1xuICB2YXIgUGxlbiA9IHYgKiBNYXRoLmNlaWwocCAvIHYpO1xuICB2YXIgUCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgZm9yKGwgPSAwOyBsIDwgUGxlbjsgbCsrKSB7XG4gICAgUC5wdXRCeXRlKHBhc3NCdWYuYXQobCAlIHApKTtcbiAgfVxuXG4gIC8qIDQuIFNldCBJPVN8fFAgdG8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgUyBhbmQgUC4gKi9cbiAgdmFyIEkgPSBTO1xuICBJLnB1dEJ1ZmZlcihQKTtcblxuICAvKiA1LiBTZXQgYz1jZWlsKG4gLyB1KS4gKi9cbiAgdmFyIGMgPSBNYXRoLmNlaWwobiAvIHUpO1xuXG4gIC8qIDYuIEZvciBpPTEsIDIsIC4uLiwgYywgZG8gdGhlIGZvbGxvd2luZzogKi9cbiAgZm9yKHZhciBpID0gMTsgaSA8PSBjOyBpKyspIHtcbiAgICAvKiBhKSBTZXQgQWk9SF5yKER8fEkpLiAobC5lLiB0aGUgcnRoIGhhc2ggb2YgRHx8SSwgSChIKEgoLi4uSChEfHxJKSkpKSAqL1xuICAgIHZhciBidWYgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgYnVmLnB1dEJ5dGVzKEQuYnl0ZXMoKSk7XG4gICAgYnVmLnB1dEJ5dGVzKEkuYnl0ZXMoKSk7XG4gICAgZm9yKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgaXRlcjsgcm91bmQrKykge1xuICAgICAgbWQuc3RhcnQoKTtcbiAgICAgIG1kLnVwZGF0ZShidWYuZ2V0Qnl0ZXMoKSk7XG4gICAgICBidWYgPSBtZC5kaWdlc3QoKTtcbiAgICB9XG5cbiAgICAvKiBiKSBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgQWkgdG8gY3JlYXRlIGEgc3RyaW5nIEIgb2YgbGVuZ3RoIHYgYnl0ZXMgKHRoZVxuICAgICAgICAgIGZpbmFsIGNvcHkgb2YgQWkgbWF5IGJlIHRydW5jYXRlZCB0byBjcmVhdGUgQikuICovXG4gICAgdmFyIEIgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgZm9yKGwgPSAwOyBsIDwgdjsgbCsrKSB7XG4gICAgICBCLnB1dEJ5dGUoYnVmLmF0KGwgJSB1KSk7XG4gICAgfVxuXG4gICAgLyogYykgVHJlYXRpbmcgSSBhcyBhIGNvbmNhdGVuYXRpb24gSTAsIEkxLCAuLi4sIElrLTEgb2Ygdi1ieXRlIGJsb2NrcyxcbiAgICAgICAgICB3aGVyZSBrPWNlaWwocyAvIHYpICsgY2VpbChwIC8gdiksIG1vZGlmeSBJIGJ5IHNldHRpbmdcbiAgICAgICAgICBJaj0oSWorQisxKSBtb2QgMnYgZm9yIGVhY2ggai4gICovXG4gICAgdmFyIGsgPSBNYXRoLmNlaWwocyAvIHYpICsgTWF0aC5jZWlsKHAgLyB2KTtcbiAgICB2YXIgSW5ldyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IoaiA9IDA7IGogPCBrOyBqKyspIHtcbiAgICAgIHZhciBjaHVuayA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoSS5nZXRCeXRlcyh2KSk7XG4gICAgICB2YXIgeCA9IDB4MWZmO1xuICAgICAgZm9yKGwgPSBCLmxlbmd0aCgpIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgeCA9IHggPj4gODtcbiAgICAgICAgeCArPSBCLmF0KGwpICsgY2h1bmsuYXQobCk7XG4gICAgICAgIGNodW5rLnNldEF0KGwsIHggJiAweGZmKTtcbiAgICAgIH1cbiAgICAgIEluZXcucHV0QnVmZmVyKGNodW5rKTtcbiAgICB9XG4gICAgSSA9IEluZXc7XG5cbiAgICAvKiBBZGQgQWkgdG8gQS4gKi9cbiAgICByZXN1bHQucHV0QnVmZmVyKGJ1Zik7XG4gIH1cblxuICByZXN1bHQudHJ1bmNhdGUocmVzdWx0Lmxlbmd0aCgpIC0gbik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBuZXcgRm9yZ2UgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIHRoZSBBU04uMSBwYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiBuZXcgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqL1xucGtpLnBiZS5nZXRDaXBoZXIgPSBmdW5jdGlvbihvaWQsIHBhcmFtcywgcGFzc3dvcmQpIHtcbiAgc3dpdGNoKG9pZCkge1xuICBjYXNlIHBraS5vaWRzWydwa2NzNVBCRVMyJ106XG4gICAgcmV0dXJuIHBraS5wYmUuZ2V0Q2lwaGVyRm9yUEJFUzIob2lkLCBwYXJhbXMsIHBhc3N3b3JkKTtcblxuICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gIGNhc2UgcGtpLm9pZHNbJ3BiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkMnXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQS0NTMTJQQkUob2lkLCBwYXJhbXMsIHBhc3N3b3JkKTtcblxuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIFBCRSBkYXRhIGJsb2NrLiBVbnN1cHBvcnRlZCBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbXG4gICAgICAncGtjczVQQkVTMicsXG4gICAgICAncGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQycsXG4gICAgICAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQydcbiAgICBdO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBuZXcgRm9yZ2UgY2lwaGVyIG9iamVjdCBpbnN0YW5jZSBhY2NvcmRpbmcgdG8gUEJFUzIgcGFyYW1zIGJsb2NrLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBJVlxuICogZnJvbSBQQkVTMiBwYXJhbWV0ZXIgYmxvY2suXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgUEtDUyM1IFBCS0RGMiBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIHRoZSBBU04uMSBQQkVTMi1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiBuZXcgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqL1xucGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMiA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKHBhcmFtcywgUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGFsZ29yaXRobSAnICtcbiAgICAgICdwYXJhbWV0ZXJzLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGNoZWNrIG9pZHNcbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmtkZk9pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ3BrY3M1UEJLREYyJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gWydwa2NzNVBCS0RGMiddO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzWydhZXMxMjgtQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydhZXMxOTItQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydhZXMyNTYtQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydkZXMtRURFMy1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlc0NCQyddKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuICcgK1xuICAgICAgJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdhZXMxMjgtQ0JDJywgJ2FlczE5Mi1DQkMnLCAnYWVzMjU2LUNCQycsICdkZXMtRURFMy1DQkMnLCAnZGVzQ0JDJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBzZXQgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGNhcHR1cmUua2RmU2FsdDtcbiAgdmFyIGNvdW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5rZGZJdGVyYXRpb25Db3VudCk7XG4gIGNvdW50ID0gY291bnQuZ2V0SW50KGNvdW50Lmxlbmd0aCgpIDw8IDMpO1xuICB2YXIgZGtMZW47XG4gIHZhciBjaXBoZXJGbjtcbiAgc3dpdGNoKHBraS5vaWRzW29pZF0pIHtcbiAgY2FzZSAnYWVzMTI4LUNCQyc6XG4gICAgZGtMZW4gPSAxNjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTItQ0JDJzpcbiAgICBka0xlbiA9IDI0O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Ni1DQkMnOlxuICAgIGRrTGVuID0gMzI7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzLUVERTMtQ0JDJzpcbiAgICBka0xlbiA9IDI0O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rlc0NCQyc6XG4gICAgZGtMZW4gPSA4O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG5cbiAgLy8gZGVjcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgd2l0aCBjaG9zZW4gUFJGIGFuZCBBRVMvREVTXG4gIHZhciBkayA9IGZvcmdlLnBrY3M1LnBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBtZCk7XG4gIHZhciBpdiA9IGNhcHR1cmUuZW5jSXY7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGZvciBQS0NTIzEyIFBCRS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY2lwaGVyIGluc3RhbmNlIGlzIGFscmVhZHkgc3RhcnRlZCB1c2luZyB0aGUga2V5ICYgSVZcbiAqIGRlcml2ZWQgZnJvbSB0aGUgcHJvdmlkZWQgcGFzc3dvcmQgYW5kIFBLQ1MjMTIgUEJFIHNhbHQuXG4gKlxuICogQHBhcmFtIG9pZCBUaGUgUEtDUyMxMiBQQkUgT0lEIChpbiBzdHJpbmcgbm90YXRpb24pLlxuICogQHBhcmFtIHBhcmFtcyBUaGUgQVNOLjEgUEtDUyMxMiBQQkUtcGFyYW1zIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVjcnlwdCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRSA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKHBhcmFtcywgcGtjczEyUGJlUGFyYW1zVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGFsZ29yaXRobSAnICtcbiAgICAgICdwYXJhbWV0ZXJzLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBzYWx0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5zYWx0KTtcbiAgdmFyIGNvdW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5pdGVyYXRpb25zKTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG5cbiAgdmFyIGRrTGVuLCBkSXZMZW4sIGNpcGhlckZuO1xuICBzd2l0Y2gob2lkKSB7XG4gICAgY2FzZSBwa2kub2lkc1sncGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQyddOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGRJdkxlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGtpLm9pZHNbJ3BiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkMnXTpcbiAgICAgIGRrTGVuID0gNTtcbiAgICAgIGRJdkxlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcbiAgICAgICAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNDApO1xuICAgICAgICBjaXBoZXIuc3RhcnQoaXYsIG51bGwpO1xuICAgICAgICByZXR1cm4gY2lwaGVyO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyAjMTIgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gZ2V0IFBSRiBtZXNzYWdlIGRpZ2VzdFxuICB2YXIgbWQgPSBwcmZPaWRUb01lc3NhZ2VEaWdlc3QoY2FwdHVyZS5wcmZPaWQpO1xuICB2YXIga2V5ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMSwgY291bnQsIGRrTGVuLCBtZCk7XG4gIG1kLnN0YXJ0KCk7XG4gIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHQsIDIsIGNvdW50LCBkSXZMZW4sIG1kKTtcblxuICByZXR1cm4gY2lwaGVyRm4oa2V5LCBpdik7XG59O1xuXG4vKipcbiAqIE9wZW5TU0wncyBsZWdhY3kga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG4gKlxuICogU2VlOiBodHRwOi8vd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlcml2ZSB0aGUga2V5IGZyb20uXG4gKiBAcGFyYW0gc2FsdCB0aGUgc2FsdCB0byB1c2UsIG51bGwgZm9yIG5vbmUuXG4gKiBAcGFyYW0gZGtMZW4gdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgZm9yIHRoZSBkZXJpdmVkIGtleS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW21kXSBhbiBvcHRpb25hbCBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLlxuICovXG5wa2kucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBka0xlbiwgbWQpIHtcbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ21kNScgaW4gZm9yZ2UubWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWQ1XCIgaGFzaCBhbGdvcml0aG0gdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICB9XG4gIGlmKHNhbHQgPT09IG51bGwpIHtcbiAgICBzYWx0ID0gJyc7XG4gIH1cbiAgdmFyIGRpZ2VzdHMgPSBbaGFzaChtZCwgcGFzc3dvcmQgKyBzYWx0KV07XG4gIGZvcih2YXIgbGVuZ3RoID0gMTYsIGkgPSAxOyBsZW5ndGggPCBka0xlbjsgKytpLCBsZW5ndGggKz0gMTYpIHtcbiAgICBkaWdlc3RzLnB1c2goaGFzaChtZCwgZGlnZXN0c1tpIC0gMV0gKyBwYXNzd29yZCArIHNhbHQpKTtcbiAgfVxuICByZXR1cm4gZGlnZXN0cy5qb2luKCcnKS5zdWJzdHIoMCwgZGtMZW4pO1xufTtcblxuZnVuY3Rpb24gaGFzaChtZCwgYnl0ZXMpIHtcbiAgcmV0dXJuIG1kLnN0YXJ0KCkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKS5nZXRCeXRlcygpO1xufVxuXG5mdW5jdGlvbiBwcmZPaWRUb01lc3NhZ2VEaWdlc3QocHJmT2lkKSB7XG4gIC8vIGdldCBQUkYgYWxnb3JpdGhtLCBkZWZhdWx0IHRvIFNIQS0xXG4gIHZhciBwcmZBbGdvcml0aG07XG4gIGlmKCFwcmZPaWQpIHtcbiAgICBwcmZBbGdvcml0aG0gPSAnaG1hY1dpdGhTSEExJztcbiAgfSBlbHNlIHtcbiAgICBwcmZBbGdvcml0aG0gPSBwa2kub2lkc1thc24xLmRlclRvT2lkKHByZk9pZCldO1xuICAgIGlmKCFwcmZBbGdvcml0aG0pIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIE9JRC4nKTtcbiAgICAgIGVycm9yLm9pZCA9IHByZk9pZDtcbiAgICAgIGVycm9yLnN1cHBvcnRlZCA9IFtcbiAgICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAgICdobWFjV2l0aFNIQTUxMiddO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKTtcbn1cblxuZnVuY3Rpb24gcHJmQWxnb3JpdGhtVG9NZXNzYWdlRGlnZXN0KHByZkFsZ29yaXRobSkge1xuICB2YXIgZmFjdG9yeSA9IGZvcmdlLm1kO1xuICBzd2l0Y2gocHJmQWxnb3JpdGhtKSB7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjI0JzpcbiAgICBmYWN0b3J5ID0gZm9yZ2UubWQuc2hhNTEyO1xuICBjYXNlICdobWFjV2l0aFNIQTEnOlxuICBjYXNlICdobWFjV2l0aFNIQTI1Nic6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMzg0JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEE1MTInOlxuICAgIHByZkFsZ29yaXRobSA9IHByZkFsZ29yaXRobS5zdWJzdHIoOCkudG9Mb3dlckNhc2UoKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBSRiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtO1xuICAgIGVycm9yLnN1cHBvcnRlZCA9IFtcbiAgICAgICdobWFjV2l0aFNIQTEnLCAnaG1hY1dpdGhTSEEyMjQnLCAnaG1hY1dpdGhTSEEyNTYnLCAnaG1hY1dpdGhTSEEzODQnLFxuICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYoIWZhY3RvcnkgfHwgIShwcmZBbGdvcml0aG0gaW4gZmFjdG9yeSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGFzaCBhbGdvcml0aG06ICcgKyBwcmZBbGdvcml0aG0pO1xuICB9XG4gIHJldHVybiBmYWN0b3J5W3ByZkFsZ29yaXRobV0uY3JlYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBia2RmMlBhcmFtcyhzYWx0LCBjb3VudEJ5dGVzLCBka0xlbiwgcHJmQWxnb3JpdGhtKSB7XG4gIHZhciBwYXJhbXMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gc2FsdFxuICAgIGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgIC8vIGl0ZXJhdGlvbiBjb3VudFxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gIF0pO1xuICAvLyB3aGVuIFBSRiBhbGdvcml0aG0gaXMgbm90IFNIQS0xIGRlZmF1bHQsIGFkZCBrZXkgbGVuZ3RoIGFuZCBQUkYgYWxnb3JpdGhtXG4gIGlmKHByZkFsZ29yaXRobSAhPT0gJ2htYWNXaXRoU0hBMScpIHtcbiAgICBwYXJhbXMudmFsdWUucHVzaChcbiAgICAgIC8vIGtleSBsZW5ndGhcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhka0xlbi50b1N0cmluZygxNikpKSxcbiAgICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzW3ByZkFsZ29yaXRobV0pLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgIF0pKTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBba2V5OiBzdHJpbmddOiBhbnkgfX0gRXh0ZW5zaW9uc1xuICogQHR5cGVkZWYge0Vycm9yfSBFcnJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gb2JqXG4gKiBAcGFyYW0ge0V4dGVuc2lvbnN9IHByb3BzXG4gKiBAcmV0dXJucyB7RXJyb3IgJiBFeHRlbnNpb25zfVxuICovXG5mdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2FueX0gZXJyIC0gQW4gRXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfEV4dGVuc2lvbnN9IGNvZGUgLSBBIHN0cmluZyBjb2RlIG9yIHByb3BzIHRvIHNldCBvbiB0aGUgZXJyb3JcbiAqIEBwYXJhbSB7RXh0ZW5zaW9uc30gW3Byb3BzXSAtIFByb3BzIHRvIHNldCBvbiB0aGUgZXJyb3JcbiAqIEByZXR1cm5zIHtFcnJvciAmIEV4dGVuc2lvbnN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKGVyciwgY29kZSwgcHJvcHMpIHtcbiAgICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgcGFzcyBhbiBFcnJvciB0byBlcnItY29kZScpO1xuICAgIH1cblxuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BzID0gY29kZTtcbiAgICAgICAgY29kZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChjb2RlKSB7XG4gICAgICAgIHByb3BzLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhc3NpZ24oZXJyLCBwcm9wcyk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICBwcm9wcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIHByb3BzLnN0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgICAgIGNvbnN0IEVyckNsYXNzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgRXJyQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXJyKSk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBhc3NpZ24obmV3IEVyckNsYXNzKCksIHByb3BzKTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVFcnJvcjtcbiIsICJpbXBvcnQgYmFzZXMgZnJvbSAnLi91dGlsL2Jhc2VzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgYmFzZSA9IGJhc2VzW2VuY29kaW5nXTtcbiAgaWYgKCFiYXNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7IGVuY29kaW5nIH1cImApO1xuICB9XG4gIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04JykgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShzdHJpbmcsICd1dGY4Jyk7XG4gIH1cbiAgcmV0dXJuIGJhc2UuZGVjb2Rlci5kZWNvZGUoYCR7IGJhc2UucHJlZml4IH0keyBzdHJpbmcgfWApO1xufSIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJleHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufSIsICIvKipcbiAqIFNlY3VyZSBIYXNoIEFsZ29yaXRobSB3aXRoIGEgMTAyNC1iaXQgYmxvY2sgc2l6ZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGluY2x1ZGVzOiBTSEEtNTEyLCBTSEEtMzg0LCBTSEEtNTEyLzIyNCwgYW5kIFNIQS01MTIvMjU2LiBGb3JcbiAqIFNIQS0yNTYgKGJsb2NrIHNpemUgNTEyIGJpdHMpLCBzZWUgc2hhMjU2LmpzLlxuICpcbiAqIFNlZSBGSVBTIDE4MC00IGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBzaGE1MTIgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTUxMiA9IGZvcmdlLnNoYTUxMiB8fCB7fTtcblxuLy8gU0hBLTUxMlxuZm9yZ2UubWQuc2hhNTEyID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5zaGE1MTIgPSBzaGE1MTI7XG5cbi8vIFNIQS0zODRcbnZhciBzaGEzODQgPSBmb3JnZS5zaGEzODQgPSBmb3JnZS5zaGE1MTIuc2hhMzg0ID0gZm9yZ2Uuc2hhNTEyLnNoYTM4NCB8fCB7fTtcbnNoYTM4NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNoYTUxMi5jcmVhdGUoJ1NIQS0zODQnKTtcbn07XG5mb3JnZS5tZC5zaGEzODQgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTM4NCA9IHNoYTM4NDtcblxuLy8gU0hBLTUxMi8yNTZcbmZvcmdlLnNoYTUxMi5zaGEyNTYgPSBmb3JnZS5zaGE1MTIuc2hhMjU2IHx8IHtcbiAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2hhNTEyLmNyZWF0ZSgnU0hBLTUxMi8yNTYnKTtcbiAgfVxufTtcbmZvcmdlLm1kWydzaGE1MTIvMjU2J10gPSBmb3JnZS5tZC5hbGdvcml0aG1zWydzaGE1MTIvMjU2J10gPVxuICBmb3JnZS5zaGE1MTIuc2hhMjU2O1xuXG4vLyBTSEEtNTEyLzIyNFxuZm9yZ2Uuc2hhNTEyLnNoYTIyNCA9IGZvcmdlLnNoYTUxMi5zaGEyMjQgfHwge1xuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzaGE1MTIuY3JlYXRlKCdTSEEtNTEyLzIyNCcpO1xuICB9XG59O1xuZm9yZ2UubWRbJ3NoYTUxMi8yMjQnXSA9IGZvcmdlLm1kLmFsZ29yaXRobXNbJ3NoYTUxMi8yMjQnXSA9XG4gIGZvcmdlLnNoYTUxMi5zaGEyMjQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0yIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChTSEEtNTEyLCBTSEEtMzg0LCBTSEEtNTEyLzIyNCxcbiAqICAgICAgICAgIFNIQS01MTIvMjU2KS5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGE1MTIuY3JlYXRlID0gZnVuY3Rpb24oYWxnb3JpdGhtKSB7XG4gIC8vIGRvIGluaXRpYWxpemF0aW9uIGFzIG5lY2Vzc2FyeVxuICBpZighX2luaXRpYWxpemVkKSB7XG4gICAgX2luaXQoKTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBhbGdvcml0aG0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYWxnb3JpdGhtID0gJ1NIQS01MTInO1xuICB9XG5cbiAgaWYoIShhbGdvcml0aG0gaW4gX3N0YXRlcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU0hBLTUxMiBhbGdvcml0aG06ICcgKyBhbGdvcml0aG0pO1xuICB9XG5cbiAgLy8gU0hBLTUxMiBzdGF0ZSBjb250YWlucyBlaWdodCA2NC1iaXQgaW50ZWdlcnMgKGVhY2ggYXMgdHdvIDMyLWJpdCBpbnRzKVxuICB2YXIgX3N0YXRlID0gX3N0YXRlc1thbGdvcml0aG1dO1xuICB2YXIgX2ggPSBudWxsO1xuXG4gIC8vIGlucHV0IGJ1ZmZlclxuICB2YXIgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyB1c2VkIGZvciA2NC1iaXQgd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG4gIGZvcih2YXIgd2kgPSAwOyB3aSA8IDgwOyArK3dpKSB7XG4gICAgX3dbd2ldID0gbmV3IEFycmF5KDIpO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGRpZ2VzdCBsZW5ndGggYnkgYWxnb3JpdGhtIG5hbWUgKGRlZmF1bHQpXG4gIHZhciBkaWdlc3RMZW5ndGggPSA2NDtcbiAgc3dpdGNoKGFsZ29yaXRobSkge1xuICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgZGlnZXN0TGVuZ3RoID0gNDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdTSEEtNTEyLzI1Nic6XG4gICAgICBkaWdlc3RMZW5ndGggPSAzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1NIQS01MTIvMjI0JzpcbiAgICAgIGRpZ2VzdExlbmd0aCA9IDI4O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBtZXNzYWdlIGRpZ2VzdCBvYmplY3RcbiAgdmFyIG1kID0ge1xuICAgIC8vIFNIQS01MTIgPT4gc2hhNTEyXG4gICAgYWxnb3JpdGhtOiBhbGdvcml0aG0ucmVwbGFjZSgnLScsICcnKS50b0xvd2VyQ2FzZSgpLFxuICAgIGJsb2NrTGVuZ3RoOiAxMjgsXG4gICAgZGlnZXN0TGVuZ3RoOiBkaWdlc3RMZW5ndGgsXG4gICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgbWVzc2FnZUxlbmd0aDogMCxcbiAgICAvLyB0cnVlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgLy8gc2l6ZSBvZiBtZXNzYWdlIGxlbmd0aCBpbiBieXRlc1xuICAgIG1lc3NhZ2VMZW5ndGhTaXplOiAxNlxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoMTI4IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGgxMjggPSBbXTtcbiAgICB2YXIgaW50MzJzID0gbWQubWVzc2FnZUxlbmd0aFNpemUgLyA0O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGgucHVzaCgwKTtcbiAgICB9XG4gICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBfaCA9IG5ldyBBcnJheShfc3RhdGUubGVuZ3RoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgX3N0YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICBfaFtpXSA9IF9zdGF0ZVtpXS5zbGljZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfaCwgX3csIF9pbnB1dCk7XG5cbiAgICAvLyBjb21wYWN0IGlucHV0IGJ1ZmZlciBldmVyeSAySyBvciBpZiBlbXB0eVxuICAgIGlmKF9pbnB1dC5yZWFkID4gMjA0OCB8fCBfaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIF9pbnB1dC5jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgKi9cbiAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgLyogTm90ZTogSGVyZSB3ZSBjb3B5IHRoZSByZW1haW5pbmcgYnl0ZXMgaW4gdGhlIGlucHV0IGJ1ZmZlciBhbmRcbiAgICBhZGQgdGhlIGFwcHJvcHJpYXRlIFNIQS01MTIgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDg5NiBtb2QgMTAyNC4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDEwMjQgYml0cyAob3IgMTI4IGJ5dGVzKS5cbiAgICBUaGlzIGRhdGEgaW5jbHVkZXMgdGhlIG1lc3NhZ2UsIHNvbWUgcGFkZGluZywgYW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgbWVzc2FnZS4gU2luY2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSB3aWxsIGJlIGVuY29kZWQgYXMgMTYgYnl0ZXMgKDEyOFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgMTEyIGJ5dGVzXG4gICAgKDg5NiBiaXRzKSBvZiBtZXNzYWdlIGFuZCBwYWRkaW5nLiBUaGVyZWZvcmUsIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2VcbiAgICBwbHVzIHRoZSBwYWRkaW5nIG11c3QgYmUgY29uZ3J1ZW50IHRvIDg5NiBtb2QgMTAyNCBiZWNhdXNlXG4gICAgMTAyNCAtIDEyOCA9IDg5Ni5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gODk2IG1vZCAxMDI0LCB0aGVuIDEwMjQgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgaCA9IG5ldyBBcnJheShfaC5sZW5ndGgpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBfaC5sZW5ndGg7ICsraSkge1xuICAgICAgaFtpXSA9IF9oW2ldLnNsaWNlKDApO1xuICAgIH1cbiAgICBfdXBkYXRlKGgsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgdmFyIGhsZW47XG4gICAgaWYoYWxnb3JpdGhtID09PSAnU0hBLTUxMicpIHtcbiAgICAgIGhsZW4gPSBoLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYoYWxnb3JpdGhtID09PSAnU0hBLTM4NCcpIHtcbiAgICAgIGhsZW4gPSBoLmxlbmd0aCAtIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhsZW4gPSBoLmxlbmd0aCAtIDQ7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBobGVuOyArK2kpIHtcbiAgICAgIHJ2YWwucHV0SW50MzIoaFtpXVswXSk7XG4gICAgICBpZihpICE9PSBobGVuIC0gMSB8fCBhbGdvcml0aG0gIT09ICdTSEEtNTEyLzIyNCcpIHtcbiAgICAgICAgcnZhbC5wdXRJbnQzMihoW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTUxMiBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIHRhYmxlIG9mIGNvbnN0YW50c1xudmFyIF9rID0gbnVsbDtcblxuLy8gaW5pdGlhbCBoYXNoIHN0YXRlc1xudmFyIF9zdGF0ZXMgPSBudWxsO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjb25zdGFudCB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBjcmVhdGUgcGFkZGluZ1xuICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgX3BhZGRpbmcgKz0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCksIDEyOCk7XG5cbiAgLy8gY3JlYXRlIEsgdGFibGUgZm9yIFNIQS01MTJcbiAgX2sgPSBbXG4gICAgWzB4NDI4YTJmOTgsIDB4ZDcyOGFlMjJdLCBbMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZF0sXG4gICAgWzB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmZdLCBbMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiY10sXG4gICAgWzB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzhdLCBbMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOV0sXG4gICAgWzB4OTIzZjgyYTQsIDB4YWYxOTRmOWJdLCBbMHhhYjFjNWVkNSwgMHhkYTZkODExOF0sXG4gICAgWzB4ZDgwN2FhOTgsIDB4YTMwMzAyNDJdLCBbMHgxMjgzNWIwMSwgMHg0NTcwNmZiZV0sXG4gICAgWzB4MjQzMTg1YmUsIDB4NGVlNGIyOGNdLCBbMHg1NTBjN2RjMywgMHhkNWZmYjRlMl0sXG4gICAgWzB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmZdLCBbMHg4MGRlYjFmZSwgMHgzYjE2OTZiMV0sXG4gICAgWzB4OWJkYzA2YTcsIDB4MjVjNzEyMzVdLCBbMHhjMTliZjE3NCwgMHhjZjY5MjY5NF0sXG4gICAgWzB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDJdLCBbMHhlZmJlNDc4NiwgMHgzODRmMjVlM10sXG4gICAgWzB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjVdLCBbMHgyNDBjYTFjYywgMHg3N2FjOWM2NV0sXG4gICAgWzB4MmRlOTJjNmYsIDB4NTkyYjAyNzVdLCBbMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4M10sXG4gICAgWzB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDRdLCBbMHg3NmY5ODhkYSwgMHg4MzExNTNiNV0sXG4gICAgWzB4OTgzZTUxNTIsIDB4ZWU2NmRmYWJdLCBbMHhhODMxYzY2ZCwgMHgyZGI0MzIxMF0sXG4gICAgWzB4YjAwMzI3YzgsIDB4OThmYjIxM2ZdLCBbMHhiZjU5N2ZjNywgMHhiZWVmMGVlNF0sXG4gICAgWzB4YzZlMDBiZjMsIDB4M2RhODhmYzJdLCBbMHhkNWE3OTE0NywgMHg5MzBhYTcyNV0sXG4gICAgWzB4MDZjYTYzNTEsIDB4ZTAwMzgyNmZdLCBbMHgxNDI5Mjk2NywgMHgwYTBlNmU3MF0sXG4gICAgWzB4MjdiNzBhODUsIDB4NDZkMjJmZmNdLCBbMHgyZTFiMjEzOCwgMHg1YzI2YzkyNl0sXG4gICAgWzB4NGQyYzZkZmMsIDB4NWFjNDJhZWRdLCBbMHg1MzM4MGQxMywgMHg5ZDk1YjNkZl0sXG4gICAgWzB4NjUwYTczNTQsIDB4OGJhZjYzZGVdLCBbMHg3NjZhMGFiYiwgMHgzYzc3YjJhOF0sXG4gICAgWzB4ODFjMmM5MmUsIDB4NDdlZGFlZTZdLCBbMHg5MjcyMmM4NSwgMHgxNDgyMzUzYl0sXG4gICAgWzB4YTJiZmU4YTEsIDB4NGNmMTAzNjRdLCBbMHhhODFhNjY0YiwgMHhiYzQyMzAwMV0sXG4gICAgWzB4YzI0YjhiNzAsIDB4ZDBmODk3OTFdLCBbMHhjNzZjNTFhMywgMHgwNjU0YmUzMF0sXG4gICAgWzB4ZDE5MmU4MTksIDB4ZDZlZjUyMThdLCBbMHhkNjk5MDYyNCwgMHg1NTY1YTkxMF0sXG4gICAgWzB4ZjQwZTM1ODUsIDB4NTc3MTIwMmFdLCBbMHgxMDZhYTA3MCwgMHgzMmJiZDFiOF0sXG4gICAgWzB4MTlhNGMxMTYsIDB4YjhkMmQwYzhdLCBbMHgxZTM3NmMwOCwgMHg1MTQxYWI1M10sXG4gICAgWzB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTldLCBbMHgzNGIwYmNiNSwgMHhlMTliNDhhOF0sXG4gICAgWzB4MzkxYzBjYjMsIDB4YzVjOTVhNjNdLCBbMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYl0sXG4gICAgWzB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzNdLCBbMHg2ODJlNmZmMywgMHhkNmIyYjhhM10sXG4gICAgWzB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmNdLCBbMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MF0sXG4gICAgWzB4ODRjODc4MTQsIDB4YTFmMGFiNzJdLCBbMHg4Y2M3MDIwOCwgMHgxYTY0MzllY10sXG4gICAgWzB4OTBiZWZmZmEsIDB4MjM2MzFlMjhdLCBbMHhhNDUwNmNlYiwgMHhkZTgyYmRlOV0sXG4gICAgWzB4YmVmOWEzZjcsIDB4YjJjNjc5MTVdLCBbMHhjNjcxNzhmMiwgMHhlMzcyNTMyYl0sXG4gICAgWzB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWNdLCBbMHhkMTg2YjhjNywgMHgyMWMwYzIwN10sXG4gICAgWzB4ZWFkYTdkZDYsIDB4Y2RlMGViMWVdLCBbMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OF0sXG4gICAgWzB4MDZmMDY3YWEsIDB4NzIxNzZmYmFdLCBbMHgwYTYzN2RjNSwgMHhhMmM4OThhNl0sXG4gICAgWzB4MTEzZjk4MDQsIDB4YmVmOTBkYWVdLCBbMHgxYjcxMGIzNSwgMHgxMzFjNDcxYl0sXG4gICAgWzB4MjhkYjc3ZjUsIDB4MjMwNDdkODRdLCBbMHgzMmNhYWI3YiwgMHg0MGM3MjQ5M10sXG4gICAgWzB4M2M5ZWJlMGEsIDB4MTVjOWJlYmNdLCBbMHg0MzFkNjdjNCwgMHg5YzEwMGQ0Y10sXG4gICAgWzB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjZdLCBbMHg1OTdmMjk5YywgMHhmYzY1N2UyYV0sXG4gICAgWzB4NWZjYjZmYWIsIDB4M2FkNmZhZWNdLCBbMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN11cbiAgXTtcblxuICAvLyBpbml0aWFsIGhhc2ggc3RhdGVzXG4gIF9zdGF0ZXMgPSB7fTtcbiAgX3N0YXRlc1snU0hBLTUxMiddID0gW1xuICAgIFsweDZhMDllNjY3LCAweGYzYmNjOTA4XSxcbiAgICBbMHhiYjY3YWU4NSwgMHg4NGNhYTczYl0sXG4gICAgWzB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmJdLFxuICAgIFsweGE1NGZmNTNhLCAweDVmMWQzNmYxXSxcbiAgICBbMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMV0sXG4gICAgWzB4OWIwNTY4OGMsIDB4MmIzZTZjMWZdLFxuICAgIFsweDFmODNkOWFiLCAweGZiNDFiZDZiXSxcbiAgICBbMHg1YmUwY2QxOSwgMHgxMzdlMjE3OV1cbiAgXTtcbiAgX3N0YXRlc1snU0hBLTM4NCddID0gW1xuICAgIFsweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4XSxcbiAgICBbMHg2MjlhMjkyYSwgMHgzNjdjZDUwN10sXG4gICAgWzB4OTE1OTAxNWEsIDB4MzA3MGRkMTddLFxuICAgIFsweDE1MmZlY2Q4LCAweGY3MGU1OTM5XSxcbiAgICBbMHg2NzMzMjY2NywgMHhmZmMwMGIzMV0sXG4gICAgWzB4OGViNDRhODcsIDB4Njg1ODE1MTFdLFxuICAgIFsweGRiMGMyZTBkLCAweDY0Zjk4ZmE3XSxcbiAgICBbMHg0N2I1NDgxZCwgMHhiZWZhNGZhNF1cbiAgXTtcbiAgX3N0YXRlc1snU0hBLTUxMi8yNTYnXSA9IFtcbiAgICBbMHgyMjMxMjE5NCwgMHhGQzJCRjcyQ10sXG4gICAgWzB4OUY1NTVGQTMsIDB4Qzg0QzY0QzJdLFxuICAgIFsweDIzOTNCODZCLCAweDZGNTNCMTUxXSxcbiAgICBbMHg5NjM4NzcxOSwgMHg1OTQwRUFCRF0sXG4gICAgWzB4OTYyODNFRTIsIDB4QTg4RUZGRTNdLFxuICAgIFsweEJFNUUxRTI1LCAweDUzODYzOTkyXSxcbiAgICBbMHgyQjAxOTlGQywgMHgyQzg1QjhBQV0sXG4gICAgWzB4MEVCNzJEREMsIDB4ODFDNTJDQTJdXG4gIF07XG4gIF9zdGF0ZXNbJ1NIQS01MTIvMjI0J10gPSBbXG4gICAgWzB4OEMzRDM3QzgsIDB4MTk1NDREQTJdLFxuICAgIFsweDczRTE5OTY2LCAweDg5RENENEQ2XSxcbiAgICBbMHgxREZBQjdBRSwgMHgzMkZGOUM4Ml0sXG4gICAgWzB4Njc5REQ1MTQsIDB4NTgyRjlGQ0ZdLFxuICAgIFsweDBGNkQyQjY5LCAweDdCRDQ0REE4XSxcbiAgICBbMHg3N0UzNkY3MywgMHgwNEM0ODk0Ml0sXG4gICAgWzB4M0Y5RDg1QTgsIDB4NkExRDM2QzhdLFxuICAgIFsweDExMTJFNkFELCAweDkxRDY5MkExXVxuICBdO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtNTEyIHN0YXRlIHdpdGggdGhlIGdpdmVuIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzIHRoZSBTSEEtNTEyIHN0YXRlIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB3IHRoZSBhcnJheSB0byB1c2UgdG8gc3RvcmUgd29yZHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHVwZGF0ZSB3aXRoLlxuICovXG5mdW5jdGlvbiBfdXBkYXRlKHMsIHcsIGJ5dGVzKSB7XG4gIC8vIGNvbnN1bWUgNTEyIGJpdCAoMTI4IGJ5dGUpIGNodW5rc1xuICB2YXIgdDFfaGksIHQxX2xvO1xuICB2YXIgdDJfaGksIHQyX2xvO1xuICB2YXIgczBfaGksIHMwX2xvO1xuICB2YXIgczFfaGksIHMxX2xvO1xuICB2YXIgY2hfaGksIGNoX2xvO1xuICB2YXIgbWFqX2hpLCBtYWpfbG87XG4gIHZhciBhX2hpLCBhX2xvO1xuICB2YXIgYl9oaSwgYl9sbztcbiAgdmFyIGNfaGksIGNfbG87XG4gIHZhciBkX2hpLCBkX2xvO1xuICB2YXIgZV9oaSwgZV9sbztcbiAgdmFyIGZfaGksIGZfbG87XG4gIHZhciBnX2hpLCBnX2xvO1xuICB2YXIgaF9oaSwgaF9sbztcbiAgdmFyIGksIGhpLCBsbywgdzIsIHc3LCB3MTUsIHcxNjtcbiAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aCgpO1xuICB3aGlsZShsZW4gPj0gMTI4KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDY0LWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA2NCA2NC1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS01MTJcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB3W2ldWzBdID0gYnl0ZXMuZ2V0SW50MzIoKSA+Pj4gMDtcbiAgICAgIHdbaV1bMV0gPSBieXRlcy5nZXRJbnQzMigpID4+PiAwO1xuICAgIH1cbiAgICBmb3IoOyBpIDwgODA7ICsraSkge1xuICAgICAgLy8gZm9yIHdvcmQgMiB3b3JkcyBhZ286IFJPVFIgMTkoeCkgXiBST1RSIDYxKHgpIF4gU0hSIDYoeClcbiAgICAgIHcyID0gd1tpIC0gMl07XG4gICAgICBoaSA9IHcyWzBdO1xuICAgICAgbG8gPSB3MlsxXTtcblxuICAgICAgLy8gaGlnaCBiaXRzXG4gICAgICB0MV9oaSA9IChcbiAgICAgICAgKChoaSA+Pj4gMTkpIHwgKGxvIDw8IDEzKSkgXiAvLyBST1RSIDE5XG4gICAgICAgICgobG8gPj4+IDI5KSB8IChoaSA8PCAzKSkgXiAvLyBST1RSIDYxLyhzd2FwICsgUk9UUiAyOSlcbiAgICAgICAgKGhpID4+PiA2KSkgPj4+IDA7IC8vIFNIUiA2XG4gICAgICAvLyBsb3cgYml0c1xuICAgICAgdDFfbG8gPSAoXG4gICAgICAgICgoaGkgPDwgMTMpIHwgKGxvID4+PiAxOSkpIF4gLy8gUk9UUiAxOVxuICAgICAgICAoKGxvIDw8IDMpIHwgKGhpID4+PiAyOSkpIF4gLy8gUk9UUiA2MS8oc3dhcCArIFJPVFIgMjkpXG4gICAgICAgICgoaGkgPDwgMjYpIHwgKGxvID4+PiA2KSkpID4+PiAwOyAvLyBTSFIgNlxuXG4gICAgICAvLyBmb3Igd29yZCAxNSB3b3JkcyBhZ286IFJPVFIgMSh4KSBeIFJPVFIgOCh4KSBeIFNIUiA3KHgpXG4gICAgICB3MTUgPSB3W2kgLSAxNV07XG4gICAgICBoaSA9IHcxNVswXTtcbiAgICAgIGxvID0gdzE1WzFdO1xuXG4gICAgICAvLyBoaWdoIGJpdHNcbiAgICAgIHQyX2hpID0gKFxuICAgICAgICAoKGhpID4+PiAxKSB8IChsbyA8PCAzMSkpIF4gLy8gUk9UUiAxXG4gICAgICAgICgoaGkgPj4+IDgpIHwgKGxvIDw8IDI0KSkgXiAvLyBST1RSIDhcbiAgICAgICAgKGhpID4+PiA3KSkgPj4+IDA7IC8vIFNIUiA3XG4gICAgICAvLyBsb3cgYml0c1xuICAgICAgdDJfbG8gPSAoXG4gICAgICAgICgoaGkgPDwgMzEpIHwgKGxvID4+PiAxKSkgXiAvLyBST1RSIDFcbiAgICAgICAgKChoaSA8PCAyNCkgfCAobG8gPj4+IDgpKSBeIC8vIFJPVFIgOFxuICAgICAgICAoKGhpIDw8IDI1KSB8IChsbyA+Pj4gNykpKSA+Pj4gMDsgLy8gU0hSIDdcblxuICAgICAgLy8gc3VtKHQxLCB3b3JkIDcgYWdvLCB0Miwgd29yZCAxNiBhZ28pIG1vZHVsbyAyXjY0IChjYXJyeSBsbyBvdmVyZmxvdylcbiAgICAgIHc3ID0gd1tpIC0gN107XG4gICAgICB3MTYgPSB3W2kgLSAxNl07XG4gICAgICBsbyA9ICh0MV9sbyArIHc3WzFdICsgdDJfbG8gKyB3MTZbMV0pO1xuICAgICAgd1tpXVswXSA9ICh0MV9oaSArIHc3WzBdICsgdDJfaGkgKyB3MTZbMF0gK1xuICAgICAgICAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgICB3W2ldWzFdID0gbG8gPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYV9oaSA9IHNbMF1bMF07XG4gICAgYV9sbyA9IHNbMF1bMV07XG4gICAgYl9oaSA9IHNbMV1bMF07XG4gICAgYl9sbyA9IHNbMV1bMV07XG4gICAgY19oaSA9IHNbMl1bMF07XG4gICAgY19sbyA9IHNbMl1bMV07XG4gICAgZF9oaSA9IHNbM11bMF07XG4gICAgZF9sbyA9IHNbM11bMV07XG4gICAgZV9oaSA9IHNbNF1bMF07XG4gICAgZV9sbyA9IHNbNF1bMV07XG4gICAgZl9oaSA9IHNbNV1bMF07XG4gICAgZl9sbyA9IHNbNV1bMV07XG4gICAgZ19oaSA9IHNbNl1bMF07XG4gICAgZ19sbyA9IHNbNl1bMV07XG4gICAgaF9oaSA9IHNbN11bMF07XG4gICAgaF9sbyA9IHNbN11bMV07XG5cbiAgICAvLyByb3VuZCBmdW5jdGlvblxuICAgIGZvcihpID0gMDsgaSA8IDgwOyArK2kpIHtcbiAgICAgIC8vIFN1bTEoZSkgPSBST1RSIDE0KGUpIF4gUk9UUiAxOChlKSBeIFJPVFIgNDEoZSlcbiAgICAgIHMxX2hpID0gKFxuICAgICAgICAoKGVfaGkgPj4+IDE0KSB8IChlX2xvIDw8IDE4KSkgXiAvLyBST1RSIDE0XG4gICAgICAgICgoZV9oaSA+Pj4gMTgpIHwgKGVfbG8gPDwgMTQpKSBeIC8vIFJPVFIgMThcbiAgICAgICAgKChlX2xvID4+PiA5KSB8IChlX2hpIDw8IDIzKSkpID4+PiAwOyAvLyBST1RSIDQxLyhzd2FwICsgUk9UUiA5KVxuICAgICAgczFfbG8gPSAoXG4gICAgICAgICgoZV9oaSA8PCAxOCkgfCAoZV9sbyA+Pj4gMTQpKSBeIC8vIFJPVFIgMTRcbiAgICAgICAgKChlX2hpIDw8IDE0KSB8IChlX2xvID4+PiAxOCkpIF4gLy8gUk9UUiAxOFxuICAgICAgICAoKGVfbG8gPDwgMjMpIHwgKGVfaGkgPj4+IDkpKSkgPj4+IDA7IC8vIFJPVFIgNDEvKHN3YXAgKyBST1RSIDkpXG5cbiAgICAgIC8vIENoKGUsIGYsIGcpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgY2hfaGkgPSAoZ19oaSBeIChlX2hpICYgKGZfaGkgXiBnX2hpKSkpID4+PiAwO1xuICAgICAgY2hfbG8gPSAoZ19sbyBeIChlX2xvICYgKGZfbG8gXiBnX2xvKSkpID4+PiAwO1xuXG4gICAgICAvLyBTdW0wKGEpID0gUk9UUiAyOChhKSBeIFJPVFIgMzQoYSkgXiBST1RSIDM5KGEpXG4gICAgICBzMF9oaSA9IChcbiAgICAgICAgKChhX2hpID4+PiAyOCkgfCAoYV9sbyA8PCA0KSkgXiAvLyBST1RSIDI4XG4gICAgICAgICgoYV9sbyA+Pj4gMikgfCAoYV9oaSA8PCAzMCkpIF4gLy8gUk9UUiAzNC8oc3dhcCArIFJPVFIgMilcbiAgICAgICAgKChhX2xvID4+PiA3KSB8IChhX2hpIDw8IDI1KSkpID4+PiAwOyAvLyBST1RSIDM5Lyhzd2FwICsgUk9UUiA3KVxuICAgICAgczBfbG8gPSAoXG4gICAgICAgICgoYV9oaSA8PCA0KSB8IChhX2xvID4+PiAyOCkpIF4gLy8gUk9UUiAyOFxuICAgICAgICAoKGFfbG8gPDwgMzApIHwgKGFfaGkgPj4+IDIpKSBeIC8vIFJPVFIgMzQvKHN3YXAgKyBST1RSIDIpXG4gICAgICAgICgoYV9sbyA8PCAyNSkgfCAoYV9oaSA+Pj4gNykpKSA+Pj4gMDsgLy8gUk9UUiAzOS8oc3dhcCArIFJPVFIgNylcblxuICAgICAgLy8gTWFqKGEsIGIsIGMpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgbWFqX2hpID0gKChhX2hpICYgYl9oaSkgfCAoY19oaSAmIChhX2hpIF4gYl9oaSkpKSA+Pj4gMDtcbiAgICAgIG1hal9sbyA9ICgoYV9sbyAmIGJfbG8pIHwgKGNfbG8gJiAoYV9sbyBeIGJfbG8pKSkgPj4+IDA7XG5cbiAgICAgIC8vIG1haW4gYWxnb3JpdGhtXG4gICAgICAvLyB0MSA9IChoICsgczEgKyBjaCArIF9rW2ldICsgX3dbaV0pIG1vZHVsbyAyXjY0IChjYXJyeSBsbyBvdmVyZmxvdylcbiAgICAgIGxvID0gKGhfbG8gKyBzMV9sbyArIGNoX2xvICsgX2tbaV1bMV0gKyB3W2ldWzFdKTtcbiAgICAgIHQxX2hpID0gKGhfaGkgKyBzMV9oaSArIGNoX2hpICsgX2tbaV1bMF0gKyB3W2ldWzBdICtcbiAgICAgICAgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgICAgdDFfbG8gPSBsbyA+Pj4gMDtcblxuICAgICAgLy8gdDIgPSBzMCArIG1haiBtb2R1bG8gMl42NCAoY2FycnkgbG8gb3ZlcmZsb3cpXG4gICAgICBsbyA9IHMwX2xvICsgbWFqX2xvO1xuICAgICAgdDJfaGkgPSAoczBfaGkgKyBtYWpfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgICB0Ml9sbyA9IGxvID4+PiAwO1xuXG4gICAgICBoX2hpID0gZ19oaTtcbiAgICAgIGhfbG8gPSBnX2xvO1xuXG4gICAgICBnX2hpID0gZl9oaTtcbiAgICAgIGdfbG8gPSBmX2xvO1xuXG4gICAgICBmX2hpID0gZV9oaTtcbiAgICAgIGZfbG8gPSBlX2xvO1xuXG4gICAgICAvLyBlID0gKGQgKyB0MSkgbW9kdWxvIDJeNjQgKGNhcnJ5IGxvIG92ZXJmbG93KVxuICAgICAgbG8gPSBkX2xvICsgdDFfbG87XG4gICAgICBlX2hpID0gKGRfaGkgKyB0MV9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICAgIGVfbG8gPSBsbyA+Pj4gMDtcblxuICAgICAgZF9oaSA9IGNfaGk7XG4gICAgICBkX2xvID0gY19sbztcblxuICAgICAgY19oaSA9IGJfaGk7XG4gICAgICBjX2xvID0gYl9sbztcblxuICAgICAgYl9oaSA9IGFfaGk7XG4gICAgICBiX2xvID0gYV9sbztcblxuICAgICAgLy8gYSA9ICh0MSArIHQyKSBtb2R1bG8gMl42NCAoY2FycnkgbG8gb3ZlcmZsb3cpXG4gICAgICBsbyA9IHQxX2xvICsgdDJfbG87XG4gICAgICBhX2hpID0gKHQxX2hpICsgdDJfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgICBhX2xvID0gbG8gPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGUgKGFkZGl0aW9uYWwgbW9kdWxvIDJeNjQpXG4gICAgbG8gPSBzWzBdWzFdICsgYV9sbztcbiAgICBzWzBdWzBdID0gKHNbMF1bMF0gKyBhX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbMF1bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1sxXVsxXSArIGJfbG87XG4gICAgc1sxXVswXSA9IChzWzFdWzBdICsgYl9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzFdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbMl1bMV0gKyBjX2xvO1xuICAgIHNbMl1bMF0gPSAoc1syXVswXSArIGNfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1syXVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzNdWzFdICsgZF9sbztcbiAgICBzWzNdWzBdID0gKHNbM11bMF0gKyBkX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbM11bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1s0XVsxXSArIGVfbG87XG4gICAgc1s0XVswXSA9IChzWzRdWzBdICsgZV9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzRdWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsbyA9IHNbNV1bMV0gKyBmX2xvO1xuICAgIHNbNV1bMF0gPSAoc1s1XVswXSArIGZfaGkgKyAoKGxvIC8gMHgxMDAwMDAwMDApID4+PiAwKSkgPj4+IDA7XG4gICAgc1s1XVsxXSA9IGxvID4+PiAwO1xuXG4gICAgbG8gPSBzWzZdWzFdICsgZ19sbztcbiAgICBzWzZdWzBdID0gKHNbNl1bMF0gKyBnX2hpICsgKChsbyAvIDB4MTAwMDAwMDAwKSA+Pj4gMCkpID4+PiAwO1xuICAgIHNbNl1bMV0gPSBsbyA+Pj4gMDtcblxuICAgIGxvID0gc1s3XVsxXSArIGhfbG87XG4gICAgc1s3XVswXSA9IChzWzddWzBdICsgaF9oaSArICgobG8gLyAweDEwMDAwMDAwMCkgPj4+IDApKSA+Pj4gMDtcbiAgICBzWzddWzFdID0gbG8gPj4+IDA7XG5cbiAgICBsZW4gLT0gMTI4O1xuICB9XG59XG4iLCAiLyohIG5vYmxlLXNlY3AyNTZrMSAtIE1JVCBMaWNlbnNlIChjKSAyMDE5IFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0ICogYXMgbm9kZUNyeXB0byBmcm9tICdjcnlwdG8nO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzNuID0gQmlnSW50KDMpO1xuY29uc3QgXzhuID0gQmlnSW50KDgpO1xuY29uc3QgQ1VSVkUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBhOiBfMG4sXG4gICAgYjogQmlnSW50KDcpLFxuICAgIFA6IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyksXG4gICAgbjogQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKSxcbiAgICBoOiBfMW4sXG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG59KTtcbmV4cG9ydCB7IENVUlZFIH07XG5mdW5jdGlvbiB3ZWlzdHJhc3MoeCkge1xuICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgeDIgPSBtb2QoeCAqIHgpO1xuICAgIGNvbnN0IHgzID0gbW9kKHgyICogeCk7XG4gICAgcmV0dXJuIG1vZCh4MyArIGEgKiB4ICsgYik7XG59XG5jb25zdCBVU0VfRU5ET01PUlBISVNNID0gQ1VSVkUuYSA9PT0gXzBuO1xuY2xhc3MgU2hhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5jbGFzcyBKYWNvYmlhblBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB6KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIFBvaW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCNmcm9tQWZmaW5lOiBleHBlY3RlZCBQb2ludCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChwLngsIHAueSwgXzFuKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQWZmaW5lQmF0Y2gocG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHRvSW52ID0gaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC56KSk7XG4gICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSk7XG4gICAgfVxuICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC50b0FmZmluZUJhdGNoKHBvaW50cykubWFwKEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEphY29iaWFuUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCBleHBlY3RlZCcpO1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgeDogWDIsIHk6IFkyLCB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgcmV0dXJuIFUxID09PSBVMiAmJiBTMSA9PT0gUzI7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpLCB0aGlzLnopO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgQSA9IG1vZChYMSAqIFgxKTtcbiAgICAgICAgY29uc3QgQiA9IG1vZChZMSAqIFkxKTtcbiAgICAgICAgY29uc3QgQyA9IG1vZChCICogQik7XG4gICAgICAgIGNvbnN0IHgxYiA9IFgxICsgQjtcbiAgICAgICAgY29uc3QgRCA9IG1vZChfMm4gKiAobW9kKHgxYiAqIHgxYikgLSBBIC0gQykpO1xuICAgICAgICBjb25zdCBFID0gbW9kKF8zbiAqIEEpO1xuICAgICAgICBjb25zdCBGID0gbW9kKEUgKiBFKTtcbiAgICAgICAgY29uc3QgWDMgPSBtb2QoRiAtIF8ybiAqIEQpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChFICogKEQgLSBYMykgLSBfOG4gKiBDKTtcbiAgICAgICAgY29uc3QgWjMgPSBtb2QoXzJuICogWTEgKiBaMSk7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgSmFjb2JpYW5Qb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKYWNvYmlhblBvaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiBYMiwgeTogWTIsIHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgaWYgKFgyID09PSBfMG4gfHwgWTIgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoWDEgPT09IF8wbiB8fCBZMSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICBjb25zdCBaMVoxID0gbW9kKFoxICogWjEpO1xuICAgICAgICBjb25zdCBaMloyID0gbW9kKFoyICogWjIpO1xuICAgICAgICBjb25zdCBVMSA9IG1vZChYMSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBVMiA9IG1vZChYMiAqIFoxWjEpO1xuICAgICAgICBjb25zdCBTMSA9IG1vZChtb2QoWTEgKiBaMikgKiBaMloyKTtcbiAgICAgICAgY29uc3QgUzIgPSBtb2QobW9kKFkyICogWjEpICogWjFaMSk7XG4gICAgICAgIGNvbnN0IEggPSBtb2QoVTIgLSBVMSk7XG4gICAgICAgIGNvbnN0IHIgPSBtb2QoUzIgLSBTMSk7XG4gICAgICAgIGlmIChIID09PSBfMG4pIHtcbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgSEggPSBtb2QoSCAqIEgpO1xuICAgICAgICBjb25zdCBISEggPSBtb2QoSCAqIEhIKTtcbiAgICAgICAgY29uc3QgViA9IG1vZChVMSAqIEhIKTtcbiAgICAgICAgY29uc3QgWDMgPSBtb2QociAqIHIgLSBISEggLSBfMm4gKiBWKTtcbiAgICAgICAgY29uc3QgWTMgPSBtb2QociAqIChWIC0gWDMpIC0gUzEgKiBISEgpO1xuICAgICAgICBjb25zdCBaMyA9IG1vZChaMSAqIFoyICogSCk7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgIGNvbnN0IFAwID0gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICBpZiAodHlwZW9mIHNjYWxhciA9PT0gJ2JpZ2ludCcgJiYgc2NhbGFyID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gUDA7XG4gICAgICAgIGxldCBuID0gbm9ybWFsaXplU2NhbGFyKHNjYWxhcik7XG4gICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKCFVU0VfRU5ET01PUlBISVNNKSB7XG4gICAgICAgICAgICBsZXQgcCA9IFAwO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBzcGxpdFNjYWxhckVuZG8obik7XG4gICAgICAgIGxldCBrMXAgPSBQMDtcbiAgICAgICAgbGV0IGsycCA9IFAwO1xuICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgIGsycCA9IG5ldyBKYWNvYmlhblBvaW50KG1vZChrMnAueCAqIENVUlZFLmJldGEpLCBrMnAueSwgazJwLnopO1xuICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgIH1cbiAgICBwcmVjb21wdXRlV2luZG93KFcpIHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IFVTRV9FTkRPTU9SUEhJU00gPyAxMjggLyBXICsgMSA6IDI1NiAvIFcgKyAxO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAyICoqIChXIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHdOQUYobiwgYWZmaW5lUG9pbnQpIHtcbiAgICAgICAgaWYgKCFhZmZpbmVQb2ludCAmJiB0aGlzLmVxdWFscyhKYWNvYmlhblBvaW50LkJBU0UpKVxuICAgICAgICAgICAgYWZmaW5lUG9pbnQgPSBQb2ludC5CQVNFO1xuICAgICAgICBjb25zdCBXID0gKGFmZmluZVBvaW50ICYmIGFmZmluZVBvaW50Ll9XSU5ET1dfU0laRSkgfHwgMTtcbiAgICAgICAgaWYgKDI1NiAlIFcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQjd05BRjogSW52YWxpZCBwcmVjb21wdXRhdGlvbiB3aW5kb3csIG11c3QgYmUgcG93ZXIgb2YgMicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVjb21wdXRlcyA9IGFmZmluZVBvaW50ICYmIHBvaW50UHJlY29tcHV0ZXMuZ2V0KGFmZmluZVBvaW50KTtcbiAgICAgICAgaWYgKCFwcmVjb21wdXRlcykge1xuICAgICAgICAgICAgcHJlY29tcHV0ZXMgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coVyk7XG4gICAgICAgICAgICBpZiAoYWZmaW5lUG9pbnQgJiYgVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzID0gSmFjb2JpYW5Qb2ludC5ub3JtYWxpemVaKHByZWNvbXB1dGVzKTtcbiAgICAgICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLnNldChhZmZpbmVQb2ludCwgcHJlY29tcHV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwID0gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICBsZXQgZiA9IEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IDEgKyAoVVNFX0VORE9NT1JQSElTTSA/IDEyOCAvIFcgOiAyNTYgLyBXKTtcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTtcbiAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTtcbiAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBwciA9IHByZWNvbXB1dGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdyAlIDIpXG4gICAgICAgICAgICAgICAgICAgIHByID0gcHIubmVnYXRlKCk7XG4gICAgICAgICAgICAgICAgZiA9IGYuYWRkKHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjYWNoZWQgPSBwcmVjb21wdXRlc1tvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPCAwKVxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBjYWNoZWQubmVnYXRlKCk7XG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNhY2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIsIGFmZmluZVBvaW50KSB7XG4gICAgICAgIGxldCBuID0gbm9ybWFsaXplU2NhbGFyKHNjYWxhcik7XG4gICAgICAgIGxldCBwb2ludDtcbiAgICAgICAgbGV0IGZha2U7XG4gICAgICAgIGlmIChVU0VfRU5ET01PUlBISVNNKSB7XG4gICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBzcGxpdFNjYWxhckVuZG8obik7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBKYWNvYmlhblBvaW50KG1vZChrMnAueCAqIENVUlZFLmJldGEpLCBrMnAueSwgazJwLnopO1xuICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobiwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICB9XG4gICAgdG9BZmZpbmUoaW52WiA9IGludmVydCh0aGlzLnopKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaXoxID0gaW52WjtcbiAgICAgICAgY29uc3QgaXoyID0gbW9kKGl6MSAqIGl6MSk7XG4gICAgICAgIGNvbnN0IGl6MyA9IG1vZChpejIgKiBpejEpO1xuICAgICAgICBjb25zdCBheCA9IG1vZCh4ICogaXoyKTtcbiAgICAgICAgY29uc3QgYXkgPSBtb2QoeSAqIGl6Myk7XG4gICAgICAgIGNvbnN0IHp6ID0gbW9kKHogKiBpejEpO1xuICAgICAgICBpZiAoenogIT09IF8xbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGF4LCBheSk7XG4gICAgfVxufVxuSmFjb2JpYW5Qb2ludC5CQVNFID0gbmV3IEphY29iaWFuUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBfMW4pO1xuSmFjb2JpYW5Qb2ludC5aRVJPID0gbmV3IEphY29iaWFuUG9pbnQoXzBuLCBfMW4sIF8wbik7XG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICUgXzJuID09PSBfMG47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcHJlc3NlZEhleChieXRlcykge1xuICAgICAgICBjb25zdCBpc1Nob3J0ID0gYnl0ZXMubGVuZ3RoID09PSAzMjtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoaXNTaG9ydCA/IGJ5dGVzIDogYnl0ZXMuc3ViYXJyYXkoMSkpO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICBjb25zdCB5MiA9IHdlaXN0cmFzcyh4KTtcbiAgICAgICAgbGV0IHkgPSBzcXJ0TW9kKHkyKTtcbiAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgIGlmIChpc1Nob3J0KSB7XG4gICAgICAgICAgICBpZiAoaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBtb2QoLXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdEJ5dGVPZGQgPSAoYnl0ZXNbMF0gJiAxKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChpc0ZpcnN0Qnl0ZU9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBtb2QoLXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVW5jb21wcmVzc2VkSGV4KGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHggPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KDEsIDMzKSk7XG4gICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KDMzLCA2NSkpO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhoZXgpO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGJ5dGVzWzBdO1xuICAgICAgICBpZiAobGVuID09PSAzMiB8fCAobGVuID09PSAzMyAmJiAoaGVhZGVyID09PSAweDAyIHx8IGhlYWRlciA9PT0gMHgwMykpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQ29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gNjUgJiYgaGVhZGVyID09PSAweDA0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVVuY29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQuZnJvbUhleDogcmVjZWl2ZWQgaW52YWxpZCBwb2ludC4gRXhwZWN0ZWQgMzItMzMgY29tcHJlc3NlZCBieXRlcyBvciA2NSB1bmNvbXByZXNzZWQgYnl0ZXMsIG5vdCAke2xlbn1gKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2lnbmF0dXJlKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpIHtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBoID0gdHJ1bmNhdGVIYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBpZiAocmVjb3ZlcnkgIT09IDAgJiYgcmVjb3ZlcnkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlY292ZXIgc2lnbmF0dXJlOiBpbnZhbGlkIHJlY292ZXJ5IGJpdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHJlY292ZXJ5ICYgMSA/ICcwMycgOiAnMDInO1xuICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1UbzMyYlN0cihyKSk7XG4gICAgICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHJpbnYgPSBpbnZlcnQociwgbik7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKC1oICogcmludiwgbik7XG4gICAgICAgIGNvbnN0IHUyID0gbW9kKHMgKiByaW52LCBuKTtcbiAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTtcbiAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVjb3ZlciBzaWduYXR1cmU6IHBvaW50IGF0IGluZmluaWZ5Jyk7XG4gICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIFE7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleChpc0NvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgdG9IZXgoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeCA9IG51bVRvMzJiU3RyKHRoaXMueCk7XG4gICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuaGFzRXZlblkoKSA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke3h9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgMDQke3h9JHtudW1UbzMyYlN0cih0aGlzLnkpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9IZXhYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCh0cnVlKS5zbGljZSgyKTtcbiAgICB9XG4gICAgdG9SYXdYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ1BvaW50IGlzIG5vdCBvbiBlbGxpcHRpYyBjdXJ2ZSc7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpIHx8ICFpc1ZhbGlkRmllbGRFbGVtZW50KHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb2QoeSAqIHkpO1xuICAgICAgICBjb25zdCByaWdodCA9IHdlaXN0cmFzcyh4KTtcbiAgICAgICAgaWYgKG1vZChsZWZ0IC0gcmlnaHQpICE9PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55O1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCBtb2QoLXRoaXMueSkpO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUodGhpcykuZG91YmxlKCkudG9BZmZpbmUoKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUodGhpcykuYWRkKEphY29iaWFuUG9pbnQuZnJvbUFmZmluZShvdGhlcikpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLm11bHRpcGx5KHNjYWxhciwgdGhpcykudG9BZmZpbmUoKTtcbiAgICB9XG4gICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICBjb25zdCBQID0gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpO1xuICAgICAgICBjb25zdCBhUCA9IGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgdGhpcyAhPT0gUG9pbnQuQkFTRSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpO1xuICAgICAgICBjb25zdCBiUSA9IEphY29iaWFuUG9pbnQuZnJvbUFmZmluZShRKS5tdWx0aXBseVVuc2FmZShiKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYVAuYWRkKGJRKTtcbiAgICAgICAgcmV0dXJuIHN1bS5lcXVhbHMoSmFjb2JpYW5Qb2ludC5aRVJPKSA/IHVuZGVmaW5lZCA6IHN1bS50b0FmZmluZSgpO1xuICAgIH1cbn1cblBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5KTtcblBvaW50LlpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMG4pO1xuZnVuY3Rpb24gc2xpY2VERVIocykge1xuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpID49IDggPyAnMDAnICsgcyA6IHM7XG59XG5mdW5jdGlvbiBwYXJzZURFUkludChkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWc6ICR7Ynl0ZXNUb0hleChkYXRhKX1gKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aGApO1xuICAgIH1cbiAgICBpZiAocmVzWzBdID09PSAweDAwICYmIHJlc1sxXSA8PSAweDdmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdHJhaWxpbmcgbGVuZ3RoJyk7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IGJ5dGVzVG9OdW1iZXIocmVzKSwgbGVmdDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9O1xufVxuZnVuY3Rpb24gcGFyc2VERVJTaWduYXR1cmUoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmUgdGFnOiAke2J5dGVzVG9IZXgoZGF0YSl9YCk7XG4gICAgfVxuICAgIGlmIChkYXRhWzFdICE9PSBkYXRhLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGE6IHIsIGxlZnQ6IHNCeXRlcyB9ID0gcGFyc2VERVJJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgY29uc3QgeyBkYXRhOiBzLCBsZWZ0OiByQnl0ZXNMZWZ0IH0gPSBwYXJzZURFUkludChzQnl0ZXMpO1xuICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmc6ICR7Ynl0ZXNUb0hleChyQnl0ZXNMZWZ0KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgciwgcyB9O1xufVxuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgY29uc3QgYXJyID0gaGV4IGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgY29uc3QgbmFtZSA9ICdTaWduYXR1cmUuZnJvbUNvbXBhY3QnO1xuICAgICAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycgJiYgIWFycilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bmFtZX06IEV4cGVjdGVkIHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgICAgIGNvbnN0IHN0ciA9IGFyciA/IGJ5dGVzVG9IZXgoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggIT09IDEyOClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfTogRXhwZWN0ZWQgNjQtYnl0ZSBoZXhgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoaGV4VG9OdW1iZXIoc3RyLnNsaWNlKDAsIDY0KSksIGhleFRvTnVtYmVyKHN0ci5zbGljZSg2NCwgMTI4KSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgY29uc3QgYXJyID0gaGV4IGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnICYmICFhcnIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTaWduYXR1cmUuZnJvbURFUjogRXhwZWN0ZWQgc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBwYXJzZURFUlNpZ25hdHVyZShhcnIgPyBoZXggOiBoZXhUb0J5dGVzKGhleCkpO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21ERVIoaGV4KTtcbiAgICB9XG4gICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIocikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2lnbmF0dXJlOiByIG11c3QgYmUgMCA8IHIgPCBuJyk7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNpZ25hdHVyZTogcyBtdXN0IGJlIDAgPCBzIDwgbicpO1xuICAgIH1cbiAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFLm4gPj4gXzFuO1xuICAgICAgICByZXR1cm4gdGhpcy5zID4gSEFMRjtcbiAgICB9XG4gICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBDVVJWRS5uIC0gdGhpcy5zKSA6IHRoaXM7XG4gICAgfVxuICAgIHRvREVSUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0RFUkhleChpc0NvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgdG9ERVJIZXgoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc0hleCA9IHNsaWNlREVSKG51bWJlclRvSGV4VW5wYWRkZWQodGhpcy5zKSk7XG4gICAgICAgIGlmIChpc0NvbXByZXNzZWQpXG4gICAgICAgICAgICByZXR1cm4gc0hleDtcbiAgICAgICAgY29uc3QgckhleCA9IHNsaWNlREVSKG51bWJlclRvSGV4VW5wYWRkZWQodGhpcy5yKSk7XG4gICAgICAgIGNvbnN0IHJMZW4gPSBudW1iZXJUb0hleFVucGFkZGVkKHJIZXgubGVuZ3RoIC8gMik7XG4gICAgICAgIGNvbnN0IHNMZW4gPSBudW1iZXJUb0hleFVucGFkZGVkKHNIZXgubGVuZ3RoIC8gMik7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG51bWJlclRvSGV4VW5wYWRkZWQockhleC5sZW5ndGggLyAyICsgc0hleC5sZW5ndGggLyAyICsgNCk7XG4gICAgICAgIHJldHVybiBgMzAke2xlbmd0aH0wMiR7ckxlbn0ke3JIZXh9MDIke3NMZW59JHtzSGV4fWA7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvREVSUmF3Qnl0ZXMoKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvREVSSGV4KCk7XG4gICAgfVxuICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICB9XG4gICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICByZXR1cm4gbnVtVG8zMmJTdHIodGhpcy5yKSArIG51bVRvMzJiU3RyKHRoaXMucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgaWYgKCFhcnJheXMuZXZlcnkoKGIpID0+IGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGxpc3QgZXhwZWN0ZWQnKTtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICBpZiAoISh1aW50OGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuY29uc3QgUE9XXzJfMjU2ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG5mdW5jdGlvbiBudW1UbzMyYlN0cihudW0pIHtcbiAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYmlnaW50Jyk7XG4gICAgaWYgKCEoXzBuIDw9IG51bSAmJiBudW0gPCBQT1dfMl8yNTYpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG51bWJlciA8IDJeMjU2Jyk7XG4gICAgcmV0dXJuIG51bS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJyk7XG59XG5mdW5jdGlvbiBudW1UbzMyYihudW0pIHtcbiAgICBjb25zdCBiID0gaGV4VG9CeXRlcyhudW1UbzMyYlN0cihudW0pKTtcbiAgICBpZiAoYi5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yOiBleHBlY3RlZCAzMiBieXRlcycpO1xuICAgIHJldHVybiBiO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb051bWJlcjogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KGAweCR7aGV4fWApO1xufVxuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnICsgaGV4Lmxlbmd0aCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVCeXRlcyhoZXgpIHtcbiAgICByZXR1cm4gaGV4IGluc3RhbmNlb2YgVWludDhBcnJheSA/IFVpbnQ4QXJyYXkuZnJvbShoZXgpIDogaGV4VG9CeXRlcyhoZXgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2NhbGFyKG51bSkge1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pICYmIG51bSA+IDApXG4gICAgICAgIHJldHVybiBCaWdJbnQobnVtKTtcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgIHJldHVybiBudW07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsaWQgcHJpdmF0ZSBzY2FsYXI6IDAgPCBzY2FsYXIgPCBjdXJ2ZS5uJyk7XG59XG5mdW5jdGlvbiBtb2QoYSwgYiA9IENVUlZFLlApIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiBwb3cyKHgsIHBvd2VyKSB7XG4gICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gUDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHNxcnRNb2QoeCkge1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgXzZuID0gQmlnSW50KDYpO1xuICAgIGNvbnN0IF8xMW4gPSBCaWdJbnQoMTEpO1xuICAgIGNvbnN0IF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpO1xuICAgIGNvbnN0IF80NG4gPSBCaWdJbnQoNDQpO1xuICAgIGNvbnN0IF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHggKiB4ICogeCkgJSBQO1xuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB4KSAlIFA7XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybikgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbikgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4pICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4pICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4pICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbikgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbikgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4pICogYjIpICUgUDtcbiAgICByZXR1cm4gcG93Mih0MiwgXzJuKTtcbn1cbmZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbyA9IENVUlZFLlApIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuZnVuY3Rpb24gaW52ZXJ0QmF0Y2gobnVtcywgcCA9IENVUlZFLlApIHtcbiAgICBjb25zdCBzY3JhdGNoID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAobnVtID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBzY3JhdGNoW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgXzFuKTtcbiAgICBjb25zdCBpbnZlcnRlZCA9IGludmVydChsYXN0TXVsdGlwbGllZCwgcCk7XG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKG51bSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgc2NyYXRjaFtpXSA9IG1vZChhY2MgKiBzY3JhdGNoW2ldLCBwKTtcbiAgICAgICAgcmV0dXJuIG1vZChhY2MgKiBudW0sIHApO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gc2NyYXRjaDtcbn1cbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG5jb25zdCBFTkRPID0ge1xuICAgIGExOiBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKSxcbiAgICBiMTogLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpLFxuICAgIGEyOiBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyksXG4gICAgYjI6IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpLFxuICAgIFBPV18yXzEyODogQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpLFxufTtcbmZ1bmN0aW9uIHNwbGl0U2NhbGFyRW5kbyhrKSB7XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICBjb25zdCB7IGExLCBiMSwgYTIsIGIyLCBQT1dfMl8xMjggfSA9IEVORE87XG4gICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICBpZiAoazFuZWcpXG4gICAgICAgIGsxID0gbiAtIGsxO1xuICAgIGlmIChrMm5lZylcbiAgICAgICAgazIgPSBuIC0gazI7XG4gICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXJFbmRvOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbn1cbmZ1bmN0aW9uIHRydW5jYXRlSGFzaChoYXNoKSB7XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgZGVsdGEgPSBieXRlTGVuZ3RoICogOCAtIDI1NjtcbiAgICBsZXQgaCA9IGJ5dGVzVG9OdW1iZXIoaGFzaCk7XG4gICAgaWYgKGRlbHRhID4gMClcbiAgICAgICAgaCA9IGggPj4gQmlnSW50KGRlbHRhKTtcbiAgICBpZiAoaCA+PSBuKVxuICAgICAgICBoIC09IG47XG4gICAgcmV0dXJuIGg7XG59XG5sZXQgX3NoYTI1NlN5bmM7XG5sZXQgX2htYWNTaGEyNTZTeW5jO1xuY2xhc3MgSG1hY0RyYmcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnYgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgxKTtcbiAgICAgICAgdGhpcy5rID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgfVxuICAgIGhtYWMoLi4udmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5obWFjU2hhMjU2KHRoaXMuaywgLi4udmFsdWVzKTtcbiAgICB9XG4gICAgaG1hY1N5bmMoLi4udmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBfaG1hY1NoYTI1NlN5bmModGhpcy5rLCAuLi52YWx1ZXMpO1xuICAgIH1cbiAgICBjaGVja1N5bmMoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgX2htYWNTaGEyNTZTeW5jICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoYUVycm9yKCdobWFjU2hhMjU2U3luYyBuZWVkcyB0byBiZSBzZXQnKTtcbiAgICB9XG4gICAgaW5jcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY291bnRlciA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCAxLDAwMCBrIHZhbHVlcyBmb3Igc2lnbigpLCBhbGwgd2VyZSBpbnZhbGlkJyk7XG4gICAgICAgIHRoaXMuY291bnRlciArPSAxO1xuICAgIH1cbiAgICBhc3luYyByZXNlZWQoc2VlZCA9IG5ldyBVaW50OEFycmF5KCkpIHtcbiAgICAgICAgdGhpcy5rID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAwXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52KTtcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmsgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52LCBVaW50OEFycmF5LmZyb20oWzB4MDFdKSwgc2VlZCk7XG4gICAgICAgIHRoaXMudiA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYpO1xuICAgIH1cbiAgICByZXNlZWRTeW5jKHNlZWQgPSBuZXcgVWludDhBcnJheSgpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTeW5jKCk7XG4gICAgICAgIHRoaXMuayA9IHRoaXMuaG1hY1N5bmModGhpcy52LCBVaW50OEFycmF5LmZyb20oWzB4MDBdKSwgc2VlZCk7XG4gICAgICAgIHRoaXMudiA9IHRoaXMuaG1hY1N5bmModGhpcy52KTtcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmsgPSB0aGlzLmhtYWNTeW5jKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAxXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlKCkge1xuICAgICAgICB0aGlzLmluY3IoKTtcbiAgICAgICAgdGhpcy52ID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudik7XG4gICAgICAgIHJldHVybiB0aGlzLnY7XG4gICAgfVxuICAgIGdlbmVyYXRlU3luYygpIHtcbiAgICAgICAgdGhpcy5jaGVja1N5bmMoKTtcbiAgICAgICAgdGhpcy5pbmNyKCk7XG4gICAgICAgIHRoaXMudiA9IHRoaXMuaG1hY1N5bmModGhpcy52KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudjtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xufVxuZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLlA7XG59XG5mdW5jdGlvbiBrbWRUb1NpZyhrQnl0ZXMsIG0sIGQpIHtcbiAgICBjb25zdCBrID0gYnl0ZXNUb051bWJlcihrQnl0ZXMpO1xuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKTtcbiAgICBjb25zdCByID0gbW9kKHEueCwgbik7XG4gICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSBtb2QoaW52ZXJ0KGssIG4pICogbW9kKG0gKyBkICogciwgbiksIG4pO1xuICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBzaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgIGNvbnN0IHJlY292ZXJ5ID0gKHEueCA9PT0gc2lnLnIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTtcbiAgICByZXR1cm4geyBzaWcsIHJlY292ZXJ5IH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcml2YXRlS2V5KGtleSkge1xuICAgIGxldCBudW07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIG51bSA9IGtleTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoa2V5KSAmJiBrZXkgPiAwKSB7XG4gICAgICAgIG51bSA9IEJpZ0ludChrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gNjQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDMyIGJ5dGVzIG9mIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIG51bSA9IGhleFRvTnVtYmVyKGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgaWYgKGtleS5sZW5ndGggIT09IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAzMiBieXRlcyBvZiBwcml2YXRlIGtleScpO1xuICAgICAgICBudW0gPSBieXRlc1RvTnVtYmVyKGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB2YWxpZCBwcml2YXRlIGtleScpO1xuICAgIH1cbiAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHByaXZhdGUga2V5OiAwIDwga2V5IDwgbicpO1xuICAgIHJldHVybiBudW07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KSB7XG4gICAgaWYgKHB1YmxpY0tleSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIHB1YmxpY0tleS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gcHVibGljS2V5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgaWYgKHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSkge1xuICAgICAgICBzaWduYXR1cmUuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tREVSKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5LCBpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgIHJldHVybiBQb2ludC5mcm9tU2lnbmF0dXJlKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbn1cbmZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICBpZiAoYXJyKVxuICAgICAgICByZXR1cm4gbGVuID09PSAzMyB8fCBsZW4gPT09IDY1O1xuICAgIGlmIChzdHIpXG4gICAgICAgIHJldHVybiBsZW4gPT09IDY2IHx8IGxlbiA9PT0gMTMwO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldFNoYXJlZFNlY3JldDogZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0U2hhcmVkU2VjcmV0OiBzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgIGNvbnN0IGIgPSBub3JtYWxpemVQdWJsaWNLZXkocHVibGljQik7XG4gICAgYi5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiBiaXRzMmludChieXRlcykge1xuICAgIGNvbnN0IHNsaWNlID0gYnl0ZXMubGVuZ3RoID4gMzIgPyBieXRlcy5zbGljZSgwLCAzMikgOiBieXRlcztcbiAgICByZXR1cm4gYnl0ZXNUb051bWJlcihzbGljZSk7XG59XG5mdW5jdGlvbiBiaXRzMm9jdGV0cyhieXRlcykge1xuICAgIGNvbnN0IHoxID0gYml0czJpbnQoYnl0ZXMpO1xuICAgIGNvbnN0IHoyID0gbW9kKHoxLCBDVVJWRS5uKTtcbiAgICByZXR1cm4gaW50Mm9jdGV0cyh6MiA8IF8wbiA/IHoxIDogejIpO1xufVxuZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICByZXR1cm4gbnVtVG8zMmIobnVtKTtcbn1cbmZ1bmN0aW9uIGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZhdGVLZXksIGV4dHJhRW50cm9weSkge1xuICAgIGlmIChtc2dIYXNoID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbjogZXhwZWN0ZWQgdmFsaWQgbWVzc2FnZSBoYXNoLCBub3QgXCIke21zZ0hhc2h9XCJgKTtcbiAgICBjb25zdCBoMSA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgIGNvbnN0IGQgPSBub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGJpdHMyb2N0ZXRzKGgxKV07XG4gICAgaWYgKGV4dHJhRW50cm9weSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChleHRyYUVudHJvcHkgPT09IHRydWUpXG4gICAgICAgICAgICBleHRyYUVudHJvcHkgPSB1dGlscy5yYW5kb21CeXRlcygzMik7XG4gICAgICAgIGNvbnN0IGUgPSBlbnN1cmVCeXRlcyhleHRyYUVudHJvcHkpO1xuICAgICAgICBpZiAoZS5sZW5ndGggIT09IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBFeHBlY3RlZCAzMiBieXRlcyBvZiBleHRyYSBkYXRhJyk7XG4gICAgICAgIHNlZWRBcmdzLnB1c2goZSk7XG4gICAgfVxuICAgIGNvbnN0IHNlZWQgPSBjb25jYXRCeXRlcyguLi5zZWVkQXJncyk7XG4gICAgY29uc3QgbSA9IGJpdHMyaW50KGgxKTtcbiAgICByZXR1cm4geyBzZWVkLCBtLCBkIH07XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVNpZyhyZWNTaWcsIG9wdHMpIHtcbiAgICBsZXQgeyBzaWcsIHJlY292ZXJ5IH0gPSByZWNTaWc7XG4gICAgY29uc3QgeyBjYW5vbmljYWwsIGRlciwgcmVjb3ZlcmVkIH0gPSBPYmplY3QuYXNzaWduKHsgY2Fub25pY2FsOiB0cnVlLCBkZXI6IHRydWUgfSwgb3B0cyk7XG4gICAgaWYgKGNhbm9uaWNhbCAmJiBzaWcuaGFzSGlnaFMoKSkge1xuICAgICAgICBzaWcgPSBzaWcubm9ybWFsaXplUygpO1xuICAgICAgICByZWNvdmVyeSBePSAxO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBkZXIgPyBzaWcudG9ERVJSYXdCeXRlcygpIDogc2lnLnRvQ29tcGFjdFJhd0J5dGVzKCk7XG4gICAgcmV0dXJuIHJlY292ZXJlZCA/IFtoYXNoZWQsIHJlY292ZXJ5XSA6IGhhc2hlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBzZWVkLCBtLCBkIH0gPSBpbml0U2lnQXJncyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzLmV4dHJhRW50cm9weSk7XG4gICAgbGV0IHNpZztcbiAgICBjb25zdCBkcmJnID0gbmV3IEhtYWNEcmJnKCk7XG4gICAgYXdhaXQgZHJiZy5yZXNlZWQoc2VlZCk7XG4gICAgd2hpbGUgKCEoc2lnID0ga21kVG9TaWcoYXdhaXQgZHJiZy5nZW5lcmF0ZSgpLCBtLCBkKSkpXG4gICAgICAgIGF3YWl0IGRyYmcucmVzZWVkKCk7XG4gICAgcmV0dXJuIGZpbmFsaXplU2lnKHNpZywgb3B0cyk7XG59XG5mdW5jdGlvbiBzaWduU3luYyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBsZXQgc2lnO1xuICAgIGNvbnN0IGRyYmcgPSBuZXcgSG1hY0RyYmcoKTtcbiAgICBkcmJnLnJlc2VlZFN5bmMoc2VlZCk7XG4gICAgd2hpbGUgKCEoc2lnID0ga21kVG9TaWcoZHJiZy5nZW5lcmF0ZVN5bmMoKSwgbSwgZCkpKVxuICAgICAgICBkcmJnLnJlc2VlZFN5bmMoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydCB7IHNpZ24sIHNpZ25TeW5jIH07XG5jb25zdCB2b3B0cyA9IHsgc3RyaWN0OiB0cnVlIH07XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gdm9wdHMpIHtcbiAgICBsZXQgc2lnO1xuICAgIHRyeSB7XG4gICAgICAgIHNpZyA9IG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIGlmIChvcHRzLnN0cmljdCAmJiBzaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGggPSB0cnVuY2F0ZUhhc2gobXNnSGFzaCk7XG4gICAgbGV0IFA7XG4gICAgdHJ5IHtcbiAgICAgICAgUCA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIGNvbnN0IHNpbnYgPSBpbnZlcnQocywgbik7XG4gICAgY29uc3QgdTEgPSBtb2QoaCAqIHNpbnYsIG4pO1xuICAgIGNvbnN0IHUyID0gbW9kKHIgKiBzaW52LCBuKTtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpO1xuICAgIGlmICghUilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHYgPSBtb2QoUi54LCBuKTtcbiAgICByZXR1cm4gdiA9PT0gcjtcbn1cbmZ1bmN0aW9uIHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShjaCkge1xuICAgIHJldHVybiBtb2QoYnl0ZXNUb051bWJlcihjaCksIENVUlZFLm4pO1xufVxuY2xhc3MgU2Nobm9yclNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKGhleCk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDY0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2Nobm9yclNpZ25hdHVyZS5mcm9tSGV4OiBleHBlY3RlZCA2NCBieXRlcywgbm90ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hub3JyU2lnbmF0dXJlKHIsIHMpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQocikgfHwgIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYlN0cih0aGlzLnIpICsgbnVtVG8zMmJTdHIodGhpcy5zKTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleCgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdYKCk7XG59XG5jbGFzcyBJbnRlcm5hbFNjaG5vcnJTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSB1dGlscy5yYW5kb21CeXRlcygpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzaWduOiBFeHBlY3RlZCB2YWxpZCBtZXNzYWdlLCBub3QgXCIke21lc3NhZ2V9XCJgKTtcbiAgICAgICAgdGhpcy5tID0gZW5zdXJlQnl0ZXMobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHsgeCwgc2NhbGFyIH0gPSB0aGlzLmdldFNjYWxhcihub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgdGhpcy5weCA9IHg7XG4gICAgICAgIHRoaXMuZCA9IHNjYWxhcjtcbiAgICAgICAgdGhpcy5yYW5kID0gZW5zdXJlQnl0ZXMoYXV4UmFuZCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmQubGVuZ3RoICE9PSAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpZ246IEV4cGVjdGVkIDMyIGJ5dGVzIG9mIGF1eCByYW5kb21uZXNzJyk7XG4gICAgfVxuICAgIGdldFNjYWxhcihwcml2KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdik7XG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHBvaW50Lmhhc0V2ZW5ZKCkgPyBwcml2IDogQ1VSVkUubiAtIHByaXY7XG4gICAgICAgIHJldHVybiB7IHBvaW50LCBzY2FsYXIsIHg6IHBvaW50LnRvUmF3WCgpIH07XG4gICAgfVxuICAgIGluaXROb25jZShkLCB0MGgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiKGQgXiBieXRlc1RvTnVtYmVyKHQwaCkpO1xuICAgIH1cbiAgICBmaW5hbGl6ZU5vbmNlKGswaCkge1xuICAgICAgICBjb25zdCBrMCA9IG1vZChieXRlc1RvTnVtYmVyKGswaCksIENVUlZFLm4pO1xuICAgICAgICBpZiAoazAgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogQ3JlYXRpb24gb2Ygc2lnbmF0dXJlIGZhaWxlZC4gayBpcyB6ZXJvJyk7XG4gICAgICAgIGNvbnN0IHsgcG9pbnQ6IFIsIHg6IHJ4LCBzY2FsYXI6IGsgfSA9IHRoaXMuZ2V0U2NhbGFyKGswKTtcbiAgICAgICAgcmV0dXJuIHsgUiwgcngsIGsgfTtcbiAgICB9XG4gICAgZmluYWxpemVTaWcoUiwgaywgZSwgZCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaG5vcnJTaWduYXR1cmUoUi54LCBtb2QoayArIGUgKiBkLCBDVVJWRS5uKSkudG9SYXdCeXRlcygpO1xuICAgIH1cbiAgICBlcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIH1cbiAgICBhc3luYyBjYWxjKCkge1xuICAgICAgICBjb25zdCB7IG0sIGQsIHB4LCByYW5kIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YWcgPSB1dGlscy50YWdnZWRIYXNoO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgYXdhaXQgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZShhd2FpdCB0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIShhd2FpdCBzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gICAgY2FsY1N5bmMoKSB7XG4gICAgICAgIGNvbnN0IHsgbSwgZCwgcHgsIHJhbmQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhZyA9IHV0aWxzLnRhZ2dlZEhhc2hTeW5jO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZSh0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZSh0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIXNjaG5vcnJWZXJpZnlTeW5jKHNpZywgbSwgcHgpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJTaWduKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsYygpO1xufVxuZnVuY3Rpb24gc2Nobm9yclNpZ25TeW5jKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsY1N5bmMoKTtcbn1cbmZ1bmN0aW9uIGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgcmF3ID0gc2lnbmF0dXJlIGluc3RhbmNlb2YgU2Nobm9yclNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWcgPSByYXcgPyBzaWduYXR1cmUgOiBTY2hub3JyU2lnbmF0dXJlLmZyb21IZXgoc2lnbmF0dXJlKTtcbiAgICBpZiAocmF3KVxuICAgICAgICBzaWcuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zaWcsXG4gICAgICAgIG06IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpLFxuICAgICAgICBQOiBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpIHtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCBub3JtYWxpemVQcml2YXRlS2V5KHMpLCBtb2QoLWUsIENVUlZFLm4pKTtcbiAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnggIT09IHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB1dGlscy50YWdnZWRIYXNoKFRBR1MuY2hhbGxlbmdlLCBudW1UbzMyYihyKSwgUC50b1Jhd1goKSwgbSkpO1xuICAgICAgICByZXR1cm4gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnlTeW5jKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyByLCBzLCBtLCBQIH0gPSBpbml0U2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUodXRpbHMudGFnZ2VkSGFzaFN5bmMoVEFHUy5jaGFsbGVuZ2UsIG51bVRvMzJiKHIpLCBQLnRvUmF3WCgpLCBtKSk7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNjaG5vcnJWZXJpZnkociwgUCwgcywgZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTaGFFcnJvcilcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSB7XG4gICAgU2lnbmF0dXJlOiBTY2hub3JyU2lnbmF0dXJlLFxuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgc2lnblN5bmM6IHNjaG5vcnJTaWduU3luYyxcbiAgICB2ZXJpZnlTeW5jOiBzY2hub3JyVmVyaWZ5U3luYyxcbn07XG5Qb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuY29uc3QgY3J5cHRvID0ge1xuICAgIG5vZGU6IG5vZGVDcnlwdG8sXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbmNvbnN0IFRBR1MgPSB7XG4gICAgY2hhbGxlbmdlOiAnQklQMDM0MC9jaGFsbGVuZ2UnLFxuICAgIGF1eDogJ0JJUDAzNDAvYXV4JyxcbiAgICBub25jZTogJ0JJUDAzNDAvbm9uY2UnLFxufTtcbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBoZXhUb0J5dGVzLFxuICAgIGNvbmNhdEJ5dGVzLFxuICAgIG1vZCxcbiAgICBpbnZlcnQsXG4gICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfYmlnaW50VG8zMkJ5dGVzOiBudW1UbzMyYixcbiAgICBfbm9ybWFsaXplUHJpdmF0ZUtleTogbm9ybWFsaXplUHJpdmF0ZUtleSxcbiAgICBoYXNoVG9Qcml2YXRlS2V5OiAoaGFzaCkgPT4ge1xuICAgICAgICBoYXNoID0gZW5zdXJlQnl0ZXMoaGFzaCk7XG4gICAgICAgIGlmIChoYXNoLmxlbmd0aCA8IDQwIHx8IGhhc2gubGVuZ3RoID4gMTAyNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgNDAtMTAyNCBieXRlcyBvZiBwcml2YXRlIGtleSBhcyBwZXIgRklQUyAxODYnKTtcbiAgICAgICAgY29uc3QgbnVtID0gbW9kKGJ5dGVzVG9OdW1iZXIoaGFzaCksIENVUlZFLm4gLSBfMW4pICsgXzFuO1xuICAgICAgICByZXR1cm4gbnVtVG8zMmIobnVtKTtcbiAgICB9LFxuICAgIHJhbmRvbUJ5dGVzOiAoYnl0ZXNMZW5ndGggPSAzMikgPT4ge1xuICAgICAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by53ZWIuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZG9tQnl0ZXMgfSA9IGNyeXB0by5ub2RlO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyYW5kb21CeXRlcyhieXRlc0xlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbHMuaGFzaFRvUHJpdmF0ZUtleSh1dGlscy5yYW5kb21CeXRlcyg0MCkpO1xuICAgIH0sXG4gICAgc2hhMjU2OiBhc3luYyAoLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by53ZWIuc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGNvbmNhdEJ5dGVzKC4uLm1lc3NhZ2VzKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIYXNoIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG0pID0+IGhhc2gudXBkYXRlKG0pKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGFzaC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHNoYTI1NiBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaG1hY1NoYTI1NjogYXN5bmMgKGtleSwgLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNrZXkgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lOiAnSE1BQycsIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0gfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb25jYXRCeXRlcyguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5zaWduKCdITUFDJywgY2tleSwgbWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIbWFjIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobSkgPT4gaGFzaC51cGRhdGUobSkpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoYXNoLmRpZ2VzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgaG1hYy1zaGEyNTYgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNoYTI1NlN5bmM6IHVuZGVmaW5lZCxcbiAgICBobWFjU2hhMjU2U3luYzogdW5kZWZpbmVkLFxuICAgIHRhZ2dlZEhhc2g6IGFzeW5jICh0YWcsIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IGF3YWl0IHV0aWxzLnNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuc2hhMjU2KHRhZ1AsIC4uLm1lc3NhZ2VzKTtcbiAgICB9LFxuICAgIHRhZ2dlZEhhc2hTeW5jOiAodGFnLCAuLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIF9zaGEyNTZTeW5jICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoYUVycm9yKCdzaGEyNTZTeW5jIGlzIHVuZGVmaW5lZCwgeW91IG5lZWQgdG8gc2V0IGl0Jyk7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IF9zaGEyNTZTeW5jKFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2hhMjU2U3luYyh0YWdQLCAuLi5tZXNzYWdlcyk7XG4gICAgfSxcbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gcG9pbnQgPT09IFBvaW50LkJBU0UgPyBwb2ludCA6IG5ldyBQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgY2FjaGVkLl9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICBjYWNoZWQubXVsdGlwbHkoXzNuKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9LFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHV0aWxzLCB7XG4gICAgc2hhMjU2U3luYzoge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NoYTI1NlN5bmM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgIGlmICghX3NoYTI1NlN5bmMpXG4gICAgICAgICAgICAgICAgX3NoYTI1NlN5bmMgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBobWFjU2hhMjU2U3luYzoge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2htYWNTaGEyNTZTeW5jO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICBpZiAoIV9obWFjU2hhMjU2U3luYylcbiAgICAgICAgICAgICAgICBfaG1hY1NoYTI1NlN5bmMgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIi8qISBub2JsZS1lZDI1NTE5IC0gTUlUIExpY2Vuc2UgKGMpIDIwMTkgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgKiBhcyBub2RlQ3J5cHRvIGZyb20gJ2NyeXB0byc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBDVV9PID0gQmlnSW50KCc3MjM3MDA1NTc3MzMyMjYyMjEzOTczMTg2NTYzMDQyOTk0MjQwODU3MTE2MzU5Mzc5OTA3NjA2MDAxOTUwOTM4Mjg1NDU0MjUwOTg5Jyk7XG5jb25zdCBDVVJWRSA9IE9iamVjdC5mcmVlemUoe1xuICAgIGE6IEJpZ0ludCgtMSksXG4gICAgZDogQmlnSW50KCczNzA5NTcwNTkzNDY2OTQzOTM0MzEzODA4MzUwODc1NDU2NTE4OTU0MjExMzg3OTg0MzIxOTAxNjM4ODc4NTUzMzA4NTk0MDI4MzU1NScpLFxuICAgIFA6IEJpZ0ludCgnNTc4OTYwNDQ2MTg2NTgwOTc3MTE3ODU0OTI1MDQzNDM5NTM5MjY2MzQ5OTIzMzI4MjAyODIwMTk3Mjg3OTIwMDM5NTY1NjQ4MTk5NDknKSxcbiAgICBsOiBDVV9PLFxuICAgIG46IENVX08sXG4gICAgaDogQmlnSW50KDgpLFxuICAgIEd4OiBCaWdJbnQoJzE1MTEyMjIxMzQ5NTM1NDAwNzcyNTAxMTUxNDA5NTg4NTMxNTExNDU0MDEyNjkzMDQxODU3MjA2MDQ2MTEzMjgzOTQ5ODQ3NzYyMjAyJyksXG4gICAgR3k6IEJpZ0ludCgnNDYzMTY4MzU2OTQ5MjY0NzgxNjk0MjgzOTQwMDM0NzUxNjMxNDEzMDc5OTM4NjYyNTYyMjU2MTU3ODMwMzM2MDMxNjUyNTE4NTU5NjAnKSxcbn0pO1xuZXhwb3J0IHsgQ1VSVkUgfTtcbmNvbnN0IFBPV18yXzI1NiA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuY29uc3QgU1FSVF9NMSA9IEJpZ0ludCgnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInKTtcbmNvbnN0IFNRUlRfRCA9IEJpZ0ludCgnNjg1MzQ3NTIxOTQ5NzU2MTU4MTU3OTM1NzI3MTE5NzYyNDY0MjQ4Mjc5MDA3OTc4NTY1MDE5NzA0Njk1ODIxNTI4OTY4NzYwNDc0MicpO1xuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSBCaWdJbnQoJzI1MDYzMDY4OTUzMzg0NjIzNDc0MTExNDE0MTU4NzAyMTUyNzAxMjQ0NTMxNTAyNDkyNjU2NDYwMDc5MjEwNDgyNjEwNDMwNzUwMjM1Jyk7XG5jb25zdCBJTlZTUVJUX0FfTUlOVVNfRCA9IEJpZ0ludCgnNTQ0NjkzMDcwMDg5MDkzMTY5MjA5OTU4MTM4Njg3NDUxNDE2MDUzOTM1OTcyOTI5Mjc0NTY5MjEyMDUzMTI4OTYzMTE3MjEwMTc1NzgnKTtcbmNvbnN0IE9ORV9NSU5VU19EX1NRID0gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG5jb25zdCBEX01JTlVTX09ORV9TUSA9IEJpZ0ludCgnNDA0NDA4MzQzNDYzMDg1MzY4NTgxMDEwNDI0NjkzMjMxOTA4MjYyNDgzOTkxNDYyMzg3MDgzNTIyNDAxMzMyMjA4NjUxMzcyNjU5NTInKTtcbmNsYXNzIEV4dGVuZGVkUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHosIHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgdGhpcy50ID0gdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHRlbmRlZFBvaW50I2Zyb21BZmZpbmU6IGV4cGVjdGVkIFBvaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGVkUG9pbnQuWkVSTztcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlbmRlZFBvaW50KHAueCwgcC55LCBfMW4sIG1vZChwLnggKiBwLnkpKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQWZmaW5lQmF0Y2gocG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHRvSW52ID0gaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC56KSk7XG4gICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSk7XG4gICAgfVxuICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZUJhdGNoKHBvaW50cykubWFwKHRoaXMuZnJvbUFmZmluZSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBhc3NlcnRFeHRQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiBYMiwgeTogWTIsIHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgY29uc3QgWDFaMiA9IG1vZChYMSAqIFoyKTtcbiAgICAgICAgY29uc3QgWDJaMSA9IG1vZChYMiAqIFoxKTtcbiAgICAgICAgY29uc3QgWTFaMiA9IG1vZChZMSAqIFoyKTtcbiAgICAgICAgY29uc3QgWTJaMSA9IG1vZChZMiAqIFoxKTtcbiAgICAgICAgcmV0dXJuIFgxWjIgPT09IFgyWjEgJiYgWTFaMiA9PT0gWTJaMTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuZGVkUG9pbnQobW9kKC10aGlzLngpLCB0aGlzLnksIHRoaXMueiwgbW9kKC10aGlzLnQpKTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgYSB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IEEgPSBtb2QoWDEgKiBYMSk7XG4gICAgICAgIGNvbnN0IEIgPSBtb2QoWTEgKiBZMSk7XG4gICAgICAgIGNvbnN0IEMgPSBtb2QoXzJuICogbW9kKFoxICogWjEpKTtcbiAgICAgICAgY29uc3QgRCA9IG1vZChhICogQSk7XG4gICAgICAgIGNvbnN0IHgxeTEgPSBYMSArIFkxO1xuICAgICAgICBjb25zdCBFID0gbW9kKG1vZCh4MXkxICogeDF5MSkgLSBBIC0gQik7XG4gICAgICAgIGNvbnN0IEcgPSBEICsgQjtcbiAgICAgICAgY29uc3QgRiA9IEcgLSBDO1xuICAgICAgICBjb25zdCBIID0gRCAtIEI7XG4gICAgICAgIGNvbnN0IFgzID0gbW9kKEUgKiBGKTtcbiAgICAgICAgY29uc3QgWTMgPSBtb2QoRyAqIEgpO1xuICAgICAgICBjb25zdCBUMyA9IG1vZChFICogSCk7XG4gICAgICAgIGNvbnN0IFozID0gbW9kKEYgKiBHKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlbmRlZFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGFzc2VydEV4dFBvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyB4OiBYMSwgeTogWTEsIHo6IFoxLCB0OiBUMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiBYMiwgeTogWTIsIHo6IFoyLCB0OiBUMiB9ID0gb3RoZXI7XG4gICAgICAgIGNvbnN0IEEgPSBtb2QoKFkxIC0gWDEpICogKFkyICsgWDIpKTtcbiAgICAgICAgY29uc3QgQiA9IG1vZCgoWTEgKyBYMSkgKiAoWTIgLSBYMikpO1xuICAgICAgICBjb25zdCBGID0gbW9kKEIgLSBBKTtcbiAgICAgICAgaWYgKEYgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZSgpO1xuICAgICAgICBjb25zdCBDID0gbW9kKFoxICogXzJuICogVDIpO1xuICAgICAgICBjb25zdCBEID0gbW9kKFQxICogXzJuICogWjIpO1xuICAgICAgICBjb25zdCBFID0gRCArIEM7XG4gICAgICAgIGNvbnN0IEcgPSBCICsgQTtcbiAgICAgICAgY29uc3QgSCA9IEQgLSBDO1xuICAgICAgICBjb25zdCBYMyA9IG1vZChFICogRik7XG4gICAgICAgIGNvbnN0IFkzID0gbW9kKEcgKiBIKTtcbiAgICAgICAgY29uc3QgVDMgPSBtb2QoRSAqIEgpO1xuICAgICAgICBjb25zdCBaMyA9IG1vZChGICogRyk7XG4gICAgICAgIHJldHVybiBuZXcgRXh0ZW5kZWRQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgfVxuICAgIHByZWNvbXB1dGVXaW5kb3coVykge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gMSArIDI1NiAvIFc7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDIgKiogKFcgLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgd05BRihuLCBhZmZpbmVQb2ludCkge1xuICAgICAgICBpZiAoIWFmZmluZVBvaW50ICYmIHRoaXMuZXF1YWxzKEV4dGVuZGVkUG9pbnQuQkFTRSkpXG4gICAgICAgICAgICBhZmZpbmVQb2ludCA9IFBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IFcgPSAoYWZmaW5lUG9pbnQgJiYgYWZmaW5lUG9pbnQuX1dJTkRPV19TSVpFKSB8fCAxO1xuICAgICAgICBpZiAoMjU2ICUgVykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCN3TkFGOiBJbnZhbGlkIHByZWNvbXB1dGF0aW9uIHdpbmRvdywgbXVzdCBiZSBwb3dlciBvZiAyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWNvbXB1dGVzID0gYWZmaW5lUG9pbnQgJiYgcG9pbnRQcmVjb21wdXRlcy5nZXQoYWZmaW5lUG9pbnQpO1xuICAgICAgICBpZiAoIXByZWNvbXB1dGVzKSB7XG4gICAgICAgICAgICBwcmVjb21wdXRlcyA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhXKTtcbiAgICAgICAgICAgIGlmIChhZmZpbmVQb2ludCAmJiBXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcHJlY29tcHV0ZXMgPSBFeHRlbmRlZFBvaW50Lm5vcm1hbGl6ZVoocHJlY29tcHV0ZXMpO1xuICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KGFmZmluZVBvaW50LCBwcmVjb21wdXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAgPSBFeHRlbmRlZFBvaW50LlpFUk87XG4gICAgICAgIGxldCBmID0gRXh0ZW5kZWRQb2ludC5aRVJPO1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gMSArIDI1NiAvIFc7XG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7XG4gICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcHIgPSBwcmVjb21wdXRlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cgJSAyKVxuICAgICAgICAgICAgICAgICAgICBwciA9IHByLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIGYgPSBmLmFkZChwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FjaGVkID0gcHJlY29tcHV0ZXNbb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzIDwgMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gY2FjaGVkLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjYWNoZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFeHRlbmRlZFBvaW50Lm5vcm1hbGl6ZVooW3AsIGZdKVswXTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyLCBhZmZpbmVQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy53TkFGKG5vcm1hbGl6ZVNjYWxhcihzY2FsYXIsIENVUlZFLmwpLCBhZmZpbmVQb2ludCk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICBsZXQgbiA9IG5vcm1hbGl6ZVNjYWxhcihzY2FsYXIsIENVUlZFLmwsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgRyA9IEV4dGVuZGVkUG9pbnQuQkFTRTtcbiAgICAgICAgY29uc3QgUDAgPSBFeHRlbmRlZFBvaW50LlpFUk87XG4gICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gUDA7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhQMCkgfHwgbiA9PT0gXzFuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhHKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYobik7XG4gICAgICAgIGxldCBwID0gUDA7XG4gICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpLmVxdWFscyhFeHRlbmRlZFBvaW50LlpFUk8pO1xuICAgIH1cbiAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5sKS5lcXVhbHMoRXh0ZW5kZWRQb2ludC5aRVJPKTtcbiAgICB9XG4gICAgdG9BZmZpbmUoaW52WiA9IGludmVydCh0aGlzLnopKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYXggPSBtb2QoeCAqIGludlopO1xuICAgICAgICBjb25zdCBheSA9IG1vZCh5ICogaW52Wik7XG4gICAgICAgIGNvbnN0IHp6ID0gbW9kKHogKiBpbnZaKTtcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChheCwgYXkpO1xuICAgIH1cbiAgICBmcm9tUmlzdHJldHRvQnl0ZXMoKSB7XG4gICAgICAgIGxlZ2FjeVJpc3QoKTtcbiAgICB9XG4gICAgdG9SaXN0cmV0dG9CeXRlcygpIHtcbiAgICAgICAgbGVnYWN5UmlzdCgpO1xuICAgIH1cbiAgICBmcm9tUmlzdHJldHRvSGFzaCgpIHtcbiAgICAgICAgbGVnYWN5UmlzdCgpO1xuICAgIH1cbn1cbkV4dGVuZGVkUG9pbnQuQkFTRSA9IG5ldyBFeHRlbmRlZFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuLCBtb2QoQ1VSVkUuR3ggKiBDVVJWRS5HeSkpO1xuRXh0ZW5kZWRQb2ludC5aRVJPID0gbmV3IEV4dGVuZGVkUG9pbnQoXzBuLCBfMW4sIF8xbiwgXzBuKTtcbmZ1bmN0aW9uIGFzc2VydEV4dFBvaW50KG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBFeHRlbmRlZFBvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXh0ZW5kZWRQb2ludCBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UnN0UG9pbnQob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJpc3RyZXR0b1BvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeVJpc3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZWdhY3kgbWV0aG9kOiBzd2l0Y2ggdG8gUmlzdHJldHRvUG9pbnQnKTtcbn1cbmNsYXNzIFJpc3RyZXR0b1BvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihlcCkge1xuICAgICAgICB0aGlzLmVwID0gZXA7XG4gICAgfVxuICAgIHN0YXRpYyBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIwKSB7XG4gICAgICAgIGNvbnN0IHsgZCB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHIgPSBtb2QoU1FSVF9NMSAqIHIwICogcjApO1xuICAgICAgICBjb25zdCBOcyA9IG1vZCgociArIF8xbikgKiBPTkVfTUlOVVNfRF9TUSk7XG4gICAgICAgIGxldCBjID0gQmlnSW50KC0xKTtcbiAgICAgICAgY29uc3QgRCA9IG1vZCgoYyAtIGQgKiByKSAqIG1vZChyICsgZCkpO1xuICAgICAgICBsZXQgeyBpc1ZhbGlkOiBOc19EX2lzX3NxLCB2YWx1ZTogcyB9ID0gdXZSYXRpbyhOcywgRCk7XG4gICAgICAgIGxldCBzXyA9IG1vZChzICogcjApO1xuICAgICAgICBpZiAoIWVkSXNOZWdhdGl2ZShzXykpXG4gICAgICAgICAgICBzXyA9IG1vZCgtc18pO1xuICAgICAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgICAgICBzID0gc187XG4gICAgICAgIGlmICghTnNfRF9pc19zcSlcbiAgICAgICAgICAgIGMgPSByO1xuICAgICAgICBjb25zdCBOdCA9IG1vZChjICogKHIgLSBfMW4pICogRF9NSU5VU19PTkVfU1EgLSBEKTtcbiAgICAgICAgY29uc3QgczIgPSBzICogcztcbiAgICAgICAgY29uc3QgVzAgPSBtb2QoKHMgKyBzKSAqIEQpO1xuICAgICAgICBjb25zdCBXMSA9IG1vZChOdCAqIFNRUlRfQURfTUlOVVNfT05FKTtcbiAgICAgICAgY29uc3QgVzIgPSBtb2QoXzFuIC0gczIpO1xuICAgICAgICBjb25zdCBXMyA9IG1vZChfMW4gKyBzMik7XG4gICAgICAgIHJldHVybiBuZXcgRXh0ZW5kZWRQb2ludChtb2QoVzAgKiBXMyksIG1vZChXMiAqIFcxKSwgbW9kKFcxICogVzMpLCBtb2QoVzAgKiBXMikpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzaFRvQ3VydmUoaGV4KSB7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKGhleCwgNjQpO1xuICAgICAgICBjb25zdCByMSA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgUjEgPSB0aGlzLmNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjEpO1xuICAgICAgICBjb25zdCByMiA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMzIsIDY0KSk7XG4gICAgICAgIGNvbnN0IFIyID0gdGhpcy5jYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0cmV0dG9Qb2ludChSMS5hZGQoUjIpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKGhleCwgMzIpO1xuICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCBlbXNnID0gJ1Jpc3RyZXR0b1BvaW50LmZyb21IZXg6IHRoZSBoZXggaXMgbm90IHZhbGlkIGVuY29kaW5nIG9mIFJpc3RyZXR0b1BvaW50JztcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXgpO1xuICAgICAgICBpZiAoIWVxdWFsQnl0ZXMobnVtYmVyVG8zMkJ5dGVzTEUocyksIGhleCkgfHwgZWRJc05lZ2F0aXZlKHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuICAgICAgICBjb25zdCBzMiA9IG1vZChzICogcyk7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKF8xbiArIGEgKiBzMik7XG4gICAgICAgIGNvbnN0IHUyID0gbW9kKF8xbiAtIGEgKiBzMik7XG4gICAgICAgIGNvbnN0IHUxXzIgPSBtb2QodTEgKiB1MSk7XG4gICAgICAgIGNvbnN0IHUyXzIgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHYgPSBtb2QoYSAqIGQgKiB1MV8yIC0gdTJfMik7XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWU6IEkgfSA9IGludmVydFNxcnQobW9kKHYgKiB1Ml8yKSk7XG4gICAgICAgIGNvbnN0IER4ID0gbW9kKEkgKiB1Mik7XG4gICAgICAgIGNvbnN0IER5ID0gbW9kKEkgKiBEeCAqIHYpO1xuICAgICAgICBsZXQgeCA9IG1vZCgocyArIHMpICogRHgpO1xuICAgICAgICBpZiAoZWRJc05lZ2F0aXZlKHgpKVxuICAgICAgICAgICAgeCA9IG1vZCgteCk7XG4gICAgICAgIGNvbnN0IHkgPSBtb2QodTEgKiBEeSk7XG4gICAgICAgIGNvbnN0IHQgPSBtb2QoeCAqIHkpO1xuICAgICAgICBpZiAoIWlzVmFsaWQgfHwgZWRJc05lZ2F0aXZlKHQpIHx8IHkgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbXNnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0cmV0dG9Qb2ludChuZXcgRXh0ZW5kZWRQb2ludCh4LCB5LCBfMW4sIHQpKTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgbGV0IHsgeCwgeSwgeiwgdCB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QobW9kKHogKyB5KSAqIG1vZCh6IC0geSkpO1xuICAgICAgICBjb25zdCB1MiA9IG1vZCh4ICogeSk7XG4gICAgICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGludnNxcnQgfSA9IGludmVydFNxcnQobW9kKHUxICogdTJzcSkpO1xuICAgICAgICBjb25zdCBEMSA9IG1vZChpbnZzcXJ0ICogdTEpO1xuICAgICAgICBjb25zdCBEMiA9IG1vZChpbnZzcXJ0ICogdTIpO1xuICAgICAgICBjb25zdCB6SW52ID0gbW9kKEQxICogRDIgKiB0KTtcbiAgICAgICAgbGV0IEQ7XG4gICAgICAgIGlmIChlZElzTmVnYXRpdmUodCAqIHpJbnYpKSB7XG4gICAgICAgICAgICBsZXQgX3ggPSBtb2QoeSAqIFNRUlRfTTEpO1xuICAgICAgICAgICAgbGV0IF95ID0gbW9kKHggKiBTUVJUX00xKTtcbiAgICAgICAgICAgIHggPSBfeDtcbiAgICAgICAgICAgIHkgPSBfeTtcbiAgICAgICAgICAgIEQgPSBtb2QoRDEgKiBJTlZTUVJUX0FfTUlOVVNfRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBEID0gRDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkSXNOZWdhdGl2ZSh4ICogekludikpXG4gICAgICAgICAgICB5ID0gbW9kKC15KTtcbiAgICAgICAgbGV0IHMgPSBtb2QoKHogLSB5KSAqIEQpO1xuICAgICAgICBpZiAoZWRJc05lZ2F0aXZlKHMpKVxuICAgICAgICAgICAgcyA9IG1vZCgtcyk7XG4gICAgICAgIHJldHVybiBudW1iZXJUbzMyQnl0ZXNMRShzKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCBiID0gb3RoZXIuZXA7XG4gICAgICAgIGNvbnN0IG9uZSA9IG1vZChhLnggKiBiLnkpID09PSBtb2QoYS55ICogYi54KTtcbiAgICAgICAgY29uc3QgdHdvID0gbW9kKGEueSAqIGIueSkgPT09IG1vZChhLnggKiBiLngpO1xuICAgICAgICByZXR1cm4gb25lIHx8IHR3bztcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0cmV0dG9Qb2ludCh0aGlzLmVwLmFkZChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdHJldHRvUG9pbnQodGhpcy5lcC5zdWJ0cmFjdChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0cmV0dG9Qb2ludCh0aGlzLmVwLm11bHRpcGx5KHNjYWxhcikpO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0cmV0dG9Qb2ludCh0aGlzLmVwLm11bHRpcGx5VW5zYWZlKHNjYWxhcikpO1xuICAgIH1cbn1cblJpc3RyZXR0b1BvaW50LkJBU0UgPSBuZXcgUmlzdHJldHRvUG9pbnQoRXh0ZW5kZWRQb2ludC5CQVNFKTtcblJpc3RyZXR0b1BvaW50LlpFUk8gPSBuZXcgUmlzdHJldHRvUG9pbnQoRXh0ZW5kZWRQb2ludC5aRVJPKTtcbmNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgV2Vha01hcCgpO1xuY2xhc3MgUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgsIHN0cmljdCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkLCBQIH0gPSBDVVJWRTtcbiAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoaGV4LCAzMik7XG4gICAgICAgIGNvbnN0IG5vcm1lZCA9IGhleC5zbGljZSgpO1xuICAgICAgICBub3JtZWRbMzFdID0gaGV4WzMxXSAmIH4weDgwO1xuICAgICAgICBjb25zdCB5ID0gYnl0ZXNUb051bWJlckxFKG5vcm1lZCk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgeSA+PSBQKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAwIDwgaGV4IDwgUCcpO1xuICAgICAgICBpZiAoIXN0cmljdCAmJiB5ID49IFBPV18yXzI1NilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMCA8IGhleCA8IDIqKjI1NicpO1xuICAgICAgICBjb25zdCB5MiA9IG1vZCh5ICogeSk7XG4gICAgICAgIGNvbnN0IHUgPSBtb2QoeTIgLSBfMW4pO1xuICAgICAgICBjb25zdCB2ID0gbW9kKGQgKiB5MiArIF8xbik7XG4gICAgICAgIGxldCB7IGlzVmFsaWQsIHZhbHVlOiB4IH0gPSB1dlJhdGlvKHUsIHYpO1xuICAgICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG4gICAgICAgIGNvbnN0IGlzWE9kZCA9ICh4ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICBjb25zdCBpc0xhc3RCeXRlT2RkID0gKGhleFszMV0gJiAweDgwKSAhPT0gMDtcbiAgICAgICAgaWYgKGlzTGFzdEJ5dGVPZGQgIT09IGlzWE9kZCkge1xuICAgICAgICAgICAgeCA9IG1vZCgteCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2YXRlS2V5KSkucG9pbnQ7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbnVtYmVyVG8zMkJ5dGVzTEUodGhpcy55KTtcbiAgICAgICAgYnl0ZXNbMzFdIHw9IHRoaXMueCAmIF8xbiA/IDB4ODAgOiAwO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7XG4gICAgfVxuICAgIHRvWDI1NTE5KCkge1xuICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHUgPSBtb2QoKF8xbiArIHkpICogaW52ZXJ0KF8xbiAtIHkpKTtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvMzJCeXRlc0xFKHUpO1xuICAgIH1cbiAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICByZXR1cm4gRXh0ZW5kZWRQb2ludC5mcm9tQWZmaW5lKHRoaXMpLmlzVG9yc2lvbkZyZWUoKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55O1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQobW9kKC10aGlzLngpLCB0aGlzLnkpO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIEV4dGVuZGVkUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5hZGQoRXh0ZW5kZWRQb2ludC5mcm9tQWZmaW5lKG90aGVyKSkudG9BZmZpbmUoKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBFeHRlbmRlZFBvaW50LmZyb21BZmZpbmUodGhpcykubXVsdGlwbHkoc2NhbGFyLCB0aGlzKS50b0FmZmluZSgpO1xuICAgIH1cbn1cblBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5KTtcblBvaW50LlpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMW4pO1xuY2xhc3MgU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihyLCBzKSB7XG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoaGV4LCA2NCk7XG4gICAgICAgIGNvbnN0IHIgPSBQb2ludC5mcm9tSGV4KGJ5dGVzLnNsaWNlKDAsIDMyKSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckxFKGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICB9XG4gICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgUG9pbnQgaW5zdGFuY2UnKTtcbiAgICAgICAgbm9ybWFsaXplU2NhbGFyKHMsIENVUlZFLmwsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHU4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICB1OC5zZXQodGhpcy5yLnRvUmF3Qnl0ZXMoKSk7XG4gICAgICAgIHU4LnNldChudW1iZXJUbzMyQnl0ZXNMRSh0aGlzLnMpLCAzMik7XG4gICAgICAgIHJldHVybiB1ODtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcygpKTtcbiAgICB9XG59XG5leHBvcnQgeyBFeHRlbmRlZFBvaW50LCBSaXN0cmV0dG9Qb2ludCwgUG9pbnQsIFNpZ25hdHVyZSB9O1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgaWYgKCFhcnJheXMuZXZlcnkoKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5IGxpc3QnKTtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICBpZiAoISh1aW50OGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBudW1iZXJUbzMyQnl0ZXNCRShudW0pIHtcbiAgICBjb25zdCBsZW5ndGggPSAzMjtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbmd0aCAqIDIsICcwJyk7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4KTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvMzJCeXRlc0xFKG51bSkge1xuICAgIHJldHVybiBudW1iZXJUbzMyQnl0ZXNCRShudW0pLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGVkSXNOZWdhdGl2ZShudW0pIHtcbiAgICByZXR1cm4gKG1vZChudW0pICYgXzFuKSA9PT0gXzFuO1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKHVpbnQ4YSkge1xuICAgIGlmICghKHVpbnQ4YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQmlnSW50KCcweCcgKyBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbSh1aW50OGEpLnJldmVyc2UoKSkpO1xufVxuY29uc3QgTUFYXzI1NUIgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuZnVuY3Rpb24gYnl0ZXMyNTVUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIG1vZChieXRlc1RvTnVtYmVyTEUoYnl0ZXMpICYgTUFYXzI1NUIpO1xufVxuZnVuY3Rpb24gbW9kKGEsIGIgPSBDVVJWRS5QKSB7XG4gICAgY29uc3QgcmVzID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlcyA+PSBfMG4gPyByZXMgOiBiICsgcmVzO1xufVxuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvID0gQ1VSVkUuUCkge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBpbnZlcnRCYXRjaChudW1zLCBwID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKG51bSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgXzFuKTtcbiAgICBjb25zdCBpbnZlcnRlZCA9IGludmVydChsYXN0TXVsdGlwbGllZCwgcCk7XG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKG51bSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gbW9kKGFjYyAqIHRtcFtpXSwgcCk7XG4gICAgICAgIHJldHVybiBtb2QoYWNjICogbnVtLCBwKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIpIHtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBQO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcG93XzJfMjUyXzMoeCkge1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgXzVuID0gQmlnSW50KDUpO1xuICAgIGNvbnN0IF8xMG4gPSBCaWdJbnQoMTApO1xuICAgIGNvbnN0IF8yMG4gPSBCaWdJbnQoMjApO1xuICAgIGNvbnN0IF80MG4gPSBCaWdJbnQoNDApO1xuICAgIGNvbnN0IF84MG4gPSBCaWdJbnQoODApO1xuICAgIGNvbnN0IHgyID0gKHggKiB4KSAlIFA7XG4gICAgY29uc3QgYjIgPSAoeDIgKiB4KSAlIFA7XG4gICAgY29uc3QgYjQgPSAocG93MihiMiwgXzJuKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjUgPSAocG93MihiNCwgXzFuKSAqIHgpICUgUDtcbiAgICBjb25zdCBiMTAgPSAocG93MihiNSwgXzVuKSAqIGI1KSAlIFA7XG4gICAgY29uc3QgYjIwID0gKHBvdzIoYjEwLCBfMTBuKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IGI0MCA9IChwb3cyKGIyMCwgXzIwbikgKiBiMjApICUgUDtcbiAgICBjb25zdCBiODAgPSAocG93MihiNDAsIF80MG4pICogYjQwKSAlIFA7XG4gICAgY29uc3QgYjE2MCA9IChwb3cyKGI4MCwgXzgwbikgKiBiODApICUgUDtcbiAgICBjb25zdCBiMjQwID0gKHBvdzIoYjE2MCwgXzgwbikgKiBiODApICUgUDtcbiAgICBjb25zdCBiMjUwID0gKHBvdzIoYjI0MCwgXzEwbikgKiBiMTApICUgUDtcbiAgICBjb25zdCBwb3dfcF81XzggPSAocG93MihiMjUwLCBfMm4pICogeCkgJSBQO1xuICAgIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cbmZ1bmN0aW9uIHV2UmF0aW8odSwgdikge1xuICAgIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdik7XG4gICAgY29uc3QgdjcgPSBtb2QodjMgKiB2MyAqIHYpO1xuICAgIGNvbnN0IHBvdyA9IHBvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84O1xuICAgIGxldCB4ID0gbW9kKHUgKiB2MyAqIHBvdyk7XG4gICAgY29uc3QgdngyID0gbW9kKHYgKiB4ICogeCk7XG4gICAgY29uc3Qgcm9vdDEgPSB4O1xuICAgIGNvbnN0IHJvb3QyID0gbW9kKHggKiBTUVJUX00xKTtcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTtcbiAgICBjb25zdCB1c2VSb290MiA9IHZ4MiA9PT0gbW9kKC11KTtcbiAgICBjb25zdCBub1Jvb3QgPSB2eDIgPT09IG1vZCgtdSAqIFNRUlRfTTEpO1xuICAgIGlmICh1c2VSb290MSlcbiAgICAgICAgeCA9IHJvb3QxO1xuICAgIGlmICh1c2VSb290MiB8fCBub1Jvb3QpXG4gICAgICAgIHggPSByb290MjtcbiAgICBpZiAoZWRJc05lZ2F0aXZlKHgpKVxuICAgICAgICB4ID0gbW9kKC14KTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cbmZ1bmN0aW9uIGludmVydFNxcnQobnVtYmVyKSB7XG4gICAgcmV0dXJuIHV2UmF0aW8oXzFuLCBudW1iZXIpO1xufVxuZnVuY3Rpb24gbW9kbExFKGhhc2gpIHtcbiAgICByZXR1cm4gbW9kKGJ5dGVzVG9OdW1iZXJMRShoYXNoKSwgQ1VSVkUubCk7XG59XG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQnl0ZXMoaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGNvbnN0IGJ5dGVzID0gaGV4IGluc3RhbmNlb2YgVWludDhBcnJheSA/IFVpbnQ4QXJyYXkuZnJvbShoZXgpIDogaGV4VG9CeXRlcyhoZXgpO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGJ5dGVzLmxlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXNgKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTY2FsYXIobnVtLCBtYXgsIHN0cmljdCA9IHRydWUpIHtcbiAgICBpZiAoIW1heClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3BlY2lmeSBtYXggdmFsdWUnKTtcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSlcbiAgICAgICAgbnVtID0gQmlnSW50KG51bSk7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIG51bSA8IG1heCkge1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoXzBuIDwgbnVtKVxuICAgICAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoXzBuIDw9IG51bSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIHNjYWxhcjogMCA8IHNjYWxhciA8IG1heCcpO1xufVxuZnVuY3Rpb24gYWRqdXN0Qnl0ZXMyNTUxOShieXRlcykge1xuICAgIGJ5dGVzWzBdICY9IDI0ODtcbiAgICBieXRlc1szMV0gJj0gMTI3O1xuICAgIGJ5dGVzWzMxXSB8PSA2NDtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBkZWNvZGVTY2FsYXIyNTUxOShuKSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRShhZGp1c3RCeXRlczI1NTE5KGVuc3VyZUJ5dGVzKG4sIDMyKSkpO1xufVxuZnVuY3Rpb24gY2hlY2tQcml2YXRlS2V5KGtleSkge1xuICAgIGtleSA9XG4gICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnIHx8IHR5cGVvZiBrZXkgPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IG51bWJlclRvMzJCeXRlc0JFKG5vcm1hbGl6ZVNjYWxhcihrZXksIFBPV18yXzI1NikpXG4gICAgICAgICAgICA6IGVuc3VyZUJ5dGVzKGtleSk7XG4gICAgaWYgKGtleS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIDMyIGJ5dGVzYCk7XG4gICAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGdldEtleUZyb21IYXNoKGhhc2hlZCkge1xuICAgIGNvbnN0IGhlYWQgPSBhZGp1c3RCeXRlczI1NTE5KGhhc2hlZC5zbGljZSgwLCAzMikpO1xuICAgIGNvbnN0IHByZWZpeCA9IGhhc2hlZC5zbGljZSgzMiwgNjQpO1xuICAgIGNvbnN0IHNjYWxhciA9IG1vZGxMRShoZWFkKTtcbiAgICBjb25zdCBwb2ludCA9IFBvaW50LkJBU0UubXVsdGlwbHkoc2NhbGFyKTtcbiAgICBjb25zdCBwb2ludEJ5dGVzID0gcG9pbnQudG9SYXdCeXRlcygpO1xuICAgIHJldHVybiB7IGhlYWQsIHByZWZpeCwgc2NhbGFyLCBwb2ludCwgcG9pbnRCeXRlcyB9O1xufVxubGV0IF9zaGE1MTJTeW5jO1xuZnVuY3Rpb24gc2hhNTEycyguLi5tKSB7XG4gICAgaWYgKHR5cGVvZiBfc2hhNTEyU3luYyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dGlscy5zaGE1MTJTeW5jIG11c3QgYmUgc2V0IHRvIHVzZSBzeW5jIG1ldGhvZHMnKTtcbiAgICByZXR1cm4gX3NoYTUxMlN5bmMoLi4ubSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRFeHRlbmRlZFB1YmxpY0tleShrZXkpIHtcbiAgICByZXR1cm4gZ2V0S2V5RnJvbUhhc2goYXdhaXQgdXRpbHMuc2hhNTEyKGNoZWNrUHJpdmF0ZUtleShrZXkpKSk7XG59XG5mdW5jdGlvbiBnZXRFeHRlbmRlZFB1YmxpY0tleVN5bmMoa2V5KSB7XG4gICAgcmV0dXJuIGdldEtleUZyb21IYXNoKHNoYTUxMnMoY2hlY2tQcml2YXRlS2V5KGtleSkpKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiAoYXdhaXQgZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdmF0ZUtleSkpLnBvaW50Qnl0ZXM7XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlTeW5jKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXlTeW5jKHByaXZhdGVLZXkpLnBvaW50Qnl0ZXM7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KSB7XG4gICAgbWVzc2FnZSA9IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGF3YWl0IGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHIgPSBtb2RsTEUoYXdhaXQgdXRpbHMuc2hhNTEyKHByZWZpeCwgbWVzc2FnZSkpO1xuICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5KHIpO1xuICAgIGNvbnN0IGsgPSBtb2RsTEUoYXdhaXQgdXRpbHMuc2hhNTEyKFIudG9SYXdCeXRlcygpLCBwb2ludEJ5dGVzLCBtZXNzYWdlKSk7XG4gICAgY29uc3QgcyA9IG1vZChyICsgayAqIHNjYWxhciwgQ1VSVkUubCk7XG4gICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoUiwgcykudG9SYXdCeXRlcygpO1xufVxuZnVuY3Rpb24gc2lnblN5bmMobWVzc2FnZSwgcHJpdmF0ZUtleSkge1xuICAgIG1lc3NhZ2UgPSBlbnN1cmVCeXRlcyhtZXNzYWdlKTtcbiAgICBjb25zdCB7IHByZWZpeCwgc2NhbGFyLCBwb2ludEJ5dGVzIH0gPSBnZXRFeHRlbmRlZFB1YmxpY0tleVN5bmMocHJpdmF0ZUtleSk7XG4gICAgY29uc3QgciA9IG1vZGxMRShzaGE1MTJzKHByZWZpeCwgbWVzc2FnZSkpO1xuICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5KHIpO1xuICAgIGNvbnN0IGsgPSBtb2RsTEUoc2hhNTEycyhSLnRvUmF3Qnl0ZXMoKSwgcG9pbnRCeXRlcywgbWVzc2FnZSkpO1xuICAgIGNvbnN0IHMgPSBtb2QociArIGsgKiBzY2FsYXIsIENVUlZFLmwpO1xuICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKFIsIHMpLnRvUmF3Qnl0ZXMoKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVWZXJpZmljYXRpb24oc2lnLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBtZXNzYWdlID0gZW5zdXJlQnl0ZXMobWVzc2FnZSk7XG4gICAgaWYgKCEocHVibGljS2V5IGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICBwdWJsaWNLZXkgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSwgZmFsc2UpO1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlID8gc2lnLmFzc2VydFZhbGlkaXR5KCkgOiBTaWduYXR1cmUuZnJvbUhleChzaWcpO1xuICAgIGNvbnN0IFNCID0gRXh0ZW5kZWRQb2ludC5CQVNFLm11bHRpcGx5VW5zYWZlKHMpO1xuICAgIHJldHVybiB7IHIsIHMsIFNCLCBwdWI6IHB1YmxpY0tleSwgbXNnOiBtZXNzYWdlIH07XG59XG5mdW5jdGlvbiBmaW5pc2hWZXJpZmljYXRpb24ocHVibGljS2V5LCByLCBTQiwgaGFzaGVkKSB7XG4gICAgY29uc3QgayA9IG1vZGxMRShoYXNoZWQpO1xuICAgIGNvbnN0IGtBID0gRXh0ZW5kZWRQb2ludC5mcm9tQWZmaW5lKHB1YmxpY0tleSkubXVsdGlwbHlVbnNhZmUoayk7XG4gICAgY29uc3QgUmtBID0gRXh0ZW5kZWRQb2ludC5mcm9tQWZmaW5lKHIpLmFkZChrQSk7XG4gICAgcmV0dXJuIFJrQS5zdWJ0cmFjdChTQikubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCkuZXF1YWxzKEV4dGVuZGVkUG9pbnQuWkVSTyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5KHNpZywgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgeyByLCBTQiwgbXNnLCBwdWIgfSA9IHByZXBhcmVWZXJpZmljYXRpb24oc2lnLCBtZXNzYWdlLCBwdWJsaWNLZXkpO1xuICAgIGNvbnN0IGhhc2hlZCA9IGF3YWl0IHV0aWxzLnNoYTUxMihyLnRvUmF3Qnl0ZXMoKSwgcHViLnRvUmF3Qnl0ZXMoKSwgbXNnKTtcbiAgICByZXR1cm4gZmluaXNoVmVyaWZpY2F0aW9uKHB1YiwgciwgU0IsIGhhc2hlZCk7XG59XG5mdW5jdGlvbiB2ZXJpZnlTeW5jKHNpZywgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgeyByLCBTQiwgbXNnLCBwdWIgfSA9IHByZXBhcmVWZXJpZmljYXRpb24oc2lnLCBtZXNzYWdlLCBwdWJsaWNLZXkpO1xuICAgIGNvbnN0IGhhc2hlZCA9IHNoYTUxMnMoci50b1Jhd0J5dGVzKCksIHB1Yi50b1Jhd0J5dGVzKCksIG1zZyk7XG4gICAgcmV0dXJuIGZpbmlzaFZlcmlmaWNhdGlvbihwdWIsIHIsIFNCLCBoYXNoZWQpO1xufVxuZXhwb3J0IGNvbnN0IHN5bmMgPSB7XG4gICAgZ2V0RXh0ZW5kZWRQdWJsaWNLZXk6IGdldEV4dGVuZGVkUHVibGljS2V5U3luYyxcbiAgICBnZXRQdWJsaWNLZXk6IGdldFB1YmxpY0tleVN5bmMsXG4gICAgc2lnbjogc2lnblN5bmMsXG4gICAgdmVyaWZ5OiB2ZXJpZnlTeW5jLFxufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUtleSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgeyBoZWFkIH0gPSBhd2FpdCBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2YXRlS2V5KTtcbiAgICBjb25zdCB1ID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpLnRvWDI1NTE5KCk7XG4gICAgcmV0dXJuIGN1cnZlMjU1MTkuc2NhbGFyTXVsdChoZWFkLCB1KTtcbn1cblBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG5mdW5jdGlvbiBjc3dhcChzd2FwLCB4XzIsIHhfMykge1xuICAgIGNvbnN0IGR1bW15ID0gbW9kKHN3YXAgKiAoeF8yIC0geF8zKSk7XG4gICAgeF8yID0gbW9kKHhfMiAtIGR1bW15KTtcbiAgICB4XzMgPSBtb2QoeF8zICsgZHVtbXkpO1xuICAgIHJldHVybiBbeF8yLCB4XzNdO1xufVxuZnVuY3Rpb24gbW9udGdvbWVyeUxhZGRlcihwb2ludFUsIHNjYWxhcikge1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgdSA9IG5vcm1hbGl6ZVNjYWxhcihwb2ludFUsIFApO1xuICAgIGNvbnN0IGsgPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyLCBQKTtcbiAgICBjb25zdCBhMjQgPSBCaWdJbnQoMTIxNjY1KTtcbiAgICBjb25zdCB4XzEgPSB1O1xuICAgIGxldCB4XzIgPSBfMW47XG4gICAgbGV0IHpfMiA9IF8wbjtcbiAgICBsZXQgeF8zID0gdTtcbiAgICBsZXQgel8zID0gXzFuO1xuICAgIGxldCBzd2FwID0gXzBuO1xuICAgIGxldCBzdztcbiAgICBmb3IgKGxldCB0ID0gQmlnSW50KDI1NSAtIDEpOyB0ID49IF8wbjsgdC0tKSB7XG4gICAgICAgIGNvbnN0IGtfdCA9IChrID4+IHQpICYgXzFuO1xuICAgICAgICBzd2FwIF49IGtfdDtcbiAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB4XzIsIHhfMyk7XG4gICAgICAgIHhfMiA9IHN3WzBdO1xuICAgICAgICB4XzMgPSBzd1sxXTtcbiAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICB6XzMgPSBzd1sxXTtcbiAgICAgICAgc3dhcCA9IGtfdDtcbiAgICAgICAgY29uc3QgQSA9IHhfMiArIHpfMjtcbiAgICAgICAgY29uc3QgQUEgPSBtb2QoQSAqIEEpO1xuICAgICAgICBjb25zdCBCID0geF8yIC0gel8yO1xuICAgICAgICBjb25zdCBCQiA9IG1vZChCICogQik7XG4gICAgICAgIGNvbnN0IEUgPSBBQSAtIEJCO1xuICAgICAgICBjb25zdCBDID0geF8zICsgel8zO1xuICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuICAgICAgICBjb25zdCBEQSA9IG1vZChEICogQSk7XG4gICAgICAgIGNvbnN0IENCID0gbW9kKEMgKiBCKTtcbiAgICAgICAgY29uc3QgZGFjYiA9IERBICsgQ0I7XG4gICAgICAgIGNvbnN0IGRhX2NiID0gREEgLSBDQjtcbiAgICAgICAgeF8zID0gbW9kKGRhY2IgKiBkYWNiKTtcbiAgICAgICAgel8zID0gbW9kKHhfMSAqIG1vZChkYV9jYiAqIGRhX2NiKSk7XG4gICAgICAgIHhfMiA9IG1vZChBQSAqIEJCKTtcbiAgICAgICAgel8yID0gbW9kKEUgKiAoQUEgKyBtb2QoYTI0ICogRSkpKTtcbiAgICB9XG4gICAgc3cgPSBjc3dhcChzd2FwLCB4XzIsIHhfMyk7XG4gICAgeF8yID0gc3dbMF07XG4gICAgeF8zID0gc3dbMV07XG4gICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgel8yID0gc3dbMF07XG4gICAgel8zID0gc3dbMV07XG4gICAgY29uc3QgeyBwb3dfcF81XzgsIGIyIH0gPSBwb3dfMl8yNTJfMyh6XzIpO1xuICAgIGNvbnN0IHhwMiA9IG1vZChwb3cyKHBvd19wXzVfOCwgQmlnSW50KDMpKSAqIGIyKTtcbiAgICByZXR1cm4gbW9kKHhfMiAqIHhwMik7XG59XG5mdW5jdGlvbiBlbmNvZGVVQ29vcmRpbmF0ZSh1KSB7XG4gICAgcmV0dXJuIG51bWJlclRvMzJCeXRlc0xFKG1vZCh1LCBDVVJWRS5QKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVVQ29vcmRpbmF0ZSh1RW5jKSB7XG4gICAgY29uc3QgdSA9IGVuc3VyZUJ5dGVzKHVFbmMsIDMyKTtcbiAgICB1WzMxXSAmPSAxMjc7XG4gICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRSh1KTtcbn1cbmV4cG9ydCBjb25zdCBjdXJ2ZTI1NTE5ID0ge1xuICAgIEJBU0VfUE9JTlRfVTogJzA5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgIHNjYWxhck11bHQocHJpdmF0ZUtleSwgcHVibGljS2V5KSB7XG4gICAgICAgIGNvbnN0IHUgPSBkZWNvZGVVQ29vcmRpbmF0ZShwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBwID0gZGVjb2RlU2NhbGFyMjU1MTkocHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IHB1ID0gbW9udGdvbWVyeUxhZGRlcih1LCBwKTtcbiAgICAgICAgaWYgKHB1ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5IHJlY2VpdmVkJyk7XG4gICAgICAgIHJldHVybiBlbmNvZGVVQ29vcmRpbmF0ZShwdSk7XG4gICAgfSxcbiAgICBzY2FsYXJNdWx0QmFzZShwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiBjdXJ2ZTI1NTE5LnNjYWxhck11bHQocHJpdmF0ZUtleSwgY3VydmUyNTUxOS5CQVNFX1BPSU5UX1UpO1xuICAgIH0sXG59O1xuY29uc3QgY3J5cHRvID0ge1xuICAgIG5vZGU6IG5vZGVDcnlwdG8sXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgICBieXRlc1RvSGV4LFxuICAgIGhleFRvQnl0ZXMsXG4gICAgY29uY2F0Qnl0ZXMsXG4gICAgZ2V0RXh0ZW5kZWRQdWJsaWNLZXksXG4gICAgbW9kLFxuICAgIGludmVydCxcbiAgICBUT1JTSU9OX1NVQkdST1VQOiBbXG4gICAgICAgICcwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAgICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuICAgICAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MCcsXG4gICAgICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzA1JyxcbiAgICAgICAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuICAgICAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmM4NScsXG4gICAgICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAgICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuICAgIF0sXG4gICAgaGFzaFRvUHJpdmF0ZVNjYWxhcjogKGhhc2gpID0+IHtcbiAgICAgICAgaGFzaCA9IGVuc3VyZUJ5dGVzKGhhc2gpO1xuICAgICAgICBpZiAoaGFzaC5sZW5ndGggPCA0MCB8fCBoYXNoLmxlbmd0aCA+IDEwMjQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDQwLTEwMjQgYnl0ZXMgb2YgcHJpdmF0ZSBrZXkgYXMgcGVyIEZJUFMgMTg2Jyk7XG4gICAgICAgIHJldHVybiBtb2QoYnl0ZXNUb051bWJlckxFKGhhc2gpLCBDVVJWRS5sIC0gXzFuKSArIF8xbjtcbiAgICB9LFxuICAgIHJhbmRvbUJ5dGVzOiAoYnl0ZXNMZW5ndGggPSAzMikgPT4ge1xuICAgICAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by53ZWIuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZG9tQnl0ZXMgfSA9IGNyeXB0by5ub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbHMucmFuZG9tQnl0ZXMoMzIpO1xuICAgIH0sXG4gICAgc2hhNTEyOiBhc3luYyAoLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNvbmNhdEJ5dGVzKC4uLm1lc3NhZ2VzKTtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by53ZWIuc3VidGxlLmRpZ2VzdCgnU0hBLTUxMicsIG1lc3NhZ2UuYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNyeXB0by5ub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNyeXB0by5ub2RlLmNyZWF0ZUhhc2goJ3NoYTUxMicpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHNoYTUxMiBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHBvaW50LmVxdWFscyhQb2ludC5CQVNFKSA/IHBvaW50IDogbmV3IFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBjYWNoZWQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgIGNhY2hlZC5tdWx0aXBseShfMm4pO1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH0sXG4gICAgc2hhNTEyU3luYzogdW5kZWZpbmVkLFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHV0aWxzLCB7XG4gICAgc2hhNTEyU3luYzoge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NoYTUxMlN5bmM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgIGlmICghX3NoYTUxMlN5bmMpXG4gICAgICAgICAgICAgICAgX3NoYTUxMlN5bmMgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwgIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZsYWcsIGFyZ3YgPSBwcm9jZXNzLmFyZ3YpID0+IHtcblx0Y29uc3QgcHJlZml4ID0gZmxhZy5zdGFydHNXaXRoKCctJykgPyAnJyA6IChmbGFnLmxlbmd0aCA9PT0gMSA/ICctJyA6ICctLScpO1xuXHRjb25zdCBwb3NpdGlvbiA9IGFyZ3YuaW5kZXhPZihwcmVmaXggKyBmbGFnKTtcblx0Y29uc3QgdGVybWluYXRvclBvc2l0aW9uID0gYXJndi5pbmRleE9mKCctLScpO1xuXHRyZXR1cm4gcG9zaXRpb24gIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zaXRpb24gPT09IC0xIHx8IHBvc2l0aW9uIDwgdGVybWluYXRvclBvc2l0aW9uKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCBoYXNGbGFnID0gcmVxdWlyZSgnaGFzLWZsYWcnKTtcblxuY29uc3Qge2Vudn0gPSBwcm9jZXNzO1xuXG5sZXQgZm9yY2VDb2xvcjtcbmlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykgfHxcblx0aGFzRmxhZygnY29sb3I9bmV2ZXInKSkge1xuXHRmb3JjZUNvbG9yID0gMDtcbn0gZWxzZSBpZiAoaGFzRmxhZygnY29sb3InKSB8fFxuXHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0aGFzRmxhZygnY29sb3I9YWx3YXlzJykpIHtcblx0Zm9yY2VDb2xvciA9IDE7XG59XG5cbmlmICgnRk9SQ0VfQ09MT1InIGluIGVudikge1xuXHRpZiAoZW52LkZPUkNFX0NPTE9SID09PSAndHJ1ZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMTtcblx0fSBlbHNlIGlmIChlbnYuRk9SQ0VfQ09MT1IgPT09ICdmYWxzZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMDtcblx0fSBlbHNlIHtcblx0XHRmb3JjZUNvbG9yID0gZW52LkZPUkNFX0NPTE9SLmxlbmd0aCA9PT0gMCA/IDEgOiBNYXRoLm1pbihwYXJzZUludChlbnYuRk9SQ0VfQ09MT1IsIDEwKSwgMyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpIHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ29sb3IoaGF2ZVN0cmVhbSwgc3RyZWFtSXNUVFkpIHtcblx0aWYgKGZvcmNlQ29sb3IgPT09IDApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmIChoYXZlU3RyZWFtICYmICFzdHJlYW1Jc1RUWSAmJiBmb3JjZUNvbG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IgfHwgMDtcblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdC8vIFdpbmRvd3MgMTAgYnVpbGQgMTA1ODYgaXMgdGhlIGZpcnN0IFdpbmRvd3MgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuXG5cdFx0Ly8gV2luZG93cyAxMCBidWlsZCAxNDkzMSBpcyB0aGUgZmlyc3QgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDE2bS9UcnVlQ29sb3IuXG5cdFx0Y29uc3Qgb3NSZWxlYXNlID0gb3MucmVsZWFzZSgpLnNwbGl0KCcuJyk7XG5cdFx0aWYgKFxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTQ5MzEgPyAzIDogMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ0knIGluIGVudikge1xuXHRcdGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knLCAnR0lUSFVCX0FDVElPTlMnLCAnQlVJTERLSVRFJ10uc29tZShzaWduID0+IHNpZ24gaW4gZW52KSB8fCBlbnYuQ0lfTkFNRSA9PT0gJ2NvZGVzaGlwJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG5cdFx0cmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuXHR9XG5cblx0aWYgKGVudi5DT0xPUlRFUk0gPT09ICd0cnVlY29sb3InKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52KSB7XG5cdFx0Y29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KChlbnYuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuXHRcdHN3aXRjaCAoZW52LlRFUk1fUFJPR1JBTSkge1xuXHRcdFx0Y2FzZSAnaVRlcm0uYXBwJzpcblx0XHRcdFx0cmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuXHRcdFx0Y2FzZSAnQXBwbGVfVGVybWluYWwnOlxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIE5vIGRlZmF1bHRcblx0XHR9XG5cdH1cblxuXHRpZiAoLy0yNTYoY29sb3IpPyQvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRMZXZlbChzdHJlYW0pIHtcblx0Y29uc3QgbGV2ZWwgPSBzdXBwb3J0c0NvbG9yKHN0cmVhbSwgc3RyZWFtICYmIHN0cmVhbS5pc1RUWSk7XG5cdHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzdXBwb3J0c0NvbG9yOiBnZXRTdXBwb3J0TGV2ZWwsXG5cdHN0ZG91dDogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDEpKSksXG5cdHN0ZGVycjogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDIpKSlcbn07XG4iLCAiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuZGVzdHJveSA9IHV0aWwuZGVwcmVjYXRlKFxuXHQoKSA9PiB7fSxcblx0J0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nXG4pO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcblx0Ly8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuXHRjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuXHRpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuXHRcdGV4cG9ydHMuY29sb3JzID0gW1xuXHRcdFx0MjAsXG5cdFx0XHQyMSxcblx0XHRcdDI2LFxuXHRcdFx0MjcsXG5cdFx0XHQzMixcblx0XHRcdDMzLFxuXHRcdFx0MzgsXG5cdFx0XHQzOSxcblx0XHRcdDQwLFxuXHRcdFx0NDEsXG5cdFx0XHQ0Mixcblx0XHRcdDQzLFxuXHRcdFx0NDQsXG5cdFx0XHQ0NSxcblx0XHRcdDU2LFxuXHRcdFx0NTcsXG5cdFx0XHQ2Mixcblx0XHRcdDYzLFxuXHRcdFx0NjgsXG5cdFx0XHQ2OSxcblx0XHRcdDc0LFxuXHRcdFx0NzUsXG5cdFx0XHQ3Nixcblx0XHRcdDc3LFxuXHRcdFx0NzgsXG5cdFx0XHQ3OSxcblx0XHRcdDgwLFxuXHRcdFx0ODEsXG5cdFx0XHQ5Mixcblx0XHRcdDkzLFxuXHRcdFx0OTgsXG5cdFx0XHQ5OSxcblx0XHRcdDExMixcblx0XHRcdDExMyxcblx0XHRcdDEyOCxcblx0XHRcdDEyOSxcblx0XHRcdDEzNCxcblx0XHRcdDEzNSxcblx0XHRcdDE0OCxcblx0XHRcdDE0OSxcblx0XHRcdDE2MCxcblx0XHRcdDE2MSxcblx0XHRcdDE2Mixcblx0XHRcdDE2Myxcblx0XHRcdDE2NCxcblx0XHRcdDE2NSxcblx0XHRcdDE2Nixcblx0XHRcdDE2Nyxcblx0XHRcdDE2OCxcblx0XHRcdDE2OSxcblx0XHRcdDE3MCxcblx0XHRcdDE3MSxcblx0XHRcdDE3Mixcblx0XHRcdDE3Myxcblx0XHRcdDE3OCxcblx0XHRcdDE3OSxcblx0XHRcdDE4NCxcblx0XHRcdDE4NSxcblx0XHRcdDE5Nixcblx0XHRcdDE5Nyxcblx0XHRcdDE5OCxcblx0XHRcdDE5OSxcblx0XHRcdDIwMCxcblx0XHRcdDIwMSxcblx0XHRcdDIwMixcblx0XHRcdDIwMyxcblx0XHRcdDIwNCxcblx0XHRcdDIwNSxcblx0XHRcdDIwNixcblx0XHRcdDIwNyxcblx0XHRcdDIwOCxcblx0XHRcdDIwOSxcblx0XHRcdDIxNCxcblx0XHRcdDIxNSxcblx0XHRcdDIyMCxcblx0XHRcdDIyMVxuXHRcdF07XG5cdH1cbn0gY2F0Y2ggKGVycm9yKSB7XG5cdC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IHtcblx0cmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuXHQvLyBDYW1lbC1jYXNlXG5cdGNvbnN0IHByb3AgPSBrZXlcblx0XHQuc3Vic3RyaW5nKDYpXG5cdFx0LnRvTG93ZXJDYXNlKClcblx0XHQucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcblx0XHRcdHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cblx0Ly8gQ29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG5cdGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXHRpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gdHJ1ZTtcblx0fSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG5cdFx0dmFsID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBOdW1iZXIodmFsKTtcblx0fVxuXG5cdG9ialtwcm9wXSA9IHZhbDtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHRyZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/XG5cdFx0Qm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOlxuXHRcdHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRjb25zdCB7bmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnN9ID0gdGhpcztcblxuXHRpZiAodXNlQ29sb3JzKSB7XG5cdFx0Y29uc3QgYyA9IHRoaXMuY29sb3I7XG5cdFx0Y29uc3QgY29sb3JDb2RlID0gJ1xcdTAwMUJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHUwMDFCWzBtYDtcblxuXHRcdGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcblx0XHRhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxQlswbScpO1xuXHR9IGVsc2Uge1xuXHRcdGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuXHRpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHRyZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0KClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBzdGRlcnIuXG4gKi9cblxuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0cmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0KC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiIsICIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciAvIG53anMgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiIsIG51bGwsIG51bGwsIG51bGwsICJtb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZpeGVkRklGTyB7XG4gIGNvbnN0cnVjdG9yIChod20pIHtcbiAgICBpZiAoIShod20gPiAwKSB8fCAoKGh3bSAtIDEpICYgaHdtKSAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdNYXggc2l6ZSBmb3IgYSBGaXhlZEZJRk8gc2hvdWxkIGJlIGEgcG93ZXIgb2YgdHdvJylcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheShod20pXG4gICAgdGhpcy5tYXNrID0gaHdtIC0gMVxuICAgIHRoaXMudG9wID0gMFxuICAgIHRoaXMuYnRtID0gMFxuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxuXG4gIHB1c2ggKGRhdGEpIHtcbiAgICBpZiAodGhpcy5idWZmZXJbdGhpcy50b3BdICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZVxuICAgIHRoaXMuYnVmZmVyW3RoaXMudG9wXSA9IGRhdGFcbiAgICB0aGlzLnRvcCA9ICh0aGlzLnRvcCArIDEpICYgdGhpcy5tYXNrXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHNoaWZ0ICgpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy5idWZmZXJbdGhpcy5idG1dXG4gICAgaWYgKGxhc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHRoaXMuYnVmZmVyW3RoaXMuYnRtXSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuYnRtID0gKHRoaXMuYnRtICsgMSkgJiB0aGlzLm1hc2tcbiAgICByZXR1cm4gbGFzdFxuICB9XG5cbiAgcGVlayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuYnRtXVxuICB9XG5cbiAgaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuYnRtXSA9PT0gdW5kZWZpbmVkXG4gIH1cbn1cbiIsICJjb25zdCBGaXhlZEZJRk8gPSByZXF1aXJlKCcuL2ZpeGVkLXNpemUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZhc3RGSUZPIHtcbiAgY29uc3RydWN0b3IgKGh3bSkge1xuICAgIHRoaXMuaHdtID0gaHdtIHx8IDE2XG4gICAgdGhpcy5oZWFkID0gbmV3IEZpeGVkRklGTyh0aGlzLmh3bSlcbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWRcbiAgfVxuXG4gIHB1c2ggKHZhbCkge1xuICAgIGlmICghdGhpcy5oZWFkLnB1c2godmFsKSkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuaGVhZFxuICAgICAgdGhpcy5oZWFkID0gcHJldi5uZXh0ID0gbmV3IEZpeGVkRklGTygyICogdGhpcy5oZWFkLmJ1ZmZlci5sZW5ndGgpXG4gICAgICB0aGlzLmhlYWQucHVzaCh2YWwpXG4gICAgfVxuICB9XG5cbiAgc2hpZnQgKCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudGFpbC5zaGlmdCgpXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkICYmIHRoaXMudGFpbC5uZXh0KSB7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy50YWlsLm5leHRcbiAgICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICAgICAgdGhpcy50YWlsID0gbmV4dFxuICAgICAgcmV0dXJuIHRoaXMudGFpbC5zaGlmdCgpXG4gICAgfVxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIHBlZWsgKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWwucGVlaygpXG4gIH1cblxuICBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkLmlzRW1wdHkoKVxuICB9XG59XG4iLCAiY29uc3QgRklGTyA9IHJlcXVpcmUoJ2Zhc3QtZmlmbycpXG5cbm1vZHVsZS5leHBvcnRzID0gKG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgbGV0IG9uRW5kXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25FbmQgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH0gZWxzZSB7XG4gICAgb25FbmQgPSBvcHRpb25zLm9uRW5kXG4gIH1cblxuICBsZXQgYnVmZmVyID0gbmV3IEZJRk8oKVxuICBsZXQgcHVzaGFibGUsIG9uTmV4dCwgZW5kZWRcblxuICBjb25zdCB3YWl0TmV4dCA9ICgpID0+IHtcbiAgICBpZiAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICAgIGlmIChvcHRpb25zLndyaXRldikge1xuICAgICAgICBsZXQgbmV4dFxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXVxuICAgICAgICB3aGlsZSAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgICAgICBpZiAobmV4dC5lcnJvcikgdGhyb3cgbmV4dC5lcnJvclxuICAgICAgICAgIHZhbHVlcy5wdXNoKG5leHQudmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogbmV4dC5kb25lLCB2YWx1ZTogdmFsdWVzIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dCA9IGJ1ZmZlci5zaGlmdCgpXG4gICAgICBpZiAobmV4dC5lcnJvcikgdGhyb3cgbmV4dC5lcnJvclxuICAgICAgcmV0dXJuIG5leHRcbiAgICB9XG5cbiAgICBpZiAoZW5kZWQpIHJldHVybiB7IGRvbmU6IHRydWUgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIG9uTmV4dCA9IG5leHQgPT4ge1xuICAgICAgICBvbk5leHQgPSBudWxsXG4gICAgICAgIGlmIChuZXh0LmVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KG5leHQuZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud3JpdGV2ICYmICFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiBuZXh0LmRvbmUsIHZhbHVlOiBbbmV4dC52YWx1ZV0gfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShuZXh0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaGFibGVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY29uc3QgYnVmZmVyTmV4dCA9IG5leHQgPT4ge1xuICAgIGlmIChvbk5leHQpIHJldHVybiBvbk5leHQobmV4dClcbiAgICBidWZmZXIucHVzaChuZXh0KVxuICAgIHJldHVybiBwdXNoYWJsZVxuICB9XG5cbiAgY29uc3QgYnVmZmVyRXJyb3IgPSBlcnIgPT4ge1xuICAgIGJ1ZmZlciA9IG5ldyBGSUZPKClcbiAgICBpZiAob25OZXh0KSByZXR1cm4gb25OZXh0KHsgZXJyb3I6IGVyciB9KVxuICAgIGJ1ZmZlci5wdXNoKHsgZXJyb3I6IGVyciB9KVxuICAgIHJldHVybiBwdXNoYWJsZVxuICB9XG5cbiAgY29uc3QgcHVzaCA9IHZhbHVlID0+IHtcbiAgICBpZiAoZW5kZWQpIHJldHVybiBwdXNoYWJsZVxuICAgIHJldHVybiBidWZmZXJOZXh0KHsgZG9uZTogZmFsc2UsIHZhbHVlIH0pXG4gIH1cbiAgY29uc3QgZW5kID0gZXJyID0+IHtcbiAgICBpZiAoZW5kZWQpIHJldHVybiBwdXNoYWJsZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIHJldHVybiBlcnIgPyBidWZmZXJFcnJvcihlcnIpIDogYnVmZmVyTmV4dCh7IGRvbmU6IHRydWUgfSlcbiAgfVxuICBjb25zdCBfcmV0dXJuID0gKCkgPT4ge1xuICAgIGJ1ZmZlciA9IG5ldyBGSUZPKClcbiAgICBlbmQoKVxuICAgIHJldHVybiB7IGRvbmU6IHRydWUgfVxuICB9XG4gIGNvbnN0IF90aHJvdyA9IGVyciA9PiB7XG4gICAgZW5kKGVycilcbiAgICByZXR1cm4geyBkb25lOiB0cnVlIH1cbiAgfVxuXG4gIHB1c2hhYmxlID0ge1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkgeyByZXR1cm4gdGhpcyB9LFxuICAgIG5leHQ6IHdhaXROZXh0LFxuICAgIHJldHVybjogX3JldHVybixcbiAgICB0aHJvdzogX3Rocm93LFxuICAgIHB1c2gsXG4gICAgZW5kXG4gIH1cblxuICBpZiAoIW9uRW5kKSByZXR1cm4gcHVzaGFibGVcblxuICBjb25zdCBfcHVzaGFibGUgPSBwdXNoYWJsZVxuXG4gIHB1c2hhYmxlID0ge1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gKCkgeyByZXR1cm4gdGhpcyB9LFxuICAgIG5leHQgKCkge1xuICAgICAgcmV0dXJuIF9wdXNoYWJsZS5uZXh0KClcbiAgICB9LFxuICAgIHRocm93IChlcnIpIHtcbiAgICAgIF9wdXNoYWJsZS50aHJvdyhlcnIpXG4gICAgICBpZiAob25FbmQpIHtcbiAgICAgICAgb25FbmQoZXJyKVxuICAgICAgICBvbkVuZCA9IG51bGxcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfVxuICAgIH0sXG4gICAgcmV0dXJuICgpIHtcbiAgICAgIF9wdXNoYWJsZS5yZXR1cm4oKVxuICAgICAgaWYgKG9uRW5kKSB7XG4gICAgICAgIG9uRW5kKClcbiAgICAgICAgb25FbmQgPSBudWxsXG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlIH1cbiAgICB9LFxuICAgIHB1c2gsXG4gICAgZW5kIChlcnIpIHtcbiAgICAgIF9wdXNoYWJsZS5lbmQoZXJyKVxuICAgICAgaWYgKG9uRW5kKSB7XG4gICAgICAgIG9uRW5kKGVycilcbiAgICAgICAgb25FbmQgPSBudWxsXG4gICAgICB9XG4gICAgICByZXR1cm4gcHVzaGFibGVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHVzaGFibGVcbn1cbiIsICIndXNlIHN0cmljdCdcblxuY29uc3QgcHVzaGFibGUgPSByZXF1aXJlKCdpdC1wdXNoYWJsZScpXG5cbi8qKlxuICogVHJlYXQgb25lIG9yIG1vcmUgaXRlcmFibGVzIGFzIGEgc2luZ2xlIGl0ZXJhYmxlLlxuICpcbiAqIE5iLiBzb3VyY2VzIGFyZSBpdGVyYXRlZCBvdmVyIGluIHBhcmFsbGVsIHNvIHRoZVxuICogb3JkZXIgb2YgZW1pdHRlZCBpdGVtcyBpcyBub3QgZ3VhcmFudGVlZC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsuLi5Bc3luY0l0ZXJhYmxlPFQ+fEl0ZXJhYmxlPFQ+fSBzb3VyY2VzXG4gKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxUPn1cbiAqL1xuY29uc3QgbWVyZ2UgPSBhc3luYyBmdW5jdGlvbiAqICguLi5zb3VyY2VzKSB7XG4gIGNvbnN0IG91dHB1dCA9IHB1c2hhYmxlKClcblxuICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHNvdXJjZXMubWFwKGFzeW5jIChzb3VyY2UpID0+IHtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2Ygc291cmNlKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChpdGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcblxuICAgICAgb3V0cHV0LmVuZCgpXG4gICAgfSBjYXRjaCAoLyoqIEB0eXBlIHthbnl9ICovIGVycikge1xuICAgICAgb3V0cHV0LmVuZChlcnIpXG4gICAgfVxuICB9LCAwKVxuXG4gIHlpZWxkICogb3V0cHV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VcbiIsIG51bGwsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwRGVmZXIoKSB7XG5cdGNvbnN0IGRlZmVycmVkID0ge307XG5cblx0ZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG5cdH0pO1xuXG5cdHJldHVybiBkZWZlcnJlZDtcbn1cbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJ2YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW09iamVjdC5rZXlzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX3RvQmluYXJ5ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIHZhciB0YWJsZSA9IG5ldyBVaW50OEFycmF5KDEyOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKylcbiAgICB0YWJsZVtpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgKiA0IC0gMjA1XSA9IGk7XG4gIHJldHVybiAoYmFzZTY0KSA9PiB7XG4gICAgdmFyIG4gPSBiYXNlNjQubGVuZ3RoLCBieXRlczIgPSBuZXcgVWludDhBcnJheSgobiAtIChiYXNlNjRbbiAtIDFdID09IFwiPVwiKSAtIChiYXNlNjRbbiAtIDJdID09IFwiPVwiKSkgKiAzIC8gNCB8IDApO1xuICAgIGZvciAodmFyIGkyID0gMCwgaiA9IDA7IGkyIDwgbjsgKSB7XG4gICAgICB2YXIgYzAgPSB0YWJsZVtiYXNlNjQuY2hhckNvZGVBdChpMisrKV0sIGMxID0gdGFibGVbYmFzZTY0LmNoYXJDb2RlQXQoaTIrKyldO1xuICAgICAgdmFyIGMyID0gdGFibGVbYmFzZTY0LmNoYXJDb2RlQXQoaTIrKyldLCBjMyA9IHRhYmxlW2Jhc2U2NC5jaGFyQ29kZUF0KGkyKyspXTtcbiAgICAgIGJ5dGVzMltqKytdID0gYzAgPDwgMiB8IGMxID4+IDQ7XG4gICAgICBieXRlczJbaisrXSA9IGMxIDw8IDQgfCBjMiA+PiAyO1xuICAgICAgYnl0ZXMyW2orK10gPSBjMiA8PCA2IHwgYzM7XG4gICAgfVxuICAgIHJldHVybiBieXRlczI7XG4gIH07XG59KSgpO1xuXG4vLyB3YXNtLWJpbmFyeTouL3hzYWxzYTIwLndhdFxudmFyIHJlcXVpcmVfeHNhbHNhMjAgPSBfX2NvbW1vbkpTKHtcbiAgXCJ3YXNtLWJpbmFyeTouL3hzYWxzYTIwLndhdFwiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gX190b0JpbmFyeShcIkFHRnpiUUVBQUFBQkdnTmdCbjkvZjM5L2Z3QmdCbjkvZjM5K2Z3RitZQU4vZjM4QUF3Y0dBQUVCQWdJQ0JRVUJBUXJvQndjb0F3WnRaVzF2Y25rQ0FBeDRjMkZzYzJFeU1GOTRiM0lBQUF4amIzSmxYM05oYkhOaE1qQUFCQXJxRVFZWUFDQUFJQUVnQWlBRElBUWdBQ2tEQUNBRkVBRTNBd0FMUFFCQjhBQWdBeUFGRUFNZ0FDQUJJQUlnQTBFUWFpQUVRZkFBRUFKQjhBQkNBRGNEQUVINEFFSUFOd01BUVlBQlFnQTNBd0JCaUFGQ0FEY0RBQXVIQlFFQmZ5QUNRUUJHQkVCQ0FBOExRZEFBSUFVcEF3QTNBd0JCMkFBZ0JVRUlhaWtEQURjREFFSGdBQ0FGUVJCcUtRTUFOd01BUWVnQUlBVkJHR29wQXdBM0F3QkJBQ0FES1FNQU53TUFRUWdnQkRjREFBSkFBMEFnQWtIQUFFa05BVUVRUVFCQjBBQVFCU0FBSUFFcEF3QkJFQ2tEQUlVM0F3QWdBRUVJYWlBQlFRaHFLUU1BUVJncEF3Q0ZOd01BSUFCQkVHb2dBVUVRYWlrREFFRWdLUU1BaFRjREFDQUFRUmhxSUFGQkdHb3BBd0JCS0NrREFJVTNBd0FnQUVFZ2FpQUJRU0JxS1FNQVFUQXBBd0NGTndNQUlBQkJLR29nQVVFb2Fpa0RBRUU0S1FNQWhUY0RBQ0FBUVRCcUlBRkJNR29wQXdCQndBQXBBd0NGTndNQUlBQkJPR29nQVVFNGFpa0RBRUhJQUNrREFJVTNBd0JCQ0VFSUtRTUFRZ0Y4TndNQUlBQkJ3QUJxSVFBZ0FVSEFBR29oQVNBQ1FjQUFheUVDREFBTEMwRUlLUU1BSVFRZ0FrRUFTd1JBUVJCQkFFSFFBQkFGQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FDUVFodURnY0hCZ1VFQXdJQkFBc2dBRUU0YWlBQlFUaHFLUU1BUWNnQUtRTUFoVGNEQUFzZ0FFRXdhaUFCUVRCcUtRTUFRY0FBS1FNQWhUY0RBQXNnQUVFb2FpQUJRU2hxS1FNQVFUZ3BBd0NGTndNQUN5QUFRU0JxSUFGQklHb3BBd0JCTUNrREFJVTNBd0FMSUFCQkdHb2dBVUVZYWlrREFFRW9LUU1BaFRjREFBc2dBRUVRYWlBQlFSQnFLUU1BUVNBcEF3Q0ZOd01BQ3lBQVFRaHFJQUZCQ0dvcEF3QkJHQ2tEQUlVM0F3QUxJQUFnQVNrREFFRVFLUU1BaFRjREFBdEJFRUlBTndNQVFSaENBRGNEQUVFZ1FnQTNBd0JCS0VJQU53TUFRVEJDQURjREFFRTRRZ0EzQXdCQndBQkNBRGNEQUVISUFFSUFOd01BUWRBQVFnQTNBd0JCMkFCQ0FEY0RBRUhnQUVJQU53TUFRZWdBUWdBM0F3QWdCQThMblFVQkVYOUI1ZkRCaXdZaEEwSHV5SUdaQXlFSVFiTGFpTXNISVExQjlNcUIyUVloRWlBQ0tBSUFJUVFnQWtFRWFpZ0NBQ0VGSUFKQkNHb29BZ0FoQmlBQ1FReHFLQUlBSVFjZ0FrRVFhaWdDQUNFT0lBSkJGR29vQWdBaER5QUNRUmhxS0FJQUlSQWdBa0VjYWlnQ0FDRVJJQUVvQWdBaENTQUJRUVJxS0FJQUlRb2dBVUVJYWlnQ0FDRUxJQUZCREdvb0FnQWhERUVVSVJNQ1FBTkFJQk5CQUVZTkFTQUhJQU1nRDJwQkIzZHpJUWNnQ3lBSElBTnFRUWwzY3lFTElBOGdDeUFIYWtFTmQzTWhEeUFESUE4Z0MycEJFbmR6SVFNZ0RDQUlJQVJxUVFkM2N5RU1JQkFnRENBSWFrRUpkM01oRUNBRUlCQWdER3BCRFhkeklRUWdDQ0FFSUJCcVFSSjNjeUVJSUJFZ0RTQUpha0VIZDNNaEVTQUZJQkVnRFdwQkNYZHpJUVVnQ1NBRklCRnFRUTEzY3lFSklBMGdDU0FGYWtFU2QzTWhEU0FHSUJJZ0RtcEJCM2R6SVFZZ0NpQUdJQkpxUVFsM2N5RUtJQTRnQ2lBR2FrRU5kM01oRGlBU0lBNGdDbXBCRW5keklSSWdCQ0FESUFacVFRZDNjeUVFSUFVZ0JDQURha0VKZDNNaEJTQUdJQVVnQkdwQkRYZHpJUVlnQXlBR0lBVnFRUkozY3lFRElBa2dDQ0FIYWtFSGQzTWhDU0FLSUFrZ0NHcEJDWGR6SVFvZ0J5QUtJQWxxUVExM2N5RUhJQWdnQnlBS2FrRVNkM01oQ0NBT0lBMGdER3BCQjNkeklRNGdDeUFPSUExcVFRbDNjeUVMSUF3Z0N5QU9ha0VOZDNNaERDQU5JQXdnQzJwQkVuZHpJUTBnRHlBU0lCRnFRUWQzY3lFUElCQWdEeUFTYWtFSmQzTWhFQ0FSSUJBZ0QycEJEWGR6SVJFZ0VpQVJJQkJxUVJKM2N5RVNJQk5CQW1zaEV3d0FDd3NnQUNBRE5nSUFJQUJCQkdvZ0NEWUNBQ0FBUVFocUlBMDJBZ0FnQUVFTWFpQVNOZ0lBSUFCQkVHb2dDVFlDQUNBQVFSUnFJQW8yQWdBZ0FFRVlhaUFMTmdJQUlBQkJIR29nRERZQ0FBc0tBQ0FBSUFFZ0FoQUZDOTBHQVNGL1FlWHd3WXNHSVFOQjdzaUJtUU1oQ0VHeTJvakxCeUVOUWZUS2dka0dJUklnQWlnQ0FDRUVJQUpCQkdvb0FnQWhCU0FDUVFocUtBSUFJUVlnQWtFTWFpZ0NBQ0VISUFKQkVHb29BZ0FoRGlBQ1FSUnFLQUlBSVE4Z0FrRVlhaWdDQUNFUUlBSkJIR29vQWdBaEVTQUJLQUlBSVFrZ0FVRUVhaWdDQUNFS0lBRkJDR29vQWdBaEN5QUJRUXhxS0FJQUlRd2dBeUVUSUFRaEZDQUZJUlVnQmlFV0lBY2hGeUFJSVJnZ0NTRVpJQW9oR2lBTElSc2dEQ0VjSUEwaEhTQU9JUjRnRHlFZklCQWhJQ0FSSVNFZ0VpRWlRUlFoSXdKQUEwQWdJMEVBUmcwQklBY2dBeUFQYWtFSGQzTWhCeUFMSUFjZ0EycEJDWGR6SVFzZ0R5QUxJQWRxUVExM2N5RVBJQU1nRHlBTGFrRVNkM01oQXlBTUlBZ2dCR3BCQjNkeklRd2dFQ0FNSUFocVFRbDNjeUVRSUFRZ0VDQU1ha0VOZDNNaEJDQUlJQVFnRUdwQkVuZHpJUWdnRVNBTklBbHFRUWQzY3lFUklBVWdFU0FOYWtFSmQzTWhCU0FKSUFVZ0VXcEJEWGR6SVFrZ0RTQUpJQVZxUVJKM2N5RU5JQVlnRWlBT2FrRUhkM01oQmlBS0lBWWdFbXBCQ1hkeklRb2dEaUFLSUFacVFRMTNjeUVPSUJJZ0RpQUtha0VTZDNNaEVpQUVJQU1nQm1wQkIzZHpJUVFnQlNBRUlBTnFRUWwzY3lFRklBWWdCU0FFYWtFTmQzTWhCaUFESUFZZ0JXcEJFbmR6SVFNZ0NTQUlJQWRxUVFkM2N5RUpJQW9nQ1NBSWFrRUpkM01oQ2lBSElBb2dDV3BCRFhkeklRY2dDQ0FISUFwcVFSSjNjeUVJSUE0Z0RTQU1ha0VIZDNNaERpQUxJQTRnRFdwQkNYZHpJUXNnRENBTElBNXFRUTEzY3lFTUlBMGdEQ0FMYWtFU2QzTWhEU0FQSUJJZ0VXcEJCM2R6SVE4Z0VDQVBJQkpxUVFsM2N5RVFJQkVnRUNBUGFrRU5kM01oRVNBU0lCRWdFR3BCRW5keklSSWdJMEVDYXlFakRBQUxDeUFBSUFNZ0UybzJBZ0FnQUVFRWFpQUVJQlJxTmdJQUlBQkJDR29nQlNBVmFqWUNBQ0FBUVF4cUlBWWdGbW8yQWdBZ0FFRVFhaUFISUJkcU5nSUFJQUJCRkdvZ0NDQVlhallDQUNBQVFSaHFJQWtnR1dvMkFnQWdBRUVjYWlBS0lCcHFOZ0lBSUFCQklHb2dDeUFiYWpZQ0FDQUFRU1JxSUF3Z0hHbzJBZ0FnQUVFb2FpQU5JQjFxTmdJQUlBQkJMR29nRGlBZWFqWUNBQ0FBUVRCcUlBOGdIMm8yQWdBZ0FFRTBhaUFRSUNCcU5nSUFJQUJCT0dvZ0VTQWhhallDQUNBQVFUeHFJQklnSW1vMkFnQUxcIik7XG4gIH1cbn0pO1xuXG4vLyB3YXNtLW1vZHVsZTouL3hzYWxzYTIwLndhdFxudmFyIGJ5dGVzID0gcmVxdWlyZV94c2Fsc2EyMCgpO1xudmFyIGNvbXBpbGVkID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShieXRlcyk7XG5tb2R1bGUuZXhwb3J0cyA9IChpbXBvcnRzKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGNvbXBpbGVkLCBpbXBvcnRzKTtcbiAgcmV0dXJuIGluc3RhbmNlLmV4cG9ydHM7XG59O1xuIiwgInZhciB4c2Fsc2EyMCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXF1aXJlKCcuL3hzYWxzYTIwJykoKVxuXG52YXIgU0lHTUEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKVxudmFyIGhlYWQgPSAxNDRcbnZhciB0b3AgPSBoZWFkXG52YXIgZnJlZSA9IFtdXG5cbm1vZHVsZS5leHBvcnRzID0gWFNhbHNhMjBcblxuWFNhbHNhMjAuTk9OQ0VCWVRFUyA9IDI0XG5YU2Fsc2EyMC5LRVlCWVRFUyA9IDMyXG5cblhTYWxzYTIwLmNvcmVfaHNhbHNhMjAgPSBjb3JlX2hzYWxzYTIwXG5YU2Fsc2EyMC5TSUdNQSA9IFNJR01BXG5cbmZ1bmN0aW9uIFhTYWxzYTIwIChub25jZSwga2V5KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBYU2Fsc2EyMCkpIHJldHVybiBuZXcgWFNhbHNhMjAobm9uY2UsIGtleSlcbiAgaWYgKCFub25jZSB8fCBub25jZS5sZW5ndGggPCAyNCkgdGhyb3cgbmV3IEVycm9yKCdub25jZSBtdXN0IGJlIGF0IGxlYXN0IDI0IGJ5dGVzJylcbiAgaWYgKCFrZXkgfHwga2V5Lmxlbmd0aCA8IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ2tleSBtdXN0IGJlIGF0IGxlYXN0IDMyIGJ5dGVzJylcbiAgdGhpcy5feG9yID0geHNhbHNhMjAgPyBuZXcgV0FTTShub25jZSwga2V5KSA6IG5ldyBGYWxsYmFjayhub25jZSwga2V5KVxufVxuXG5YU2Fsc2EyMC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQpIHtcbiAgaWYgKCFpbnB1dCkgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3IgQnVmZmVyJylcbiAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aClcbiAgaWYgKGlucHV0Lmxlbmd0aCkgdGhpcy5feG9yLnVwZGF0ZShpbnB1dCwgb3V0cHV0KVxuICByZXR1cm4gb3V0cHV0XG59XG5cblhTYWxzYTIwLnByb3RvdHlwZS5maW5hbCA9XG5YU2Fsc2EyMC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3hvci5maW5hbGl6ZSgpXG4gIHRoaXMuX3hvciA9IG51bGxcbn1cblxuZnVuY3Rpb24gV0FTTSAobm9uY2UsIGtleSkge1xuICBpZiAoIWZyZWUubGVuZ3RoKSB7XG4gICAgZnJlZS5wdXNoKGhlYWQpXG4gICAgaGVhZCArPSA2NFxuICB9XG5cbiAgdGhpcy5fcG9pbnRlciA9IGZyZWUucG9wKClcbiAgdGhpcy5fbm9uY2UgPSB0aGlzLl9wb2ludGVyICsgOFxuICB0aGlzLl9rZXkgPSB0aGlzLl9ub25jZSArIDI0XG4gIHRoaXMuX292ZXJmbG93ID0gMFxuICB0aGlzLl9tZW1vcnkgPSBuZXcgVWludDhBcnJheSh4c2Fsc2EyMC5tZW1vcnkuYnVmZmVyKVxuXG4gIHRoaXMuX21lbW9yeS5maWxsKDAsIHRoaXMuX3BvaW50ZXIsIHRoaXMuX3BvaW50ZXIgKyA4KVxuICB0aGlzLl9tZW1vcnkuc2V0KG5vbmNlLCB0aGlzLl9ub25jZSlcbiAgdGhpcy5fbWVtb3J5LnNldChrZXksIHRoaXMuX2tleSlcbn1cblxuV0FTTS5wcm90b3R5cGUucmVhbGxvYyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHhzYWxzYTIwLm1lbW9yeS5ncm93KE1hdGguY2VpbChNYXRoLmFicyhzaXplIC0gdGhpcy5fbWVtb3J5Lmxlbmd0aCkgLyA2NTUzNikpXG4gIHRoaXMuX21lbW9yeSA9IG5ldyBVaW50OEFycmF5KHhzYWxzYTIwLm1lbW9yeS5idWZmZXIpXG59XG5cbldBU00ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0KSB7XG4gIHZhciBsZW4gPSB0aGlzLl9vdmVyZmxvdyArIGlucHV0Lmxlbmd0aFxuICB2YXIgc3RhcnQgPSBoZWFkICsgdGhpcy5fb3ZlcmZsb3dcblxuICB0b3AgPSBoZWFkICsgbGVuXG4gIGlmICh0b3AgPj0gdGhpcy5fbWVtb3J5Lmxlbmd0aCkgdGhpcy5yZWFsbG9jKHRvcClcblxuICB0aGlzLl9tZW1vcnkuc2V0KGlucHV0LCBzdGFydClcbiAgeHNhbHNhMjAueHNhbHNhMjBfeG9yKHRoaXMuX3BvaW50ZXIsIGhlYWQsIGhlYWQsIGxlbiwgdGhpcy5fbm9uY2UsIHRoaXMuX2tleSlcbiAgb3V0cHV0LnNldCh0aGlzLl9tZW1vcnkuc3ViYXJyYXkoc3RhcnQsIGhlYWQgKyBsZW4pKVxuXG4gIHRoaXMuX292ZXJmbG93ID0gbGVuICYgNjNcbn1cblxuV0FTTS5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX21lbW9yeS5maWxsKDAsIHRoaXMuX3BvaW50ZXIsIHRoaXMuX2tleSArIDMyKVxuICBpZiAodG9wID4gaGVhZCkge1xuICAgIHRoaXMuX21lbW9yeS5maWxsKDAsIGhlYWQsIHRvcClcbiAgICB0b3AgPSAwXG4gIH1cbiAgZnJlZS5wdXNoKHRoaXMuX3BvaW50ZXIpXG59XG5cbmZ1bmN0aW9uIEZhbGxiYWNrIChub25jZSwga2V5KSB7XG4gIHRoaXMuX3MgPSBuZXcgVWludDhBcnJheSgzMilcbiAgdGhpcy5feiA9IG5ldyBVaW50OEFycmF5KDE2KVxuICB0aGlzLl9vdmVyZmxvdyA9IDBcbiAgY29yZV9oc2Fsc2EyMCh0aGlzLl9zLCBub25jZSwga2V5LCBTSUdNQSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHRoaXMuX3pbaV0gPSBub25jZVtpICsgMTZdXG59XG5cbkZhbGxiYWNrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCkge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDY0KVxuICB2YXIgdSA9IDBcbiAgdmFyIGkgPSB0aGlzLl9vdmVyZmxvd1xuICB2YXIgYiA9IGlucHV0Lmxlbmd0aCArIHRoaXMuX292ZXJmbG93XG4gIHZhciB6ID0gdGhpcy5felxuICB2YXIgbXBvcyA9IC10aGlzLl9vdmVyZmxvd1xuICB2YXIgY3BvcyA9IC10aGlzLl9vdmVyZmxvd1xuXG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY29yZV9zYWxzYTIwKHgsIHosIHRoaXMuX3MsIFNJR01BKVxuICAgIGZvciAoOyBpIDwgNjQ7IGkrKykgb3V0cHV0W2Nwb3MgKyBpXSA9IGlucHV0W21wb3MgKyBpXSBeIHhbaV1cbiAgICB1ID0gMVxuICAgIGZvciAoaSA9IDg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1ICs9ICh6W2ldICYgMHhmZikgfCAwXG4gICAgICB6W2ldID0gdSAmIDB4ZmZcbiAgICAgIHUgPj4+PSA4XG4gICAgfVxuICAgIGIgLT0gNjRcbiAgICBjcG9zICs9IDY0XG4gICAgbXBvcyArPSA2NFxuICAgIGkgPSAwXG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY29yZV9zYWxzYTIwKHgsIHosIHRoaXMuX3MsIFNJR01BKVxuICAgIGZvciAoOyBpIDwgYjsgaSsrKSBvdXRwdXRbY3BvcyArIGldID0gaW5wdXRbbXBvcyArIGldIF4geFtpXVxuICB9XG5cbiAgdGhpcy5fb3ZlcmZsb3cgPSBiICYgNjNcbn1cblxuRmFsbGJhY2sucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9zLmZpbGwoMClcbiAgdGhpcy5fei5maWxsKDApXG59XG5cbi8vIGJlbG93IG1ldGhvZHMgYXJlIHBvcnRlZCBmcm9tIHR3ZWV0IG5hY2xcblxuZnVuY3Rpb24gY29yZV9zYWxzYTIwKG8sIHAsIGssIGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpIDw8IDggfCAoY1sgMl0gJiAweGZmKSA8PCAxNiB8IChjWyAzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZikgPDwgOCB8IChrWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKGtbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKSA8PCA4IHwgKGtbIDZdICYgMHhmZikgPDwgMTYgfCAoa1sgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpIDw8IDggfCAoa1sxMF0gJiAweGZmKSA8PCAxNiB8IChrWzExXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZikgPDwgOCB8IChrWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKGtbMTVdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKSA8PCA4IHwgKGNbIDZdICYgMHhmZikgPDwgMTYgfCAoY1sgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpIDw8IDggfCAocFsgMl0gJiAweGZmKSA8PCAxNiB8IChwWyAzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZikgPDwgOCB8IChwWyA2XSAmIDB4ZmYpIDw8IDE2IHwgKHBbIDddICYgMHhmZikgPDwgMjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKSA8PCA4IHwgKHBbMTBdICYgMHhmZikgPDwgMTYgfCAocFsxMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpIDw8IDggfCAocFsxNF0gJiAweGZmKSA8PCAxNiB8IChwWzE1XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZikgPDwgOCB8IChjWzEwXSAmIDB4ZmYpIDw8IDE2IHwgKGNbMTFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKSA8PCA4IHwgKGtbMThdICYgMHhmZikgPDwgMTYgfCAoa1sxOV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpIDw8IDggfCAoa1syMl0gJiAweGZmKSA8PCAxNiB8IChrWzIzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZikgPDwgOCB8IChrWzI2XSAmIDB4ZmYpIDw8IDE2IHwgKGtbMjddICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKSA8PCA4IHwgKGtbMzBdICYgMHhmZikgPDwgMTYgfCAoa1szMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpIDw8IDggfCAoY1sxNF0gJiAweGZmKSA8PCAxNiB8IChjWzE1XSAmIDB4ZmYpIDw8IDI0XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDBcbiAgICB4NCBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4NCArIHgwIHwgMFxuICAgIHg4IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg4ICsgeDQgfCAwXG4gICAgeDEyIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MTIgKyB4OCB8IDBcbiAgICB4MCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4NSArIHgxIHwgMFxuICAgIHg5IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg5ICsgeDUgfCAwXG4gICAgeDEzIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgxMyArIHg5IHwgMFxuICAgIHgxIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MSArIHgxMyB8IDBcbiAgICB4NSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTAgKyB4NiB8IDBcbiAgICB4MTQgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDE0ICsgeDEwIHwgMFxuICAgIHgyIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgyICsgeDE0IHwgMFxuICAgIHg2IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4NiArIHgyIHwgMFxuICAgIHgxMCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwXG4gICAgeDMgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDMgKyB4MTUgfCAwXG4gICAgeDcgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDcgKyB4MyB8IDBcbiAgICB4MTEgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxMSArIHg3IHwgMFxuICAgIHgxNSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MCArIHgzIHwgMFxuICAgIHgxIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxICsgeDAgfCAwXG4gICAgeDIgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDIgKyB4MSB8IDBcbiAgICB4MyBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDMgKyB4MiB8IDBcbiAgICB4MCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4NSArIHg0IHwgMFxuICAgIHg2IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg2ICsgeDUgfCAwXG4gICAgeDcgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDcgKyB4NiB8IDBcbiAgICB4NCBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDQgKyB4NyB8IDBcbiAgICB4NSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTAgKyB4OSB8IDBcbiAgICB4MTEgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDExICsgeDEwIHwgMFxuICAgIHg4IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg4ICsgeDExIHwgMFxuICAgIHg5IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4OSArIHg4IHwgMFxuICAgIHgxMCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwXG4gICAgeDEyIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxMiArIHgxNSB8IDBcbiAgICB4MTMgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDEzICsgeDEyIHwgMFxuICAgIHgxNCBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDE0ICsgeDEzIHwgMFxuICAgIHgxNSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwXG4gICB4MSA9ICB4MSArICBqMSB8IDBcbiAgIHgyID0gIHgyICsgIGoyIHwgMFxuICAgeDMgPSAgeDMgKyAgajMgfCAwXG4gICB4NCA9ICB4NCArICBqNCB8IDBcbiAgIHg1ID0gIHg1ICsgIGo1IHwgMFxuICAgeDYgPSAgeDYgKyAgajYgfCAwXG4gICB4NyA9ICB4NyArICBqNyB8IDBcbiAgIHg4ID0gIHg4ICsgIGo4IHwgMFxuICAgeDkgPSAgeDkgKyAgajkgfCAwXG4gIHgxMCA9IHgxMCArIGoxMCB8IDBcbiAgeDExID0geDExICsgajExIHwgMFxuICB4MTIgPSB4MTIgKyBqMTIgfCAwXG4gIHgxMyA9IHgxMyArIGoxMyB8IDBcbiAgeDE0ID0geDE0ICsgajE0IHwgMFxuICB4MTUgPSB4MTUgKyBqMTUgfCAwXG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmXG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZlxuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmZcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmXG5cbiAgb1sgNF0gPSB4MSA+Pj4gIDAgJiAweGZmXG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZlxuICBvWyA2XSA9IHgxID4+PiAxNiAmIDB4ZmZcbiAgb1sgN10gPSB4MSA+Pj4gMjQgJiAweGZmXG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmXG4gIG9bIDldID0geDIgPj4+ICA4ICYgMHhmZlxuICBvWzEwXSA9IHgyID4+PiAxNiAmIDB4ZmZcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmXG5cbiAgb1sxMl0gPSB4MyA+Pj4gIDAgJiAweGZmXG4gIG9bMTNdID0geDMgPj4+ICA4ICYgMHhmZlxuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmZcbiAgb1sxNV0gPSB4MyA+Pj4gMjQgJiAweGZmXG5cbiAgb1sxNl0gPSB4NCA+Pj4gIDAgJiAweGZmXG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZlxuICBvWzE4XSA9IHg0ID4+PiAxNiAmIDB4ZmZcbiAgb1sxOV0gPSB4NCA+Pj4gMjQgJiAweGZmXG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmXG4gIG9bMjFdID0geDUgPj4+ICA4ICYgMHhmZlxuICBvWzIyXSA9IHg1ID4+PiAxNiAmIDB4ZmZcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmXG5cbiAgb1syNF0gPSB4NiA+Pj4gIDAgJiAweGZmXG4gIG9bMjVdID0geDYgPj4+ICA4ICYgMHhmZlxuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmZcbiAgb1syN10gPSB4NiA+Pj4gMjQgJiAweGZmXG5cbiAgb1syOF0gPSB4NyA+Pj4gIDAgJiAweGZmXG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZlxuICBvWzMwXSA9IHg3ID4+PiAxNiAmIDB4ZmZcbiAgb1szMV0gPSB4NyA+Pj4gMjQgJiAweGZmXG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmXG4gIG9bMzNdID0geDggPj4+ICA4ICYgMHhmZlxuICBvWzM0XSA9IHg4ID4+PiAxNiAmIDB4ZmZcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmXG5cbiAgb1szNl0gPSB4OSA+Pj4gIDAgJiAweGZmXG4gIG9bMzddID0geDkgPj4+ICA4ICYgMHhmZlxuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmZcbiAgb1szOV0gPSB4OSA+Pj4gMjQgJiAweGZmXG5cbiAgb1s0MF0gPSB4MTAgPj4+ICAwICYgMHhmZlxuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmXG4gIG9bNDJdID0geDEwID4+PiAxNiAmIDB4ZmZcbiAgb1s0M10gPSB4MTAgPj4+IDI0ICYgMHhmZlxuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmZcbiAgb1s0NV0gPSB4MTEgPj4+ICA4ICYgMHhmZlxuICBvWzQ2XSA9IHgxMSA+Pj4gMTYgJiAweGZmXG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmZcblxuICBvWzQ4XSA9IHgxMiA+Pj4gIDAgJiAweGZmXG4gIG9bNDldID0geDEyID4+PiAgOCAmIDB4ZmZcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZlxuICBvWzUxXSA9IHgxMiA+Pj4gMjQgJiAweGZmXG5cbiAgb1s1Ml0gPSB4MTMgPj4+ICAwICYgMHhmZlxuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmXG4gIG9bNTRdID0geDEzID4+PiAxNiAmIDB4ZmZcbiAgb1s1NV0gPSB4MTMgPj4+IDI0ICYgMHhmZlxuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmZcbiAgb1s1N10gPSB4MTQgPj4+ICA4ICYgMHhmZlxuICBvWzU4XSA9IHgxNCA+Pj4gMTYgJiAweGZmXG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmZcblxuICBvWzYwXSA9IHgxNSA+Pj4gIDAgJiAweGZmXG4gIG9bNjFdID0geDE1ID4+PiAgOCAmIDB4ZmZcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZlxuICBvWzYzXSA9IHgxNSA+Pj4gMjQgJiAweGZmXG59XG5cbmZ1bmN0aW9uIGNvcmVfaHNhbHNhMjAobyxwLGssYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZikgPDwgOCB8IChjWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKGNbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKSA8PCA4IHwgKGtbIDJdICYgMHhmZikgPDwgMTYgfCAoa1sgM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpIDw8IDggfCAoa1sgNl0gJiAweGZmKSA8PCAxNiB8IChrWyA3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZikgPDwgOCB8IChrWzEwXSAmIDB4ZmYpIDw8IDE2IHwgKGtbMTFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKSA8PCA4IHwgKGtbMTRdICYgMHhmZikgPDwgMTYgfCAoa1sxNV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpIDw8IDggfCAoY1sgNl0gJiAweGZmKSA8PCAxNiB8IChjWyA3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZikgPDwgOCB8IChwWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKHBbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKSA8PCA4IHwgKHBbIDZdICYgMHhmZikgPDwgMTYgfCAocFsgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpIDw8IDggfCAocFsxMF0gJiAweGZmKSA8PCAxNiB8IChwWzExXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZikgPDwgOCB8IChwWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKHBbMTVdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKSA8PCA4IHwgKGNbMTBdICYgMHhmZikgPDwgMTYgfCAoY1sxMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpIDw8IDggfCAoa1sxOF0gJiAweGZmKSA8PCAxNiB8IChrWzE5XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZikgPDwgOCB8IChrWzIyXSAmIDB4ZmYpIDw8IDE2IHwgKGtbMjNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKSA8PCA4IHwgKGtbMjZdICYgMHhmZikgPDwgMTYgfCAoa1syN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpIDw8IDggfCAoa1szMF0gJiAweGZmKSA8PCAxNiB8IChrWzMxXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZikgPDwgOCB8IChjWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKGNbMTVdICYgMHhmZikgPDwgMjRcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMFxuICAgIHg0IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg0ICsgeDAgfCAwXG4gICAgeDggXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDggKyB4NCB8IDBcbiAgICB4MTIgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxMiArIHg4IHwgMFxuICAgIHgwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHg1ICsgeDEgfCAwXG4gICAgeDkgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDkgKyB4NSB8IDBcbiAgICB4MTMgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDEzICsgeDkgfCAwXG4gICAgeDEgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxICsgeDEzIHwgMFxuICAgIHg1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxMCArIHg2IHwgMFxuICAgIHgxNCBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MTQgKyB4MTAgfCAwXG4gICAgeDIgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDIgKyB4MTQgfCAwXG4gICAgeDYgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHg2ICsgeDIgfCAwXG4gICAgeDEwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxNSArIHgxMSB8IDBcbiAgICB4MyBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MyArIHgxNSB8IDBcbiAgICB4NyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4NyArIHgzIHwgMFxuICAgIHgxMSBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDExICsgeDcgfCAwXG4gICAgeDE1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgwICsgeDMgfCAwXG4gICAgeDEgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDEgKyB4MCB8IDBcbiAgICB4MiBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MiArIHgxIHwgMFxuICAgIHgzIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MyArIHgyIHwgMFxuICAgIHgwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHg1ICsgeDQgfCAwXG4gICAgeDYgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDYgKyB4NSB8IDBcbiAgICB4NyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4NyArIHg2IHwgMFxuICAgIHg0IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4NCArIHg3IHwgMFxuICAgIHg1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxMCArIHg5IHwgMFxuICAgIHgxMSBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MTEgKyB4MTAgfCAwXG4gICAgeDggXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDggKyB4MTEgfCAwXG4gICAgeDkgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHg5ICsgeDggfCAwXG4gICAgeDEwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxNSArIHgxNCB8IDBcbiAgICB4MTIgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDEyICsgeDE1IHwgMFxuICAgIHgxMyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwXG4gICAgeDE0IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MTQgKyB4MTMgfCAwXG4gICAgeDE1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmXG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZlxuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmZcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmXG5cbiAgb1sgNF0gPSB4NSA+Pj4gIDAgJiAweGZmXG4gIG9bIDVdID0geDUgPj4+ICA4ICYgMHhmZlxuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmZcbiAgb1sgN10gPSB4NSA+Pj4gMjQgJiAweGZmXG5cbiAgb1sgOF0gPSB4MTAgPj4+ICAwICYgMHhmZlxuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmXG4gIG9bMTBdID0geDEwID4+PiAxNiAmIDB4ZmZcbiAgb1sxMV0gPSB4MTAgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmZcbiAgb1sxM10gPSB4MTUgPj4+ICA4ICYgMHhmZlxuICBvWzE0XSA9IHgxNSA+Pj4gMTYgJiAweGZmXG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmZcblxuICBvWzE2XSA9IHg2ID4+PiAgMCAmIDB4ZmZcbiAgb1sxN10gPSB4NiA+Pj4gIDggJiAweGZmXG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZlxuICBvWzE5XSA9IHg2ID4+PiAyNCAmIDB4ZmZcblxuICBvWzIwXSA9IHg3ID4+PiAgMCAmIDB4ZmZcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmXG4gIG9bMjJdID0geDcgPj4+IDE2ICYgMHhmZlxuICBvWzIzXSA9IHg3ID4+PiAyNCAmIDB4ZmZcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmZcbiAgb1syNV0gPSB4OCA+Pj4gIDggJiAweGZmXG4gIG9bMjZdID0geDggPj4+IDE2ICYgMHhmZlxuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmZcblxuICBvWzI4XSA9IHg5ID4+PiAgMCAmIDB4ZmZcbiAgb1syOV0gPSB4OSA+Pj4gIDggJiAweGZmXG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZlxuICBvWzMxXSA9IHg5ID4+PiAyNCAmIDB4ZmZcbn1cbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBUYWtlcyBhbiAoYXN5bmMpIGl0ZXJhYmxlIGFuZCByZXR1cm5zIG9uZSB3aXRoIGVhY2ggaXRlbSBtYXBwZWQgYnkgdGhlIHBhc3NlZFxuICogZnVuY3Rpb24uXG4gKlxuICogQHRlbXBsYXRlIEksT1xuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPEk+fEl0ZXJhYmxlPEk+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSSk6T3xQcm9taXNlPE8+fSBmdW5jXG4gKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxPPn1cbiAqL1xuY29uc3QgbWFwID0gYXN5bmMgZnVuY3Rpb24gKiAoc291cmNlLCBmdW5jKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHNvdXJjZSkge1xuICAgIHlpZWxkIGZ1bmModmFsKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwXG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiY29uc3Qgd29yZCA9ICdbYS1mQS1GXFxcXGQ6XSc7XG5cbmNvbnN0IGJvdW5kcnkgPSBvcHRpb25zID0+IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlQm91bmRhcmllc1xuXHQ/IGAoPzooPzw9XFxcXHN8XikoPz0ke3dvcmR9KXwoPzw9JHt3b3JkfSkoPz1cXFxcc3wkKSlgXG5cdDogJyc7XG5cbmNvbnN0IHY0ID0gJyg/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9JztcblxuY29uc3QgdjZzZWdtZW50ID0gJ1thLWZBLUZcXFxcZF17MSw0fSc7XG5cbmNvbnN0IHY2ID0gYFxuKD86XG4oPzoke3Y2c2VnbWVudH06KXs3fSg/OiR7djZzZWdtZW50fXw6KXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxOjI6Mzo0OjU6Njo3OjogIDE6MjozOjQ6NTo2Ojc6OFxuKD86JHt2NnNlZ21lbnR9Oil7Nn0oPzoke3Y0fXw6JHt2NnNlZ21lbnR9fDopfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMToyOjM6NDo1OjY6OiAgICAxOjI6Mzo0OjU6Njo6OCAgIDE6MjozOjQ6NTo2Ojo4ICAxOjI6Mzo0OjU6Njo6MS4yLjMuNFxuKD86JHt2NnNlZ21lbnR9Oil7NX0oPzo6JHt2NH18KD86OiR7djZzZWdtZW50fSl7MSwyfXw6KXwgICAgICAgICAgICAgICAgICAgLy8gMToyOjM6NDo1OjogICAgICAxOjI6Mzo0OjU6Ojc6OCAgIDE6MjozOjQ6NTo6OCAgICAxOjI6Mzo0OjU6Ojc6MS4yLjMuNFxuKD86JHt2NnNlZ21lbnR9Oil7NH0oPzooPzo6JHt2NnNlZ21lbnR9KXswLDF9OiR7djR9fCg/Ojoke3Y2c2VnbWVudH0pezEsM318Oil8IC8vIDE6MjozOjQ6OiAgICAgICAgMToyOjM6NDo6Njo3OjggICAxOjI6Mzo0Ojo4ICAgICAgMToyOjM6NDo6Njo3OjEuMi4zLjRcbig/OiR7djZzZWdtZW50fTopezN9KD86KD86OiR7djZzZWdtZW50fSl7MCwyfToke3Y0fXwoPzo6JHt2NnNlZ21lbnR9KXsxLDR9fDopfCAvLyAxOjI6Mzo6ICAgICAgICAgIDE6MjozOjo1OjY6Nzo4ICAgMToyOjM6OjggICAgICAgIDE6MjozOjo1OjY6NzoxLjIuMy40XG4oPzoke3Y2c2VnbWVudH06KXsyfSg/Oig/Ojoke3Y2c2VnbWVudH0pezAsM306JHt2NH18KD86OiR7djZzZWdtZW50fSl7MSw1fXw6KXwgLy8gMToyOjogICAgICAgICAgICAxOjI6OjQ6NTo2Ojc6OCAgIDE6Mjo6OCAgICAgICAgICAxOjI6OjQ6NTo2Ojc6MS4yLjMuNFxuKD86JHt2NnNlZ21lbnR9Oil7MX0oPzooPzo6JHt2NnNlZ21lbnR9KXswLDR9OiR7djR9fCg/Ojoke3Y2c2VnbWVudH0pezEsNn18Oil8IC8vIDE6OiAgICAgICAgICAgICAgMTo6Mzo0OjU6Njo3OjggICAxOjo4ICAgICAgICAgICAgMTo6Mzo0OjU6Njo3OjEuMi4zLjRcbig/OjooPzooPzo6JHt2NnNlZ21lbnR9KXswLDV9OiR7djR9fCg/Ojoke3Y2c2VnbWVudH0pezEsN318OikpICAgICAgICAgICAgIC8vIDo6MjozOjQ6NTo2Ojc6OCAgOjoyOjM6NDo1OjY6Nzo4ICA6OjggICAgICAgICAgICAgOjoxLjIuMy40XG4pKD86JVswLTlhLXpBLVpdezEsfSk/ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJWV0aDAgICAgICAgICAgICAlMVxuYC5yZXBsYWNlKC9cXHMqXFwvXFwvLiokL2dtLCAnJykucmVwbGFjZSgvXFxuL2csICcnKS50cmltKCk7XG5cbi8vIFByZS1jb21waWxlIG9ubHkgdGhlIGV4YWN0IHJlZ2V4ZXMgYmVjYXVzZSBhZGRpbmcgYSBnbG9iYWwgZmxhZyBtYWtlIHJlZ2V4ZXMgc3RhdGVmdWxcbmNvbnN0IHY0NkV4YWN0ID0gbmV3IFJlZ0V4cChgKD86XiR7djR9JCl8KD86XiR7djZ9JClgKTtcbmNvbnN0IHY0ZXhhY3QgPSBuZXcgUmVnRXhwKGBeJHt2NH0kYCk7XG5jb25zdCB2NmV4YWN0ID0gbmV3IFJlZ0V4cChgXiR7djZ9JGApO1xuXG5jb25zdCBpcFJlZ2V4ID0gb3B0aW9ucyA9PiBvcHRpb25zICYmIG9wdGlvbnMuZXhhY3Rcblx0PyB2NDZFeGFjdFxuXHQ6IG5ldyBSZWdFeHAoYCg/OiR7Ym91bmRyeShvcHRpb25zKX0ke3Y0fSR7Ym91bmRyeShvcHRpb25zKX0pfCg/OiR7Ym91bmRyeShvcHRpb25zKX0ke3Y2fSR7Ym91bmRyeShvcHRpb25zKX0pYCwgJ2cnKTtcblxuaXBSZWdleC52NCA9IG9wdGlvbnMgPT4gb3B0aW9ucyAmJiBvcHRpb25zLmV4YWN0ID8gdjRleGFjdCA6IG5ldyBSZWdFeHAoYCR7Ym91bmRyeShvcHRpb25zKX0ke3Y0fSR7Ym91bmRyeShvcHRpb25zKX1gLCAnZycpO1xuaXBSZWdleC52NiA9IG9wdGlvbnMgPT4gb3B0aW9ucyAmJiBvcHRpb25zLmV4YWN0ID8gdjZleGFjdCA6IG5ldyBSZWdFeHAoYCR7Ym91bmRyeShvcHRpb25zKX0ke3Y2fSR7Ym91bmRyeShvcHRpb25zKX1gLCAnZycpO1xuXG5leHBvcnQgZGVmYXVsdCBpcFJlZ2V4O1xuIiwgImltcG9ydCB2bSBmcm9tICdub2RlOnZtJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuY3Rpb25UaW1lb3V0KGZ1bmN0aW9uXywge3RpbWVvdXR9ID0ge30pIHtcblx0Y29uc3Qgc2NyaXB0ID0gbmV3IHZtLlNjcmlwdCgncmV0dXJuVmFsdWUgPSBmdW5jdGlvbl8oKScpO1xuXG5cdGNvbnN0IHdyYXBwZWRGdW5jdGlvbiA9ICguLi5hcmd1bWVudHNfKSA9PiB7XG5cdFx0Y29uc3QgY29udGV4dCA9IHtcblx0XHRcdGZ1bmN0aW9uXzogKCkgPT4gZnVuY3Rpb25fKC4uLmFyZ3VtZW50c18pLFxuXHRcdH07XG5cblx0XHRzY3JpcHQucnVuSW5OZXdDb250ZXh0KGNvbnRleHQsIHt0aW1lb3V0fSk7XG5cblx0XHRyZXR1cm4gY29udGV4dC5yZXR1cm5WYWx1ZTtcblx0fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlZEZ1bmN0aW9uLCAnbmFtZScsIHtcblx0XHR2YWx1ZTogYGZ1bmN0aW9uVGltZW91dCgke2Z1bmN0aW9uXy5uYW1lIHx8ICc8YW5vbnltb3VzPid9KWAsXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHR9KTtcblxuXHRyZXR1cm4gd3JhcHBlZEZ1bmN0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUaW1lb3V0RXJyb3IoZXJyb3IpIHtcblx0cmV0dXJuIGVycm9yPy5jb2RlID09PSAnRVJSX1NDUklQVF9FWEVDVVRJT05fVElNRU9VVCc7XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udmVydEhydGltZShocnRpbWUpIHtcblx0Y29uc3QgbmFub3NlY29uZHMgPSBocnRpbWU7XG5cdGNvbnN0IG51bWJlciA9IE51bWJlcihuYW5vc2Vjb25kcyk7XG5cdGNvbnN0IG1pbGxpc2Vjb25kcyA9IG51bWJlciAvIDEwMDAwMDA7XG5cdGNvbnN0IHNlY29uZHMgPSBudW1iZXIgLyAxMDAwMDAwMDAwO1xuXG5cdHJldHVybiB7XG5cdFx0c2Vjb25kcyxcblx0XHRtaWxsaXNlY29uZHMsXG5cdFx0bmFub3NlY29uZHNcblx0fTtcbn1cbiIsICJpbXBvcnQgY29udmVydEhydGltZSBmcm9tICdjb252ZXJ0LWhydGltZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpbWVTcGFuKCkge1xuXHRjb25zdCBzdGFydCA9IHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpO1xuXHRjb25zdCBlbmQgPSB0eXBlID0+IGNvbnZlcnRIcnRpbWUocHJvY2Vzcy5ocnRpbWUuYmlnaW50KCkgLSBzdGFydClbdHlwZV07XG5cblx0Y29uc3QgcmV0dXJuVmFsdWUgPSAoKSA9PiBlbmQoJ21pbGxpc2Vjb25kcycpO1xuXHRyZXR1cm5WYWx1ZS5yb3VuZGVkID0gKCkgPT4gTWF0aC5yb3VuZChlbmQoJ21pbGxpc2Vjb25kcycpKTtcblx0cmV0dXJuVmFsdWUuc2Vjb25kcyA9ICgpID0+IGVuZCgnc2Vjb25kcycpO1xuXHRyZXR1cm5WYWx1ZS5uYW5vc2Vjb25kcyA9ICgpID0+IGVuZCgnbmFub3NlY29uZHMnKTtcblxuXHRyZXR1cm4gcmV0dXJuVmFsdWU7XG59XG4iLCAiY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUmVnZXhwKHZhbHVlKSB7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG4iLCAiaW1wb3J0IGlzUmVnZXhwIGZyb20gJ2lzLXJlZ2V4cCc7XG5cbmNvbnN0IGZsYWdNYXAgPSB7XG5cdGdsb2JhbDogJ2cnLFxuXHRpZ25vcmVDYXNlOiAnaScsXG5cdG11bHRpbGluZTogJ20nLFxuXHRkb3RBbGw6ICdzJyxcblx0c3RpY2t5OiAneScsXG5cdHVuaWNvZGU6ICd1J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xvbmVkUmVnZXhwKHJlZ2V4cCwgb3B0aW9ucyA9IHt9KSB7XG5cdGlmICghaXNSZWdleHAocmVnZXhwKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgUmVnRXhwIGluc3RhbmNlJyk7XG5cdH1cblxuXHRjb25zdCBmbGFncyA9IE9iamVjdC5rZXlzKGZsYWdNYXApLm1hcChmbGFnID0+IChcblx0XHQodHlwZW9mIG9wdGlvbnNbZmxhZ10gPT09ICdib29sZWFuJyA/IG9wdGlvbnNbZmxhZ10gOiByZWdleHBbZmxhZ10pID8gZmxhZ01hcFtmbGFnXSA6ICcnXG5cdCkpLmpvaW4oJycpO1xuXG5cdGNvbnN0IGNsb25lZFJlZ2V4cCA9IG5ldyBSZWdFeHAob3B0aW9ucy5zb3VyY2UgfHwgcmVnZXhwLnNvdXJjZSwgZmxhZ3MpO1xuXG5cdGNsb25lZFJlZ2V4cC5sYXN0SW5kZXggPSB0eXBlb2Ygb3B0aW9ucy5sYXN0SW5kZXggPT09ICdudW1iZXInID9cblx0XHRvcHRpb25zLmxhc3RJbmRleCA6XG5cdFx0cmVnZXhwLmxhc3RJbmRleDtcblxuXHRyZXR1cm4gY2xvbmVkUmVnZXhwO1xufVxuIiwgImltcG9ydCBmdW5jdGlvblRpbWVvdXQsIHtpc1RpbWVvdXRFcnJvcn0gZnJvbSAnZnVuY3Rpb24tdGltZW91dCc7XG5pbXBvcnQgdGltZVNwYW4gZnJvbSAndGltZS1zcGFuJztcbmltcG9ydCBjbG9uZVJlZ2V4cCBmcm9tICdjbG9uZS1yZWdleHAnOyAvLyBUT0RPOiBVc2UgYHN0cnVjdHVyZWRDbG9uZWAgaW5zdGVhZCB3aGVuIHRhcmdldGluZyBOb2RlLmpzIDE4LlxuXG5jb25zdCByZXN1bHRUb01hdGNoID0gcmVzdWx0ID0+ICh7XG5cdG1hdGNoOiByZXN1bHRbMF0sXG5cdGluZGV4OiByZXN1bHQuaW5kZXgsXG5cdGdyb3VwczogcmVzdWx0LnNsaWNlKDEpLFxuXHRuYW1lZEdyb3VwczogcmVzdWx0Lmdyb3VwcyA/PyB7fSxcblx0aW5wdXQ6IHJlc3VsdC5pbnB1dCxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXRjaChyZWdleCwgc3RyaW5nLCB7dGltZW91dH0gPSB7fSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBmdW5jdGlvblRpbWVvdXQoKCkgPT4gY2xvbmVSZWdleHAocmVnZXgpLnRlc3Qoc3RyaW5nKSwge3RpbWVvdXR9KSgpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmIChpc1RpbWVvdXRFcnJvcihlcnJvcikpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3RNYXRjaChyZWdleCwgc3RyaW5nLCB7dGltZW91dH0gPSB7fSkge1xuXHR0cnkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IGZ1bmN0aW9uVGltZW91dCgoKSA9PiBjbG9uZVJlZ2V4cChyZWdleCkuZXhlYyhzdHJpbmcpLCB7dGltZW91dH0pKCk7XG5cblx0XHRpZiAocmVzdWx0ID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdFRvTWF0Y2gocmVzdWx0KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRpZiAoaXNUaW1lb3V0RXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMocmVnZXgsIHN0cmluZywge3RpbWVvdXQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1hdGNoVGltZW91dCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0gPSB7fSkge1xuXHRpZiAoIXJlZ2V4Lmdsb2JhbCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignVGhlIHJlZ2V4IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIGZsYWcsIG90aGVyd2lzZSwgdXNlIGBmaXJzdE1hdGNoKClgIGluc3RlYWQnKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0KiBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IG1hdGNoZXMgPSBzdHJpbmcubWF0Y2hBbGwocmVnZXgpOyAvLyBUaGUgcmVnZXggaXMgb25seSBleGVjdXRlZCB3aGVuIGl0ZXJhdGVkIG92ZXIuXG5cblx0XHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0XHRjb25zdCBuZXh0TWF0Y2ggPSBmdW5jdGlvblRpbWVvdXQoKCkgPT4gbWF0Y2hlcy5uZXh0KCksIHt0aW1lb3V0OiAodGltZW91dCAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IG1hdGNoVGltZW91dCAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSA/IE1hdGgubWluKHRpbWVvdXQsIG1hdGNoVGltZW91dCkgOiB1bmRlZmluZWR9KTsgLy8gYG1hdGNoZXMubmV4dGAgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGFuIGFycm93IGZ1bmN0aW9uIHNvIHRoYXQgaXQgZG9lc24ndCBsb29zZSBpdHMgY29udGV4dC5cblxuXHRcdFx0XHRcdGNvbnN0IGVuZCA9IHRpbWVTcGFuKCk7XG5cdFx0XHRcdFx0Y29uc3Qge3ZhbHVlLCBkb25lfSA9IG5leHRNYXRjaCgpO1xuXHRcdFx0XHRcdHRpbWVvdXQgLT0gTWF0aC5jZWlsKGVuZCgpKTtcblxuXHRcdFx0XHRcdGlmIChkb25lKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR5aWVsZCByZXN1bHRUb01hdGNoKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKCFpc1RpbWVvdXRFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH07XG59XG4iLCAiaW1wb3J0IGlwUmVnZXggZnJvbSAnaXAtcmVnZXgnO1xuaW1wb3J0IHtpc01hdGNofSBmcm9tICdzdXBlci1yZWdleCc7XG5cbmNvbnN0IG1heElQdjRMZW5ndGggPSAxNTtcbmNvbnN0IG1heElQdjZMZW5ndGggPSA0NTtcblxuY29uc3Qgb3B0aW9ucyA9IHtcblx0dGltZW91dDogNDAwLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSVAoc3RyaW5nKSB7XG5cdHJldHVybiBpc01hdGNoKGlwUmVnZXgoe2V4YWN0OiB0cnVlfSksIHN0cmluZy5zbGljZSgwLCBtYXhJUHY2TGVuZ3RoKSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0lQdjYoc3RyaW5nKSB7XG5cdHJldHVybiBpc01hdGNoKGlwUmVnZXgudjYoe2V4YWN0OiB0cnVlfSksIHN0cmluZy5zbGljZSgwLCBtYXhJUHY2TGVuZ3RoKSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0lQdjQoc3RyaW5nKSB7XG5cdHJldHVybiBpc01hdGNoKGlwUmVnZXgudjQoe2V4YWN0OiB0cnVlfSksIHN0cmluZy5zbGljZSgwLCBtYXhJUHY0TGVuZ3RoKSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpcFZlcnNpb24oc3RyaW5nKSB7XG5cdHJldHVybiBpc0lQKHN0cmluZykgPyAoaXNJUHY2KHN0cmluZykgPyA2IDogNCkgOiB1bmRlZmluZWQ7XG59XG4iLCBudWxsLCBudWxsLCAibW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuICAsIE1TQkFMTCA9IH5SRVNUXG4gICwgSU5UID0gTWF0aC5wb3coMiwgMzEpXG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIGlmIChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiBudW0gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIGVuY29kZS5ieXRlcyA9IDBcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGVuY29kZSB2YXJpbnQnKVxuICB9XG4gIG91dCA9IG91dCB8fCBbXVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gLz0gMTI4XG4gIH1cbiAgd2hpbGUobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSA+Pj49IDdcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDBcbiAgXG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDFcbiAgXG4gIHJldHVybiBvdXRcbn1cbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCB8fCBzaGlmdCA+IDQ5KSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsICJcbnZhciBOMSA9IE1hdGgucG93KDIsICA3KVxudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpXG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSlcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KVxudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpXG52YXIgTjYgPSBNYXRoLnBvdygyLCA0MilcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KVxudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpXG52YXIgTjkgPSBNYXRoLnBvdygyLCA2MylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA8IE4xID8gMVxuICA6IHZhbHVlIDwgTjIgPyAyXG4gIDogdmFsdWUgPCBOMyA/IDNcbiAgOiB2YWx1ZSA8IE40ID8gNFxuICA6IHZhbHVlIDwgTjUgPyA1XG4gIDogdmFsdWUgPCBONiA/IDZcbiAgOiB2YWx1ZSA8IE43ID8gN1xuICA6IHZhbHVlIDwgTjggPyA4XG4gIDogdmFsdWUgPCBOOSA/IDlcbiAgOiAgICAgICAgICAgICAgMTBcbiAgKVxufVxuIiwgIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZTogcmVxdWlyZSgnLi9lbmNvZGUuanMnKVxuICAsIGRlY29kZTogcmVxdWlyZSgnLi9kZWNvZGUuanMnKVxuICAsIGVuY29kaW5nTGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aC5qcycpXG59XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IGV4cG9ydHM7XG5cbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XG5cbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcblxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcblxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcblxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xuXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcblxuLyoqXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcblxuLyoqXG4gKiBHbG9iYWwgb2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxuICAgICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuICAgICAgICAgICB8fCB0eXBlb2Ygc2VsZiAgICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblxuLyoqXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7QXJyYXkuPCo+fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdOyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgb2JqZWN0LlxuICogQHR5cGUge09iamVjdH1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKi9cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNzZXQgPVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cbiAqIEBpbnRlcmZhY2UgQnVmZmVyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XG4gKi9cblxuLyoqXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxuICovXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcbiAqL1xudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxuICAgICAgICA6IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbn07XG5cbi8qKlxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XG4gKi9cbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXG4gKiBAaW50ZXJmYWNlIExvbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxuICovXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcbiAqL1xudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIHJldHVybiBkc3Q7XG59XG5cbnV0aWwubWVyZ2UgPSBtZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcblxuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIChDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQ3VzdG9tRXJyb3I7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmFtZTsgfSB9KTtcblxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxuICogQGNsYXNzZGVzYyBFcnJvciBzdWJjbGFzcyBpbmRpY2F0aW5nIGEgcHJvdG9jb2wgc3BlY2lmYyBlcnJvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICAgIE15TWVzc2FnZS5kZWNvZGUoc29tZUJ1ZmZlcik7IC8vIHRocm93cyBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcbiAqICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIHNvIGZhcjogXCIgKyBKU09OLnN0cmluZ2lmeShlLmluc3RhbmNlKSk7XG4gKiB9XG4gKi9cbnV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcblxuLyoqXG4gKiBTbyBmYXIgZGVjb2RlZCBtZXNzYWdlIGluc3RhbmNlLlxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cbiAqL1xuXG4vKipcbiAqIEEgT25lT2YgZ2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mR2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mR2V0dGVyfSBVbmJvdW5kIGdldHRlclxuICovXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZTZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZlNldHRlcn0gVW5ib3VuZCBzZXR0ZXJcbiAqL1xudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gb3B0aW9ucyB1c2VkIGZvciB7QGxpbmsgTWVzc2FnZSN0b0pTT059IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcbiAqXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xuICogLSBCeXRlcyBiZWNvbWUgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXG4gKiAtIFJlcGVhdGVkIGZpZWxkcyBiZWNvbWUgYXJyYXlzXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXG4gKlxuICogQHR5cGUge0lDb252ZXJzaW9uT3B0aW9uc31cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXG4gKi9cbnV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBqc29uOiB0cnVlXG59O1xuXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQnVmZmVyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIG5vZGUgNC54IGJ1ZmZlcnMgYXJlIGluY29tcGF0aWJsZSAmIGltbXV0YWJsZVxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgICB9O1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH07XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbn1cblxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBjcmVhdGVfYXJyYXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXG4gKi9cblJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbn07XG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNXRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNHRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xufTtcblxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcblxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHN0YXJ0ID09PSBlbmQgLy8gZml4IGZvciBJRSAxMC9XaW44IGFuZCBvdGhlcnMnIHN1YmFycmF5IHJldHVybmluZyBhcnJheSBvZiBzaXplIDFcbiAgICAgICAgPyBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMClcbiAgICAgICAgOiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG5cbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xuICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vLyBFeHRlbmRzIEV2ZW50RW1pdHRlclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cbiAqXG4gKiBEaWZmZXJzIGZyb20ge0BsaW5rIFJQQ0ltcGxDYWxsYmFja30gaW4gdGhhdCBpdCBpcyBhbiBhY3R1YWwgY2FsbGJhY2sgb2YgYSBzZXJ2aWNlIG1ldGhvZCB3aGljaCBtYXkgbm90IHJldHVybiBgcmVzcG9uc2UgPSBudWxsYC5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBSUEMgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXG4gKiBAZXh0ZW5kcyB1dGlsLkV2ZW50RW1pdHRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cbiAgICAgKiBAdHlwZSB7UlBDSW1wbHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG59XG5cbi8qKlxuICogQ2FsbHMgYSBzZXJ2aWNlIG1ldGhvZCB0aHJvdWdoIHtAbGluayBycGMuU2VydmljZSNycGNJbXBsfHJwY0ltcGx9LlxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXM+fSByZXNwb25zZUN0b3IgUmVzcG9uc2UgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcblxuICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcblxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmLnJlcXVlc3REZWxpbWl0ZWQgPyBcImVuY29kZURlbGltaXRlZFwiIDogXCJlbmNvZGVcIl0ocmVxdWVzdCkuZmluaXNoKCksXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kKC8qIGVuZGVkQnlSUEMgKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IGB0aGlzYFxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xuICAgIGlmICh0aGlzLnJwY0ltcGwpIHtcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy5ycGNJbXBsID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcnBjID0gZXhwb3J0cztcblxuLyoqXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXG4gKiBAdHlwZWRlZiBSUENJbXBsXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBOYW1lZCByb290cy5cbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCAiLy8gbWluaW1hbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LW1pbmltYWxcIik7XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiBhIGRvdWJsZSBlbmRlZCBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gRGVucXVlKGFycmF5LCBvcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9oZWFkID0gMDtcbiAgdGhpcy5fdGFpbCA9IDA7XG4gIHRoaXMuX2NhcGFjaXR5ID0gb3B0aW9ucy5jYXBhY2l0eTtcbiAgdGhpcy5fY2FwYWNpdHlNYXNrID0gMHgzO1xuICB0aGlzLl9saXN0ID0gbmV3IEFycmF5KDQpO1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICB0aGlzLl9mcm9tQXJyYXkoYXJyYXkpO1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLVxuICogIFBVQkxJQyBBUElcbiAqIC0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleCBmcm9tIHRoZSBsaXN0LlxuICogMCBpcyB0aGUgZmlyc3QgZWxlbWVudCwgMSBpcyB0aGUgc2Vjb25kLCBhbmQgc28gb24uLi5cbiAqIEVsZW1lbnRzIGF0IG5lZ2F0aXZlIHZhbHVlcyBhcmUgdGhhdCBtYW55IGZyb20gdGhlIGVuZDogLTEgaXMgb25lIGJlZm9yZSB0aGUgZW5kXG4gKiAodGhlIGxhc3QgZWxlbWVudCksIC0yIGlzIHR3byBiZWZvcmUgdGhlIGVuZCAob25lIGJlZm9yZSBsYXN0KSwgZXRjLlxuICogQHBhcmFtIGluZGV4XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5wZWVrQXQgPSBmdW5jdGlvbiBwZWVrQXQoaW5kZXgpIHtcbiAgdmFyIGkgPSBpbmRleDtcbiAgLy8gZXhwZWN0IGEgbnVtYmVyIG9yIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKChpICE9PSAoaSB8IDApKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgdmFyIGxlbiA9IHRoaXMuc2l6ZSgpO1xuICBpZiAoaSA+PSBsZW4gfHwgaSA8IC1sZW4pIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChpIDwgMCkgaSArPSBsZW47XG4gIGkgPSAodGhpcy5faGVhZCArIGkpICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICByZXR1cm4gdGhpcy5fbGlzdFtpXTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHBlZWtBdCgpXG4gKiBAcGFyYW0gaVxuICogQHJldHVybnMgeyp9XG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGkpIHtcbiAgcmV0dXJuIHRoaXMucGVla0F0KGkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0IHdpdGhvdXQgcmVtb3ZpbmcgaXQuXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gcGVlaygpIHtcbiAgaWYgKHRoaXMuX2hlYWQgPT09IHRoaXMuX3RhaWwpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiB0aGlzLl9saXN0W3RoaXMuX2hlYWRdO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgcGVlaygpXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5wZWVrRnJvbnQgPSBmdW5jdGlvbiBwZWVrRnJvbnQoKSB7XG4gIHJldHVybiB0aGlzLnBlZWsoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlbSB0aGF0IGlzIGF0IHRoZSBiYWNrIG9mIHRoZSBxdWV1ZSB3aXRob3V0IHJlbW92aW5nIGl0LlxuICogVXNlcyBwZWVrQXQoLTEpXG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUucGVla0JhY2sgPSBmdW5jdGlvbiBwZWVrQmFjaygpIHtcbiAgcmV0dXJuIHRoaXMucGVla0F0KC0xKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHF1ZXVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZW5xdWUucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuICBnZXQ6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZW1zIG9uIHRoZSBsaXN0LCBvciAwIGlmIGVtcHR5LlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSgpIHtcbiAgaWYgKHRoaXMuX2hlYWQgPT09IHRoaXMuX3RhaWwpIHJldHVybiAwO1xuICBpZiAodGhpcy5faGVhZCA8IHRoaXMuX3RhaWwpIHJldHVybiB0aGlzLl90YWlsIC0gdGhpcy5faGVhZDtcbiAgZWxzZSByZXR1cm4gdGhpcy5fY2FwYWNpdHlNYXNrICsgMSAtICh0aGlzLl9oZWFkIC0gdGhpcy5fdGFpbCk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBpdGVtIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QuXG4gKiBAcGFyYW0gaXRlbVxuICovXG5EZW5xdWUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KGl0ZW0pIHtcbiAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuc2l6ZSgpO1xuICB2YXIgbGVuID0gdGhpcy5fbGlzdC5sZW5ndGg7XG4gIHRoaXMuX2hlYWQgPSAodGhpcy5faGVhZCAtIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICB0aGlzLl9saXN0W3RoaXMuX2hlYWRdID0gaXRlbTtcbiAgaWYgKHRoaXMuX3RhaWwgPT09IHRoaXMuX2hlYWQpIHRoaXMuX2dyb3dBcnJheSgpO1xuICBpZiAodGhpcy5fY2FwYWNpdHkgJiYgdGhpcy5zaXplKCkgPiB0aGlzLl9jYXBhY2l0eSkgdGhpcy5wb3AoKTtcbiAgaWYgKHRoaXMuX2hlYWQgPCB0aGlzLl90YWlsKSByZXR1cm4gdGhpcy5fdGFpbCAtIHRoaXMuX2hlYWQ7XG4gIGVsc2UgcmV0dXJuIHRoaXMuX2NhcGFjaXR5TWFzayArIDEgLSAodGhpcy5faGVhZCAtIHRoaXMuX3RhaWwpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgZmlyc3QgaXRlbSBvbiB0aGUgbGlzdCxcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBsaXN0IGlzIGVtcHR5LlxuICogQHJldHVybnMgeyp9XG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICBpZiAoaGVhZCA9PT0gdGhpcy5fdGFpbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9saXN0W2hlYWRdO1xuICB0aGlzLl9saXN0W2hlYWRdID0gdW5kZWZpbmVkO1xuICB0aGlzLl9oZWFkID0gKGhlYWQgKyAxKSAmIHRoaXMuX2NhcGFjaXR5TWFzaztcbiAgaWYgKGhlYWQgPCAyICYmIHRoaXMuX3RhaWwgPiAxMDAwMCAmJiB0aGlzLl90YWlsIDw9IHRoaXMuX2xpc3QubGVuZ3RoID4+PiAyKSB0aGlzLl9zaHJpbmtBcnJheSgpO1xuICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGl0ZW0gdG8gdGhlIGJvdHRvbSBvZiB0aGUgbGlzdC5cbiAqIEBwYXJhbSBpdGVtXG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2goaXRlbSkge1xuICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5zaXplKCk7XG4gIHZhciB0YWlsID0gdGhpcy5fdGFpbDtcbiAgdGhpcy5fbGlzdFt0YWlsXSA9IGl0ZW07XG4gIHRoaXMuX3RhaWwgPSAodGFpbCArIDEpICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICBpZiAodGhpcy5fdGFpbCA9PT0gdGhpcy5faGVhZCkge1xuICAgIHRoaXMuX2dyb3dBcnJheSgpO1xuICB9XG4gIGlmICh0aGlzLl9jYXBhY2l0eSAmJiB0aGlzLnNpemUoKSA+IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgdGhpcy5zaGlmdCgpO1xuICB9XG4gIGlmICh0aGlzLl9oZWFkIDwgdGhpcy5fdGFpbCkgcmV0dXJuIHRoaXMuX3RhaWwgLSB0aGlzLl9oZWFkO1xuICBlbHNlIHJldHVybiB0aGlzLl9jYXBhY2l0eU1hc2sgKyAxIC0gKHRoaXMuX2hlYWQgLSB0aGlzLl90YWlsKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGxhc3QgaXRlbSBvbiB0aGUgbGlzdC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBsaXN0IGlzIGVtcHR5LlxuICogQHJldHVybnMgeyp9XG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wKCkge1xuICB2YXIgdGFpbCA9IHRoaXMuX3RhaWw7XG4gIGlmICh0YWlsID09PSB0aGlzLl9oZWFkKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgbGVuID0gdGhpcy5fbGlzdC5sZW5ndGg7XG4gIHRoaXMuX3RhaWwgPSAodGFpbCAtIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICB2YXIgaXRlbSA9IHRoaXMuX2xpc3RbdGhpcy5fdGFpbF07XG4gIHRoaXMuX2xpc3RbdGhpcy5fdGFpbF0gPSB1bmRlZmluZWQ7XG4gIGlmICh0aGlzLl9oZWFkIDwgMiAmJiB0YWlsID4gMTAwMDAgJiYgdGFpbCA8PSBsZW4gPj4+IDIpIHRoaXMuX3Nocmlua0FycmF5KCk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGZyb20gdGhlIGxpc3QuXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAqIEBwYXJhbSBpbmRleFxuICogQHJldHVybnMgeyp9XG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUucmVtb3ZlT25lID0gZnVuY3Rpb24gcmVtb3ZlT25lKGluZGV4KSB7XG4gIHZhciBpID0gaW5kZXg7XG4gIC8vIGV4cGVjdCBhIG51bWJlciBvciByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICgoaSAhPT0gKGkgfCAwKSkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh0aGlzLl9oZWFkID09PSB0aGlzLl90YWlsKSByZXR1cm4gdm9pZCAwO1xuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSgpO1xuICB2YXIgbGVuID0gdGhpcy5fbGlzdC5sZW5ndGg7XG4gIGlmIChpID49IHNpemUgfHwgaSA8IC1zaXplKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaSA8IDApIGkgKz0gc2l6ZTtcbiAgaSA9ICh0aGlzLl9oZWFkICsgaSkgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gIHZhciBpdGVtID0gdGhpcy5fbGlzdFtpXTtcbiAgdmFyIGs7XG4gIGlmIChpbmRleCA8IHNpemUgLyAyKSB7XG4gICAgZm9yIChrID0gaW5kZXg7IGsgPiAwOyBrLS0pIHtcbiAgICAgIHRoaXMuX2xpc3RbaV0gPSB0aGlzLl9saXN0W2kgPSAoaSAtIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrXTtcbiAgICB9XG4gICAgdGhpcy5fbGlzdFtpXSA9IHZvaWQgMDtcbiAgICB0aGlzLl9oZWFkID0gKHRoaXMuX2hlYWQgKyAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFzaztcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGsgPSBzaXplIC0gMSAtIGluZGV4OyBrID4gMDsgay0tKSB7XG4gICAgICB0aGlzLl9saXN0W2ldID0gdGhpcy5fbGlzdFtpID0gKCBpICsgMSArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2tdO1xuICAgIH1cbiAgICB0aGlzLl9saXN0W2ldID0gdm9pZCAwO1xuICAgIHRoaXMuX3RhaWwgPSAodGhpcy5fdGFpbCAtIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleCBmcm9tIHRoZSBsaXN0LlxuICogUmV0dXJucyBhcnJheSBvZiByZW1vdmVkIGl0ZW1zLlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gKiBAcGFyYW0gaW5kZXhcbiAqIEBwYXJhbSBjb3VudFxuICogQHJldHVybnMge2FycmF5fVxuICovXG5EZW5xdWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShpbmRleCwgY291bnQpIHtcbiAgdmFyIGkgPSBpbmRleDtcbiAgdmFyIHJlbW92ZWQ7XG4gIHZhciBkZWxfY291bnQgPSBjb3VudDtcbiAgLy8gZXhwZWN0IGEgbnVtYmVyIG9yIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKChpICE9PSAoaSB8IDApKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHRoaXMuX2hlYWQgPT09IHRoaXMuX3RhaWwpIHJldHVybiB2b2lkIDA7XG4gIHZhciBzaXplID0gdGhpcy5zaXplKCk7XG4gIHZhciBsZW4gPSB0aGlzLl9saXN0Lmxlbmd0aDtcbiAgaWYgKGkgPj0gc2l6ZSB8fCBpIDwgLXNpemUgfHwgY291bnQgPCAxKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaSA8IDApIGkgKz0gc2l6ZTtcbiAgaWYgKGNvdW50ID09PSAxIHx8ICFjb3VudCkge1xuICAgIHJlbW92ZWQgPSBuZXcgQXJyYXkoMSk7XG4gICAgcmVtb3ZlZFswXSA9IHRoaXMucmVtb3ZlT25lKGkpO1xuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG4gIGlmIChpID09PSAwICYmIGkgKyBjb3VudCA+PSBzaXplKSB7XG4gICAgcmVtb3ZlZCA9IHRoaXMudG9BcnJheSgpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuICBpZiAoaSArIGNvdW50ID4gc2l6ZSkgY291bnQgPSBzaXplIC0gaTtcbiAgdmFyIGs7XG4gIHJlbW92ZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICBmb3IgKGsgPSAwOyBrIDwgY291bnQ7IGsrKykge1xuICAgIHJlbW92ZWRba10gPSB0aGlzLl9saXN0Wyh0aGlzLl9oZWFkICsgaSArIGspICYgdGhpcy5fY2FwYWNpdHlNYXNrXTtcbiAgfVxuICBpID0gKHRoaXMuX2hlYWQgKyBpKSAmIHRoaXMuX2NhcGFjaXR5TWFzaztcbiAgaWYgKGluZGV4ICsgY291bnQgPT09IHNpemUpIHtcbiAgICB0aGlzLl90YWlsID0gKHRoaXMuX3RhaWwgLSBjb3VudCArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gICAgZm9yIChrID0gY291bnQ7IGsgPiAwOyBrLS0pIHtcbiAgICAgIHRoaXMuX2xpc3RbaSA9IChpICsgMSArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2tdID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICB0aGlzLl9oZWFkID0gKHRoaXMuX2hlYWQgKyBjb3VudCArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gICAgZm9yIChrID0gY291bnQgLSAxOyBrID4gMDsgay0tKSB7XG4gICAgICB0aGlzLl9saXN0W2kgPSAoaSArIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrXSA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH1cbiAgaWYgKGkgPCBzaXplIC8gMikge1xuICAgIHRoaXMuX2hlYWQgPSAodGhpcy5faGVhZCArIGluZGV4ICsgY291bnQgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgIGZvciAoayA9IGluZGV4OyBrID4gMDsgay0tKSB7XG4gICAgICB0aGlzLnVuc2hpZnQodGhpcy5fbGlzdFtpID0gKGkgLSAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFza10pO1xuICAgIH1cbiAgICBpID0gKHRoaXMuX2hlYWQgLSAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFzaztcbiAgICB3aGlsZSAoZGVsX2NvdW50ID4gMCkge1xuICAgICAgdGhpcy5fbGlzdFtpID0gKGkgLSAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFza10gPSB2b2lkIDA7XG4gICAgICBkZWxfY291bnQtLTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMCkgdGhpcy5fdGFpbCA9IGk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdGFpbCA9IGk7XG4gICAgaSA9IChpICsgY291bnQgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgIGZvciAoayA9IHNpemUgLSAoY291bnQgKyBpbmRleCk7IGsgPiAwOyBrLS0pIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLl9saXN0W2krK10pO1xuICAgIH1cbiAgICBpID0gdGhpcy5fdGFpbDtcbiAgICB3aGlsZSAoZGVsX2NvdW50ID4gMCkge1xuICAgICAgdGhpcy5fbGlzdFtpID0gKGkgKyAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFza10gPSB2b2lkIDA7XG4gICAgICBkZWxfY291bnQtLTtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuX2hlYWQgPCAyICYmIHRoaXMuX3RhaWwgPiAxMDAwMCAmJiB0aGlzLl90YWlsIDw9IGxlbiA+Pj4gMikgdGhpcy5fc2hyaW5rQXJyYXkoKTtcbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuXG4vKipcbiAqIE5hdGl2ZSBzcGxpY2UgaW1wbGVtZW50YXRpb24uXG4gKiBSZW1vdmUgbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleCBmcm9tIHRoZSBsaXN0IGFuZC9vciBhZGQgbmV3IGVsZW1lbnRzLlxuICogUmV0dXJucyBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIG9yIGVtcHR5IGFycmF5IGlmIGNvdW50ID09IDAuXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0gaW5kZXhcbiAqIEBwYXJhbSBjb3VudFxuICogQHBhcmFtIHsuLi4qfSBbZWxlbWVudHNdXG4gKiBAcmV0dXJucyB7YXJyYXl9XG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24gc3BsaWNlKGluZGV4LCBjb3VudCkge1xuICB2YXIgaSA9IGluZGV4O1xuICAvLyBleHBlY3QgYSBudW1iZXIgb3IgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoKGkgIT09IChpIHwgMCkpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSgpO1xuICBpZiAoaSA8IDApIGkgKz0gc2l6ZTtcbiAgaWYgKGkgPiBzaXplKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICB2YXIgaztcbiAgICB2YXIgdGVtcDtcbiAgICB2YXIgcmVtb3ZlZDtcbiAgICB2YXIgYXJnX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xpc3QubGVuZ3RoO1xuICAgIHZhciBhcmd1bWVudHNfaW5kZXggPSAyO1xuICAgIGlmICghc2l6ZSB8fCBpIDwgc2l6ZSAvIDIpIHtcbiAgICAgIHRlbXAgPSBuZXcgQXJyYXkoaSk7XG4gICAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG4gICAgICAgIHRlbXBba10gPSB0aGlzLl9saXN0Wyh0aGlzLl9oZWFkICsgaykgJiB0aGlzLl9jYXBhY2l0eU1hc2tdO1xuICAgICAgfVxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdGhpcy5faGVhZCA9ICh0aGlzLl9oZWFkICsgaSArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZWQgPSB0aGlzLnJlbW92ZShpLCBjb3VudCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSAodGhpcy5faGVhZCArIGkgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ19sZW4gPiBhcmd1bWVudHNfaW5kZXgpIHtcbiAgICAgICAgdGhpcy51bnNoaWZ0KGFyZ3VtZW50c1stLWFyZ19sZW5dKTtcbiAgICAgIH1cbiAgICAgIGZvciAoayA9IGk7IGsgPiAwOyBrLS0pIHtcbiAgICAgICAgdGhpcy51bnNoaWZ0KHRlbXBbayAtIDFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcCA9IG5ldyBBcnJheShzaXplIC0gKGkgKyBjb3VudCkpO1xuICAgICAgdmFyIGxlbmcgPSB0ZW1wLmxlbmd0aDtcbiAgICAgIGZvciAoayA9IDA7IGsgPCBsZW5nOyBrKyspIHtcbiAgICAgICAgdGVtcFtrXSA9IHRoaXMuX2xpc3RbKHRoaXMuX2hlYWQgKyBpICsgY291bnQgKyBrKSAmIHRoaXMuX2NhcGFjaXR5TWFza107XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlZCA9IFtdO1xuICAgICAgICBpZiAoaSAhPSBzaXplKSB7XG4gICAgICAgICAgdGhpcy5fdGFpbCA9ICh0aGlzLl9oZWFkICsgaSArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZWQgPSB0aGlzLnJlbW92ZShpLCBjb3VudCk7XG4gICAgICAgIHRoaXMuX3RhaWwgPSAodGhpcy5fdGFpbCAtIGxlbmcgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ3VtZW50c19pbmRleCA8IGFyZ19sZW4pIHtcbiAgICAgICAgdGhpcy5wdXNoKGFyZ3VtZW50c1thcmd1bWVudHNfaW5kZXgrK10pO1xuICAgICAgfVxuICAgICAgZm9yIChrID0gMDsgayA8IGxlbmc7IGsrKykge1xuICAgICAgICB0aGlzLnB1c2godGVtcFtrXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZShpLCBjb3VudCk7XG4gIH1cbn07XG5cbi8qKlxuICogU29mdCBjbGVhciAtIGRvZXMgbm90IHJlc2V0IGNhcGFjaXR5LlxuICovXG5EZW5xdWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gIHRoaXMuX2hlYWQgPSAwO1xuICB0aGlzLl90YWlsID0gMDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIHdoZXRoZXIgdGhlIGxpc3QgaXMgZW1wdHkuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgcmV0dXJuIHRoaXMuX2hlYWQgPT09IHRoaXMuX3RhaWw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHF1ZXVlIGl0ZW1zLlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5EZW5xdWUucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fY29weUFycmF5KGZhbHNlKTtcbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLVxuICogICBJTlRFUk5BTFNcbiAqIC0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEZpbGxzIHRoZSBxdWV1ZSB3aXRoIGl0ZW1zIGZyb20gYW4gYXJyYXlcbiAqIEZvciB1c2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUuX2Zyb21BcnJheSA9IGZ1bmN0aW9uIF9mcm9tQXJyYXkoYXJyYXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgdGhpcy5wdXNoKGFycmF5W2ldKTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBmdWxsQ29weVxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuRGVucXVlLnByb3RvdHlwZS5fY29weUFycmF5ID0gZnVuY3Rpb24gX2NvcHlBcnJheShmdWxsQ29weSkge1xuICB2YXIgbmV3QXJyYXkgPSBbXTtcbiAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpO1xuICBpZiAoZnVsbENvcHkgfHwgdGhpcy5faGVhZCA+IHRoaXMuX3RhaWwpIHtcbiAgICBmb3IgKGkgPSB0aGlzLl9oZWFkOyBpIDwgbGVuOyBpKyspIG5ld0FycmF5LnB1c2gobGlzdFtpXSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX3RhaWw7IGkrKykgbmV3QXJyYXkucHVzaChsaXN0W2ldKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSB0aGlzLl9oZWFkOyBpIDwgdGhpcy5fdGFpbDsgaSsrKSBuZXdBcnJheS5wdXNoKGxpc3RbaV0pO1xuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn07XG5cbi8qKlxuICogR3Jvd3MgdGhlIGludGVybmFsIGxpc3QgYXJyYXkuXG4gKiBAcHJpdmF0ZVxuICovXG5EZW5xdWUucHJvdG90eXBlLl9ncm93QXJyYXkgPSBmdW5jdGlvbiBfZ3Jvd0FycmF5KCkge1xuICBpZiAodGhpcy5faGVhZCkge1xuICAgIC8vIGNvcHkgZXhpc3RpbmcgZGF0YSwgaGVhZCB0byBlbmQsIHRoZW4gYmVnaW5uaW5nIHRvIHRhaWwuXG4gICAgdGhpcy5fbGlzdCA9IHRoaXMuX2NvcHlBcnJheSh0cnVlKTtcbiAgICB0aGlzLl9oZWFkID0gMDtcbiAgfVxuXG4gIC8vIGhlYWQgaXMgYXQgMCBhbmQgYXJyYXkgaXMgbm93IGZ1bGwsIHNhZmUgdG8gZXh0ZW5kXG4gIHRoaXMuX3RhaWwgPSB0aGlzLl9saXN0Lmxlbmd0aDtcblxuICB0aGlzLl9saXN0Lmxlbmd0aCA8PD0gMTtcbiAgdGhpcy5fY2FwYWNpdHlNYXNrID0gKHRoaXMuX2NhcGFjaXR5TWFzayA8PCAxKSB8IDE7XG59O1xuXG4vKipcbiAqIFNocmlua3MgdGhlIGludGVybmFsIGxpc3QgYXJyYXkuXG4gKiBAcHJpdmF0ZVxuICovXG5EZW5xdWUucHJvdG90eXBlLl9zaHJpbmtBcnJheSA9IGZ1bmN0aW9uIF9zaHJpbmtBcnJheSgpIHtcbiAgdGhpcy5fbGlzdC5sZW5ndGggPj4+PSAxO1xuICB0aGlzLl9jYXBhY2l0eU1hc2sgPj4+PSAxO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERlbnF1ZTtcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgeyBhcHAsIEJyb3dzZXJXaW5kb3csIG5hdGl2ZVRoZW1lIH0gZnJvbSAnZWxlY3Ryb24nXG5pbXBvcnQgeyB0b1N0cmluZyBhcyB1aW50OEFycmF5VG9TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy90by1zdHJpbmcnO1xuaW1wb3J0IHsgY29uY2F0IGFzIHVpbnQ4QXJyYXlDb25jYXQgfSBmcm9tICd1aW50OGFycmF5cy9jb25jYXQnO1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IG9zIGZyb20gJ29zJ1xuXG4vLyBuZWVkZWQgaW4gY2FzZSBwcm9jZXNzIGlzIHVuZGVmaW5lZCB1bmRlciBMaW51eFxuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtIHx8IG9zLnBsYXRmb3JtKClcblxudHJ5IHtcbiAgaWYgKHBsYXRmb3JtID09PSAnd2luMzInICYmIG5hdGl2ZVRoZW1lLnNob3VsZFVzZURhcmtDb2xvcnMgPT09IHRydWUpIHtcbiAgICByZXF1aXJlKCdmcycpLnVubGlua1N5bmMocGF0aC5qb2luKGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLCAnRGV2VG9vbHMgRXh0ZW5zaW9ucycpKVxuICB9XG59IGNhdGNoIChfKSB7IH1cblxubGV0IG1haW5XaW5kb3dcblxuYXN5bmMgZnVuY3Rpb24gc3RhcnRJcGZzKClcbntcbiAgY29uc3QgeyBjcmVhdGVFZDI1NTE5UGVlcklkIH0gPSBhd2FpdCBpbXBvcnQoJ0BsaWJwMnAvcGVlci1pZC1mYWN0b3J5Jyk7XG4gIGNvbnN0IHsgUHJlU2hhcmVkS2V5Q29ubmVjdGlvblByb3RlY3RvciB9ID0gYXdhaXQgaW1wb3J0KCdsaWJwMnAvcG5ldCcpO1xuICBjb25zdCB7IEdvc3NpcFN1YiB9ID0gYXdhaXQgaW1wb3J0KCdAY2hhaW5zYWZlL2xpYnAycC1nb3NzaXBzdWInKTtcbiAgY29uc3QgeyBjcmVhdGVGcm9tUHJpdktleSB9ID0gYXdhaXQgaW1wb3J0KCdAbGlicDJwL3BlZXItaWQtZmFjdG9yeScpO1xuICBjb25zdCB7IHVubWFyc2hhbFByaXZhdGVLZXkgfSA9IGF3YWl0IGltcG9ydCgnQGxpYnAycC9jcnlwdG8va2V5cycpO1xuICBjb25zdCBjcmVhdGVJcGZzID0gKGF3YWl0IGltcG9ydCgnaXBmcycpKS5jcmVhdGU7XG5cbiAgLy8gY29uc3QgcGlkID0gYXdhaXQgY3JlYXRlRWQyNTUxOVBlZXJJZCgpO1xuICAvLyBjb25zb2xlLmxvZyhwaWQudG9TdHJpbmcoKSk7XG4gIC8vIGNvbnN0IGVuYyA9IEJ1ZmZlci5mcm9tKHBpZC5wcml2YXRlS2V5KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIC8vIGNvbnNvbGUubG9nKGVuYyk7XG4gIC8vIGNvbnN0IGRlYyA9IEJ1ZmZlci5mcm9tKGVuYywgJ2Jhc2U2NCcpO1xuICAvLyBjb25zb2xlLmxvZyhkZWMpO1xuICAvLyBjb25zdCBQSyA9IGF3YWl0IHVubWFyc2hhbFByaXZhdGVLZXkobmV3IFVpbnQ4QXJyYXkoZGVjKSk7XG5cbiAgY29uc3QgcHJpdmtleUMgPSBcIkNBRVNRRnRGVDdoeUtmczZZTDB2OVl3K0d6bHZvR3lteGlRUGI4TVlHVE12V3F5a2JtRm5yaXIyWGJsVFQ1Tm5NUytGcUZOSG5PWUNPZ3NweEkvYm1SOUZDRlk9XCI7XG4gIGNvbnN0IHByaXZrZXlKID0gXCJDQUVTUUNpblp6TWFXV2h3bWJZZnAxdDZXUmZHK3h2b1U5OG5NSHdpb00zd1lWSXFMOG1QZzdFT3FqZ2tUK2FJVGFiaVJlSVpvNGxVeUxvK2tJMGZXRkR4SXo0PVwiO1xuICBjb25zdCBwcml2a2V5TSA9IFwiQ0FFU1FLYVNFa1M5azM2cTFNNTlOeGxuY2lvSTR0NkJMRXFJczJFMGZRd0pabFh5WG9QM0pWZmo5bHozMUNYUElVWktFN1UyZWZnWVcxM3lxZUd2TldLbW5LZz1cIjtcbiAgY29uc3QgcHJpdmtleU8gPSBcIkNBRVNRUEhXcUtHTWpMWGxIeW9ZWUVmZEh6bmhZWHdteGkyZFVQY1VDaU00cGluRE16QWM4T21zdGRQSjREUHF6ZHYveTNRRlM5eUkwU09GaWpPNDNKOTE5Z3c9XCI7XG4gIFxuICBjb25zdCBib290c3RyYXAgPSBbXTtcbiAgLy8gY29uc3QgYm9vdHN0cmFwID0gW1xuICAvLyAgICcvaXA0LzUuNTEuMTcyLjM5L3RjcC80MDAyL3AycC94eHgnLFxuICAvLyAgICcvaXA0LzUuNTEuMTcyLjM5L3RjcC80MDAyL3AycC94eHgnLFxuICAvLyAgICcvaXA0LzUuNTEuMTcyLjM5L3RjcC80MDAzL3dzL3AycC94eHgnLFxuICAvLyBdO1xuICBcbiAgY29uc3QgcHJpdktleSA9IEJ1ZmZlci5mcm9tKHByaXZrZXlPLCAnYmFzZTY0Jyk7XG4gIGNvbnN0IFBLID0gYXdhaXQgdW5tYXJzaGFsUHJpdmF0ZUtleShuZXcgVWludDhBcnJheShwcml2S2V5KSk7XG4gIFxuICAvLyBjb25zdCBteVBlZXJJZCA9IGF3YWl0IGNyZWF0ZUVkMjU1MTlQZWVySWQoKTtcbiAgY29uc3QgbXlQZWVySWQgPSBhd2FpdCBjcmVhdGVGcm9tUHJpdktleShQSyk7XG4gIGNvbnNvbGUubG9nKCdteSBwZWVySWQ6JyxteVBlZXJJZC50b1N0cmluZygpKTtcblxuXG4gIGNvbnN0IHN3YXJtS2V5ID0gJ0wydGxlUzl6ZDJGeWJTOXdjMnN2TVM0d0xqQXZDaTlpWVhObE1UWXZDalprTURCbU5qQTNNRGMyWlRFM05UTTBOelpoTURrM01XUTNOREF6Tm1WaVpEVTVZVEk0TkRRNFlqTmtaR0ZtT1RBd1pUWXpZakpoWkRjNE1qZ3pPR0knO1xuXG4gIGNvbnN0IHAycE9wdGlvbnMgPSB7XG4gICAgcGVlcklkOiBteVBlZXJJZCxcbiAgICBwdWJzdWI6IG5ldyBHb3NzaXBTdWIoe1xuICAgICAgYWxsb3dQdWJsaXNoVG9aZXJvUGVlcnM6IHRydWUsXG4gICAgICBmYWxsYmFja1RvRmxvb2RzdWI6IHRydWUsXG4gICAgICBlbWl0U2VsZjogZmFsc2UsXG4gICAgICBtYXhJbmJvdW5kU3RyZWFtczogNjQsXG4gICAgICBtYXhPdXRib3VuZFN0cmVhbXM6IDEyOCxcbiAgICB9KSxcbiAgICBjb25uZWN0aW9uUHJvdGVjdG9yOiBuZXcgUHJlU2hhcmVkS2V5Q29ubmVjdGlvblByb3RlY3Rvcih7XG4gICAgICBwc2s6IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHN3YXJtS2V5LCAnYmFzZTY0JykpLFxuICAgIH0pLFxuICAgIG5hdDoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgfSxcbiAgfTtcblxuICBpcGZzID0gYXdhaXQgY3JlYXRlSXBmcyh7XG4gICAgbGlicDJwOiBwMnBPcHRpb25zLFxuICAgIHJlcG86IHBhdGguam9pbihvcy5ob21lZGlyKCksICcuaXBmcy0nK215UGVlcklkLnRvU3RyaW5nKCkpLFxuICAgIGNvbmZpZzoge1xuICAgICAgQm9vdHN0cmFwOiBib290c3RyYXAsXG4gICAgfSxcbiAgfSk7XG5cbiAgY29uc3QgbGlicDJwID0gaXBmcy5saWJwMnA7XG5cbiAgbGlicDJwLmNvbm5lY3Rpb25NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3BlZXI6Y29ubmVjdCcsIGFzeW5jIChldnQpID0+IHtcbiAgICBjb25zdCB7IGRldGFpbDogY29ubmVjdGlvbiB9ID0gZXZ0O1xuICAgIGNvbnN0IHsgcmVtb3RlUGVlciB9ID0gY29ubmVjdGlvbjtcbiAgICBjb25zb2xlLmxvZyggJ3BlZXI6Y29ubmVjdCcsIHJlbW90ZVBlZXIudG9TdHJpbmcoKSk7XG4gIH0pO1xuXG4gIGxpYnAycC5jb25uZWN0aW9uTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKCdwZWVyOmRpc2Nvbm5lY3QnLCBhc3luYyAoZXZ0KSA9PiB7XG4gICAgY29uc3QgeyBkZXRhaWw6IGNvbm5lY3Rpb24gfSA9IGV2dDtcbiAgICBjb25zdCB7IHJlbW90ZVBlZXIgfSA9IGNvbm5lY3Rpb247XG4gICAgY29uc29sZS5sb2coICdwZWVyOmRpc2Nvbm5lY3QnLCByZW1vdGVQZWVyLnRvU3RyaW5nKCkpO1xuICB9KTtcblxuICBhd2FpdCBpcGZzLnB1YnN1Yi5zdWJzY3JpYmUoJ2lwZnNmaWxlbXNnJywgYXN5bmMgKG1zZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdnb3QgZmlsZSBtZXNzYWdlIDogJywgbXNnLmZyb20udG9TdHJpbmcoKSwgdWludDhBcnJheVRvU3RyaW5nKG1zZy5kYXRhKSk7XG5cbiAgICBjb25zdCBjaWQgPSBDSUQucGFyc2UodWludDhBcnJheVRvU3RyaW5nKG1zZy5kYXRhKSk7XG5cbiAgICAvL3JlYWQgZmlsZVxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXBmcy5jYXQoY2lkKSkge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gdWludDhBcnJheVRvU3RyaW5nKHVpbnQ4QXJyYXlDb25jYXQoY2h1bmtzKSk7XG4gICAgY29uc29sZS5sb2coJ2dvdCBmaWxlIDogJywgY29udGVudCk7XG4gIH0pO1xuXG4gIGF3YWl0IGlwZnMucHVic3ViLnN1YnNjcmliZSgnaXBmc2RhZ21zZycsIGFzeW5jIChtc2cpID0+IHtcbiAgICBjb25zb2xlLmxvZygnZ290IGRhZyBtZXNzYWdlIDogJW8nLCBtc2cuZnJvbS50b1N0cmluZygpLCB1aW50OEFycmF5VG9TdHJpbmcobXNnLmRhdGEpKTtcblxuICAgIC8vIHJlYWQgZGFnXG4gICAgY29uc3QgY2lkID0gQ0lELnBhcnNlKHVpbnQ4QXJyYXlUb1N0cmluZyhtc2cuZGF0YSkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlwZnMuZGFnLmdldChjaWQpO1xuICAgIGNvbnNvbGUubG9nKCdnb3QgZGFnIDogJywgcmVzdWx0LnZhbHVlKTtcbiAgfSk7XG5cbiAgLy8gMiBzdWJzY3JpYmUgPT4gMiBldmVudHNcbiAgLy8gYXdhaXQgaXBmcy5wdWJzdWIuc3Vic2NyaWJlKCdpcGZzZmlsZW1zZycsIChtc2cpID0+IHtcbiAgLy8gICBjb25zb2xlLmxvZygnZ290IG1lc3NhZ2UgOiAnLCBtc2cuZnJvbS50b1N0cmluZygpLCB1aW50OEFycmF5VG9TdHJpbmcobXNnLmRhdGEpKTtcbiAgLy8gfSk7XG5cbiAgbGV0IG5maWxlID0gMDtcbiAgc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgIC8vIHNob3cgY29ubmVjdGVkIHBlZXJzXG4gICAgY29uc3QgcGVlcnMgPSBhd2FpdCBpcGZzLnB1YnN1Yi5wZWVycygnaXBmc2ZpbGVtc2cnKTtcbiAgICBwZWVycy5mb3JFYWNoKChwKT0+IGNvbnNvbGUubG9nKCdwZWVyIDogJywgcC50b1N0cmluZygpKSk7XG5cbiAgICAvLyBwdXQgZmlsZSBjb250ZW50XG4gICAgY29uc3QgcmVzZmlsZSA9IGF3YWl0IGlwZnMuYWRkKG15UGVlcklkLnRvU3RyaW5nKCkrJyBpcGZzIGZpbGUgIycgKyBuZmlsZSk7XG4gICAgY29uc29sZS5sb2coJ3NhdmUgaXBmcyA6ICcsIHJlc2ZpbGUucGF0aCk7XG5cbiAgICBhd2FpdCBpcGZzLnB1YnN1Yi5wdWJsaXNoKCdpcGZzZmlsZW1zZycsICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocmVzZmlsZS5wYXRoKSk7XG5cbiAgICAvLyBwdXQgZGFnIGNvbnRlbnRcbiAgICBjb25zdCByZXNkYWcgPSBhd2FpdCBpcGZzLmRhZy5wdXQoe1xuICAgICAgY29udGVudDogbXlQZWVySWQudG9TdHJpbmcoKSsnIGlwZnMgZGFnICMnICsgbmZpbGUsXG4gICAgfSwgeyBzdG9yZUNvZGVjOiAnZGFnLWNib3InLCBoYXNoQWxnOiAnc2hhMi0yNTYnIH0pO1xuICAgIGNvbnNvbGUubG9nKCdzYXZlIGRhZyA6ICcsIHJlc2RhZy50b1N0cmluZygpKTsgXG4gICAgICBcbiAgICBhd2FpdCBpcGZzLnB1YnN1Yi5wdWJsaXNoKCdpcGZzZGFnbXNnJywgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHJlc2RhZy50b1N0cmluZygpKSk7XG5cbiAgICBuZmlsZSsrO1xuXG4gIH0sMTAwMDApO1xuXG4gIGNvbnNvbGUubG9nKGF3YWl0IGlwZnMuYm9vdHN0cmFwLmxpc3QoKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdpbmRvdyAoKSB7XG4gIC8qKlxuICAgKiBJbml0aWFsIHdpbmRvdyBvcHRpb25zXG4gICAqL1xuICBtYWluV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xuICAgIGljb246IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICdpY29ucy9pY29uLnBuZycpLCAvLyB0cmF5IGljb25cbiAgICB3aWR0aDogMTAwMCxcbiAgICBoZWlnaHQ6IDYwMCxcbiAgICB1c2VDb250ZW50U2l6ZTogdHJ1ZSxcbiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgY29udGV4dElzb2xhdGlvbjogdHJ1ZSxcbiAgICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly92Mi5xdWFzYXIuZGV2L3F1YXNhci1jbGktdml0ZS9kZXZlbG9waW5nLWVsZWN0cm9uLWFwcHMvZWxlY3Ryb24tcHJlbG9hZC1zY3JpcHRcbiAgICAgIHByZWxvYWQ6IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIHByb2Nlc3MuZW52LlFVQVNBUl9FTEVDVFJPTl9QUkVMT0FEKVxuICAgIH1cbiAgfSlcblxuICBtYWluV2luZG93LmxvYWRVUkwocHJvY2Vzcy5lbnYuQVBQX1VSTClcblxuICBpZiAocHJvY2Vzcy5lbnYuREVCVUdHSU5HKSB7XG4gICAgLy8gaWYgb24gREVWIG9yIFByb2R1Y3Rpb24gd2l0aCBkZWJ1ZyBlbmFibGVkXG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5vcGVuRGV2VG9vbHMoKVxuICB9IGVsc2Uge1xuICAgIC8vIHdlJ3JlIG9uIHByb2R1Y3Rpb247IG5vIGFjY2VzcyB0byBkZXZ0b29scyBwbHNcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLm9uKCdkZXZ0b29scy1vcGVuZWQnLCAoKSA9PiB7XG4gICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLmNsb3NlRGV2VG9vbHMoKVxuICAgIH0pXG4gIH1cblxuICBzdGFydElwZnMoKTtcblxuICBtYWluV2luZG93Lm9uKCdjbG9zZWQnLCAoKSA9PiB7XG4gICAgbWFpbldpbmRvdyA9IG51bGxcbiAgfSlcbn1cblxuYXBwLndoZW5SZWFkeSgpLnRoZW4oY3JlYXRlV2luZG93KVxuXG5hcHAub24oJ3dpbmRvdy1hbGwtY2xvc2VkJywgKCkgPT4ge1xuICBpZiAocGxhdGZvcm0gIT09ICdkYXJ3aW4nKSB7XG4gICAgYXBwLnF1aXQoKVxuICB9XG59KVxuXG5hcHAub24oJ2FjdGl2YXRlJywgKCkgPT4ge1xuICBpZiAobWFpbldpbmRvdyA9PT0gbnVsbCkge1xuICAgIGNyZWF0ZVdpbmRvdygpXG4gIH1cbn0pXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTLEtBQUssVUFBVUEsT0FBTTtBQUM1QixNQUFJLFNBQVMsVUFBVSxLQUFLO0FBQzFCLFVBQU0sSUFBSSxVQUFVLG1CQUFtQjtBQUFBLEVBQ3pDO0FBQ0EsTUFBSSxXQUFXLElBQUksV0FBVyxHQUFHO0FBQ2pDLFdBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDeEMsYUFBUyxLQUFLO0FBQUEsRUFDaEI7QUFDQSxXQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxLQUFLO0FBQ3hDLFFBQUksSUFBSSxTQUFTLE9BQU8sQ0FBQztBQUN6QixRQUFJLEtBQUssRUFBRSxXQUFXLENBQUM7QUFDdkIsUUFBSSxTQUFTLFFBQVEsS0FBSztBQUN4QixZQUFNLElBQUksVUFBVSxJQUFJLGVBQWU7QUFBQSxJQUN6QztBQUNBLGFBQVMsTUFBTTtBQUFBLEVBQ2pCO0FBQ0EsTUFBSSxPQUFPLFNBQVM7QUFDcEIsTUFBSSxTQUFTLFNBQVMsT0FBTyxDQUFDO0FBQzlCLE1BQUksU0FBUyxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxHQUFHO0FBQzFDLE1BQUksVUFBVSxLQUFLLElBQUksR0FBRyxJQUFJLEtBQUssSUFBSSxJQUFJO0FBQzNDLFdBQVNDLFFBQU8sUUFBUTtBQUN0QixRQUFJLGtCQUFrQjtBQUFXO0FBQUEsYUFDeEIsWUFBWSxPQUFPLE1BQU0sR0FBRztBQUNuQyxlQUFTLElBQUksV0FBVyxPQUFPLFFBQVEsT0FBTyxZQUFZLE9BQU8sVUFBVTtBQUFBLElBQzdFLFdBQVcsTUFBTSxRQUFRLE1BQU0sR0FBRztBQUNoQyxlQUFTLFdBQVcsS0FBSyxNQUFNO0FBQUEsSUFDakM7QUFDQSxRQUFJLEVBQUUsa0JBQWtCLGFBQWE7QUFDbkMsWUFBTSxJQUFJLFVBQVUscUJBQXFCO0FBQUEsSUFDM0M7QUFDQSxRQUFJLE9BQU8sV0FBVyxHQUFHO0FBQ3ZCLGFBQU87QUFBQSxJQUNUO0FBQ0EsUUFBSSxTQUFTO0FBQ2IsUUFBSUMsVUFBUztBQUNiLFFBQUksU0FBUztBQUNiLFFBQUksT0FBTyxPQUFPO0FBQ2xCLFdBQU8sV0FBVyxRQUFRLE9BQU8sWUFBWSxHQUFHO0FBQzlDO0FBQ0E7QUFBQSxJQUNGO0FBQ0EsUUFBSSxRQUFRLE9BQU8sVUFBVSxVQUFVLE1BQU07QUFDN0MsUUFBSSxNQUFNLElBQUksV0FBVyxJQUFJO0FBQzdCLFdBQU8sV0FBVyxNQUFNO0FBQ3RCLFVBQUksUUFBUSxPQUFPO0FBQ25CLFVBQUlDLEtBQUk7QUFDUixlQUFTLE1BQU0sT0FBTyxJQUFJLFVBQVUsS0FBS0EsS0FBSUQsWUFBVyxRQUFRLElBQUksT0FBT0MsTUFBSztBQUM5RSxpQkFBUyxNQUFNLElBQUksU0FBUztBQUM1QixZQUFJLE9BQU8sUUFBUSxTQUFTO0FBQzVCLGdCQUFRLFFBQVEsU0FBUztBQUFBLE1BQzNCO0FBQ0EsVUFBSSxVQUFVLEdBQUc7QUFDZixjQUFNLElBQUksTUFBTSxnQkFBZ0I7QUFBQSxNQUNsQztBQUNBLE1BQUFELFVBQVNDO0FBQ1Q7QUFBQSxJQUNGO0FBQ0EsUUFBSSxNQUFNLE9BQU9EO0FBQ2pCLFdBQU8sUUFBUSxRQUFRLElBQUksU0FBUyxHQUFHO0FBQ3JDO0FBQUEsSUFDRjtBQUNBLFFBQUksTUFBTSxPQUFPLE9BQU8sTUFBTTtBQUM5QixXQUFPLE1BQU0sTUFBTSxFQUFFLEtBQUs7QUFDeEIsYUFBTyxTQUFTLE9BQU8sSUFBSSxJQUFJO0FBQUEsSUFDakM7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNBLFdBQVMsYUFBYSxRQUFRO0FBQzVCLFFBQUksT0FBTyxXQUFXLFVBQVU7QUFDOUIsWUFBTSxJQUFJLFVBQVUsaUJBQWlCO0FBQUEsSUFDdkM7QUFDQSxRQUFJLE9BQU8sV0FBVyxHQUFHO0FBQ3ZCLGFBQU8sSUFBSSxXQUFXO0FBQUEsSUFDeEI7QUFDQSxRQUFJLE1BQU07QUFDVixRQUFJLE9BQU8sU0FBUyxLQUFLO0FBQ3ZCO0FBQUEsSUFDRjtBQUNBLFFBQUksU0FBUztBQUNiLFFBQUlBLFVBQVM7QUFDYixXQUFPLE9BQU8sU0FBUyxRQUFRO0FBQzdCO0FBQ0E7QUFBQSxJQUNGO0FBQ0EsUUFBSSxRQUFRLE9BQU8sU0FBUyxPQUFPLFNBQVMsTUFBTTtBQUNsRCxRQUFJLE9BQU8sSUFBSSxXQUFXLElBQUk7QUFDOUIsV0FBTyxPQUFPLE1BQU07QUFDbEIsVUFBSSxRQUFRLFNBQVMsT0FBTyxXQUFXLEdBQUc7QUFDMUMsVUFBSSxVQUFVLEtBQUs7QUFDakI7QUFBQSxNQUNGO0FBQ0EsVUFBSUMsS0FBSTtBQUNSLGVBQVMsTUFBTSxPQUFPLElBQUksVUFBVSxLQUFLQSxLQUFJRCxZQUFXLFFBQVEsSUFBSSxPQUFPQyxNQUFLO0FBQzlFLGlCQUFTLE9BQU8sS0FBSyxTQUFTO0FBQzlCLGFBQUssT0FBTyxRQUFRLFFBQVE7QUFDNUIsZ0JBQVEsUUFBUSxRQUFRO0FBQUEsTUFDMUI7QUFDQSxVQUFJLFVBQVUsR0FBRztBQUNmLGNBQU0sSUFBSSxNQUFNLGdCQUFnQjtBQUFBLE1BQ2xDO0FBQ0EsTUFBQUQsVUFBU0M7QUFDVDtBQUFBLElBQ0Y7QUFDQSxRQUFJLE9BQU8sU0FBUyxLQUFLO0FBQ3ZCO0FBQUEsSUFDRjtBQUNBLFFBQUksTUFBTSxPQUFPRDtBQUNqQixXQUFPLFFBQVEsUUFBUSxLQUFLLFNBQVMsR0FBRztBQUN0QztBQUFBLElBQ0Y7QUFDQSxRQUFJLE1BQU0sSUFBSSxXQUFXLFVBQVUsT0FBTyxJQUFJO0FBQzlDLFFBQUlFLEtBQUk7QUFDUixXQUFPLFFBQVEsTUFBTTtBQUNuQixVQUFJQSxRQUFPLEtBQUs7QUFBQSxJQUNsQjtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0EsV0FBU0MsUUFBT0MsU0FBUTtBQUN0QixRQUFJLFNBQVMsYUFBYUEsT0FBTTtBQUNoQyxRQUFJLFFBQVE7QUFDVixhQUFPO0FBQUEsSUFDVDtBQUNBLFVBQU0sSUFBSSxNQUFNLE9BQVFOLGlCQUFpQjtBQUFBLEVBQzNDO0FBQ0EsU0FBTztBQUFBLElBQ0wsUUFBUUM7QUFBQSxJQUNSO0FBQUEsSUFDQSxRQUFRSTtBQUFBLEVBQ1Y7QUFDRjtBQWpJQSxJQWtJSSxLQUNBLGlDQUNHO0FBcElQO0FBQUE7QUFrSUEsSUFBSSxNQUFNO0FBQ1YsSUFBSSxrQ0FBa0M7QUFDdEMsSUFBTyxpQkFBUTtBQUFBO0FBQUE7OztBQ3BJZixJQUFNLE9BTUEsUUFhQSxRQVdBLFlBQ0E7QUEvQk47QUFBQTtBQUFBLElBQU0sUUFBUSxJQUFJLFdBQVcsQ0FBQztBQU05QixJQUFNLFNBQVMsQ0FBQyxJQUFJLE9BQU87QUFDekIsVUFBSSxPQUFPO0FBQ1QsZUFBTztBQUNULFVBQUksR0FBRyxlQUFlLEdBQUcsWUFBWTtBQUNuQyxlQUFPO0FBQUEsTUFDVDtBQUNBLGVBQVMsS0FBSyxHQUFHLEtBQUssR0FBRyxZQUFZLE1BQU07QUFDekMsWUFBSSxHQUFHLFFBQVEsR0FBRyxLQUFLO0FBQ3JCLGlCQUFPO0FBQUEsUUFDVDtBQUFBLE1BQ0Y7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUNBLElBQU0sU0FBUyxPQUFLO0FBQ2xCLFVBQUksYUFBYSxjQUFjLEVBQUUsWUFBWSxTQUFTO0FBQ3BELGVBQU87QUFDVCxVQUFJLGFBQWE7QUFDZixlQUFPLElBQUksV0FBVyxDQUFDO0FBQ3pCLFVBQUksWUFBWSxPQUFPLENBQUMsR0FBRztBQUN6QixlQUFPLElBQUksV0FBVyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsVUFBVTtBQUFBLE1BQzVEO0FBQ0EsWUFBTSxJQUFJLE1BQU0sbUNBQW1DO0FBQUEsSUFDckQ7QUFFQSxJQUFNLGFBQWEsU0FBTyxJQUFJLFlBQVksRUFBRSxPQUFPLEdBQUc7QUFDdEQsSUFBTSxXQUFXLE9BQUssSUFBSSxZQUFZLEVBQUUsT0FBTyxDQUFDO0FBQUE7QUFBQTs7O0FDL0JoRCxJQUVNLFNBY0EsU0F3QkEsaUJBaUJPLElBSUEsT0FnQkEsTUFDQSxPQVNQLFFBOEJBLFFBd0JPO0FBN0liO0FBQUE7QUFBQTtBQUNBO0FBQ0EsSUFBTSxVQUFOLE1BQWM7QUFBQSxNQUNaLFlBQVlFLE9BQU0sUUFBUSxZQUFZO0FBQ3BDLGFBQUssT0FBT0E7QUFDWixhQUFLLFNBQVM7QUFDZCxhQUFLLGFBQWE7QUFBQSxNQUNwQjtBQUFBLE1BQ0EsT0FBTyxPQUFPO0FBQ1osWUFBSSxpQkFBaUIsWUFBWTtBQUMvQixpQkFBTyxHQUFJLEtBQUssU0FBVyxLQUFLLFdBQVcsS0FBSztBQUFBLFFBQ2xELE9BQU87QUFDTCxnQkFBTSxNQUFNLG1DQUFtQztBQUFBLFFBQ2pEO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxJQUFNLFVBQU4sTUFBYztBQUFBLE1BQ1osWUFBWUEsT0FBTSxRQUFRLFlBQVk7QUFDcEMsYUFBSyxPQUFPQTtBQUNaLGFBQUssU0FBUztBQUNkLFlBQUksT0FBTyxZQUFZLENBQUMsTUFBTSxRQUFXO0FBQ3ZDLGdCQUFNLElBQUksTUFBTSwwQkFBMEI7QUFBQSxRQUM1QztBQUNBLGFBQUssa0JBQWtCLE9BQU8sWUFBWSxDQUFDO0FBQzNDLGFBQUssYUFBYTtBQUFBLE1BQ3BCO0FBQUEsTUFDQSxPQUFPLE1BQU07QUFDWCxZQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCLGNBQUksS0FBSyxZQUFZLENBQUMsTUFBTSxLQUFLLGlCQUFpQjtBQUNoRCxrQkFBTSxNQUFNLHFDQUFzQyxLQUFLLFVBQVUsSUFBSSxNQUFRLEtBQUssbURBQXFELEtBQUssUUFBUztBQUFBLFVBQ3ZKO0FBQ0EsaUJBQU8sS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLE9BQU8sTUFBTSxDQUFDO0FBQUEsUUFDdkQsT0FBTztBQUNMLGdCQUFNLE1BQU0sbUNBQW1DO0FBQUEsUUFDakQ7QUFBQSxNQUNGO0FBQUEsTUFDQSxHQUFHLFNBQVM7QUFDVixlQUFPLEdBQUcsTUFBTSxPQUFPO0FBQUEsTUFDekI7QUFBQSxJQUNGO0FBQ0EsSUFBTSxrQkFBTixNQUFzQjtBQUFBLE1BQ3BCLFlBQVlDLFdBQVU7QUFDcEIsYUFBSyxXQUFXQTtBQUFBLE1BQ2xCO0FBQUEsTUFDQSxHQUFHLFNBQVM7QUFDVixlQUFPLEdBQUcsTUFBTSxPQUFPO0FBQUEsTUFDekI7QUFBQSxNQUNBLE9BQU8sT0FBTztBQUNaLGNBQU0sU0FBUyxNQUFNO0FBQ3JCLGNBQU0sVUFBVSxLQUFLLFNBQVM7QUFDOUIsWUFBSSxTQUFTO0FBQ1gsaUJBQU8sUUFBUSxPQUFPLEtBQUs7QUFBQSxRQUM3QixPQUFPO0FBQ0wsZ0JBQU0sV0FBVyxxQ0FBc0MsS0FBSyxVQUFVLEtBQUssZ0NBQWtDLE9BQU8sS0FBSyxLQUFLLFFBQVEsaUJBQWtCO0FBQUEsUUFDMUo7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNPLElBQU0sS0FBSyxDQUFDLE1BQU0sVUFBVSxJQUFJLGdCQUFnQjtBQUFBLE1BQ3JELEdBQUcsS0FBSyxZQUFZLEVBQUUsQ0FBQyxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQzFDLEdBQUcsTUFBTSxZQUFZLEVBQUUsQ0FBQyxNQUFNLFNBQVMsTUFBTTtBQUFBLElBQy9DLENBQUM7QUFDTSxJQUFNLFFBQU4sTUFBWTtBQUFBLE1BQ2pCLFlBQVlELE9BQU0sUUFBUSxZQUFZLFlBQVk7QUFDaEQsYUFBSyxPQUFPQTtBQUNaLGFBQUssU0FBUztBQUNkLGFBQUssYUFBYTtBQUNsQixhQUFLLGFBQWE7QUFDbEIsYUFBSyxVQUFVLElBQUksUUFBUUEsT0FBTSxRQUFRLFVBQVU7QUFDbkQsYUFBSyxVQUFVLElBQUksUUFBUUEsT0FBTSxRQUFRLFVBQVU7QUFBQSxNQUNyRDtBQUFBLE1BQ0EsT0FBTyxPQUFPO0FBQ1osZUFBTyxLQUFLLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDbEM7QUFBQSxNQUNBLE9BQU8sT0FBTztBQUNaLGVBQU8sS0FBSyxRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2xDO0FBQUEsSUFDRjtBQUNPLElBQU0sT0FBTyxDQUFDLEVBQUMsTUFBQUEsT0FBTSxRQUFRLFFBQUFFLFNBQVEsUUFBQUMsUUFBTSxNQUFNLElBQUksTUFBTUgsT0FBTSxRQUFRRSxTQUFRQyxPQUFNO0FBQ3ZGLElBQU0sUUFBUSxDQUFDLEVBQUMsUUFBUSxNQUFBSCxPQUFNLFVBQUFJLFVBQVEsTUFBTTtBQUNqRCxZQUFNLEVBQUMsUUFBQUYsU0FBUSxRQUFBQyxRQUFNLElBQUksZUFBTUMsV0FBVUosS0FBSTtBQUM3QyxhQUFPLEtBQUs7QUFBQSxRQUNWO0FBQUEsUUFDQSxNQUFBQTtBQUFBLFFBQ0EsUUFBQUU7QUFBQSxRQUNBLFFBQVEsVUFBUSxPQUFPQyxRQUFPLElBQUksQ0FBQztBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNIO0FBQ0EsSUFBTSxTQUFTLENBQUNFLFNBQVFELFdBQVUsYUFBYUosVUFBUztBQUN0RCxZQUFNTSxTQUFRLENBQUM7QUFDZixlQUFTLElBQUksR0FBRyxJQUFJRixVQUFTLFFBQVEsRUFBRSxHQUFHO0FBQ3hDLFFBQUFFLE9BQU1GLFVBQVMsTUFBTTtBQUFBLE1BQ3ZCO0FBQ0EsVUFBSSxNQUFNQyxRQUFPO0FBQ2pCLGFBQU9BLFFBQU8sTUFBTSxPQUFPLEtBQUs7QUFDOUIsVUFBRTtBQUFBLE1BQ0o7QUFDQSxZQUFNLE1BQU0sSUFBSSxXQUFXLE1BQU0sY0FBYyxJQUFJLENBQUM7QUFDcEQsVUFBSSxPQUFPO0FBQ1gsVUFBSSxTQUFTO0FBQ2IsVUFBSSxVQUFVO0FBQ2QsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUUsR0FBRztBQUM1QixjQUFNLFFBQVFDLE9BQU1ELFFBQU87QUFDM0IsWUFBSSxVQUFVLFFBQVc7QUFDdkIsZ0JBQU0sSUFBSSxZQUFZLE9BQVFMLGlCQUFpQjtBQUFBLFFBQ2pEO0FBQ0EsaUJBQVMsVUFBVSxjQUFjO0FBQ2pDLGdCQUFRO0FBQ1IsWUFBSSxRQUFRLEdBQUc7QUFDYixrQkFBUTtBQUNSLGNBQUksYUFBYSxNQUFNLFVBQVU7QUFBQSxRQUNuQztBQUFBLE1BQ0Y7QUFDQSxVQUFJLFFBQVEsZUFBZSxNQUFNLFVBQVUsSUFBSSxNQUFNO0FBQ25ELGNBQU0sSUFBSSxZQUFZLHdCQUF3QjtBQUFBLE1BQ2hEO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFDQSxJQUFNLFNBQVMsQ0FBQyxNQUFNSSxXQUFVLGdCQUFnQjtBQUM5QyxZQUFNLE1BQU1BLFVBQVNBLFVBQVMsU0FBUyxPQUFPO0FBQzlDLFlBQU0sUUFBUSxLQUFLLGVBQWU7QUFDbEMsVUFBSSxNQUFNO0FBQ1YsVUFBSSxPQUFPO0FBQ1gsVUFBSSxTQUFTO0FBQ2IsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsRUFBRSxHQUFHO0FBQ3BDLGlCQUFTLFVBQVUsSUFBSSxLQUFLO0FBQzVCLGdCQUFRO0FBQ1IsZUFBTyxPQUFPLGFBQWE7QUFDekIsa0JBQVE7QUFDUixpQkFBT0EsVUFBUyxPQUFPLFVBQVU7QUFBQSxRQUNuQztBQUFBLE1BQ0Y7QUFDQSxVQUFJLE1BQU07QUFDUixlQUFPQSxVQUFTLE9BQU8sVUFBVSxjQUFjO0FBQUEsTUFDakQ7QUFDQSxVQUFJLEtBQUs7QUFDUCxlQUFPLElBQUksU0FBUyxjQUFjLEdBQUc7QUFDbkMsaUJBQU87QUFBQSxRQUNUO0FBQUEsTUFDRjtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQ08sSUFBTSxVQUFVLENBQUMsRUFBQyxNQUFBSixPQUFNLFFBQVEsYUFBYSxVQUFBSSxVQUFRLE1BQU07QUFDaEUsYUFBTyxLQUFLO0FBQUEsUUFDVjtBQUFBLFFBQ0EsTUFBQUo7QUFBQSxRQUNBLE9BQU8sT0FBTztBQUNaLGlCQUFPLE9BQU8sT0FBT0ksV0FBVSxXQUFXO0FBQUEsUUFDNUM7QUFBQSxRQUNBLE9BQU8sT0FBTztBQUNaLGlCQUFPLE9BQU8sT0FBT0EsV0FBVSxhQUFhSixLQUFJO0FBQUEsUUFDbEQ7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBQUE7QUFBQTs7O0FDeEpBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFLYTtBQUxiO0FBQUE7QUFBQTtBQUNBO0FBSU8sSUFBTSxXQUFXLEtBQUs7QUFBQSxNQUMzQixRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixRQUFRLFNBQU8sU0FBUyxHQUFHO0FBQUEsTUFDM0IsUUFBUSxTQUFPLFdBQVcsR0FBRztBQUFBLElBQy9CLENBQUM7QUFBQTtBQUFBOzs7QUNWRDtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQ2E7QUFEYjtBQUFBO0FBQUE7QUFDTyxJQUFNLFFBQVEsUUFBUTtBQUFBLE1BQzNCLFFBQVE7QUFBQSxNQUNSLE1BQU07QUFBQSxNQUNOLFVBQVU7QUFBQSxNQUNWLGFBQWE7QUFBQSxJQUNmLENBQUM7QUFBQTtBQUFBOzs7QUNORDtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQ2E7QUFEYjtBQUFBO0FBQUE7QUFDTyxJQUFNLFFBQVEsUUFBUTtBQUFBLE1BQzNCLFFBQVE7QUFBQSxNQUNSLE1BQU07QUFBQSxNQUNOLFVBQVU7QUFBQSxNQUNWLGFBQWE7QUFBQSxJQUNmLENBQUM7QUFBQTtBQUFBOzs7QUNORDtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQ2E7QUFEYjtBQUFBO0FBQUE7QUFDTyxJQUFNLFNBQVMsTUFBTTtBQUFBLE1BQzFCLFFBQVE7QUFBQSxNQUNSLE1BQU07QUFBQSxNQUNOLFVBQVU7QUFBQSxJQUNaLENBQUM7QUFBQTtBQUFBOzs7QUNMRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFDYSxRQU1BO0FBUGI7QUFBQTtBQUFBO0FBQ08sSUFBTSxTQUFTLFFBQVE7QUFBQSxNQUM1QixRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsSUFDZixDQUFDO0FBQ00sSUFBTSxjQUFjLFFBQVE7QUFBQSxNQUNqQyxRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsSUFDZixDQUFDO0FBQUE7QUFBQTs7O0FDWkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFDYSxRQU1BLGFBTUEsV0FNQSxnQkFNQSxXQU1BLGdCQU1BLGNBTUEsbUJBTUE7QUFqRGI7QUFBQTtBQUFBO0FBQ08sSUFBTSxTQUFTLFFBQVE7QUFBQSxNQUM1QixRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsSUFDZixDQUFDO0FBQ00sSUFBTSxjQUFjLFFBQVE7QUFBQSxNQUNqQyxRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsSUFDZixDQUFDO0FBQ00sSUFBTSxZQUFZLFFBQVE7QUFBQSxNQUMvQixRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsSUFDZixDQUFDO0FBQ00sSUFBTSxpQkFBaUIsUUFBUTtBQUFBLE1BQ3BDLFFBQVE7QUFBQSxNQUNSLE1BQU07QUFBQSxNQUNOLFVBQVU7QUFBQSxNQUNWLGFBQWE7QUFBQSxJQUNmLENBQUM7QUFDTSxJQUFNLFlBQVksUUFBUTtBQUFBLE1BQy9CLFFBQVE7QUFBQSxNQUNSLE1BQU07QUFBQSxNQUNOLFVBQVU7QUFBQSxNQUNWLGFBQWE7QUFBQSxJQUNmLENBQUM7QUFDTSxJQUFNLGlCQUFpQixRQUFRO0FBQUEsTUFDcEMsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLElBQ2YsQ0FBQztBQUNNLElBQU0sZUFBZSxRQUFRO0FBQUEsTUFDbEMsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLElBQ2YsQ0FBQztBQUNNLElBQU0sb0JBQW9CLFFBQVE7QUFBQSxNQUN2QyxRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsSUFDZixDQUFDO0FBQ00sSUFBTSxVQUFVLFFBQVE7QUFBQSxNQUM3QixRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsSUFDZixDQUFDO0FBQUE7QUFBQTs7O0FDdEREO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUNhLFFBS0E7QUFOYjtBQUFBO0FBQUE7QUFDTyxJQUFNLFNBQVMsTUFBTTtBQUFBLE1BQzFCLFFBQVE7QUFBQSxNQUNSLE1BQU07QUFBQSxNQUNOLFVBQVU7QUFBQSxJQUNaLENBQUM7QUFDTSxJQUFNLGNBQWMsTUFBTTtBQUFBLE1BQy9CLFFBQVE7QUFBQSxNQUNSLE1BQU07QUFBQSxNQUNOLFVBQVU7QUFBQSxJQUNaLENBQUM7QUFBQTtBQUFBOzs7QUNWRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFDYSxXQUtBO0FBTmI7QUFBQTtBQUFBO0FBQ08sSUFBTSxZQUFZLE1BQU07QUFBQSxNQUM3QixNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsSUFDWixDQUFDO0FBQ00sSUFBTSxlQUFlLE1BQU07QUFBQSxNQUNoQyxNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsSUFDWixDQUFDO0FBQUE7QUFBQTs7O0FDVkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUNhLFFBTUEsV0FNQSxXQU1BO0FBbkJiO0FBQUE7QUFBQTtBQUNPLElBQU0sU0FBUyxRQUFRO0FBQUEsTUFDNUIsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLElBQ2YsQ0FBQztBQUNNLElBQU0sWUFBWSxRQUFRO0FBQUEsTUFDL0IsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLElBQ2YsQ0FBQztBQUNNLElBQU0sWUFBWSxRQUFRO0FBQUEsTUFDL0IsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLElBQ2YsQ0FBQztBQUNNLElBQU0sZUFBZSxRQUFRO0FBQUEsTUFDbEMsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLElBQ2YsQ0FBQztBQUFBO0FBQUE7OztBQ3hCRDtBQUFBO0FBQUE7QUFBQTtBQVVBLFNBQVNPLFFBQU8sTUFBTTtBQUNwQixTQUFPLEtBQUssT0FBTyxDQUFDLEdBQUcsTUFBTTtBQUMzQixTQUFLLHFCQUFxQjtBQUMxQixXQUFPO0FBQUEsRUFDVCxHQUFHLEVBQUU7QUFDUDtBQUNBLFNBQVNDLFFBQU8sS0FBSztBQUNuQixRQUFNLE9BQU8sQ0FBQztBQUNkLGFBQVcsUUFBUSxLQUFLO0FBQ3RCLFVBQU0sTUFBTSxxQkFBcUIsS0FBSyxZQUFZLENBQUM7QUFDbkQsUUFBSSxRQUFRLFFBQVc7QUFDckIsWUFBTSxJQUFJLE1BQU0sK0JBQWdDLE1BQU87QUFBQSxJQUN6RDtBQUNBLFNBQUssS0FBSyxHQUFHO0FBQUEsRUFDZjtBQUNBLFNBQU8sSUFBSSxXQUFXLElBQUk7QUFDNUI7QUExQkEsSUFDTSxVQUNBLHNCQUlBLHNCQXFCTztBQTNCYjtBQUFBO0FBQUE7QUFDQSxJQUFNLFdBQVcsTUFBTSxLQUFLLG9yRUFBczJGO0FBQ2w0RixJQUFNLHVCQUF1QixTQUFTLE9BQU8sQ0FBQyxHQUFHLEdBQUcsTUFBTTtBQUN4RCxRQUFFLEtBQUs7QUFDUCxhQUFPO0FBQUEsSUFDVCxHQUFHLENBQUMsQ0FBQztBQUNMLElBQU0sdUJBQXVCLFNBQVMsT0FBTyxDQUFDLEdBQUcsR0FBRyxNQUFNO0FBQ3hELFFBQUUsRUFBRSxZQUFZLENBQUMsS0FBSztBQUN0QixhQUFPO0FBQUEsSUFDVCxHQUFHLENBQUMsQ0FBQztBQWtCRSxJQUFNLGVBQWUsS0FBSztBQUFBLE1BQy9CLFFBQVE7QUFBQSxNQUNSLE1BQU07QUFBQSxNQUNOLFFBQUFEO0FBQUEsTUFDQSxRQUFBQztBQUFBLElBQ0YsQ0FBQztBQUFBO0FBQUE7OztBQzlCRCxTQUFTQyxRQUFPLEtBQUssS0FBSyxRQUFRO0FBQ2hDLFFBQU0sT0FBTyxDQUFDO0FBQ2QsV0FBUyxVQUFVO0FBQ25CLE1BQUksWUFBWTtBQUNoQixTQUFPLE9BQU8sS0FBSztBQUNqQixRQUFJLFlBQVksTUFBTSxNQUFNO0FBQzVCLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTyxNQUFNLFFBQVE7QUFDbkIsUUFBSSxZQUFZLE1BQU0sTUFBTTtBQUM1QixhQUFTO0FBQUEsRUFDWDtBQUNBLE1BQUksVUFBVSxNQUFNO0FBQ3BCLEVBQUFBLFFBQU8sUUFBUSxTQUFTLFlBQVk7QUFDcEMsU0FBTztBQUNUO0FBR0EsU0FBUyxLQUFLLEtBQUssUUFBUTtBQUN6QixNQUFJLE1BQU0sR0FBRyxTQUFTLFVBQVUsR0FBRyxRQUFRLEdBQUcsVUFBVSxRQUFRLEdBQUcsSUFBSSxJQUFJO0FBQzNFLEtBQUc7QUFDRCxRQUFJLFdBQVcsR0FBRztBQUNoQixXQUFLLFFBQVE7QUFDYixZQUFNLElBQUksV0FBVyx5QkFBeUI7QUFBQSxJQUNoRDtBQUNBLFFBQUksSUFBSTtBQUNSLFdBQU8sUUFBUSxNQUFNLElBQUksV0FBVyxTQUFTLElBQUksVUFBVSxLQUFLLElBQUksR0FBRyxLQUFLO0FBQzVFLGFBQVM7QUFBQSxFQUNYLFNBQVMsS0FBSztBQUNkLE9BQUssUUFBUSxVQUFVO0FBQ3ZCLFNBQU87QUFDVDtBQWpDQSxJQUFJLFVBQ0EsS0FBVyxNQUFZLFFBQWdCLEtBaUJ2Q0MsU0FDQSxPQUFhLFFBZWIsSUFDQSxJQUNBLElBQ0EsSUFDQSxJQUNBLElBQ0EsSUFDQSxJQUNBLElBQ0EsUUFHQSxRQUtBLGNBQ0c7QUFwRFA7QUFBQTtBQUFBLElBQUksV0FBV0Q7QUFDZixJQUFJLE1BQU07QUFBVixJQUFlLE9BQU87QUFBdEIsSUFBMkIsU0FBUyxDQUFDO0FBQXJDLElBQTJDLE1BQU0sS0FBSyxJQUFJLEdBQUcsRUFBRTtBQWlCL0QsSUFBSUMsVUFBUztBQUNiLElBQUksUUFBUTtBQUFaLElBQWlCLFNBQVM7QUFlMUIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLENBQUM7QUFDdEIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDdkIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDdkIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDdkIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDdkIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDdkIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDdkIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDdkIsSUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDdkIsSUFBSSxTQUFTLFNBQVUsT0FBTztBQUM1QixhQUFPLFFBQVEsS0FBSyxJQUFJLFFBQVEsS0FBSyxJQUFJLFFBQVEsS0FBSyxJQUFJLFFBQVEsS0FBSyxJQUFJLFFBQVEsS0FBSyxJQUFJLFFBQVEsS0FBSyxJQUFJLFFBQVEsS0FBSyxJQUFJLFFBQVEsS0FBSyxJQUFJLFFBQVEsS0FBSyxJQUFJO0FBQUEsSUFDbEs7QUFDQSxJQUFJLFNBQVM7QUFBQSxNQUNYLFFBQVE7QUFBQSxNQUNSLFFBQVFBO0FBQUEsTUFDUixnQkFBZ0I7QUFBQSxJQUNsQjtBQUNBLElBQUksZUFBZTtBQUNuQixJQUFPLGlCQUFRO0FBQUE7QUFBQTs7O0FDcERmLElBQ2FDLFNBT0EsVUFJQTtBQVpiLElBQUFDLGVBQUE7QUFBQTtBQUFBO0FBQ08sSUFBTUQsVUFBUyxVQUFRO0FBQzVCLFlBQU1FLFFBQU8sZUFBTyxPQUFPLElBQUk7QUFDL0IsYUFBTztBQUFBLFFBQ0xBO0FBQUEsUUFDQSxlQUFPLE9BQU87QUFBQSxNQUNoQjtBQUFBLElBQ0Y7QUFDTyxJQUFNLFdBQVcsQ0FBQyxLQUFLLFFBQVEsU0FBUyxNQUFNO0FBQ25ELHFCQUFPLE9BQU8sS0FBSyxRQUFRLE1BQU07QUFDakMsYUFBTztBQUFBLElBQ1Q7QUFDTyxJQUFNLGlCQUFpQixTQUFPO0FBQ25DLGFBQU8sZUFBTyxlQUFlLEdBQUc7QUFBQSxJQUNsQztBQUFBO0FBQUE7OztBQ2RBLElBS2EsUUFVQUMsU0FVQUMsU0FPQTtBQWhDYjtBQUFBO0FBQUE7QUFJQSxJQUFBQztBQUNPLElBQU0sU0FBUyxDQUFDQyxPQUFNQyxZQUFXO0FBQ3RDLFlBQU0sT0FBT0EsUUFBTztBQUNwQixZQUFNLGFBQW9CLGVBQWVELEtBQUk7QUFDN0MsWUFBTSxlQUFlLGFBQW9CLGVBQWUsSUFBSTtBQUM1RCxZQUFNLFFBQVEsSUFBSSxXQUFXLGVBQWUsSUFBSTtBQUNoRCxNQUFPLFNBQVNBLE9BQU0sT0FBTyxDQUFDO0FBQzlCLE1BQU8sU0FBUyxNQUFNLE9BQU8sVUFBVTtBQUN2QyxZQUFNLElBQUlDLFNBQVEsWUFBWTtBQUM5QixhQUFPLElBQUksT0FBT0QsT0FBTSxNQUFNQyxTQUFRLEtBQUs7QUFBQSxJQUM3QztBQUNPLElBQU1KLFVBQVMsZUFBYTtBQUNqQyxZQUFNLFFBQVEsT0FBTyxTQUFTO0FBQzlCLFlBQU0sQ0FBQ0csT0FBTSxVQUFVLElBQVdILFFBQU8sS0FBSztBQUM5QyxZQUFNLENBQUMsTUFBTSxZQUFZLElBQVdBLFFBQU8sTUFBTSxTQUFTLFVBQVUsQ0FBQztBQUNyRSxZQUFNSSxVQUFTLE1BQU0sU0FBUyxhQUFhLFlBQVk7QUFDdkQsVUFBSUEsUUFBTyxlQUFlLE1BQU07QUFDOUIsY0FBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsTUFDcEM7QUFDQSxhQUFPLElBQUksT0FBT0QsT0FBTSxNQUFNQyxTQUFRLEtBQUs7QUFBQSxJQUM3QztBQUNPLElBQU1ILFVBQVMsQ0FBQyxHQUFHLE1BQU07QUFDOUIsVUFBSSxNQUFNLEdBQUc7QUFDWCxlQUFPO0FBQUEsTUFDVCxPQUFPO0FBQ0wsZUFBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFFBQVEsT0FBVyxFQUFFLE9BQU8sRUFBRSxLQUFLO0FBQUEsTUFDOUU7QUFBQSxJQUNGO0FBQ08sSUFBTSxTQUFOLE1BQWE7QUFBQSxNQUNsQixZQUFZRSxPQUFNLE1BQU1DLFNBQVEsT0FBTztBQUNyQyxhQUFLLE9BQU9EO0FBQ1osYUFBSyxPQUFPO0FBQ1osYUFBSyxTQUFTQztBQUNkLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNGO0FBQUE7QUFBQTs7O0FDdkNBLElBQ2FDLE9BQ0E7QUFGYjtBQUFBO0FBQUE7QUFDTyxJQUFNQSxRQUFPLENBQUMsRUFBQyxNQUFBQyxPQUFNLE1BQUFDLE9BQU0sUUFBQUMsUUFBTSxNQUFNLElBQUksT0FBT0YsT0FBTUMsT0FBTUMsT0FBTTtBQUNwRSxJQUFNLFNBQU4sTUFBYTtBQUFBLE1BQ2xCLFlBQVlGLE9BQU1DLE9BQU1DLFNBQVE7QUFDOUIsYUFBSyxPQUFPRjtBQUNaLGFBQUssT0FBT0M7QUFDWixhQUFLLFNBQVNDO0FBQUEsTUFDaEI7QUFBQSxNQUNBLE9BQU8sT0FBTztBQUNaLFlBQUksaUJBQWlCLFlBQVk7QUFDL0IsZ0JBQU0sU0FBUyxLQUFLLE9BQU8sS0FBSztBQUNoQyxpQkFBTyxrQkFBa0IsYUFBb0IsT0FBTyxLQUFLLE1BQU0sTUFBTSxJQUFJLE9BQU8sS0FBSyxDQUFBQyxZQUFpQixPQUFPLEtBQUssTUFBTUEsT0FBTSxDQUFDO0FBQUEsUUFDakksT0FBTztBQUNMLGdCQUFNLE1BQU0sbUNBQW1DO0FBQUEsUUFDakQ7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBO0FBQUE7OztBQ2hCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBR2EsUUFLQTtBQVJiO0FBQUE7QUFBQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNPLElBQU0sU0FBU0MsTUFBSztBQUFBLE1BQ3pCLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLFFBQVEsV0FBUyxPQUFPLGNBQUFDLFFBQU8sV0FBVyxRQUFRLEVBQUUsT0FBTyxLQUFLLEVBQUUsT0FBTyxDQUFDO0FBQUEsSUFDNUUsQ0FBQztBQUNNLElBQU0sU0FBU0QsTUFBSztBQUFBLE1BQ3pCLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLFFBQVEsV0FBUyxPQUFPLGNBQUFDLFFBQU8sV0FBVyxRQUFRLEVBQUUsT0FBTyxLQUFLLEVBQUUsT0FBTyxDQUFDO0FBQUEsSUFDNUUsQ0FBQztBQUFBO0FBQUE7OztBQ1pELElBQUFDLG9CQUFBO0FBQUEsU0FBQUEsbUJBQUE7QUFBQSxrQkFBQUM7QUFBQTtBQUFBLElBRU0sTUFDQSxNQUNBQyxTQUNBLFFBQ09EO0FBTmIsSUFBQUUsaUJBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQSxJQUFNLE9BQU87QUFDYixJQUFNLE9BQU87QUFDYixJQUFNRCxVQUFTO0FBQ2YsSUFBTSxTQUFTLFdBQWdCLE9BQU8sTUFBTUEsUUFBTyxLQUFLLENBQUM7QUFDbEQsSUFBTUQsWUFBVztBQUFBLE1BQ3RCO0FBQUEsTUFDQTtBQUFBLE1BQ0EsUUFBQUM7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBO0FBQUE7OztBQ1hBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQ0FBLElBQU0sYUFDQTtBQUROO0FBQUE7QUFBQSxJQUFNLGNBQWMsSUFBSSxZQUFZO0FBQ3BDLElBQU0sY0FBYyxJQUFJLFlBQVk7QUFBQTtBQUFBOzs7QUNEcEMsSUFLYSxLQXVNUCxpQkFrQ0EsWUFjQSxZQVdBLGFBQ0EsY0FDQSxXQVNBLFdBQ0EsVUFLQSxRQUtBLFNBQ0EsV0FPQTtBQXJTTjtBQUFBO0FBQUEsSUFBQUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU0sTUFBTixNQUFVO0FBQUEsTUFDZixZQUFZQyxVQUFTQyxPQUFNLFdBQVcsT0FBTztBQUMzQyxhQUFLLE9BQU9BO0FBQ1osYUFBSyxVQUFVRDtBQUNmLGFBQUssWUFBWTtBQUNqQixhQUFLLFFBQVE7QUFDYixhQUFLLGFBQWEsTUFBTTtBQUN4QixhQUFLLGFBQWEsTUFBTTtBQUN4QixhQUFLLFFBQVE7QUFDYixhQUFLLGFBQWEsb0JBQUksSUFBSTtBQUMxQixlQUFPLGlCQUFpQixNQUFNO0FBQUEsVUFDNUIsWUFBWTtBQUFBLFVBQ1osWUFBWTtBQUFBLFVBQ1osTUFBTTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsT0FBTztBQUFBLFVBQ1AsWUFBWTtBQUFBLFVBQ1osT0FBTztBQUFBLFFBQ1QsQ0FBQztBQUFBLE1BQ0g7QUFBQSxNQUNBLE9BQU87QUFDTCxnQkFBUSxLQUFLO0FBQUEsZUFDUixHQUFHO0FBQ0osbUJBQU87QUFBQSxVQUNUO0FBQUEsbUJBQ087QUFDTCxrQkFBTSxFQUFDLE1BQUFDLE9BQU0sVUFBUyxJQUFJO0FBQzFCLGdCQUFJQSxVQUFTLGFBQWE7QUFDeEIsb0JBQU0sSUFBSSxNQUFNLDBDQUEwQztBQUFBLFlBQzVEO0FBQ0EsZ0JBQUksVUFBVSxTQUFTLGNBQWM7QUFDbkMsb0JBQU0sSUFBSSxNQUFNLG9EQUFvRDtBQUFBLFlBQ3RFO0FBQ0EsbUJBQU8sSUFBSSxTQUFTLFNBQVM7QUFBQSxVQUMvQjtBQUFBO0FBQUEsTUFFSjtBQUFBLE1BQ0EsT0FBTztBQUNMLGdCQUFRLEtBQUs7QUFBQSxlQUNSLEdBQUc7QUFDSixrQkFBTSxFQUFDLE1BQUFBLE9BQU0sUUFBQUMsUUFBTSxJQUFJLEtBQUs7QUFDNUIsa0JBQU0sWUFBbUIsT0FBT0QsT0FBTUMsT0FBTTtBQUM1QyxtQkFBTyxJQUFJLFNBQVMsS0FBSyxNQUFNLFNBQVM7QUFBQSxVQUMxQztBQUFBLGVBQ0csR0FBRztBQUNKLG1CQUFPO0FBQUEsVUFDVDtBQUFBLG1CQUNPO0FBQ0wsa0JBQU0sTUFBTSwrQkFBZ0MsS0FBSyxtREFBb0Q7QUFBQSxVQUN2RztBQUFBO0FBQUEsTUFFSjtBQUFBLE1BQ0EsT0FBTyxPQUFPO0FBQ1osZUFBTyxTQUFTLEtBQUssU0FBUyxNQUFNLFFBQVEsS0FBSyxZQUFZLE1BQU0sV0FBa0JDLFFBQU8sS0FBSyxXQUFXLE1BQU0sU0FBUztBQUFBLE1BQzdIO0FBQUEsTUFDQSxTQUFTQyxPQUFNO0FBQ2IsY0FBTSxFQUFDLE9BQU8sU0FBQUosVUFBUyxXQUFVLElBQUk7QUFDckMsZ0JBQVFBO0FBQUEsZUFDSDtBQUNILG1CQUFPLFdBQVcsT0FBTyxZQUFZSSxTQUFRLFVBQVUsT0FBTztBQUFBO0FBRTlELG1CQUFPLFdBQVcsT0FBTyxZQUFZQSxTQUFRLE9BQU8sT0FBTztBQUFBO0FBQUEsTUFFL0Q7QUFBQSxNQUNBLFNBQVM7QUFDUCxlQUFPO0FBQUEsVUFDTCxNQUFNLEtBQUs7QUFBQSxVQUNYLFNBQVMsS0FBSztBQUFBLFVBQ2QsTUFBTSxLQUFLLFVBQVU7QUFBQSxRQUN2QjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLEtBQUssT0FBTyxlQUFlO0FBQ3pCLGVBQU87QUFBQSxNQUNUO0FBQUEsTUFDQSxDQUFDLE9BQU8sSUFBSSw0QkFBNEIsS0FBSztBQUMzQyxlQUFPLFNBQVMsS0FBSyxTQUFTLElBQUk7QUFBQSxNQUNwQztBQUFBLE1BQ0EsT0FBTyxNQUFNLE9BQU87QUFDbEIsa0JBQVUsU0FBUyxrQkFBa0I7QUFDckMsZUFBTyxDQUFDLEVBQUUsVUFBVSxNQUFNLGNBQWMsTUFBTSxVQUFVO0FBQUEsTUFDMUQ7QUFBQSxNQUNBLElBQUksc0JBQXNCO0FBQ3hCLGNBQU0sSUFBSSxNQUFNLDZCQUE2QjtBQUFBLE1BQy9DO0FBQUEsTUFDQSxJQUFJLFFBQVE7QUFDVixjQUFNLElBQUksTUFBTSxxRUFBcUU7QUFBQSxNQUN2RjtBQUFBLE1BQ0EsSUFBSSxTQUFTO0FBQ1gsY0FBTSxJQUFJLE1BQU0sbUVBQW1FO0FBQUEsTUFDckY7QUFBQSxNQUNBLElBQUksZ0JBQWdCO0FBQ2xCLGNBQU0sSUFBSSxNQUFNLHdDQUF3QztBQUFBLE1BQzFEO0FBQUEsTUFDQSxJQUFJLFNBQVM7QUFDWCxjQUFNLElBQUksTUFBTSxpQ0FBaUM7QUFBQSxNQUNuRDtBQUFBLE1BQ0EsT0FBTyxNQUFNLE9BQU87QUFDbEIsWUFBSSxpQkFBaUIsS0FBSztBQUN4QixpQkFBTztBQUFBLFFBQ1QsV0FBVyxTQUFTLFFBQVEsTUFBTSxVQUFVLE9BQU87QUFDakQsZ0JBQU0sRUFBQyxTQUFBSixVQUFTLE1BQUFDLE9BQU0sV0FBVyxNQUFLLElBQUk7QUFDMUMsaUJBQU8sSUFBSSxJQUFJRCxVQUFTQyxPQUFNLFdBQVcsU0FBUyxVQUFVRCxVQUFTQyxPQUFNLFVBQVUsS0FBSyxDQUFDO0FBQUEsUUFDN0YsV0FBVyxTQUFTLFFBQVEsTUFBTSxlQUFlLE1BQU07QUFDckQsZ0JBQU0sRUFBQyxTQUFBRCxVQUFTLFdBQVcsTUFBQUMsTUFBSSxJQUFJO0FBQ25DLGdCQUFNQyxVQUFnQkcsUUFBTyxTQUFTO0FBQ3RDLGlCQUFPLElBQUksT0FBT0wsVUFBU0MsT0FBTUMsT0FBTTtBQUFBLFFBQ3pDLE9BQU87QUFDTCxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBQUEsTUFDQSxPQUFPLE9BQU9GLFVBQVNDLE9BQU1DLFNBQVE7QUFDbkMsWUFBSSxPQUFPRCxVQUFTLFVBQVU7QUFDNUIsZ0JBQU0sSUFBSSxNQUFNLHVDQUF1QztBQUFBLFFBQ3pEO0FBQ0EsZ0JBQVFEO0FBQUEsZUFDSCxHQUFHO0FBQ0osZ0JBQUlDLFVBQVMsYUFBYTtBQUN4QixvQkFBTSxJQUFJLE1BQU0sd0NBQXlDLDZCQUE4QjtBQUFBLFlBQ3pGLE9BQU87QUFDTCxxQkFBTyxJQUFJLElBQUlELFVBQVNDLE9BQU1DLFNBQVFBLFFBQU8sS0FBSztBQUFBLFlBQ3BEO0FBQUEsVUFDRjtBQUFBLGVBQ0csR0FBRztBQUNKLGtCQUFNLFFBQVEsVUFBVUYsVUFBU0MsT0FBTUMsUUFBTyxLQUFLO0FBQ25ELG1CQUFPLElBQUksSUFBSUYsVUFBU0MsT0FBTUMsU0FBUSxLQUFLO0FBQUEsVUFDN0M7QUFBQSxtQkFDTztBQUNMLGtCQUFNLElBQUksTUFBTSxpQkFBaUI7QUFBQSxVQUNuQztBQUFBO0FBQUEsTUFFSjtBQUFBLE1BQ0EsT0FBTyxTQUFTQSxTQUFRO0FBQ3RCLGVBQU8sSUFBSSxPQUFPLEdBQUcsYUFBYUEsT0FBTTtBQUFBLE1BQzFDO0FBQUEsTUFDQSxPQUFPLFNBQVNELE9BQU1DLFNBQVE7QUFDNUIsZUFBTyxJQUFJLE9BQU8sR0FBR0QsT0FBTUMsT0FBTTtBQUFBLE1BQ25DO0FBQUEsTUFDQSxPQUFPLE9BQU8sT0FBTztBQUNuQixjQUFNLENBQUMsS0FBSyxTQUFTLElBQUksSUFBSSxZQUFZLEtBQUs7QUFDOUMsWUFBSSxVQUFVLFFBQVE7QUFDcEIsZ0JBQU0sSUFBSSxNQUFNLGtCQUFrQjtBQUFBLFFBQ3BDO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLE9BQU8sWUFBWSxPQUFPO0FBQ3hCLGNBQU0sUUFBUSxJQUFJLGFBQWEsS0FBSztBQUNwQyxjQUFNLGFBQWEsTUFBTSxPQUFPLE1BQU07QUFDdEMsY0FBTSxpQkFBaUIsT0FBTyxNQUFNLFNBQVMsWUFBWSxhQUFhLE1BQU0sYUFBYSxDQUFDO0FBQzFGLFlBQUksZUFBZSxlQUFlLE1BQU0sZUFBZTtBQUNyRCxnQkFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsUUFDcEM7QUFDQSxjQUFNLGNBQWMsZUFBZSxTQUFTLE1BQU0sZ0JBQWdCLE1BQU0sVUFBVTtBQUNsRixjQUFNQSxVQUFTLElBQVcsT0FBTyxNQUFNLGVBQWUsTUFBTSxZQUFZLGFBQWEsY0FBYztBQUNuRyxjQUFNLE1BQU0sTUFBTSxZQUFZLElBQUksSUFBSSxTQUFTQSxPQUFNLElBQUksSUFBSSxTQUFTLE1BQU0sT0FBT0EsT0FBTTtBQUN6RixlQUFPO0FBQUEsVUFDTDtBQUFBLFVBQ0EsTUFBTSxTQUFTLE1BQU0sSUFBSTtBQUFBLFFBQzNCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsT0FBTyxhQUFhLGNBQWM7QUFDaEMsWUFBSSxTQUFTO0FBQ2IsY0FBTSxPQUFPLE1BQU07QUFDakIsZ0JBQU0sQ0FBQyxHQUFHSSxPQUFNLElBQVdELFFBQU8sYUFBYSxTQUFTLE1BQU0sQ0FBQztBQUMvRCxvQkFBVUM7QUFDVixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxZQUFJTixXQUFVLEtBQUs7QUFDbkIsWUFBSSxRQUFRO0FBQ1osWUFBSUEsYUFBWSxJQUFJO0FBQ2xCLFVBQUFBLFdBQVU7QUFDVixtQkFBUztBQUFBLFFBQ1gsV0FBV0EsYUFBWSxHQUFHO0FBQ3hCLGtCQUFRLEtBQUs7QUFBQSxRQUNmO0FBQ0EsWUFBSUEsYUFBWSxLQUFLQSxhQUFZLEdBQUc7QUFDbEMsZ0JBQU0sSUFBSSxXQUFXLHVCQUF3QkEsVUFBVTtBQUFBLFFBQ3pEO0FBQ0EsY0FBTSxhQUFhO0FBQ25CLGNBQU0sZ0JBQWdCLEtBQUs7QUFDM0IsY0FBTSxhQUFhLEtBQUs7QUFDeEIsY0FBTSxPQUFPLFNBQVM7QUFDdEIsY0FBTSxnQkFBZ0IsT0FBTztBQUM3QixlQUFPO0FBQUEsVUFDTCxTQUFBQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLE9BQU8sTUFBTSxRQUFRSSxPQUFNO0FBQ3pCLGNBQU0sQ0FBQyxRQUFRLEtBQUssSUFBSSxnQkFBZ0IsUUFBUUEsS0FBSTtBQUNwRCxjQUFNLE1BQU0sSUFBSSxPQUFPLEtBQUs7QUFDNUIsWUFBSSxXQUFXLElBQUksUUFBUSxNQUFNO0FBQ2pDLGVBQU87QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUNBLElBQU0sa0JBQWtCLENBQUMsUUFBUUEsVUFBUztBQUN4QyxjQUFRLE9BQU87QUFBQSxhQUNWLEtBQUs7QUFDTixnQkFBTSxVQUFVQSxTQUFRO0FBQ3hCLGlCQUFPO0FBQUEsWUFDTCxVQUFVO0FBQUEsWUFDVixRQUFRLE9BQU8sR0FBSSxVQUFVLFNBQVcsUUFBUztBQUFBLFVBQ25EO0FBQUEsUUFDRjtBQUFBLGFBQ0csVUFBVSxRQUFRO0FBQ25CLGdCQUFNLFVBQVVBLFNBQVE7QUFDeEIsaUJBQU87QUFBQSxZQUNMLFVBQVU7QUFBQSxZQUNWLFFBQVEsT0FBTyxNQUFNO0FBQUEsVUFDdkI7QUFBQSxRQUNGO0FBQUEsYUFDRyxPQUFPLFFBQVE7QUFDaEIsZ0JBQU0sVUFBVUEsU0FBUTtBQUN4QixpQkFBTztBQUFBLFlBQ0wsT0FBTztBQUFBLFlBQ1AsUUFBUSxPQUFPLE1BQU07QUFBQSxVQUN2QjtBQUFBLFFBQ0Y7QUFBQSxpQkFDTztBQUNMLGNBQUlBLFNBQVEsTUFBTTtBQUNoQixrQkFBTSxNQUFNLGlGQUFpRjtBQUFBLFVBQy9GO0FBQ0EsaUJBQU87QUFBQSxZQUNMLE9BQU87QUFBQSxZQUNQQSxNQUFLLE9BQU8sTUFBTTtBQUFBLFVBQ3BCO0FBQUEsUUFDRjtBQUFBO0FBQUEsSUFFSjtBQUNBLElBQU0sYUFBYSxDQUFDLE9BQU8sT0FBT0EsVUFBUztBQUN6QyxZQUFNLEVBQUMsT0FBTSxJQUFJQTtBQUNqQixVQUFJLFdBQVcsVUFBVSxRQUFRO0FBQy9CLGNBQU0sTUFBTSw4QkFBK0JBLE1BQUssZUFBZ0I7QUFBQSxNQUNsRTtBQUNBLFlBQU0sTUFBTSxNQUFNLElBQUksTUFBTTtBQUM1QixVQUFJLE9BQU8sTUFBTTtBQUNmLGNBQU1HLE9BQU1ILE1BQUssT0FBTyxLQUFLLEVBQUUsTUFBTSxDQUFDO0FBQ3RDLGNBQU0sSUFBSSxRQUFRRyxJQUFHO0FBQ3JCLGVBQU9BO0FBQUEsTUFDVCxPQUFPO0FBQ0wsZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBQ0EsSUFBTSxhQUFhLENBQUMsT0FBTyxPQUFPSCxVQUFTO0FBQ3pDLFlBQU0sRUFBQyxPQUFNLElBQUlBO0FBQ2pCLFlBQU0sTUFBTSxNQUFNLElBQUksTUFBTTtBQUM1QixVQUFJLE9BQU8sTUFBTTtBQUNmLGNBQU1HLE9BQU1ILE1BQUssT0FBTyxLQUFLO0FBQzdCLGNBQU0sSUFBSSxRQUFRRyxJQUFHO0FBQ3JCLGVBQU9BO0FBQUEsTUFDVCxPQUFPO0FBQ0wsZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBQ0EsSUFBTSxjQUFjO0FBQ3BCLElBQU0sZUFBZTtBQUNyQixJQUFNLFlBQVksQ0FBQ1AsVUFBU0MsT0FBTSxjQUFjO0FBQzlDLFlBQU0sYUFBb0IsZUFBZUQsUUFBTztBQUNoRCxZQUFNLGFBQWEsYUFBb0IsZUFBZUMsS0FBSTtBQUMxRCxZQUFNLFFBQVEsSUFBSSxXQUFXLGFBQWEsVUFBVSxVQUFVO0FBQzlELE1BQU8sU0FBU0QsVUFBUyxPQUFPLENBQUM7QUFDakMsTUFBTyxTQUFTQyxPQUFNLE9BQU8sVUFBVTtBQUN2QyxZQUFNLElBQUksV0FBVyxVQUFVO0FBQy9CLGFBQU87QUFBQSxJQUNUO0FBQ0EsSUFBTSxZQUFZLE9BQU8sSUFBSSxrQkFBa0I7QUFDL0MsSUFBTSxXQUFXO0FBQUEsTUFDZixVQUFVO0FBQUEsTUFDVixjQUFjO0FBQUEsTUFDZCxZQUFZO0FBQUEsSUFDZDtBQUNBLElBQU0sU0FBUztBQUFBLE1BQ2IsVUFBVTtBQUFBLE1BQ1YsWUFBWTtBQUFBLE1BQ1osY0FBYztBQUFBLElBQ2hCO0FBQ0EsSUFBTSxVQUFVO0FBQ2hCLElBQU0sWUFBWSxDQUFDLE9BQU9PLGFBQVk7QUFDcEMsVUFBSSxNQUFNLEtBQUssT0FBTyxHQUFHO0FBQ3ZCLGdCQUFRLEtBQUtBLFFBQU87QUFBQSxNQUN0QixPQUFPO0FBQ0wsY0FBTSxJQUFJLE1BQU1BLFFBQU87QUFBQSxNQUN6QjtBQUFBLElBQ0Y7QUFDQSxJQUFNLHFCQUFxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNyUzNCO0FBQUE7QUFBQTtBQUNBLElBQUFDO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7O0FDSkEsSUFxQk0sT0FZQTtBQWpDTjtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUFDO0FBQ0E7QUFDQTtBQUNBO0FBT0EsSUFBTSxRQUFRO0FBQUEsTUFDWixHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsSUFDTDtBQUNBLElBQU0sU0FBUztBQUFBLE1BQ2IsR0FBRztBQUFBLE1BQ0gsR0FBR0M7QUFBQSxJQUNMO0FBQUE7QUFBQTs7O0FDcENPLFNBQVMsTUFBTSxPQUFPLEdBQUc7QUFDOUIsTUFBSSxXQUFXLFVBQVUsUUFBUSxXQUFXLE9BQU8sU0FBUyxNQUFNO0FBQ2hFLFdBQU8sV0FBVyxPQUFPLE1BQU0sSUFBSTtBQUFBLEVBQ3JDO0FBQ0EsU0FBTyxJQUFJLFdBQVcsSUFBSTtBQUM1QjtBQUNPLFNBQVMsWUFBWSxPQUFPLEdBQUc7QUFDcEMsTUFBSSxXQUFXLFVBQVUsUUFBUSxXQUFXLE9BQU8sZUFBZSxNQUFNO0FBQ3RFLFdBQU8sV0FBVyxPQUFPLFlBQVksSUFBSTtBQUFBLEVBQzNDO0FBQ0EsU0FBTyxJQUFJLFdBQVcsSUFBSTtBQUM1QjtBQVhBO0FBQUE7QUFBQTtBQUFBOzs7QUNFQSxTQUFTLFlBQVlDLE9BQU0sUUFBUUMsU0FBUUMsU0FBUTtBQUNqRCxTQUFPO0FBQUEsSUFDTCxNQUFBRjtBQUFBLElBQ0E7QUFBQSxJQUNBLFNBQVM7QUFBQSxNQUNQLE1BQUFBO0FBQUEsTUFDQTtBQUFBLE1BQ0EsUUFBQUM7QUFBQSxJQUNGO0FBQUEsSUFDQSxTQUFTLEVBQUUsUUFBQUMsUUFBTztBQUFBLEVBQ3BCO0FBQ0Y7QUFiQSxJQWNNLFFBT0EsT0FjQSxPQVNDO0FBNUNQO0FBQUE7QUFBQTtBQUNBO0FBYUEsSUFBTSxTQUFTLFlBQVksUUFBUSxLQUFLLFNBQU87QUFDN0MsWUFBTSxVQUFVLElBQUksWUFBWSxNQUFNO0FBQ3RDLGFBQU8sTUFBTSxRQUFRLE9BQU8sR0FBRztBQUFBLElBQ2pDLEdBQUcsU0FBTztBQUNSLFlBQU0sVUFBVSxJQUFJLFlBQVk7QUFDaEMsYUFBTyxRQUFRLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQztBQUFBLElBQ3hDLENBQUM7QUFDRCxJQUFNLFFBQVEsWUFBWSxTQUFTLEtBQUssU0FBTztBQUM3QyxVQUFJQyxVQUFTO0FBQ2IsZUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNuQyxRQUFBQSxXQUFVLE9BQU8sYUFBYSxJQUFJLEVBQUU7QUFBQSxNQUN0QztBQUNBLGFBQU9BO0FBQUEsSUFDVCxHQUFHLFNBQU87QUFDUixZQUFNLElBQUksVUFBVSxDQUFDO0FBQ3JCLFlBQU0sTUFBTSxZQUFZLElBQUksTUFBTTtBQUNsQyxlQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQ25DLFlBQUksS0FBSyxJQUFJLFdBQVcsQ0FBQztBQUFBLE1BQzNCO0FBQ0EsYUFBTztBQUFBLElBQ1QsQ0FBQztBQUNELElBQU0sUUFBUTtBQUFBLE1BQ1osTUFBTTtBQUFBLE1BQ04sU0FBUztBQUFBLE1BQ1QsS0FBSyxNQUFNO0FBQUEsTUFDWCxRQUFRO0FBQUEsTUFDUjtBQUFBLE1BQ0EsUUFBUTtBQUFBLE1BQ1IsR0FBRztBQUFBLElBQ0w7QUFDQSxJQUFPLGdCQUFRO0FBQUE7QUFBQTs7O0FDM0NSLFNBQVNDLFVBQVMsT0FBTyxXQUFXLFFBQVE7QUFDakQsUUFBTUMsUUFBTyxjQUFNO0FBQ25CLE1BQUksQ0FBQ0EsT0FBTTtBQUNULFVBQU0sSUFBSSxNQUFNLHlCQUEwQixXQUFZO0FBQUEsRUFDeEQ7QUFDQSxPQUFLLGFBQWEsVUFBVSxhQUFhLFlBQVksV0FBVyxVQUFVLFFBQVEsV0FBVyxPQUFPLFFBQVEsTUFBTTtBQUNoSCxXQUFPLFdBQVcsT0FBTyxLQUFLLE1BQU0sUUFBUSxNQUFNLFlBQVksTUFBTSxVQUFVLEVBQUUsU0FBUyxNQUFNO0FBQUEsRUFDakc7QUFDQSxTQUFPQSxNQUFLLFFBQVEsT0FBTyxLQUFLLEVBQUUsVUFBVSxDQUFDO0FBQy9DO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDQ08sU0FBUyxPQUFPLFFBQVFDLFNBQVE7QUFDckMsTUFBSSxDQUFDQSxTQUFRO0FBQ1gsSUFBQUEsVUFBUyxPQUFPLE9BQU8sQ0FBQyxLQUFLLFNBQVMsTUFBTSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQzVEO0FBQ0EsUUFBTSxTQUFTLFlBQVlBLE9BQU07QUFDakMsTUFBSSxTQUFTO0FBQ2IsYUFBVyxPQUFPLFFBQVE7QUFDeEIsV0FBTyxJQUFJLEtBQUssTUFBTTtBQUN0QixjQUFVLElBQUk7QUFBQSxFQUNoQjtBQUNBLFNBQU87QUFDVDtBQVpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQ0FBO0FBQUEsZ0RBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVTtBQW1CakIsYUFBUyxVQUFVLElBQUksS0FBbUI7QUFDdEMsVUFBSSxTQUFVLElBQUksTUFBTSxVQUFVLFNBQVMsQ0FBQyxHQUN4QyxTQUFVLEdBQ1YsUUFBVSxHQUNWLFVBQVU7QUFDZCxhQUFPLFFBQVEsVUFBVTtBQUNyQixlQUFPLFlBQVksVUFBVTtBQUNqQyxhQUFPLElBQUksUUFBUSxTQUFTLFNBQVMsU0FBUyxRQUFRO0FBQ2xELGVBQU8sVUFBVSxTQUFTLFNBQVMsS0FBbUI7QUFDbEQsY0FBSSxTQUFTO0FBQ1Qsc0JBQVU7QUFDVixnQkFBSTtBQUNBLHFCQUFPLEdBQUc7QUFBQSxpQkFDVDtBQUNELGtCQUFJQyxVQUFTLElBQUksTUFBTSxVQUFVLFNBQVMsQ0FBQyxHQUN2Q0MsVUFBUztBQUNiLHFCQUFPQSxVQUFTRCxRQUFPO0FBQ25CLGdCQUFBQSxRQUFPQyxhQUFZLFVBQVVBO0FBQ2pDLHNCQUFRLE1BQU0sTUFBTUQsT0FBTTtBQUFBLFlBQzlCO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxZQUFJO0FBQ0EsYUFBRyxNQUFNLE9BQU8sTUFBTSxNQUFNO0FBQUEsUUFDaEMsU0FBUyxLQUFQO0FBQ0UsY0FBSSxTQUFTO0FBQ1Qsc0JBQVU7QUFDVixtQkFBTyxHQUFHO0FBQUEsVUFDZDtBQUFBLFFBQ0o7QUFBQSxNQUNKLENBQUM7QUFBQSxJQUNMO0FBQUE7QUFBQTs7O0FDbkRBO0FBQUEsNkNBQUFFLFVBQUE7QUFBQTtBQU9BLFFBQUlDLFVBQVNEO0FBT2IsSUFBQUMsUUFBTyxTQUFTLFNBQVNDLFFBQU9DLFNBQVE7QUFDcEMsVUFBSSxJQUFJQSxRQUFPO0FBQ2YsVUFBSSxDQUFDO0FBQ0QsZUFBTztBQUNYLFVBQUksSUFBSTtBQUNSLGFBQU8sRUFBRSxJQUFJLElBQUksS0FBS0EsUUFBTyxPQUFPLENBQUMsTUFBTTtBQUN2QyxVQUFFO0FBQ04sYUFBTyxLQUFLLEtBQUtBLFFBQU8sU0FBUyxDQUFDLElBQUksSUFBSTtBQUFBLElBQzlDO0FBR0EsUUFBSSxNQUFNLElBQUksTUFBTSxFQUFFO0FBR3RCLFFBQUksTUFBTSxJQUFJLE1BQU0sR0FBRztBQUd2QixTQUFTLElBQUksR0FBRyxJQUFJO0FBQ2hCLFVBQUksSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxNQUFNO0FBRDVFO0FBVVQsSUFBQUYsUUFBTyxTQUFTLFNBQVNHLFFBQU8sUUFBUSxPQUFPLEtBQUs7QUFDaEQsVUFBSSxRQUFRLE1BQ1IsUUFBUSxDQUFDO0FBQ2IsVUFBSUMsS0FBSSxHQUNKLElBQUksR0FDSjtBQUNKLGFBQU8sUUFBUSxLQUFLO0FBQ2hCLFlBQUksSUFBSSxPQUFPO0FBQ2YsZ0JBQVE7QUFBQSxlQUNDO0FBQ0Qsa0JBQU1BLFFBQU8sSUFBSSxLQUFLO0FBQ3RCLGlCQUFLLElBQUksTUFBTTtBQUNmLGdCQUFJO0FBQ0o7QUFBQSxlQUNDO0FBQ0Qsa0JBQU1BLFFBQU8sSUFBSSxJQUFJLEtBQUs7QUFDMUIsaUJBQUssSUFBSSxPQUFPO0FBQ2hCLGdCQUFJO0FBQ0o7QUFBQSxlQUNDO0FBQ0Qsa0JBQU1BLFFBQU8sSUFBSSxJQUFJLEtBQUs7QUFDMUIsa0JBQU1BLFFBQU8sSUFBSSxJQUFJO0FBQ3JCLGdCQUFJO0FBQ0o7QUFBQTtBQUVSLFlBQUlBLEtBQUksTUFBTTtBQUNWLFdBQUMsVUFBVSxRQUFRLENBQUMsSUFBSSxLQUFLLE9BQU8sYUFBYSxNQUFNLFFBQVEsS0FBSyxDQUFDO0FBQ3JFLFVBQUFBLEtBQUk7QUFBQSxRQUNSO0FBQUEsTUFDSjtBQUNBLFVBQUksR0FBRztBQUNILGNBQU1BLFFBQU8sSUFBSTtBQUNqQixjQUFNQSxRQUFPO0FBQ2IsWUFBSSxNQUFNO0FBQ04sZ0JBQU1BLFFBQU87QUFBQSxNQUNyQjtBQUNBLFVBQUksT0FBTztBQUNQLFlBQUlBO0FBQ0EsZ0JBQU0sS0FBSyxPQUFPLGFBQWEsTUFBTSxRQUFRLE1BQU0sTUFBTSxHQUFHQSxFQUFDLENBQUMsQ0FBQztBQUNuRSxlQUFPLE1BQU0sS0FBSyxFQUFFO0FBQUEsTUFDeEI7QUFDQSxhQUFPLE9BQU8sYUFBYSxNQUFNLFFBQVEsTUFBTSxNQUFNLEdBQUdBLEVBQUMsQ0FBQztBQUFBLElBQzlEO0FBRUEsUUFBSSxrQkFBa0I7QUFVdEIsSUFBQUosUUFBTyxTQUFTLFNBQVNLLFFBQU9ILFNBQVEsUUFBUSxRQUFRO0FBQ3BELFVBQUksUUFBUTtBQUNaLFVBQUksSUFBSSxHQUNKO0FBQ0osZUFBU0UsS0FBSSxHQUFHQSxLQUFJRixRQUFPLFVBQVM7QUFDaEMsWUFBSSxJQUFJQSxRQUFPLFdBQVdFLElBQUc7QUFDN0IsWUFBSSxNQUFNLE1BQU0sSUFBSTtBQUNoQjtBQUNKLGFBQUssSUFBSSxJQUFJLFFBQVE7QUFDakIsZ0JBQU0sTUFBTSxlQUFlO0FBQy9CLGdCQUFRO0FBQUEsZUFDQztBQUNELGdCQUFJO0FBQ0osZ0JBQUk7QUFDSjtBQUFBLGVBQ0M7QUFDRCxtQkFBTyxZQUFZLEtBQUssS0FBSyxJQUFJLE9BQU87QUFDeEMsZ0JBQUk7QUFDSixnQkFBSTtBQUNKO0FBQUEsZUFDQztBQUNELG1CQUFPLGFBQWEsSUFBSSxPQUFPLEtBQUssSUFBSSxPQUFPO0FBQy9DLGdCQUFJO0FBQ0osZ0JBQUk7QUFDSjtBQUFBLGVBQ0M7QUFDRCxtQkFBTyxhQUFhLElBQUksTUFBTSxJQUFJO0FBQ2xDLGdCQUFJO0FBQ0o7QUFBQTtBQUFBLE1BRVo7QUFDQSxVQUFJLE1BQU07QUFDTixjQUFNLE1BQU0sZUFBZTtBQUMvQixhQUFPLFNBQVM7QUFBQSxJQUNwQjtBQU9BLElBQUFKLFFBQU8sT0FBTyxTQUFTLEtBQUtFLFNBQVE7QUFDaEMsYUFBTyxtRUFBbUUsS0FBS0EsT0FBTTtBQUFBLElBQ3pGO0FBQUE7QUFBQTs7O0FDMUlBO0FBQUEsbURBQUFJLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVUM7QUFRakIsYUFBU0EsZ0JBQWU7QUFPcEIsV0FBSyxhQUFhLENBQUM7QUFBQSxJQUN2QjtBQVNBLElBQUFBLGNBQWEsVUFBVSxLQUFLLFNBQVMsR0FBRyxLQUFLLElBQUksS0FBSztBQUNsRCxPQUFDLEtBQUssV0FBVyxTQUFTLEtBQUssV0FBVyxPQUFPLENBQUMsSUFBSSxLQUFLO0FBQUEsUUFDdkQ7QUFBQSxRQUNBLEtBQU0sT0FBTztBQUFBLE1BQ2pCLENBQUM7QUFDRCxhQUFPO0FBQUEsSUFDWDtBQVFBLElBQUFBLGNBQWEsVUFBVSxNQUFNLFNBQVMsSUFBSSxLQUFLLElBQUk7QUFDL0MsVUFBSSxRQUFRO0FBQ1IsYUFBSyxhQUFhLENBQUM7QUFBQSxXQUNsQjtBQUNELFlBQUksT0FBTztBQUNQLGVBQUssV0FBVyxPQUFPLENBQUM7QUFBQSxhQUN2QjtBQUNELGNBQUksWUFBWSxLQUFLLFdBQVc7QUFDaEMsbUJBQVMsSUFBSSxHQUFHLElBQUksVUFBVTtBQUMxQixnQkFBSSxVQUFVLEdBQUcsT0FBTztBQUNwQix3QkFBVSxPQUFPLEdBQUcsQ0FBQztBQUFBO0FBRXJCLGdCQUFFO0FBQUEsUUFDZDtBQUFBLE1BQ0o7QUFDQSxhQUFPO0FBQUEsSUFDWDtBQVFBLElBQUFBLGNBQWEsVUFBVSxPQUFPLFNBQVMsS0FBSyxLQUFLO0FBQzdDLFVBQUksWUFBWSxLQUFLLFdBQVc7QUFDaEMsVUFBSSxXQUFXO0FBQ1gsWUFBSSxPQUFPLENBQUMsR0FDUixJQUFJO0FBQ1IsZUFBTyxJQUFJLFVBQVU7QUFDakIsZUFBSyxLQUFLLFVBQVUsSUFBSTtBQUM1QixhQUFLLElBQUksR0FBRyxJQUFJLFVBQVU7QUFDdEIsb0JBQVUsR0FBRyxHQUFHLE1BQU0sVUFBVSxLQUFLLEtBQUssSUFBSTtBQUFBLE1BQ3REO0FBQ0EsYUFBTztBQUFBLElBQ1g7QUFBQTtBQUFBOzs7QUMzRUE7QUFBQSw0Q0FBQUMsVUFBQUMsU0FBQTtBQUFBO0FBRUEsSUFBQUEsUUFBTyxVQUFVLFFBQVEsT0FBTztBQXFGaEMsYUFBUyxRQUFRRCxVQUFTO0FBR3RCLFVBQUksT0FBTyxpQkFBaUI7QUFBYSxTQUFDLFdBQVc7QUFFakQsY0FBSSxNQUFNLElBQUksYUFBYSxDQUFFLEVBQUcsQ0FBQyxHQUM3QixNQUFNLElBQUksV0FBVyxJQUFJLE1BQU0sR0FDL0IsS0FBTSxJQUFJLE9BQU87QUFFckIsbUJBQVMsbUJBQW1CLEtBQUssS0FBSyxLQUFLO0FBQ3ZDLGdCQUFJLEtBQUs7QUFDVCxnQkFBSSxPQUFXLElBQUk7QUFDbkIsZ0JBQUksTUFBTSxLQUFLLElBQUk7QUFDbkIsZ0JBQUksTUFBTSxLQUFLLElBQUk7QUFDbkIsZ0JBQUksTUFBTSxLQUFLLElBQUk7QUFBQSxVQUN2QjtBQUVBLG1CQUFTLG1CQUFtQixLQUFLLEtBQUssS0FBSztBQUN2QyxnQkFBSSxLQUFLO0FBQ1QsZ0JBQUksT0FBVyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQUEsVUFDdkI7QUFHQSxVQUFBQSxTQUFRLGVBQWUsS0FBSyxxQkFBcUI7QUFFakQsVUFBQUEsU0FBUSxlQUFlLEtBQUsscUJBQXFCO0FBRWpELG1CQUFTLGtCQUFrQixLQUFLLEtBQUs7QUFDakMsZ0JBQUksS0FBSyxJQUFJO0FBQ2IsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsbUJBQU8sSUFBSTtBQUFBLFVBQ2Y7QUFFQSxtQkFBUyxrQkFBa0IsS0FBSyxLQUFLO0FBQ2pDLGdCQUFJLEtBQUssSUFBSTtBQUNiLGdCQUFJLEtBQUssSUFBSSxNQUFNO0FBQ25CLGdCQUFJLEtBQUssSUFBSSxNQUFNO0FBQ25CLGdCQUFJLEtBQUssSUFBSSxNQUFNO0FBQ25CLG1CQUFPLElBQUk7QUFBQSxVQUNmO0FBR0EsVUFBQUEsU0FBUSxjQUFjLEtBQUssb0JBQW9CO0FBRS9DLFVBQUFBLFNBQVEsY0FBYyxLQUFLLG9CQUFvQjtBQUFBLFFBR25ELEdBQUc7QUFBQTtBQUFRLFNBQUMsV0FBVztBQUVuQixtQkFBUyxtQkFBbUIsV0FBVyxLQUFLLEtBQUssS0FBSztBQUNsRCxnQkFBSUUsUUFBTyxNQUFNLElBQUksSUFBSTtBQUN6QixnQkFBSUE7QUFDQSxvQkFBTSxDQUFDO0FBQ1gsZ0JBQUksUUFBUTtBQUNSLHdCQUFVLElBQUksTUFBTSxJQUFtQixJQUFxQixZQUFZLEtBQUssR0FBRztBQUFBLHFCQUMzRSxNQUFNLEdBQUc7QUFDZCx3QkFBVSxZQUFZLEtBQUssR0FBRztBQUFBLHFCQUN6QixNQUFNO0FBQ1gseUJBQVdBLFNBQVEsS0FBSyxnQkFBZ0IsR0FBRyxLQUFLLEdBQUc7QUFBQSxxQkFDOUMsTUFBTTtBQUNYLHlCQUFXQSxTQUFRLEtBQUssS0FBSyxNQUFNLE1BQU0sb0JBQXFCLE9BQU8sR0FBRyxLQUFLLEdBQUc7QUFBQSxpQkFDL0U7QUFDRCxrQkFBSSxXQUFXLEtBQUssTUFBTSxLQUFLLElBQUksR0FBRyxJQUFJLEtBQUssR0FBRyxHQUM5QyxXQUFXLEtBQUssTUFBTSxNQUFNLEtBQUssSUFBSSxHQUFHLENBQUMsUUFBUSxJQUFJLE9BQU8sSUFBSTtBQUNwRSx5QkFBV0EsU0FBUSxLQUFLLFdBQVcsT0FBTyxLQUFLLGNBQWMsR0FBRyxLQUFLLEdBQUc7QUFBQSxZQUM1RTtBQUFBLFVBQ0o7QUFFQSxVQUFBRixTQUFRLGVBQWUsbUJBQW1CLEtBQUssTUFBTSxXQUFXO0FBQ2hFLFVBQUFBLFNBQVEsZUFBZSxtQkFBbUIsS0FBSyxNQUFNLFdBQVc7QUFFaEUsbUJBQVMsa0JBQWtCLFVBQVUsS0FBSyxLQUFLO0FBQzNDLGdCQUFJLE9BQU8sU0FBUyxLQUFLLEdBQUcsR0FDeEJFLFNBQVEsUUFBUSxNQUFNLElBQUksR0FDMUIsV0FBVyxTQUFTLEtBQUssS0FDekIsV0FBVyxPQUFPO0FBQ3RCLG1CQUFPLGFBQWEsTUFDZCxXQUNBLE1BQ0FBLFFBQU8sV0FDUCxhQUFhLElBQ2JBLFFBQU8sdUJBQXdCLFdBQy9CQSxRQUFPLEtBQUssSUFBSSxHQUFHLFdBQVcsR0FBRyxLQUFLLFdBQVc7QUFBQSxVQUMzRDtBQUVBLFVBQUFGLFNBQVEsY0FBYyxrQkFBa0IsS0FBSyxNQUFNLFVBQVU7QUFDN0QsVUFBQUEsU0FBUSxjQUFjLGtCQUFrQixLQUFLLE1BQU0sVUFBVTtBQUFBLFFBRWpFLEdBQUc7QUFHSCxVQUFJLE9BQU8saUJBQWlCO0FBQWEsU0FBQyxXQUFXO0FBRWpELGNBQUksTUFBTSxJQUFJLGFBQWEsQ0FBQyxFQUFFLENBQUMsR0FDM0IsTUFBTSxJQUFJLFdBQVcsSUFBSSxNQUFNLEdBQy9CLEtBQU0sSUFBSSxPQUFPO0FBRXJCLG1CQUFTLG9CQUFvQixLQUFLLEtBQUssS0FBSztBQUN4QyxnQkFBSSxLQUFLO0FBQ1QsZ0JBQUksT0FBVyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGdCQUFJLE1BQU0sS0FBSyxJQUFJO0FBQUEsVUFDdkI7QUFFQSxtQkFBUyxvQkFBb0IsS0FBSyxLQUFLLEtBQUs7QUFDeEMsZ0JBQUksS0FBSztBQUNULGdCQUFJLE9BQVcsSUFBSTtBQUNuQixnQkFBSSxNQUFNLEtBQUssSUFBSTtBQUNuQixnQkFBSSxNQUFNLEtBQUssSUFBSTtBQUNuQixnQkFBSSxNQUFNLEtBQUssSUFBSTtBQUNuQixnQkFBSSxNQUFNLEtBQUssSUFBSTtBQUNuQixnQkFBSSxNQUFNLEtBQUssSUFBSTtBQUNuQixnQkFBSSxNQUFNLEtBQUssSUFBSTtBQUNuQixnQkFBSSxNQUFNLEtBQUssSUFBSTtBQUFBLFVBQ3ZCO0FBR0EsVUFBQUEsU0FBUSxnQkFBZ0IsS0FBSyxzQkFBc0I7QUFFbkQsVUFBQUEsU0FBUSxnQkFBZ0IsS0FBSyxzQkFBc0I7QUFFbkQsbUJBQVMsbUJBQW1CLEtBQUssS0FBSztBQUNsQyxnQkFBSSxLQUFLLElBQUk7QUFDYixnQkFBSSxLQUFLLElBQUksTUFBTTtBQUNuQixnQkFBSSxLQUFLLElBQUksTUFBTTtBQUNuQixnQkFBSSxLQUFLLElBQUksTUFBTTtBQUNuQixnQkFBSSxLQUFLLElBQUksTUFBTTtBQUNuQixnQkFBSSxLQUFLLElBQUksTUFBTTtBQUNuQixnQkFBSSxLQUFLLElBQUksTUFBTTtBQUNuQixnQkFBSSxLQUFLLElBQUksTUFBTTtBQUNuQixtQkFBTyxJQUFJO0FBQUEsVUFDZjtBQUVBLG1CQUFTLG1CQUFtQixLQUFLLEtBQUs7QUFDbEMsZ0JBQUksS0FBSyxJQUFJO0FBQ2IsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsZ0JBQUksS0FBSyxJQUFJLE1BQU07QUFDbkIsbUJBQU8sSUFBSTtBQUFBLFVBQ2Y7QUFHQSxVQUFBQSxTQUFRLGVBQWUsS0FBSyxxQkFBcUI7QUFFakQsVUFBQUEsU0FBUSxlQUFlLEtBQUsscUJBQXFCO0FBQUEsUUFHckQsR0FBRztBQUFBO0FBQVEsU0FBQyxXQUFXO0FBRW5CLG1CQUFTLG9CQUFvQixXQUFXLE1BQU0sTUFBTSxLQUFLLEtBQUssS0FBSztBQUMvRCxnQkFBSUUsUUFBTyxNQUFNLElBQUksSUFBSTtBQUN6QixnQkFBSUE7QUFDQSxvQkFBTSxDQUFDO0FBQ1gsZ0JBQUksUUFBUSxHQUFHO0FBQ1gsd0JBQVUsR0FBRyxLQUFLLE1BQU0sSUFBSTtBQUM1Qix3QkFBVSxJQUFJLE1BQU0sSUFBbUIsSUFBcUIsWUFBWSxLQUFLLE1BQU0sSUFBSTtBQUFBLFlBQzNGLFdBQVcsTUFBTSxHQUFHLEdBQUc7QUFDbkIsd0JBQVUsR0FBRyxLQUFLLE1BQU0sSUFBSTtBQUM1Qix3QkFBVSxZQUFZLEtBQUssTUFBTSxJQUFJO0FBQUEsWUFDekMsV0FBVyxNQUFNLHVCQUF5QjtBQUN0Qyx3QkFBVSxHQUFHLEtBQUssTUFBTSxJQUFJO0FBQzVCLHlCQUFXQSxTQUFRLEtBQUssZ0JBQWdCLEdBQUcsS0FBSyxNQUFNLElBQUk7QUFBQSxZQUM5RCxPQUFPO0FBQ0gsa0JBQUk7QUFDSixrQkFBSSxNQUFNLHdCQUF5QjtBQUMvQiwyQkFBVyxNQUFNO0FBQ2pCLDBCQUFVLGFBQWEsR0FBRyxLQUFLLE1BQU0sSUFBSTtBQUN6QywyQkFBV0EsU0FBUSxLQUFLLFdBQVcsZ0JBQWdCLEdBQUcsS0FBSyxNQUFNLElBQUk7QUFBQSxjQUN6RSxPQUFPO0FBQ0gsb0JBQUksV0FBVyxLQUFLLE1BQU0sS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEdBQUc7QUFDbEQsb0JBQUksYUFBYTtBQUNiLDZCQUFXO0FBQ2YsMkJBQVcsTUFBTSxLQUFLLElBQUksR0FBRyxDQUFDLFFBQVE7QUFDdEMsMEJBQVUsV0FBVyxxQkFBcUIsR0FBRyxLQUFLLE1BQU0sSUFBSTtBQUM1RCwyQkFBV0EsU0FBUSxLQUFLLFdBQVcsUUFBUSxLQUFLLFdBQVcsVUFBVSxhQUFhLEdBQUcsS0FBSyxNQUFNLElBQUk7QUFBQSxjQUN4RztBQUFBLFlBQ0o7QUFBQSxVQUNKO0FBRUEsVUFBQUYsU0FBUSxnQkFBZ0Isb0JBQW9CLEtBQUssTUFBTSxhQUFhLEdBQUcsQ0FBQztBQUN4RSxVQUFBQSxTQUFRLGdCQUFnQixvQkFBb0IsS0FBSyxNQUFNLGFBQWEsR0FBRyxDQUFDO0FBRXhFLG1CQUFTLG1CQUFtQixVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUs7QUFDeEQsZ0JBQUksS0FBSyxTQUFTLEtBQUssTUFBTSxJQUFJLEdBQzdCLEtBQUssU0FBUyxLQUFLLE1BQU0sSUFBSTtBQUNqQyxnQkFBSUUsU0FBUSxNQUFNLE1BQU0sSUFBSSxHQUN4QixXQUFXLE9BQU8sS0FBSyxNQUN2QixXQUFXLGNBQWMsS0FBSyxXQUFXO0FBQzdDLG1CQUFPLGFBQWEsT0FDZCxXQUNBLE1BQ0FBLFFBQU8sV0FDUCxhQUFhLElBQ2JBLFFBQU8sU0FBUyxXQUNoQkEsUUFBTyxLQUFLLElBQUksR0FBRyxXQUFXLElBQUksS0FBSyxXQUFXO0FBQUEsVUFDNUQ7QUFFQSxVQUFBRixTQUFRLGVBQWUsbUJBQW1CLEtBQUssTUFBTSxZQUFZLEdBQUcsQ0FBQztBQUNyRSxVQUFBQSxTQUFRLGVBQWUsbUJBQW1CLEtBQUssTUFBTSxZQUFZLEdBQUcsQ0FBQztBQUFBLFFBRXpFLEdBQUc7QUFFSCxhQUFPQTtBQUFBLElBQ1g7QUFJQSxhQUFTLFlBQVksS0FBSyxLQUFLLEtBQUs7QUFDaEMsVUFBSSxPQUFZLE1BQWE7QUFDN0IsVUFBSSxNQUFNLEtBQU0sUUFBUSxJQUFLO0FBQzdCLFVBQUksTUFBTSxLQUFNLFFBQVEsS0FBSztBQUM3QixVQUFJLE1BQU0sS0FBTSxRQUFRO0FBQUEsSUFDNUI7QUFFQSxhQUFTLFlBQVksS0FBSyxLQUFLLEtBQUs7QUFDaEMsVUFBSSxPQUFZLFFBQVE7QUFDeEIsVUFBSSxNQUFNLEtBQU0sUUFBUSxLQUFLO0FBQzdCLFVBQUksTUFBTSxLQUFNLFFBQVEsSUFBSztBQUM3QixVQUFJLE1BQU0sS0FBTSxNQUFhO0FBQUEsSUFDakM7QUFFQSxhQUFTLFdBQVcsS0FBSyxLQUFLO0FBQzFCLGNBQVEsSUFBSSxPQUNKLElBQUksTUFBTSxNQUFNLElBQ2hCLElBQUksTUFBTSxNQUFNLEtBQ2hCLElBQUksTUFBTSxNQUFNLFFBQVE7QUFBQSxJQUNwQztBQUVBLGFBQVMsV0FBVyxLQUFLLEtBQUs7QUFDMUIsY0FBUSxJQUFJLFFBQVksS0FDaEIsSUFBSSxNQUFNLE1BQU0sS0FDaEIsSUFBSSxNQUFNLE1BQU0sSUFDaEIsSUFBSSxNQUFNLFFBQVE7QUFBQSxJQUM5QjtBQUFBO0FBQUE7OztBQzlVQTtBQUFBO0FBQUE7QUFDQSxXQUFPLFVBQVU7QUFRakIsYUFBUyxRQUFRLFlBQVk7QUFDekIsVUFBSTtBQUNBLFlBQUksTUFBTSxLQUFLLFFBQVEsUUFBUSxLQUFJLElBQUksQ0FBQyxFQUFFLFVBQVU7QUFDcEQsWUFBSSxRQUFRLElBQUksVUFBVSxPQUFPLEtBQUssR0FBRyxFQUFFO0FBQ3ZDLGlCQUFPO0FBQUEsTUFDZixTQUFTLEdBQVA7QUFBQSxNQUFXO0FBQ2IsYUFBTztBQUFBLElBQ1g7QUFBQTtBQUFBOzs7QUNoQkE7QUFBQSwyQ0FBQUcsVUFBQTtBQUFBO0FBT0EsUUFBSSxPQUFPQTtBQU9YLFNBQUssU0FBUyxTQUFTLFlBQVlDLFNBQVE7QUFDdkMsVUFBSSxNQUFNLEdBQ04sSUFBSTtBQUNSLGVBQVMsSUFBSSxHQUFHLElBQUlBLFFBQU8sUUFBUSxFQUFFLEdBQUc7QUFDcEMsWUFBSUEsUUFBTyxXQUFXLENBQUM7QUFDdkIsWUFBSSxJQUFJO0FBQ0osaUJBQU87QUFBQSxpQkFDRixJQUFJO0FBQ1QsaUJBQU87QUFBQSxrQkFDRCxJQUFJLFdBQVksVUFBV0EsUUFBTyxXQUFXLElBQUksQ0FBQyxJQUFJLFdBQVksT0FBUTtBQUNoRixZQUFFO0FBQ0YsaUJBQU87QUFBQSxRQUNYO0FBQ0ksaUJBQU87QUFBQSxNQUNmO0FBQ0EsYUFBTztBQUFBLElBQ1g7QUFTQSxTQUFLLE9BQU8sU0FBUyxVQUFVLFFBQVEsT0FBTyxLQUFLO0FBQy9DLFVBQUksTUFBTSxNQUFNO0FBQ2hCLFVBQUksTUFBTTtBQUNOLGVBQU87QUFDWCxVQUFJLFFBQVEsTUFDUixRQUFRLENBQUMsR0FDVCxJQUFJLEdBQ0o7QUFDSixhQUFPLFFBQVEsS0FBSztBQUNoQixZQUFJLE9BQU87QUFDWCxZQUFJLElBQUk7QUFDSixnQkFBTSxPQUFPO0FBQUEsaUJBQ1IsSUFBSSxPQUFPLElBQUk7QUFDcEIsZ0JBQU0sUUFBUSxJQUFJLE9BQU8sSUFBSSxPQUFPLFdBQVc7QUFBQSxpQkFDMUMsSUFBSSxPQUFPLElBQUksS0FBSztBQUN6QixnQkFBTSxJQUFJLE1BQU0sTUFBTSxPQUFPLFdBQVcsT0FBTyxNQUFNLE9BQU8sV0FBVyxPQUFPLElBQUksT0FBTyxXQUFXLE1BQU07QUFDMUcsZ0JBQU0sT0FBTyxTQUFVLEtBQUs7QUFDNUIsZ0JBQU0sT0FBTyxTQUFVLElBQUk7QUFBQSxRQUMvQjtBQUNJLGdCQUFNLFFBQVEsSUFBSSxPQUFPLE1BQU0sT0FBTyxXQUFXLE9BQU8sSUFBSSxPQUFPLFdBQVc7QUFDbEYsWUFBSSxJQUFJLE1BQU07QUFDVixXQUFDLFVBQVUsUUFBUSxDQUFDLElBQUksS0FBSyxPQUFPLGFBQWEsTUFBTSxRQUFRLEtBQUssQ0FBQztBQUNyRSxjQUFJO0FBQUEsUUFDUjtBQUFBLE1BQ0o7QUFDQSxVQUFJLE9BQU87QUFDUCxZQUFJO0FBQ0EsZ0JBQU0sS0FBSyxPQUFPLGFBQWEsTUFBTSxRQUFRLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ25FLGVBQU8sTUFBTSxLQUFLLEVBQUU7QUFBQSxNQUN4QjtBQUNBLGFBQU8sT0FBTyxhQUFhLE1BQU0sUUFBUSxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFBQSxJQUM5RDtBQVNBLFNBQUssUUFBUSxTQUFTLFdBQVdBLFNBQVEsUUFBUSxRQUFRO0FBQ3JELFVBQUksUUFBUSxRQUNSLElBQ0E7QUFDSixlQUFTLElBQUksR0FBRyxJQUFJQSxRQUFPLFFBQVEsRUFBRSxHQUFHO0FBQ3BDLGFBQUtBLFFBQU8sV0FBVyxDQUFDO0FBQ3hCLFlBQUksS0FBSyxLQUFLO0FBQ1YsaUJBQU8sWUFBWTtBQUFBLFFBQ3ZCLFdBQVcsS0FBSyxNQUFNO0FBQ2xCLGlCQUFPLFlBQVksTUFBTSxJQUFVO0FBQ25DLGlCQUFPLFlBQVksS0FBVyxLQUFLO0FBQUEsUUFDdkMsWUFBWSxLQUFLLFdBQVksV0FBWSxLQUFLQSxRQUFPLFdBQVcsSUFBSSxDQUFDLEtBQUssV0FBWSxPQUFRO0FBQzFGLGVBQUssVUFBWSxLQUFLLFNBQVcsT0FBTyxLQUFLO0FBQzdDLFlBQUU7QUFDRixpQkFBTyxZQUFZLE1BQU0sS0FBVTtBQUNuQyxpQkFBTyxZQUFZLE1BQU0sS0FBSyxLQUFLO0FBQ25DLGlCQUFPLFlBQVksTUFBTSxJQUFLLEtBQUs7QUFDbkMsaUJBQU8sWUFBWSxLQUFXLEtBQUs7QUFBQSxRQUN2QyxPQUFPO0FBQ0gsaUJBQU8sWUFBWSxNQUFNLEtBQVU7QUFDbkMsaUJBQU8sWUFBWSxNQUFNLElBQUssS0FBSztBQUNuQyxpQkFBTyxZQUFZLEtBQVcsS0FBSztBQUFBLFFBQ3ZDO0FBQUEsTUFDSjtBQUNBLGFBQU8sU0FBUztBQUFBLElBQ3BCO0FBQUE7QUFBQTs7O0FDeEdBO0FBQUEsMkNBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVTtBQTZCakIsYUFBUyxLQUFLQyxRQUFPLE9BQU8sTUFBTTtBQUM5QixVQUFJLE9BQVMsUUFBUTtBQUNyQixVQUFJLE1BQVMsU0FBUztBQUN0QixVQUFJLE9BQVM7QUFDYixVQUFJLFNBQVM7QUFDYixhQUFPLFNBQVMsV0FBV0MsT0FBTTtBQUM3QixZQUFJQSxRQUFPLEtBQUtBLFFBQU87QUFDbkIsaUJBQU9ELE9BQU1DLEtBQUk7QUFDckIsWUFBSSxTQUFTQSxRQUFPLE1BQU07QUFDdEIsaUJBQU9ELE9BQU0sSUFBSTtBQUNqQixtQkFBUztBQUFBLFFBQ2I7QUFDQSxZQUFJLE1BQU0sTUFBTSxLQUFLLE1BQU0sUUFBUSxVQUFVQyxLQUFJO0FBQ2pELFlBQUksU0FBUztBQUNULG9CQUFVLFNBQVMsS0FBSztBQUM1QixlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFBQTtBQUFBOzs7QUMvQ0E7QUFBQSxpREFBQUMsVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVQztBQUVqQixRQUFJLE9BQU87QUFVWCxhQUFTQSxVQUFTLElBQUksSUFBSTtBQVN0QixXQUFLLEtBQUssT0FBTztBQU1qQixXQUFLLEtBQUssT0FBTztBQUFBLElBQ3JCO0FBT0EsUUFBSSxPQUFPQSxVQUFTLE9BQU8sSUFBSUEsVUFBUyxHQUFHLENBQUM7QUFFNUMsU0FBSyxXQUFXLFdBQVc7QUFBRSxhQUFPO0FBQUEsSUFBRztBQUN2QyxTQUFLLFdBQVcsS0FBSyxXQUFXLFdBQVc7QUFBRSxhQUFPO0FBQUEsSUFBTTtBQUMxRCxTQUFLLFNBQVMsV0FBVztBQUFFLGFBQU87QUFBQSxJQUFHO0FBT3JDLFFBQUksV0FBV0EsVUFBUyxXQUFXO0FBT25DLElBQUFBLFVBQVMsYUFBYSxTQUFTLFdBQVcsT0FBTztBQUM3QyxVQUFJLFVBQVU7QUFDVixlQUFPO0FBQ1gsVUFBSUMsUUFBTyxRQUFRO0FBQ25CLFVBQUlBO0FBQ0EsZ0JBQVEsQ0FBQztBQUNiLFVBQUksS0FBSyxVQUFVLEdBQ2YsTUFBTSxRQUFRLE1BQU0sZUFBZTtBQUN2QyxVQUFJQSxPQUFNO0FBQ04sYUFBSyxDQUFDLE9BQU87QUFDYixhQUFLLENBQUMsT0FBTztBQUNiLFlBQUksRUFBRSxLQUFLLFlBQVk7QUFDbkIsZUFBSztBQUNMLGNBQUksRUFBRSxLQUFLO0FBQ1AsaUJBQUs7QUFBQSxRQUNiO0FBQUEsTUFDSjtBQUNBLGFBQU8sSUFBSUQsVUFBUyxJQUFJLEVBQUU7QUFBQSxJQUM5QjtBQU9BLElBQUFBLFVBQVMsT0FBTyxTQUFTRSxNQUFLLE9BQU87QUFDakMsVUFBSSxPQUFPLFVBQVU7QUFDakIsZUFBT0YsVUFBUyxXQUFXLEtBQUs7QUFDcEMsVUFBSSxLQUFLLFNBQVMsS0FBSyxHQUFHO0FBRXRCLFlBQUksS0FBSztBQUNMLGtCQUFRLEtBQUssS0FBSyxXQUFXLEtBQUs7QUFBQTtBQUVsQyxpQkFBT0EsVUFBUyxXQUFXLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxNQUN0RDtBQUNBLGFBQU8sTUFBTSxPQUFPLE1BQU0sT0FBTyxJQUFJQSxVQUFTLE1BQU0sUUFBUSxHQUFHLE1BQU0sU0FBUyxDQUFDLElBQUk7QUFBQSxJQUN2RjtBQU9BLElBQUFBLFVBQVMsVUFBVSxXQUFXLFNBQVMsU0FBU0csV0FBVTtBQUN0RCxVQUFJLENBQUNBLGFBQVksS0FBSyxPQUFPLElBQUk7QUFDN0IsWUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLE1BQU0sR0FDdEIsS0FBSyxDQUFDLEtBQUssT0FBVztBQUMxQixZQUFJLENBQUM7QUFDRCxlQUFLLEtBQUssTUFBTTtBQUNwQixlQUFPLEVBQUUsS0FBSyxLQUFLO0FBQUEsTUFDdkI7QUFDQSxhQUFPLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFBQSxJQUMvQjtBQU9BLElBQUFILFVBQVMsVUFBVSxTQUFTLFNBQVMsT0FBT0csV0FBVTtBQUNsRCxhQUFPLEtBQUssT0FDTixJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxRQUFRQSxTQUFRLENBQUMsSUFFekQsRUFBRSxLQUFLLEtBQUssS0FBSyxHQUFHLE1BQU0sS0FBSyxLQUFLLEdBQUcsVUFBVSxRQUFRQSxTQUFRLEVBQUU7QUFBQSxJQUM3RTtBQUVBLFFBQUksYUFBYSxPQUFPLFVBQVU7QUFPbEMsSUFBQUgsVUFBUyxXQUFXLFNBQVMsU0FBUyxNQUFNO0FBQ3hDLFVBQUksU0FBUztBQUNULGVBQU87QUFDWCxhQUFPLElBQUlBO0FBQUEsU0FDTCxXQUFXLEtBQUssTUFBTSxDQUFDLElBQ3ZCLFdBQVcsS0FBSyxNQUFNLENBQUMsS0FBSyxJQUM1QixXQUFXLEtBQUssTUFBTSxDQUFDLEtBQUssS0FDNUIsV0FBVyxLQUFLLE1BQU0sQ0FBQyxLQUFLLFFBQVE7QUFBQSxTQUVwQyxXQUFXLEtBQUssTUFBTSxDQUFDLElBQ3ZCLFdBQVcsS0FBSyxNQUFNLENBQUMsS0FBSyxJQUM1QixXQUFXLEtBQUssTUFBTSxDQUFDLEtBQUssS0FDNUIsV0FBVyxLQUFLLE1BQU0sQ0FBQyxLQUFLLFFBQVE7QUFBQSxNQUMxQztBQUFBLElBQ0o7QUFNQSxJQUFBQSxVQUFTLFVBQVUsU0FBUyxTQUFTLFNBQVM7QUFDMUMsYUFBTyxPQUFPO0FBQUEsUUFDVixLQUFLLEtBQVk7QUFBQSxRQUNqQixLQUFLLE9BQU8sSUFBSztBQUFBLFFBQ2pCLEtBQUssT0FBTyxLQUFLO0FBQUEsUUFDakIsS0FBSyxPQUFPO0FBQUEsUUFDWixLQUFLLEtBQVk7QUFBQSxRQUNqQixLQUFLLE9BQU8sSUFBSztBQUFBLFFBQ2pCLEtBQUssT0FBTyxLQUFLO0FBQUEsUUFDakIsS0FBSyxPQUFPO0FBQUEsTUFDaEI7QUFBQSxJQUNKO0FBTUEsSUFBQUEsVUFBUyxVQUFVLFdBQVcsU0FBUyxXQUFXO0FBQzlDLFVBQUksT0FBUyxLQUFLLE1BQU07QUFDeEIsV0FBSyxPQUFRLEtBQUssTUFBTSxJQUFJLEtBQUssT0FBTyxNQUFNLFVBQVU7QUFDeEQsV0FBSyxNQUFRLEtBQUssTUFBTSxJQUFzQixVQUFVO0FBQ3hELGFBQU87QUFBQSxJQUNYO0FBTUEsSUFBQUEsVUFBUyxVQUFVLFdBQVcsU0FBUyxXQUFXO0FBQzlDLFVBQUksT0FBTyxFQUFFLEtBQUssS0FBSztBQUN2QixXQUFLLE9BQVEsS0FBSyxPQUFPLElBQUksS0FBSyxNQUFNLE1BQU0sVUFBVTtBQUN4RCxXQUFLLE1BQVEsS0FBSyxPQUFPLElBQXFCLFVBQVU7QUFDeEQsYUFBTztBQUFBLElBQ1g7QUFNQSxJQUFBQSxVQUFTLFVBQVUsU0FBUyxTQUFTSSxVQUFTO0FBQzFDLFVBQUksUUFBUyxLQUFLLElBQ2QsU0FBUyxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxHQUM1QyxRQUFTLEtBQUssT0FBTztBQUN6QixhQUFPLFVBQVUsSUFDVixVQUFVLElBQ1IsUUFBUSxRQUNOLFFBQVEsTUFBTSxJQUFJLElBQ2xCLFFBQVEsVUFBVSxJQUFJLElBQ3hCLFFBQVEsUUFDTixRQUFRLE1BQU0sSUFBSSxJQUNsQixRQUFRLFVBQVUsSUFBSSxJQUMxQixRQUFRLE1BQU0sSUFBSTtBQUFBLElBQzdCO0FBQUE7QUFBQTs7O0FDdk1BO0FBQUEsZ0RBQUFDLFVBQUE7QUFBQTtBQUNBLFFBQUksT0FBT0E7QUFHWCxTQUFLLFlBQVk7QUFHakIsU0FBSyxTQUFTO0FBR2QsU0FBSyxlQUFlO0FBR3BCLFNBQUssUUFBUTtBQUdiLFNBQUssVUFBVTtBQUdmLFNBQUssT0FBTztBQUdaLFNBQUssT0FBTztBQUdaLFNBQUssV0FBVztBQU9oQixTQUFLLFNBQVMsUUFBUSxPQUFPLFdBQVcsZUFDbEIsVUFDQSxPQUFPLFdBQ1AsT0FBTyxRQUFRLFlBQ2YsT0FBTyxRQUFRLFNBQVMsSUFBSTtBQU9sRCxTQUFLLFNBQVMsS0FBSyxVQUFVLFVBQ2YsT0FBTyxXQUFXLGVBQWUsVUFDakMsT0FBTyxTQUFXLGVBQWUsUUFDakNBO0FBUWQsU0FBSyxhQUFhLE9BQU8sU0FBUyxPQUFPLE9BQU8sQ0FBQyxDQUFDLElBQStCLENBQUM7QUFPbEYsU0FBSyxjQUFjLE9BQU8sU0FBUyxPQUFPLE9BQU8sQ0FBQyxDQUFDLElBQStCLENBQUM7QUFRbkYsU0FBSyxZQUFZLE9BQU8sYUFBd0MsU0FBUyxVQUFVLE9BQU87QUFDdEYsYUFBTyxPQUFPLFVBQVUsWUFBWSxTQUFTLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxNQUFNO0FBQUEsSUFDakY7QUFPQSxTQUFLLFdBQVcsU0FBUyxTQUFTLE9BQU87QUFDckMsYUFBTyxPQUFPLFVBQVUsWUFBWSxpQkFBaUI7QUFBQSxJQUN6RDtBQU9BLFNBQUssV0FBVyxTQUFTLFNBQVMsT0FBTztBQUNyQyxhQUFPLFNBQVMsT0FBTyxVQUFVO0FBQUEsSUFDckM7QUFVQSxTQUFLLFFBUUwsS0FBSyxRQUFRLFNBQVMsTUFBTSxLQUFLLE1BQU07QUFDbkMsVUFBSSxRQUFRLElBQUk7QUFDaEIsVUFBSSxTQUFTLFFBQVEsSUFBSSxlQUFlLElBQUk7QUFDeEMsZUFBTyxPQUFPLFVBQVUsYUFBYSxNQUFNLFFBQVEsS0FBSyxJQUFJLE1BQU0sU0FBUyxPQUFPLEtBQUssS0FBSyxFQUFFLFVBQVU7QUFDNUcsYUFBTztBQUFBLElBQ1g7QUFhQSxTQUFLLFNBQVUsV0FBVztBQUN0QixVQUFJO0FBQ0EsWUFBSUMsVUFBUyxLQUFLLFFBQVEsUUFBUSxFQUFFO0FBRXBDLGVBQU9BLFFBQU8sVUFBVSxZQUFZQSxVQUFvQztBQUFBLE1BQzVFLFNBQVMsR0FBUDtBQUVFLGVBQU87QUFBQSxNQUNYO0FBQUEsSUFDSixFQUFHO0FBR0gsU0FBSyxlQUFlO0FBR3BCLFNBQUssc0JBQXNCO0FBTzNCLFNBQUssWUFBWSxTQUFTLFVBQVUsYUFBYTtBQUU3QyxhQUFPLE9BQU8sZ0JBQWdCLFdBQ3hCLEtBQUssU0FDRCxLQUFLLG9CQUFvQixXQUFXLElBQ3BDLElBQUksS0FBSyxNQUFNLFdBQVcsSUFDOUIsS0FBSyxTQUNELEtBQUssYUFBYSxXQUFXLElBQzdCLE9BQU8sZUFBZSxjQUNsQixjQUNBLElBQUksV0FBVyxXQUFXO0FBQUEsSUFDNUM7QUFNQSxTQUFLLFFBQVEsT0FBTyxlQUFlLGNBQWMsYUFBd0M7QUFlekYsU0FBSyxPQUFrQyxLQUFLLE9BQU8sV0FBc0MsS0FBSyxPQUFPLFFBQVEsUUFDdEUsS0FBSyxPQUFPLFFBQ3ZDLEtBQUssUUFBUSxNQUFNO0FBTy9CLFNBQUssU0FBUztBQU9kLFNBQUssVUFBVTtBQU9mLFNBQUssVUFBVTtBQU9mLFNBQUssYUFBYSxTQUFTLFdBQVcsT0FBTztBQUN6QyxhQUFPLFFBQ0QsS0FBSyxTQUFTLEtBQUssS0FBSyxFQUFFLE9BQU8sSUFDakMsS0FBSyxTQUFTO0FBQUEsSUFDeEI7QUFRQSxTQUFLLGVBQWUsU0FBUyxhQUFhLE1BQU1DLFdBQVU7QUFDdEQsVUFBSSxPQUFPLEtBQUssU0FBUyxTQUFTLElBQUk7QUFDdEMsVUFBSSxLQUFLO0FBQ0wsZUFBTyxLQUFLLEtBQUssU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFRO0FBQ3hELGFBQU8sS0FBSyxTQUFTLFFBQVFBLFNBQVEsQ0FBQztBQUFBLElBQzFDO0FBVUEsYUFBU0MsT0FBTSxLQUFLQyxNQUFLLFVBQVU7QUFDL0IsZUFBUyxPQUFPLE9BQU8sS0FBS0EsSUFBRyxHQUFHLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxFQUFFO0FBQ3hELFlBQUksSUFBSSxLQUFLLFFBQVEsVUFBYSxDQUFDO0FBQy9CLGNBQUksS0FBSyxNQUFNQSxLQUFJLEtBQUs7QUFDaEMsYUFBTztBQUFBLElBQ1g7QUFFQSxTQUFLLFFBQVFEO0FBT2IsU0FBSyxVQUFVLFNBQVMsUUFBUSxLQUFLO0FBQ2pDLGFBQU8sSUFBSSxPQUFPLENBQUMsRUFBRSxZQUFZLElBQUksSUFBSSxVQUFVLENBQUM7QUFBQSxJQUN4RDtBQVFBLGFBQVMsU0FBU0UsT0FBTTtBQUVwQixlQUFTLFlBQVlDLFVBQVMsWUFBWTtBQUV0QyxZQUFJLEVBQUUsZ0JBQWdCO0FBQ2xCLGlCQUFPLElBQUksWUFBWUEsVUFBUyxVQUFVO0FBSzlDLGVBQU8sZUFBZSxNQUFNLFdBQVcsRUFBRSxLQUFLLFdBQVc7QUFBRSxpQkFBT0E7QUFBQSxRQUFTLEVBQUUsQ0FBQztBQUc5RSxZQUFJLE1BQU07QUFDTixnQkFBTSxrQkFBa0IsTUFBTSxXQUFXO0FBQUE7QUFFekMsaUJBQU8sZUFBZSxNQUFNLFNBQVMsRUFBRSxPQUFPLElBQUksTUFBTSxFQUFFLFNBQVMsR0FBRyxDQUFDO0FBRTNFLFlBQUk7QUFDQSxVQUFBSCxPQUFNLE1BQU0sVUFBVTtBQUFBLE1BQzlCO0FBRUEsa0JBQVksWUFBWSxPQUFPLE9BQU8sTUFBTSxXQUFXO0FBQUEsUUFDbkQsYUFBYTtBQUFBLFVBQ1QsT0FBTztBQUFBLFVBQ1AsVUFBVTtBQUFBLFVBQ1YsWUFBWTtBQUFBLFVBQ1osY0FBYztBQUFBLFFBQ2xCO0FBQUEsUUFDQSxNQUFNO0FBQUEsVUFDRixNQUFNO0FBQUUsbUJBQU9FO0FBQUEsVUFBTTtBQUFBLFVBQ3JCLEtBQUs7QUFBQSxVQUNMLFlBQVk7QUFBQSxVQUtaLGNBQWM7QUFBQSxRQUNsQjtBQUFBLFFBQ0EsVUFBVTtBQUFBLFVBQ04sUUFBUTtBQUFFLG1CQUFPLEtBQUssT0FBTyxPQUFPLEtBQUs7QUFBQSxVQUFTO0FBQUEsVUFDbEQsVUFBVTtBQUFBLFVBQ1YsWUFBWTtBQUFBLFVBQ1osY0FBYztBQUFBLFFBQ2xCO0FBQUEsTUFDSixDQUFDO0FBRUQsYUFBTztBQUFBLElBQ1g7QUFFQSxTQUFLLFdBQVc7QUFtQmhCLFNBQUssZ0JBQWdCLFNBQVMsZUFBZTtBQW9CN0MsU0FBSyxjQUFjLFNBQVMsU0FBUyxZQUFZO0FBQzdDLFVBQUksV0FBVyxDQUFDO0FBQ2hCLGVBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxRQUFRLEVBQUU7QUFDckMsaUJBQVMsV0FBVyxNQUFNO0FBTzlCLGFBQU8sV0FBVztBQUNkLGlCQUFTLE9BQU8sT0FBTyxLQUFLLElBQUksR0FBR0UsS0FBSSxLQUFLLFNBQVMsR0FBR0EsS0FBSSxJQUFJLEVBQUVBO0FBQzlELGNBQUksU0FBUyxLQUFLQSxTQUFRLEtBQUssS0FBSyxLQUFLQSxTQUFRLFVBQWEsS0FBSyxLQUFLQSxTQUFRO0FBQzVFLG1CQUFPLEtBQUtBO0FBQUEsTUFDeEI7QUFBQSxJQUNKO0FBZUEsU0FBSyxjQUFjLFNBQVMsU0FBUyxZQUFZO0FBUTdDLGFBQU8sU0FBU0YsT0FBTTtBQUNsQixpQkFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsRUFBRTtBQUNyQyxjQUFJLFdBQVcsT0FBT0E7QUFDbEIsbUJBQU8sS0FBSyxXQUFXO0FBQUEsTUFDbkM7QUFBQSxJQUNKO0FBa0JBLFNBQUssZ0JBQWdCO0FBQUEsTUFDakIsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsTUFBTTtBQUFBLElBQ1Y7QUFHQSxTQUFLLGFBQWEsV0FBVztBQUN6QixVQUFJSixVQUFTLEtBQUs7QUFFbEIsVUFBSSxDQUFDQSxTQUFRO0FBQ1QsYUFBSyxlQUFlLEtBQUssc0JBQXNCO0FBQy9DO0FBQUEsTUFDSjtBQUdBLFdBQUssZUFBZUEsUUFBTyxTQUFTLFdBQVcsUUFBUUEsUUFBTyxRQUUxRCxTQUFTLFlBQVksT0FBTyxVQUFVO0FBQ2xDLGVBQU8sSUFBSUEsUUFBTyxPQUFPLFFBQVE7QUFBQSxNQUNyQztBQUNKLFdBQUssc0JBQXNCQSxRQUFPLGVBRTlCLFNBQVMsbUJBQW1CLE1BQU07QUFDOUIsZUFBTyxJQUFJQSxRQUFPLElBQUk7QUFBQSxNQUMxQjtBQUFBLElBQ1I7QUFBQTtBQUFBOzs7QUNyYkE7QUFBQSwwQ0FBQU8sVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVQztBQUVqQixRQUFJLE9BQVk7QUFFaEIsUUFBSTtBQUVKLFFBQUlDLFlBQVksS0FBSztBQUFyQixRQUNJQyxVQUFZLEtBQUs7QUFEckIsUUFFSSxPQUFZLEtBQUs7QUFXckIsYUFBUyxHQUFHLElBQUksS0FBSyxLQUFLO0FBTXRCLFdBQUssS0FBSztBQU1WLFdBQUssTUFBTTtBQU1YLFdBQUssT0FBTztBQU1aLFdBQUssTUFBTTtBQUFBLElBQ2Y7QUFHQSxhQUFTQyxRQUFPO0FBQUEsSUFBQztBQVVqQixhQUFTLE1BQU0sUUFBUTtBQU1uQixXQUFLLE9BQU8sT0FBTztBQU1uQixXQUFLLE9BQU8sT0FBTztBQU1uQixXQUFLLE1BQU0sT0FBTztBQU1sQixXQUFLLE9BQU8sT0FBTztBQUFBLElBQ3ZCO0FBT0EsYUFBU0gsVUFBUztBQU1kLFdBQUssTUFBTTtBQU1YLFdBQUssT0FBTyxJQUFJLEdBQUdHLE9BQU0sR0FBRyxDQUFDO0FBTTdCLFdBQUssT0FBTyxLQUFLO0FBTWpCLFdBQUssU0FBUztBQUFBLElBT2xCO0FBRUEsUUFBSUMsVUFBUyxTQUFTQSxVQUFTO0FBQzNCLGFBQU8sS0FBSyxTQUNOLFNBQVMsc0JBQXNCO0FBQzdCLGdCQUFRSixRQUFPLFNBQVMsU0FBUyxnQkFBZ0I7QUFDN0MsaUJBQU8sSUFBSSxhQUFhO0FBQUEsUUFDNUIsR0FBRztBQUFBLE1BQ1AsSUFFRSxTQUFTLGVBQWU7QUFDdEIsZUFBTyxJQUFJQSxRQUFPO0FBQUEsTUFDdEI7QUFBQSxJQUNSO0FBT0EsSUFBQUEsUUFBTyxTQUFTSSxRQUFPO0FBT3ZCLElBQUFKLFFBQU8sUUFBUSxTQUFTSyxPQUFNLE1BQU07QUFDaEMsYUFBTyxJQUFJLEtBQUssTUFBTSxJQUFJO0FBQUEsSUFDOUI7QUFJQSxRQUFJLEtBQUssVUFBVTtBQUNmLE1BQUFMLFFBQU8sUUFBUSxLQUFLLEtBQUtBLFFBQU8sT0FBTyxLQUFLLE1BQU0sVUFBVSxRQUFRO0FBVXhFLElBQUFBLFFBQU8sVUFBVSxRQUFRLFNBQVMsS0FBSyxJQUFJLEtBQUssS0FBSztBQUNqRCxXQUFLLE9BQU8sS0FBSyxLQUFLLE9BQU8sSUFBSSxHQUFHLElBQUksS0FBSyxHQUFHO0FBQ2hELFdBQUssT0FBTztBQUNaLGFBQU87QUFBQSxJQUNYO0FBRUEsYUFBUyxVQUFVLEtBQUssS0FBSyxLQUFLO0FBQzlCLFVBQUksT0FBTyxNQUFNO0FBQUEsSUFDckI7QUFFQSxhQUFTLGNBQWMsS0FBSyxLQUFLLEtBQUs7QUFDbEMsYUFBTyxNQUFNLEtBQUs7QUFDZCxZQUFJLFNBQVMsTUFBTSxNQUFNO0FBQ3pCLGlCQUFTO0FBQUEsTUFDYjtBQUNBLFVBQUksT0FBTztBQUFBLElBQ2Y7QUFXQSxhQUFTLFNBQVMsS0FBSyxLQUFLO0FBQ3hCLFdBQUssTUFBTTtBQUNYLFdBQUssT0FBTztBQUNaLFdBQUssTUFBTTtBQUFBLElBQ2Y7QUFFQSxhQUFTLFlBQVksT0FBTyxPQUFPLEdBQUcsU0FBUztBQUMvQyxhQUFTLFVBQVUsS0FBSztBQU94QixJQUFBQSxRQUFPLFVBQVUsU0FBUyxTQUFTLGFBQWEsT0FBTztBQUduRCxXQUFLLFFBQVEsS0FBSyxPQUFPLEtBQUssS0FBSyxPQUFPLElBQUk7QUFBQSxTQUN6QyxRQUFRLFVBQVUsS0FDVCxNQUFZLElBQ3BCLFFBQVEsUUFBWSxJQUNwQixRQUFRLFVBQVksSUFDcEIsUUFBUSxZQUFZLElBQ0E7QUFBQSxRQUMxQjtBQUFBLE1BQUssR0FBRztBQUNSLGFBQU87QUFBQSxJQUNYO0FBUUEsSUFBQUEsUUFBTyxVQUFVLFFBQVEsU0FBUyxZQUFZLE9BQU87QUFDakQsYUFBTyxRQUFRLElBQ1QsS0FBSyxNQUFNLGVBQWUsSUFBSUMsVUFBUyxXQUFXLEtBQUssQ0FBQyxJQUN4RCxLQUFLLE9BQU8sS0FBSztBQUFBLElBQzNCO0FBT0EsSUFBQUQsUUFBTyxVQUFVLFNBQVMsU0FBUyxhQUFhLE9BQU87QUFDbkQsYUFBTyxLQUFLLFFBQVEsU0FBUyxJQUFJLFNBQVMsUUFBUSxDQUFDO0FBQUEsSUFDdkQ7QUFFQSxhQUFTLGNBQWMsS0FBSyxLQUFLLEtBQUs7QUFDbEMsYUFBTyxJQUFJLElBQUk7QUFDWCxZQUFJLFNBQVMsSUFBSSxLQUFLLE1BQU07QUFDNUIsWUFBSSxNQUFNLElBQUksT0FBTyxJQUFJLElBQUksTUFBTSxRQUFRO0FBQzNDLFlBQUksUUFBUTtBQUFBLE1BQ2hCO0FBQ0EsYUFBTyxJQUFJLEtBQUssS0FBSztBQUNqQixZQUFJLFNBQVMsSUFBSSxLQUFLLE1BQU07QUFDNUIsWUFBSSxLQUFLLElBQUksT0FBTztBQUFBLE1BQ3hCO0FBQ0EsVUFBSSxTQUFTLElBQUk7QUFBQSxJQUNyQjtBQVFBLElBQUFBLFFBQU8sVUFBVSxTQUFTLFNBQVMsYUFBYSxPQUFPO0FBQ25ELFVBQUksT0FBT0MsVUFBUyxLQUFLLEtBQUs7QUFDOUIsYUFBTyxLQUFLLE1BQU0sZUFBZSxLQUFLLE9BQU8sR0FBRyxJQUFJO0FBQUEsSUFDeEQ7QUFTQSxJQUFBRCxRQUFPLFVBQVUsUUFBUUEsUUFBTyxVQUFVO0FBUTFDLElBQUFBLFFBQU8sVUFBVSxTQUFTLFNBQVMsYUFBYSxPQUFPO0FBQ25ELFVBQUksT0FBT0MsVUFBUyxLQUFLLEtBQUssRUFBRSxTQUFTO0FBQ3pDLGFBQU8sS0FBSyxNQUFNLGVBQWUsS0FBSyxPQUFPLEdBQUcsSUFBSTtBQUFBLElBQ3hEO0FBT0EsSUFBQUQsUUFBTyxVQUFVLE9BQU8sU0FBUyxXQUFXLE9BQU87QUFDL0MsYUFBTyxLQUFLLE1BQU0sV0FBVyxHQUFHLFFBQVEsSUFBSSxDQUFDO0FBQUEsSUFDakQ7QUFFQSxhQUFTLGFBQWEsS0FBSyxLQUFLLEtBQUs7QUFDakMsVUFBSSxPQUFZLE1BQWM7QUFDOUIsVUFBSSxNQUFNLEtBQU0sUUFBUSxJQUFNO0FBQzlCLFVBQUksTUFBTSxLQUFNLFFBQVEsS0FBTTtBQUM5QixVQUFJLE1BQU0sS0FBTSxRQUFRO0FBQUEsSUFDNUI7QUFPQSxJQUFBQSxRQUFPLFVBQVUsVUFBVSxTQUFTLGNBQWMsT0FBTztBQUNyRCxhQUFPLEtBQUssTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDO0FBQUEsSUFDbEQ7QUFRQSxJQUFBQSxRQUFPLFVBQVUsV0FBV0EsUUFBTyxVQUFVO0FBUTdDLElBQUFBLFFBQU8sVUFBVSxVQUFVLFNBQVMsY0FBYyxPQUFPO0FBQ3JELFVBQUksT0FBT0MsVUFBUyxLQUFLLEtBQUs7QUFDOUIsYUFBTyxLQUFLLE1BQU0sY0FBYyxHQUFHLEtBQUssRUFBRSxFQUFFLE1BQU0sY0FBYyxHQUFHLEtBQUssRUFBRTtBQUFBLElBQzlFO0FBU0EsSUFBQUQsUUFBTyxVQUFVLFdBQVdBLFFBQU8sVUFBVTtBQVE3QyxJQUFBQSxRQUFPLFVBQVUsUUFBUSxTQUFTLFlBQVksT0FBTztBQUNqRCxhQUFPLEtBQUssTUFBTSxLQUFLLE1BQU0sY0FBYyxHQUFHLEtBQUs7QUFBQSxJQUN2RDtBQVFBLElBQUFBLFFBQU8sVUFBVSxTQUFTLFNBQVMsYUFBYSxPQUFPO0FBQ25ELGFBQU8sS0FBSyxNQUFNLEtBQUssTUFBTSxlQUFlLEdBQUcsS0FBSztBQUFBLElBQ3hEO0FBRUEsUUFBSSxhQUFhLEtBQUssTUFBTSxVQUFVLE1BQ2hDLFNBQVMsZUFBZSxLQUFLLEtBQUssS0FBSztBQUNyQyxVQUFJLElBQUksS0FBSyxHQUFHO0FBQUEsSUFDcEIsSUFFRSxTQUFTLGVBQWUsS0FBSyxLQUFLLEtBQUs7QUFDckMsZUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsRUFBRTtBQUM5QixZQUFJLE1BQU0sS0FBSyxJQUFJO0FBQUEsSUFDM0I7QUFPSixJQUFBQSxRQUFPLFVBQVUsUUFBUSxTQUFTLFlBQVksT0FBTztBQUNqRCxVQUFJLE1BQU0sTUFBTSxXQUFXO0FBQzNCLFVBQUksQ0FBQztBQUNELGVBQU8sS0FBSyxNQUFNLFdBQVcsR0FBRyxDQUFDO0FBQ3JDLFVBQUksS0FBSyxTQUFTLEtBQUssR0FBRztBQUN0QixZQUFJLE1BQU1BLFFBQU8sTUFBTSxNQUFNRSxRQUFPLE9BQU8sS0FBSyxDQUFDO0FBQ2pELFFBQUFBLFFBQU8sT0FBTyxPQUFPLEtBQUssQ0FBQztBQUMzQixnQkFBUTtBQUFBLE1BQ1o7QUFDQSxhQUFPLEtBQUssT0FBTyxHQUFHLEVBQUUsTUFBTSxZQUFZLEtBQUssS0FBSztBQUFBLElBQ3hEO0FBT0EsSUFBQUYsUUFBTyxVQUFVLFNBQVMsU0FBUyxhQUFhLE9BQU87QUFDbkQsVUFBSSxNQUFNLEtBQUssT0FBTyxLQUFLO0FBQzNCLGFBQU8sTUFDRCxLQUFLLE9BQU8sR0FBRyxFQUFFLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxJQUM3QyxLQUFLLE1BQU0sV0FBVyxHQUFHLENBQUM7QUFBQSxJQUNwQztBQU9BLElBQUFBLFFBQU8sVUFBVSxPQUFPLFNBQVMsT0FBTztBQUNwQyxXQUFLLFNBQVMsSUFBSSxNQUFNLElBQUk7QUFDNUIsV0FBSyxPQUFPLEtBQUssT0FBTyxJQUFJLEdBQUdHLE9BQU0sR0FBRyxDQUFDO0FBQ3pDLFdBQUssTUFBTTtBQUNYLGFBQU87QUFBQSxJQUNYO0FBTUEsSUFBQUgsUUFBTyxVQUFVLFFBQVEsU0FBUyxRQUFRO0FBQ3RDLFVBQUksS0FBSyxRQUFRO0FBQ2IsYUFBSyxPQUFTLEtBQUssT0FBTztBQUMxQixhQUFLLE9BQVMsS0FBSyxPQUFPO0FBQzFCLGFBQUssTUFBUyxLQUFLLE9BQU87QUFDMUIsYUFBSyxTQUFTLEtBQUssT0FBTztBQUFBLE1BQzlCLE9BQU87QUFDSCxhQUFLLE9BQU8sS0FBSyxPQUFPLElBQUksR0FBR0csT0FBTSxHQUFHLENBQUM7QUFDekMsYUFBSyxNQUFPO0FBQUEsTUFDaEI7QUFDQSxhQUFPO0FBQUEsSUFDWDtBQU1BLElBQUFILFFBQU8sVUFBVSxTQUFTLFNBQVMsU0FBUztBQUN4QyxVQUFJLE9BQU8sS0FBSyxNQUNaLE9BQU8sS0FBSyxNQUNaLE1BQU8sS0FBSztBQUNoQixXQUFLLE1BQU0sRUFBRSxPQUFPLEdBQUc7QUFDdkIsVUFBSSxLQUFLO0FBQ0wsYUFBSyxLQUFLLE9BQU8sS0FBSztBQUN0QixhQUFLLE9BQU87QUFDWixhQUFLLE9BQU87QUFBQSxNQUNoQjtBQUNBLGFBQU87QUFBQSxJQUNYO0FBTUEsSUFBQUEsUUFBTyxVQUFVLFNBQVMsU0FBUyxTQUFTO0FBQ3hDLFVBQUksT0FBTyxLQUFLLEtBQUssTUFDakIsTUFBTyxLQUFLLFlBQVksTUFBTSxLQUFLLEdBQUcsR0FDdEMsTUFBTztBQUNYLGFBQU8sTUFBTTtBQUNULGFBQUssR0FBRyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQzFCLGVBQU8sS0FBSztBQUNaLGVBQU8sS0FBSztBQUFBLE1BQ2hCO0FBRUEsYUFBTztBQUFBLElBQ1g7QUFFQSxJQUFBQSxRQUFPLGFBQWEsU0FBUyxlQUFlO0FBQ3hDLHFCQUFlO0FBQ2YsTUFBQUEsUUFBTyxTQUFTSSxRQUFPO0FBQ3ZCLG1CQUFhLFdBQVc7QUFBQSxJQUM1QjtBQUFBO0FBQUE7OztBQ2hkQTtBQUFBLGlEQUFBRSxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFHakIsUUFBSUMsVUFBUztBQUNiLEtBQUMsYUFBYSxZQUFZLE9BQU8sT0FBT0EsUUFBTyxTQUFTLEdBQUcsY0FBYztBQUV6RSxRQUFJLE9BQU87QUFRWCxhQUFTLGVBQWU7QUFDcEIsTUFBQUEsUUFBTyxLQUFLLElBQUk7QUFBQSxJQUNwQjtBQUVBLGlCQUFhLGFBQWEsV0FBWTtBQU9sQyxtQkFBYSxRQUFRLEtBQUs7QUFFMUIsbUJBQWEsbUJBQW1CLEtBQUssVUFBVSxLQUFLLE9BQU8scUJBQXFCLGNBQWMsS0FBSyxPQUFPLFVBQVUsSUFBSSxTQUFTLFFBQzNILFNBQVMscUJBQXFCLEtBQUssS0FBSyxLQUFLO0FBQzdDLFlBQUksSUFBSSxLQUFLLEdBQUc7QUFBQSxNQUVsQixJQUVFLFNBQVMsc0JBQXNCLEtBQUssS0FBSyxLQUFLO0FBQzlDLFlBQUksSUFBSTtBQUNOLGNBQUksS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFJLE1BQU07QUFBQTtBQUM3QixtQkFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJO0FBQzNCLGdCQUFJLFNBQVMsSUFBSTtBQUFBLE1BQ3JCO0FBQUEsSUFDUjtBQU1BLGlCQUFhLFVBQVUsUUFBUSxTQUFTLG1CQUFtQixPQUFPO0FBQzlELFVBQUksS0FBSyxTQUFTLEtBQUs7QUFDbkIsZ0JBQVEsS0FBSyxhQUFhLE9BQU8sUUFBUTtBQUM3QyxVQUFJLE1BQU0sTUFBTSxXQUFXO0FBQzNCLFdBQUssT0FBTyxHQUFHO0FBQ2YsVUFBSTtBQUNBLGFBQUssTUFBTSxhQUFhLGtCQUFrQixLQUFLLEtBQUs7QUFDeEQsYUFBTztBQUFBLElBQ1g7QUFFQSxhQUFTLGtCQUFrQixLQUFLLEtBQUssS0FBSztBQUN0QyxVQUFJLElBQUksU0FBUztBQUNiLGFBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxHQUFHO0FBQUEsZUFDeEIsSUFBSTtBQUNULFlBQUksVUFBVSxLQUFLLEdBQUc7QUFBQTtBQUV0QixZQUFJLE1BQU0sS0FBSyxHQUFHO0FBQUEsSUFDMUI7QUFLQSxpQkFBYSxVQUFVLFNBQVMsU0FBUyxvQkFBb0IsT0FBTztBQUNoRSxVQUFJLE1BQU0sS0FBSyxPQUFPLFdBQVcsS0FBSztBQUN0QyxXQUFLLE9BQU8sR0FBRztBQUNmLFVBQUk7QUFDQSxhQUFLLE1BQU0sbUJBQW1CLEtBQUssS0FBSztBQUM1QyxhQUFPO0FBQUEsSUFDWDtBQVVBLGlCQUFhLFdBQVc7QUFBQTtBQUFBOzs7QUNwRnhCO0FBQUEsMENBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVUM7QUFFakIsUUFBSSxPQUFZO0FBRWhCLFFBQUk7QUFFSixRQUFJQyxZQUFZLEtBQUs7QUFBckIsUUFDSSxPQUFZLEtBQUs7QUFHckIsYUFBUyxnQkFBZ0JDLFNBQVEsYUFBYTtBQUMxQyxhQUFPLFdBQVcseUJBQXlCQSxRQUFPLE1BQU0sU0FBUyxlQUFlLEtBQUssUUFBUUEsUUFBTyxHQUFHO0FBQUEsSUFDM0c7QUFRQSxhQUFTRixRQUFPLFFBQVE7QUFNcEIsV0FBSyxNQUFNO0FBTVgsV0FBSyxNQUFNO0FBTVgsV0FBSyxNQUFNLE9BQU87QUFBQSxJQUN0QjtBQUVBLFFBQUksZUFBZSxPQUFPLGVBQWUsY0FDbkMsU0FBUyxtQkFBbUIsUUFBUTtBQUNsQyxVQUFJLGtCQUFrQixjQUFjLE1BQU0sUUFBUSxNQUFNO0FBQ3BELGVBQU8sSUFBSUEsUUFBTyxNQUFNO0FBQzVCLFlBQU0sTUFBTSxnQkFBZ0I7QUFBQSxJQUNoQyxJQUVFLFNBQVNHLGNBQWEsUUFBUTtBQUM1QixVQUFJLE1BQU0sUUFBUSxNQUFNO0FBQ3BCLGVBQU8sSUFBSUgsUUFBTyxNQUFNO0FBQzVCLFlBQU0sTUFBTSxnQkFBZ0I7QUFBQSxJQUNoQztBQUVKLFFBQUlJLFVBQVMsU0FBU0EsVUFBUztBQUMzQixhQUFPLEtBQUssU0FDTixTQUFTLG9CQUFvQixRQUFRO0FBQ25DLGdCQUFRSixRQUFPLFNBQVMsU0FBUyxjQUFjSyxTQUFRO0FBQ25ELGlCQUFPLEtBQUssT0FBTyxTQUFTQSxPQUFNLElBQzVCLElBQUksYUFBYUEsT0FBTSxJQUV2QixhQUFhQSxPQUFNO0FBQUEsUUFDN0IsR0FBRyxNQUFNO0FBQUEsTUFDYixJQUVFO0FBQUEsSUFDVjtBQVNBLElBQUFMLFFBQU8sU0FBU0ksUUFBTztBQUV2QixJQUFBSixRQUFPLFVBQVUsU0FBUyxLQUFLLE1BQU0sVUFBVSxZQUF1QyxLQUFLLE1BQU0sVUFBVTtBQU8zRyxJQUFBQSxRQUFPLFVBQVUsU0FBVSxTQUFTLG9CQUFvQjtBQUNwRCxVQUFJLFFBQVE7QUFDWixhQUFPLFNBQVMsY0FBYztBQUMxQixpQkFBa0IsS0FBSyxJQUFJLEtBQUssT0FBTyxTQUFnQjtBQUFHLFlBQUksS0FBSyxJQUFJLEtBQUssU0FBUztBQUFLLGlCQUFPO0FBQ2pHLGlCQUFTLFNBQVMsS0FBSyxJQUFJLEtBQUssT0FBTyxRQUFTLE9BQU87QUFBRyxZQUFJLEtBQUssSUFBSSxLQUFLLFNBQVM7QUFBSyxpQkFBTztBQUNqRyxpQkFBUyxTQUFTLEtBQUssSUFBSSxLQUFLLE9BQU8sUUFBUSxRQUFRO0FBQUcsWUFBSSxLQUFLLElBQUksS0FBSyxTQUFTO0FBQUssaUJBQU87QUFDakcsaUJBQVMsU0FBUyxLQUFLLElBQUksS0FBSyxPQUFPLFFBQVEsUUFBUTtBQUFHLFlBQUksS0FBSyxJQUFJLEtBQUssU0FBUztBQUFLLGlCQUFPO0FBQ2pHLGlCQUFTLFNBQVMsS0FBSyxJQUFJLEtBQUssT0FBUSxPQUFPLFFBQVE7QUFBRyxZQUFJLEtBQUssSUFBSSxLQUFLLFNBQVM7QUFBSyxpQkFBTztBQUdqRyxhQUFLLEtBQUssT0FBTyxLQUFLLEtBQUssS0FBSztBQUM1QixlQUFLLE1BQU0sS0FBSztBQUNoQixnQkFBTSxnQkFBZ0IsTUFBTSxFQUFFO0FBQUEsUUFDbEM7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0osRUFBRztBQU1ILElBQUFBLFFBQU8sVUFBVSxRQUFRLFNBQVMsYUFBYTtBQUMzQyxhQUFPLEtBQUssT0FBTyxJQUFJO0FBQUEsSUFDM0I7QUFNQSxJQUFBQSxRQUFPLFVBQVUsU0FBUyxTQUFTLGNBQWM7QUFDN0MsVUFBSSxRQUFRLEtBQUssT0FBTztBQUN4QixhQUFPLFVBQVUsSUFBSSxFQUFFLFFBQVEsS0FBSztBQUFBLElBQ3hDO0FBSUEsYUFBUyxpQkFBaUI7QUFFdEIsVUFBSSxPQUFPLElBQUlDLFVBQVMsR0FBRyxDQUFDO0FBQzVCLFVBQUksSUFBSTtBQUNSLFVBQUksS0FBSyxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQ3pCLGVBQU8sSUFBSSxHQUFHLEVBQUUsR0FBRztBQUVmLGVBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssT0FBTyxRQUFRLElBQUksT0FBTztBQUM5RCxjQUFJLEtBQUssSUFBSSxLQUFLLFNBQVM7QUFDdkIsbUJBQU87QUFBQSxRQUNmO0FBRUEsYUFBSyxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxPQUFPLFFBQVEsUUFBUTtBQUMzRCxhQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLE9BQU8sUUFBUyxPQUFPO0FBQzNELFlBQUksS0FBSyxJQUFJLEtBQUssU0FBUztBQUN2QixpQkFBTztBQUNYLFlBQUk7QUFBQSxNQUNSLE9BQU87QUFDSCxlQUFPLElBQUksR0FBRyxFQUFFLEdBQUc7QUFFZixjQUFJLEtBQUssT0FBTyxLQUFLO0FBQ2pCLGtCQUFNLGdCQUFnQixJQUFJO0FBRTlCLGVBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssT0FBTyxRQUFRLElBQUksT0FBTztBQUM5RCxjQUFJLEtBQUssSUFBSSxLQUFLLFNBQVM7QUFDdkIsbUJBQU87QUFBQSxRQUNmO0FBRUEsYUFBSyxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxTQUFTLFFBQVEsSUFBSSxPQUFPO0FBQ2hFLGVBQU87QUFBQSxNQUNYO0FBQ0EsVUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDekIsZUFBTyxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBRWYsZUFBSyxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxJQUFJLE9BQU87QUFDbEUsY0FBSSxLQUFLLElBQUksS0FBSyxTQUFTO0FBQ3ZCLG1CQUFPO0FBQUEsUUFDZjtBQUFBLE1BQ0osT0FBTztBQUNILGVBQU8sSUFBSSxHQUFHLEVBQUUsR0FBRztBQUVmLGNBQUksS0FBSyxPQUFPLEtBQUs7QUFDakIsa0JBQU0sZ0JBQWdCLElBQUk7QUFFOUIsZUFBSyxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxJQUFJLE9BQU87QUFDbEUsY0FBSSxLQUFLLElBQUksS0FBSyxTQUFTO0FBQ3ZCLG1CQUFPO0FBQUEsUUFDZjtBQUFBLE1BQ0o7QUFFQSxZQUFNLE1BQU0seUJBQXlCO0FBQUEsSUFDekM7QUE2QkEsSUFBQUQsUUFBTyxVQUFVLE9BQU8sU0FBUyxZQUFZO0FBQ3pDLGFBQU8sS0FBSyxPQUFPLE1BQU07QUFBQSxJQUM3QjtBQUVBLGFBQVMsZ0JBQWdCLEtBQUssS0FBSztBQUMvQixjQUFRLElBQUksTUFBTSxLQUNWLElBQUksTUFBTSxNQUFNLElBQ2hCLElBQUksTUFBTSxNQUFNLEtBQ2hCLElBQUksTUFBTSxNQUFNLFFBQVE7QUFBQSxJQUNwQztBQU1BLElBQUFBLFFBQU8sVUFBVSxVQUFVLFNBQVMsZUFBZTtBQUcvQyxVQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFDcEIsY0FBTSxnQkFBZ0IsTUFBTSxDQUFDO0FBRWpDLGFBQU8sZ0JBQWdCLEtBQUssS0FBSyxLQUFLLE9BQU8sQ0FBQztBQUFBLElBQ2xEO0FBTUEsSUFBQUEsUUFBTyxVQUFVLFdBQVcsU0FBUyxnQkFBZ0I7QUFHakQsVUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQ3BCLGNBQU0sZ0JBQWdCLE1BQU0sQ0FBQztBQUVqQyxhQUFPLGdCQUFnQixLQUFLLEtBQUssS0FBSyxPQUFPLENBQUMsSUFBSTtBQUFBLElBQ3REO0FBSUEsYUFBUyxjQUFnQztBQUdyQyxVQUFJLEtBQUssTUFBTSxJQUFJLEtBQUs7QUFDcEIsY0FBTSxnQkFBZ0IsTUFBTSxDQUFDO0FBRWpDLGFBQU8sSUFBSUMsVUFBUyxnQkFBZ0IsS0FBSyxLQUFLLEtBQUssT0FBTyxDQUFDLEdBQUcsZ0JBQWdCLEtBQUssS0FBSyxLQUFLLE9BQU8sQ0FBQyxDQUFDO0FBQUEsSUFDMUc7QUF1QkEsSUFBQUQsUUFBTyxVQUFVLFFBQVEsU0FBUyxhQUFhO0FBRzNDLFVBQUksS0FBSyxNQUFNLElBQUksS0FBSztBQUNwQixjQUFNLGdCQUFnQixNQUFNLENBQUM7QUFFakMsVUFBSSxRQUFRLEtBQUssTUFBTSxZQUFZLEtBQUssS0FBSyxLQUFLLEdBQUc7QUFDckQsV0FBSyxPQUFPO0FBQ1osYUFBTztBQUFBLElBQ1g7QUFPQSxJQUFBQSxRQUFPLFVBQVUsU0FBUyxTQUFTLGNBQWM7QUFHN0MsVUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQ3BCLGNBQU0sZ0JBQWdCLE1BQU0sQ0FBQztBQUVqQyxVQUFJLFFBQVEsS0FBSyxNQUFNLGFBQWEsS0FBSyxLQUFLLEtBQUssR0FBRztBQUN0RCxXQUFLLE9BQU87QUFDWixhQUFPO0FBQUEsSUFDWDtBQU1BLElBQUFBLFFBQU8sVUFBVSxRQUFRLFNBQVMsYUFBYTtBQUMzQyxVQUFJTSxVQUFTLEtBQUssT0FBTyxHQUNyQixRQUFTLEtBQUssS0FDZCxNQUFTLEtBQUssTUFBTUE7QUFHeEIsVUFBSSxNQUFNLEtBQUs7QUFDWCxjQUFNLGdCQUFnQixNQUFNQSxPQUFNO0FBRXRDLFdBQUssT0FBT0E7QUFDWixVQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDdEIsZUFBTyxLQUFLLElBQUksTUFBTSxPQUFPLEdBQUc7QUFDcEMsYUFBTyxVQUFVLE1BQ1gsSUFBSSxLQUFLLElBQUksWUFBWSxDQUFDLElBQzFCLEtBQUssT0FBTyxLQUFLLEtBQUssS0FBSyxPQUFPLEdBQUc7QUFBQSxJQUMvQztBQU1BLElBQUFOLFFBQU8sVUFBVSxTQUFTLFNBQVMsY0FBYztBQUM3QyxVQUFJLFFBQVEsS0FBSyxNQUFNO0FBQ3ZCLGFBQU8sS0FBSyxLQUFLLE9BQU8sR0FBRyxNQUFNLE1BQU07QUFBQSxJQUMzQztBQU9BLElBQUFBLFFBQU8sVUFBVSxPQUFPLFNBQVMsS0FBS00sU0FBUTtBQUMxQyxVQUFJLE9BQU9BLFlBQVcsVUFBVTtBQUU1QixZQUFJLEtBQUssTUFBTUEsVUFBUyxLQUFLO0FBQ3pCLGdCQUFNLGdCQUFnQixNQUFNQSxPQUFNO0FBQ3RDLGFBQUssT0FBT0E7QUFBQSxNQUNoQixPQUFPO0FBQ0gsV0FBRztBQUVDLGNBQUksS0FBSyxPQUFPLEtBQUs7QUFDakIsa0JBQU0sZ0JBQWdCLElBQUk7QUFBQSxRQUNsQyxTQUFTLEtBQUssSUFBSSxLQUFLLFNBQVM7QUFBQSxNQUNwQztBQUNBLGFBQU87QUFBQSxJQUNYO0FBT0EsSUFBQU4sUUFBTyxVQUFVLFdBQVcsU0FBUyxVQUFVO0FBQzNDLGNBQVE7QUFBQSxhQUNDO0FBQ0QsZUFBSyxLQUFLO0FBQ1Y7QUFBQSxhQUNDO0FBQ0QsZUFBSyxLQUFLLENBQUM7QUFDWDtBQUFBLGFBQ0M7QUFDRCxlQUFLLEtBQUssS0FBSyxPQUFPLENBQUM7QUFDdkI7QUFBQSxhQUNDO0FBQ0Qsa0JBQVEsV0FBVyxLQUFLLE9BQU8sSUFBSSxPQUFPLEdBQUc7QUFDekMsaUJBQUssU0FBUyxRQUFRO0FBQUEsVUFDMUI7QUFDQTtBQUFBLGFBQ0M7QUFDRCxlQUFLLEtBQUssQ0FBQztBQUNYO0FBQUE7QUFJQSxnQkFBTSxNQUFNLHVCQUF1QixXQUFXLGdCQUFnQixLQUFLLEdBQUc7QUFBQTtBQUU5RSxhQUFPO0FBQUEsSUFDWDtBQUVBLElBQUFBLFFBQU8sYUFBYSxTQUFTLGVBQWU7QUFDeEMscUJBQWU7QUFDZixNQUFBQSxRQUFPLFNBQVNJLFFBQU87QUFDdkIsbUJBQWEsV0FBVztBQUV4QixVQUFJLEtBQUssS0FBSyxPQUFPLFdBQXNDO0FBQzNELFdBQUssTUFBTUosUUFBTyxXQUFXO0FBQUEsUUFFekIsT0FBTyxTQUFTLGFBQWE7QUFDekIsaUJBQU8sZUFBZSxLQUFLLElBQUksRUFBRSxJQUFJLEtBQUs7QUFBQSxRQUM5QztBQUFBLFFBRUEsUUFBUSxTQUFTLGNBQWM7QUFDM0IsaUJBQU8sZUFBZSxLQUFLLElBQUksRUFBRSxJQUFJLElBQUk7QUFBQSxRQUM3QztBQUFBLFFBRUEsUUFBUSxTQUFTLGNBQWM7QUFDM0IsaUJBQU8sZUFBZSxLQUFLLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxLQUFLO0FBQUEsUUFDekQ7QUFBQSxRQUVBLFNBQVMsU0FBUyxlQUFlO0FBQzdCLGlCQUFPLFlBQVksS0FBSyxJQUFJLEVBQUUsSUFBSSxJQUFJO0FBQUEsUUFDMUM7QUFBQSxRQUVBLFVBQVUsU0FBUyxnQkFBZ0I7QUFDL0IsaUJBQU8sWUFBWSxLQUFLLElBQUksRUFBRSxJQUFJLEtBQUs7QUFBQSxRQUMzQztBQUFBLE1BRUosQ0FBQztBQUFBLElBQ0w7QUFBQTtBQUFBOzs7QUMxWkE7QUFBQSxpREFBQU8sVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVO0FBR2pCLFFBQUlDLFVBQVM7QUFDYixLQUFDLGFBQWEsWUFBWSxPQUFPLE9BQU9BLFFBQU8sU0FBUyxHQUFHLGNBQWM7QUFFekUsUUFBSSxPQUFPO0FBU1gsYUFBUyxhQUFhLFFBQVE7QUFDMUIsTUFBQUEsUUFBTyxLQUFLLE1BQU0sTUFBTTtBQUFBLElBTzVCO0FBRUEsaUJBQWEsYUFBYSxXQUFZO0FBRWxDLFVBQUksS0FBSztBQUNMLHFCQUFhLFVBQVUsU0FBUyxLQUFLLE9BQU8sVUFBVTtBQUFBLElBQzlEO0FBTUEsaUJBQWEsVUFBVSxTQUFTLFNBQVMscUJBQXFCO0FBQzFELFVBQUksTUFBTSxLQUFLLE9BQU87QUFDdEIsYUFBTyxLQUFLLElBQUksWUFDVixLQUFLLElBQUksVUFBVSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLE1BQU0sS0FBSyxLQUFLLEdBQUcsQ0FBQyxJQUMxRSxLQUFLLElBQUksU0FBUyxTQUFTLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssTUFBTSxLQUFLLEtBQUssR0FBRyxDQUFDO0FBQUEsSUFDNUY7QUFTQSxpQkFBYSxXQUFXO0FBQUE7QUFBQTs7O0FDbER4QjtBQUFBLCtDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFFakIsUUFBSSxPQUFPO0FBR1gsS0FBQyxRQUFRLFlBQVksT0FBTyxPQUFPLEtBQUssYUFBYSxTQUFTLEdBQUcsY0FBYztBQW1DL0UsYUFBUyxRQUFRLFNBQVMsa0JBQWtCLG1CQUFtQjtBQUUzRCxVQUFJLE9BQU8sWUFBWTtBQUNuQixjQUFNLFVBQVUsNEJBQTRCO0FBRWhELFdBQUssYUFBYSxLQUFLLElBQUk7QUFNM0IsV0FBSyxVQUFVO0FBTWYsV0FBSyxtQkFBbUIsUUFBUSxnQkFBZ0I7QUFNaEQsV0FBSyxvQkFBb0IsUUFBUSxpQkFBaUI7QUFBQSxJQUN0RDtBQWFBLFlBQVEsVUFBVSxVQUFVLFNBQVMsUUFBUSxRQUFRLGFBQWEsY0FBYyxTQUFTLFVBQVU7QUFFL0YsVUFBSSxDQUFDO0FBQ0QsY0FBTSxVQUFVLDJCQUEyQjtBQUUvQyxVQUFJQyxRQUFPO0FBQ1gsVUFBSSxDQUFDO0FBQ0QsZUFBTyxLQUFLLFVBQVUsU0FBU0EsT0FBTSxRQUFRLGFBQWEsY0FBYyxPQUFPO0FBRW5GLFVBQUksQ0FBQ0EsTUFBSyxTQUFTO0FBQ2YsbUJBQVcsV0FBVztBQUFFLG1CQUFTLE1BQU0sZUFBZSxDQUFDO0FBQUEsUUFBRyxHQUFHLENBQUM7QUFDOUQsZUFBTztBQUFBLE1BQ1g7QUFFQSxVQUFJO0FBQ0EsZUFBT0EsTUFBSztBQUFBLFVBQ1I7QUFBQSxVQUNBLFlBQVlBLE1BQUssbUJBQW1CLG9CQUFvQixVQUFVLE9BQU8sRUFBRSxPQUFPO0FBQUEsVUFDbEYsU0FBUyxZQUFZLEtBQUssVUFBVTtBQUVoQyxnQkFBSSxLQUFLO0FBQ0wsY0FBQUEsTUFBSyxLQUFLLFNBQVMsS0FBSyxNQUFNO0FBQzlCLHFCQUFPLFNBQVMsR0FBRztBQUFBLFlBQ3ZCO0FBRUEsZ0JBQUksYUFBYSxNQUFNO0FBQ25CLGNBQUFBLE1BQUssSUFBcUIsSUFBSTtBQUM5QixxQkFBTztBQUFBLFlBQ1g7QUFFQSxnQkFBSSxFQUFFLG9CQUFvQixlQUFlO0FBQ3JDLGtCQUFJO0FBQ0EsMkJBQVcsYUFBYUEsTUFBSyxvQkFBb0Isb0JBQW9CLFVBQVUsUUFBUTtBQUFBLGNBQzNGLFNBQVNDLE1BQVA7QUFDRSxnQkFBQUQsTUFBSyxLQUFLLFNBQVNDLE1BQUssTUFBTTtBQUM5Qix1QkFBTyxTQUFTQSxJQUFHO0FBQUEsY0FDdkI7QUFBQSxZQUNKO0FBRUEsWUFBQUQsTUFBSyxLQUFLLFFBQVEsVUFBVSxNQUFNO0FBQ2xDLG1CQUFPLFNBQVMsTUFBTSxRQUFRO0FBQUEsVUFDbEM7QUFBQSxRQUNKO0FBQUEsTUFDSixTQUFTLEtBQVA7QUFDRSxRQUFBQSxNQUFLLEtBQUssU0FBUyxLQUFLLE1BQU07QUFDOUIsbUJBQVcsV0FBVztBQUFFLG1CQUFTLEdBQUc7QUFBQSxRQUFHLEdBQUcsQ0FBQztBQUMzQyxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFPQSxZQUFRLFVBQVUsTUFBTSxTQUFTLElBQUksWUFBWTtBQUM3QyxVQUFJLEtBQUssU0FBUztBQUNkLFlBQUksQ0FBQztBQUNELGVBQUssUUFBUSxNQUFNLE1BQU0sSUFBSTtBQUNqQyxhQUFLLFVBQVU7QUFDZixhQUFLLEtBQUssS0FBSyxFQUFFLElBQUk7QUFBQSxNQUN6QjtBQUNBLGFBQU87QUFBQSxJQUNYO0FBQUE7QUFBQTs7O0FDN0lBO0FBQUEsdUNBQUFFLFVBQUE7QUFBQTtBQU1BLFFBQUksTUFBTUE7QUE2QlYsUUFBSSxVQUFVO0FBQUE7QUFBQTs7O0FDbkNkO0FBQUEseUNBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVSxDQUFDO0FBQUE7QUFBQTs7O0FDRGxCO0FBQUEsaURBQUFDLFVBQUE7QUFBQTtBQUNBLFFBQUksV0FBV0E7QUFRZixhQUFTLFFBQVE7QUFHakIsYUFBUyxTQUFlO0FBQ3hCLGFBQVMsZUFBZTtBQUN4QixhQUFTLFNBQWU7QUFDeEIsYUFBUyxlQUFlO0FBR3hCLGFBQVMsT0FBZTtBQUN4QixhQUFTLE1BQWU7QUFDeEIsYUFBUyxRQUFlO0FBQ3hCLGFBQVMsWUFBZTtBQU94QixhQUFTLFlBQVk7QUFDakIsZUFBUyxLQUFLLFdBQVc7QUFDekIsZUFBUyxPQUFPLFdBQVcsU0FBUyxZQUFZO0FBQ2hELGVBQVMsT0FBTyxXQUFXLFNBQVMsWUFBWTtBQUFBLElBQ3BEO0FBR0EsY0FBVTtBQUFBO0FBQUE7OztBQ25DVjtBQUFBLDhDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFTakIsYUFBUyxRQUFRLGdCQUFnQixjQUFjO0FBRzNDLFVBQUksT0FBTyxtQkFBbUIsVUFBVTtBQUNwQyx1QkFBZTtBQUNmLHlCQUFpQjtBQUFBLE1BQ3JCO0FBRUEsVUFBSSxPQUFPLENBQUM7QUFZWixlQUFTLFFBQVEscUJBQXFCO0FBSWxDLFlBQUksT0FBTyx3QkFBd0IsVUFBVTtBQUN6QyxjQUFJLFNBQVNDLFVBQVM7QUFDdEIsY0FBSSxRQUFRO0FBQ1Isb0JBQVEsSUFBSSxjQUFjLE1BQU07QUFDcEMsbUJBQVMsWUFBWTtBQUNyQixjQUFJLHFCQUFxQjtBQUNyQixnQkFBSSxZQUFjLE9BQU8sS0FBSyxtQkFBbUIsR0FDN0MsY0FBYyxJQUFJLE1BQU0sVUFBVSxTQUFTLENBQUMsR0FDNUMsY0FBYyxJQUFJLE1BQU0sVUFBVSxNQUFNLEdBQ3hDLGNBQWM7QUFDbEIsbUJBQU8sY0FBYyxVQUFVLFFBQVE7QUFDbkMsMEJBQVksZUFBZSxVQUFVO0FBQ3JDLDBCQUFZLGVBQWUsb0JBQW9CLFVBQVU7QUFBQSxZQUM3RDtBQUNBLHdCQUFZLGVBQWU7QUFDM0IsbUJBQU8sU0FBUyxNQUFNLE1BQU0sV0FBVyxFQUFFLE1BQU0sTUFBTSxXQUFXO0FBQUEsVUFDcEU7QUFDQSxpQkFBTyxTQUFTLE1BQU0sRUFBRTtBQUFBLFFBQzVCO0FBR0EsWUFBSSxlQUFlLElBQUksTUFBTSxVQUFVLFNBQVMsQ0FBQyxHQUM3QyxlQUFlO0FBQ25CLGVBQU8sZUFBZSxhQUFhO0FBQy9CLHVCQUFhLGdCQUFnQixVQUFVLEVBQUU7QUFDN0MsdUJBQWU7QUFDZiw4QkFBc0Isb0JBQW9CLFFBQVEsZ0JBQWdCLFNBQVMsUUFBUSxJQUFJLElBQUk7QUFDdkYsY0FBSSxRQUFRLGFBQWE7QUFDekIsa0JBQVE7QUFBQSxpQkFDQztBQUFBLGlCQUFVO0FBQUsscUJBQU8sT0FBTyxPQUFPLEtBQUssQ0FBQztBQUFBLGlCQUMxQztBQUFLLHFCQUFPLE9BQU8sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUFBLGlCQUNwQztBQUFLLHFCQUFPLEtBQUssVUFBVSxLQUFLO0FBQUEsaUJBQ2hDO0FBQUsscUJBQU8sT0FBTyxLQUFLO0FBQUE7QUFFakMsaUJBQU87QUFBQSxRQUNYLENBQUM7QUFDRCxZQUFJLGlCQUFpQixhQUFhO0FBQzlCLGdCQUFNLE1BQU0sMEJBQTBCO0FBQzFDLGFBQUssS0FBSyxtQkFBbUI7QUFDN0IsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTQSxVQUFTLHNCQUFzQjtBQUNwQyxlQUFPLGVBQWUsd0JBQXdCLGdCQUFnQixNQUFNLE9BQU8sa0JBQWtCLGVBQWUsS0FBSyxHQUFHLEtBQUssTUFBTSxXQUFXLEtBQUssS0FBSyxNQUFNLElBQUk7QUFBQSxNQUNsSztBQUVBLGNBQVEsV0FBV0E7QUFDbkIsYUFBTztBQUFBLElBQ1g7QUFnQkEsWUFBUSxVQUFVO0FBQUE7QUFBQTs7O0FDbEdsQjtBQUFBLDRDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFFakIsUUFBSSxZQUFZO0FBQWhCLFFBQ0lDLFdBQVk7QUFFaEIsUUFBSSxLQUFLQSxTQUFRLElBQUk7QUEyQnJCLGFBQVMsTUFBTSxVQUFVQyxVQUFTLFVBQVU7QUFDeEMsVUFBSSxPQUFPQSxhQUFZLFlBQVk7QUFDL0IsbUJBQVdBO0FBQ1gsUUFBQUEsV0FBVSxDQUFDO0FBQUEsTUFDZixXQUFXLENBQUNBO0FBQ1IsUUFBQUEsV0FBVSxDQUFDO0FBRWYsVUFBSSxDQUFDO0FBQ0QsZUFBTyxVQUFVLE9BQU8sTUFBTSxVQUFVQSxRQUFPO0FBR25ELFVBQUksQ0FBQ0EsU0FBUSxPQUFPLE1BQU0sR0FBRztBQUN6QixlQUFPLEdBQUcsU0FBUyxVQUFVLFNBQVMsc0JBQXNCLEtBQUssVUFBVTtBQUN2RSxpQkFBTyxPQUFPLE9BQU8sbUJBQW1CLGNBQ2xDLE1BQU0sSUFBSSxVQUFVQSxVQUFTLFFBQVEsSUFDckMsTUFDQSxTQUFTLEdBQUcsSUFDWixTQUFTLE1BQU1BLFNBQVEsU0FBUyxXQUFXLFNBQVMsU0FBUyxNQUFNLENBQUM7QUFBQSxRQUM5RSxDQUFDO0FBR0wsYUFBTyxNQUFNLElBQUksVUFBVUEsVUFBUyxRQUFRO0FBQUEsSUFDaEQ7QUF1QkEsVUFBTSxNQUFNLFNBQVMsVUFBVSxVQUFVQSxVQUFTLFVBQVU7QUFDeEQsVUFBSSxNQUFNLElBQUksZUFBZTtBQUM3QixVQUFJLHFCQUE0QyxTQUFTLDBCQUEwQjtBQUUvRSxZQUFJLElBQUksZUFBZTtBQUNuQixpQkFBTztBQUtYLFlBQUksSUFBSSxXQUFXLEtBQUssSUFBSSxXQUFXO0FBQ25DLGlCQUFPLFNBQVMsTUFBTSxZQUFZLElBQUksTUFBTSxDQUFDO0FBSWpELFlBQUlBLFNBQVEsUUFBUTtBQUNoQixjQUFJLFNBQVMsSUFBSTtBQUNqQixjQUFJLENBQUMsUUFBUTtBQUNULHFCQUFTLENBQUM7QUFDVixxQkFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLGFBQWEsUUFBUSxFQUFFO0FBQzNDLHFCQUFPLEtBQUssSUFBSSxhQUFhLFdBQVcsQ0FBQyxJQUFJLEdBQUc7QUFBQSxVQUN4RDtBQUNBLGlCQUFPLFNBQVMsTUFBTSxPQUFPLGVBQWUsY0FBYyxJQUFJLFdBQVcsTUFBTSxJQUFJLE1BQU07QUFBQSxRQUM3RjtBQUNBLGVBQU8sU0FBUyxNQUFNLElBQUksWUFBWTtBQUFBLE1BQzFDO0FBRUEsVUFBSUEsU0FBUSxRQUFRO0FBRWhCLFlBQUksc0JBQXNCO0FBQ3RCLGNBQUksaUJBQWlCLG9DQUFvQztBQUM3RCxZQUFJLGVBQWU7QUFBQSxNQUN2QjtBQUVBLFVBQUksS0FBSyxPQUFPLFFBQVE7QUFDeEIsVUFBSSxLQUFLO0FBQUEsSUFDYjtBQUFBO0FBQUE7OztBQ2xIQTtBQUFBLDJDQUFBQyxVQUFBO0FBQUE7QUFPQSxRQUFJQyxRQUFPRDtBQUVYLFFBQUksYUFNSkMsTUFBSyxhQUFhLFNBQVNDLFlBQVdELE9BQU07QUFDeEMsYUFBTyxlQUFlLEtBQUtBLEtBQUk7QUFBQSxJQUNuQztBQUVBLFFBQUksWUFNSkEsTUFBSyxZQUFZLFNBQVNFLFdBQVVGLE9BQU07QUFDdEMsTUFBQUEsUUFBT0EsTUFBSyxRQUFRLE9BQU8sR0FBRyxFQUNsQixRQUFRLFdBQVcsR0FBRztBQUNsQyxVQUFJLFFBQVdBLE1BQUssTUFBTSxHQUFHLEdBQ3pCLFdBQVcsV0FBV0EsS0FBSSxHQUMxQixTQUFXO0FBQ2YsVUFBSTtBQUNBLGlCQUFTLE1BQU0sTUFBTSxJQUFJO0FBQzdCLGVBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxVQUFTO0FBQy9CLFlBQUksTUFBTSxPQUFPLE1BQU07QUFDbkIsY0FBSSxJQUFJLEtBQUssTUFBTSxJQUFJLE9BQU87QUFDMUIsa0JBQU0sT0FBTyxFQUFFLEdBQUcsQ0FBQztBQUFBLG1CQUNkO0FBQ0wsa0JBQU0sT0FBTyxHQUFHLENBQUM7QUFBQTtBQUVqQixjQUFFO0FBQUEsUUFDVixXQUFXLE1BQU0sT0FBTztBQUNwQixnQkFBTSxPQUFPLEdBQUcsQ0FBQztBQUFBO0FBRWpCLFlBQUU7QUFBQSxNQUNWO0FBQ0EsYUFBTyxTQUFTLE1BQU0sS0FBSyxHQUFHO0FBQUEsSUFDbEM7QUFTQSxJQUFBQSxNQUFLLFVBQVUsU0FBUyxRQUFRLFlBQVksYUFBYSxtQkFBbUI7QUFDeEUsVUFBSSxDQUFDO0FBQ0Qsc0JBQWMsVUFBVSxXQUFXO0FBQ3ZDLFVBQUksV0FBVyxXQUFXO0FBQ3RCLGVBQU87QUFDWCxVQUFJLENBQUM7QUFDRCxxQkFBYSxVQUFVLFVBQVU7QUFDckMsY0FBUSxhQUFhLFdBQVcsUUFBUSxrQkFBa0IsRUFBRSxHQUFHLFNBQVMsVUFBVSxhQUFhLE1BQU0sV0FBVyxJQUFJO0FBQUEsSUFDeEg7QUFBQTtBQUFBOzs7QUNoRUE7QUFBQSx5Q0FBQUcsVUFBQTtBQUFBO0FBTUEsUUFBSSxRQUFRQTtBQUVaLFFBQUksT0FBTztBQUVYLFFBQUksSUFBSTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFFQSxhQUFTLEtBQUssUUFBUSxRQUFRO0FBQzFCLFVBQUksSUFBSSxHQUFHLElBQUksQ0FBQztBQUNoQixnQkFBVTtBQUNWLGFBQU8sSUFBSSxPQUFPO0FBQVEsVUFBRSxFQUFFLElBQUksV0FBVyxPQUFPO0FBQ3BELGFBQU87QUFBQSxJQUNYO0FBc0JBLFVBQU0sUUFBUSxLQUFLO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDbkIsQ0FBQztBQXVCRCxVQUFNLFdBQVcsS0FBSztBQUFBLE1BQ0g7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxLQUFLO0FBQUEsTUFDTDtBQUFBLElBQ25CLENBQUM7QUFZRCxVQUFNLE9BQU8sS0FBSztBQUFBLE1BQ0M7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDbkIsR0FBRyxDQUFDO0FBbUJKLFVBQU0sU0FBUyxLQUFLO0FBQUEsTUFDRDtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDbkIsR0FBRyxDQUFDO0FBb0JKLFVBQU0sU0FBUyxLQUFLO0FBQUEsTUFDRDtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ25CLENBQUM7QUFBQTtBQUFBOzs7QUNuTUQ7QUFBQSx5Q0FBQUMsVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVO0FBR2pCLFFBQUksbUJBQW1CO0FBQ3ZCLE1BQUUsTUFBTSxZQUFZLE9BQU8sT0FBTyxpQkFBaUIsU0FBUyxHQUFHLGNBQWMsT0FBTyxZQUFZO0FBRWhHLFFBQUksT0FBUTtBQUFaLFFBQ0ksUUFBUTtBQURaLFFBRUksT0FBUTtBQUVaLFFBQUk7QUFFSixRQUFJLFNBQVM7QUF1QmIsVUFBTSxXQUFXLFNBQVMsU0FBU0MsT0FBTSxNQUFNO0FBQzNDLGFBQU8sSUFBSSxNQUFNQSxPQUFNLEtBQUssSUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssUUFBUSxLQUFLLFNBQVMsS0FBSyxPQUFPO0FBQUEsSUFDakc7QUFnQkEsYUFBUyxNQUFNQSxPQUFNLElBQUksTUFBTSxNQUFNLFFBQVFDLFVBQVMsU0FBUztBQUUzRCxVQUFJLEtBQUssU0FBUyxJQUFJLEdBQUc7QUFDckIsa0JBQVU7QUFDVixRQUFBQSxXQUFVO0FBQ1YsZUFBTyxTQUFTO0FBQUEsTUFDcEIsV0FBVyxLQUFLLFNBQVMsTUFBTSxHQUFHO0FBQzlCLGtCQUFVQTtBQUNWLFFBQUFBLFdBQVU7QUFDVixpQkFBUztBQUFBLE1BQ2I7QUFFQSx1QkFBaUIsS0FBSyxNQUFNRCxPQUFNQyxRQUFPO0FBRXpDLFVBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRSxLQUFLLEtBQUs7QUFDNUIsY0FBTSxVQUFVLG1DQUFtQztBQUV2RCxVQUFJLENBQUMsS0FBSyxTQUFTLElBQUk7QUFDbkIsY0FBTSxVQUFVLHVCQUF1QjtBQUUzQyxVQUFJLFNBQVMsVUFBYSxDQUFDLE9BQU8sS0FBSyxPQUFPLEtBQUssU0FBUyxFQUFFLFlBQVksQ0FBQztBQUN2RSxjQUFNLFVBQVUsNEJBQTRCO0FBRWhELFVBQUksV0FBVyxVQUFhLENBQUMsS0FBSyxTQUFTLE1BQU07QUFDN0MsY0FBTSxVQUFVLHlCQUF5QjtBQU03QyxVQUFJLFNBQVMsbUJBQW1CO0FBQzVCLGVBQU87QUFBQSxNQUNYO0FBQ0EsV0FBSyxPQUFPLFFBQVEsU0FBUyxhQUFhLE9BQU87QUFNakQsV0FBSyxPQUFPO0FBTVosV0FBSyxLQUFLO0FBTVYsV0FBSyxTQUFTLFVBQVU7QUFNeEIsV0FBSyxXQUFXLFNBQVM7QUFNekIsV0FBSyxXQUFXLENBQUMsS0FBSztBQU10QixXQUFLLFdBQVcsU0FBUztBQU16QixXQUFLLE1BQU07QUFNWCxXQUFLLFVBQVU7QUFNZixXQUFLLFNBQVM7QUFNZCxXQUFLLGNBQWM7QUFNbkIsV0FBSyxlQUFlO0FBTXBCLFdBQUssT0FBTyxLQUFLLE9BQU8sTUFBTSxLQUFLLFVBQVUsU0FBdUM7QUFNcEYsV0FBSyxRQUFRLFNBQVM7QUFNdEIsV0FBSyxlQUFlO0FBTXBCLFdBQUssaUJBQWlCO0FBTXRCLFdBQUssaUJBQWlCO0FBT3RCLFdBQUssVUFBVTtBQU1mLFdBQUssVUFBVTtBQUFBLElBQ25CO0FBUUEsV0FBTyxlQUFlLE1BQU0sV0FBVyxVQUFVO0FBQUEsTUFDN0MsS0FBSyxXQUFXO0FBRVosWUFBSSxLQUFLLFlBQVk7QUFDakIsZUFBSyxVQUFVLEtBQUssVUFBVSxRQUFRLE1BQU07QUFDaEQsZUFBTyxLQUFLO0FBQUEsTUFDaEI7QUFBQSxJQUNKLENBQUM7QUFLRCxVQUFNLFVBQVUsWUFBWSxTQUFTLFVBQVVELE9BQU0sT0FBTyxVQUFVO0FBQ2xFLFVBQUlBLFVBQVM7QUFDVCxhQUFLLFVBQVU7QUFDbkIsYUFBTyxpQkFBaUIsVUFBVSxVQUFVLEtBQUssTUFBTUEsT0FBTSxPQUFPLFFBQVE7QUFBQSxJQUNoRjtBQXVCQSxVQUFNLFVBQVUsU0FBUyxTQUFTLE9BQU8sZUFBZTtBQUNwRCxVQUFJLGVBQWUsZ0JBQWdCLFFBQVEsY0FBYyxZQUFZLElBQUk7QUFDekUsYUFBTyxLQUFLLFNBQVM7QUFBQSxRQUNqQjtBQUFBLFFBQVksS0FBSyxTQUFTLGNBQWMsS0FBSyxRQUFRO0FBQUEsUUFDckQ7QUFBQSxRQUFZLEtBQUs7QUFBQSxRQUNqQjtBQUFBLFFBQVksS0FBSztBQUFBLFFBQ2pCO0FBQUEsUUFBWSxLQUFLO0FBQUEsUUFDakI7QUFBQSxRQUFZLEtBQUs7QUFBQSxRQUNqQjtBQUFBLFFBQVksZUFBZSxLQUFLLFVBQVU7QUFBQSxNQUM5QyxDQUFDO0FBQUEsSUFDTDtBQU9BLFVBQU0sVUFBVSxVQUFVLFNBQVMsVUFBVTtBQUV6QyxVQUFJLEtBQUs7QUFDTCxlQUFPO0FBRVgsV0FBSyxLQUFLLGNBQWMsTUFBTSxTQUFTLEtBQUssV0FBVyxRQUFXO0FBQzlELGFBQUssZ0JBQWdCLEtBQUssaUJBQWlCLEtBQUssZUFBZSxTQUFTLEtBQUssUUFBUSxpQkFBaUIsS0FBSyxJQUFJO0FBQy9HLFlBQUksS0FBSyx3QkFBd0I7QUFDN0IsZUFBSyxjQUFjO0FBQUE7QUFFbkIsZUFBSyxjQUFjLEtBQUssYUFBYSxPQUFPLE9BQU8sS0FBSyxLQUFLLGFBQWEsTUFBTSxFQUFFO0FBQUEsTUFDMUYsV0FBVyxLQUFLLFdBQVcsS0FBSyxRQUFRLGlCQUFpQjtBQUVyRCxhQUFLLGNBQWM7QUFBQSxNQUN2QjtBQUdBLFVBQUksS0FBSyxXQUFXLEtBQUssUUFBUSxjQUFjLE1BQU07QUFDakQsYUFBSyxjQUFjLEtBQUssUUFBUTtBQUNoQyxZQUFJLEtBQUssd0JBQXdCLFFBQVEsT0FBTyxLQUFLLGdCQUFnQjtBQUNqRSxlQUFLLGNBQWMsS0FBSyxhQUFhLE9BQU8sS0FBSztBQUFBLE1BQ3pEO0FBR0EsVUFBSSxLQUFLLFNBQVM7QUFDZCxZQUFJLEtBQUssUUFBUSxXQUFXLFFBQVEsS0FBSyxRQUFRLFdBQVcsVUFBYSxLQUFLLGdCQUFnQixFQUFFLEtBQUssd0JBQXdCO0FBQ3pILGlCQUFPLEtBQUssUUFBUTtBQUN4QixZQUFJLENBQUMsT0FBTyxLQUFLLEtBQUssT0FBTyxFQUFFO0FBQzNCLGVBQUssVUFBVTtBQUFBLE1BQ3ZCO0FBR0EsVUFBSSxLQUFLLE1BQU07QUFDWCxhQUFLLGNBQWMsS0FBSyxLQUFLLFdBQVcsS0FBSyxhQUFhLEtBQUssS0FBSyxPQUFPLENBQUMsTUFBTSxHQUFHO0FBR3JGLFlBQUksT0FBTztBQUNQLGlCQUFPLE9BQU8sS0FBSyxXQUFXO0FBQUEsTUFFdEMsV0FBVyxLQUFLLFNBQVMsT0FBTyxLQUFLLGdCQUFnQixVQUFVO0FBQzNELFlBQUk7QUFDSixZQUFJLEtBQUssT0FBTyxLQUFLLEtBQUssV0FBVztBQUNqQyxlQUFLLE9BQU8sT0FBTyxLQUFLLGFBQWEsTUFBTSxLQUFLLFVBQVUsS0FBSyxPQUFPLE9BQU8sS0FBSyxXQUFXLENBQUMsR0FBRyxDQUFDO0FBQUE7QUFFbEcsZUFBSyxLQUFLLE1BQU0sS0FBSyxhQUFhLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxPQUFPLEtBQUssV0FBVyxDQUFDLEdBQUcsQ0FBQztBQUNqRyxhQUFLLGNBQWM7QUFBQSxNQUN2QjtBQUdBLFVBQUksS0FBSztBQUNMLGFBQUssZUFBZSxLQUFLO0FBQUEsZUFDcEIsS0FBSztBQUNWLGFBQUssZUFBZSxLQUFLO0FBQUE7QUFFekIsYUFBSyxlQUFlLEtBQUs7QUFHN0IsVUFBSSxLQUFLLGtCQUFrQjtBQUN2QixhQUFLLE9BQU8sS0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLO0FBRWpELGFBQU8saUJBQWlCLFVBQVUsUUFBUSxLQUFLLElBQUk7QUFBQSxJQUN2RDtBQXNCQSxVQUFNLElBQUksU0FBUyxjQUFjLFNBQVMsV0FBVyxXQUFXLGNBQWM7QUFHMUUsVUFBSSxPQUFPLGNBQWM7QUFDckIsb0JBQVksS0FBSyxhQUFhLFNBQVMsRUFBRTtBQUFBLGVBR3BDLGFBQWEsT0FBTyxjQUFjO0FBQ3ZDLG9CQUFZLEtBQUssYUFBYSxTQUFTLEVBQUU7QUFFN0MsYUFBTyxTQUFTLGVBQWUsV0FBVyxXQUFXO0FBQ2pELGFBQUssYUFBYSxVQUFVLFdBQVcsRUFDbEMsSUFBSSxJQUFJLE1BQU0sV0FBVyxTQUFTLFdBQVcsV0FBVyxFQUFFLFdBQVcsYUFBYSxDQUFDLENBQUM7QUFBQSxNQUM3RjtBQUFBLElBQ0o7QUFnQkEsVUFBTSxhQUFhLFNBQVMsVUFBVSxPQUFPO0FBQ3pDLGFBQU87QUFBQSxJQUNYO0FBQUE7QUFBQTs7O0FDeFhBO0FBQUEseUNBQUFFLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVTtBQUdqQixRQUFJLG1CQUFtQjtBQUN2QixNQUFFLE1BQU0sWUFBWSxPQUFPLE9BQU8saUJBQWlCLFNBQVMsR0FBRyxjQUFjLE9BQU8sWUFBWTtBQUVoRyxRQUFJLFFBQVE7QUFBWixRQUNJLE9BQVE7QUFZWixhQUFTLE1BQU1DLE9BQU0sWUFBWUMsVUFBUyxTQUFTO0FBQy9DLFVBQUksQ0FBQyxNQUFNLFFBQVEsVUFBVSxHQUFHO0FBQzVCLFFBQUFBLFdBQVU7QUFDVixxQkFBYTtBQUFBLE1BQ2pCO0FBQ0EsdUJBQWlCLEtBQUssTUFBTUQsT0FBTUMsUUFBTztBQUd6QyxVQUFJLEVBQUUsZUFBZSxVQUFhLE1BQU0sUUFBUSxVQUFVO0FBQ3RELGNBQU0sVUFBVSw2QkFBNkI7QUFNakQsV0FBSyxRQUFRLGNBQWMsQ0FBQztBQU81QixXQUFLLGNBQWMsQ0FBQztBQU1wQixXQUFLLFVBQVU7QUFBQSxJQUNuQjtBQWdCQSxVQUFNLFdBQVcsU0FBUyxTQUFTRCxPQUFNLE1BQU07QUFDM0MsYUFBTyxJQUFJLE1BQU1BLE9BQU0sS0FBSyxPQUFPLEtBQUssU0FBUyxLQUFLLE9BQU87QUFBQSxJQUNqRTtBQU9BLFVBQU0sVUFBVSxTQUFTLFNBQVMsT0FBTyxlQUFlO0FBQ3BELFVBQUksZUFBZSxnQkFBZ0IsUUFBUSxjQUFjLFlBQVksSUFBSTtBQUN6RSxhQUFPLEtBQUssU0FBUztBQUFBLFFBQ2pCO0FBQUEsUUFBWSxLQUFLO0FBQUEsUUFDakI7QUFBQSxRQUFZLEtBQUs7QUFBQSxRQUNqQjtBQUFBLFFBQVksZUFBZSxLQUFLLFVBQVU7QUFBQSxNQUM5QyxDQUFDO0FBQUEsSUFDTDtBQVNBLGFBQVMsa0JBQWtCLE9BQU87QUFDOUIsVUFBSSxNQUFNO0FBQ04saUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxZQUFZLFFBQVEsRUFBRTtBQUM1QyxjQUFJLENBQUMsTUFBTSxZQUFZLEdBQUc7QUFDdEIsa0JBQU0sT0FBTyxJQUFJLE1BQU0sWUFBWSxFQUFFO0FBQUE7QUFBQSxJQUNyRDtBQU9BLFVBQU0sVUFBVSxNQUFNLFNBQVMsSUFBSSxPQUFPO0FBR3RDLFVBQUksRUFBRSxpQkFBaUI7QUFDbkIsY0FBTSxVQUFVLHVCQUF1QjtBQUUzQyxVQUFJLE1BQU0sVUFBVSxNQUFNLFdBQVcsS0FBSztBQUN0QyxjQUFNLE9BQU8sT0FBTyxLQUFLO0FBQzdCLFdBQUssTUFBTSxLQUFLLE1BQU0sSUFBSTtBQUMxQixXQUFLLFlBQVksS0FBSyxLQUFLO0FBQzNCLFlBQU0sU0FBUztBQUNmLHdCQUFrQixJQUFJO0FBQ3RCLGFBQU87QUFBQSxJQUNYO0FBT0EsVUFBTSxVQUFVLFNBQVMsU0FBUyxPQUFPLE9BQU87QUFHNUMsVUFBSSxFQUFFLGlCQUFpQjtBQUNuQixjQUFNLFVBQVUsdUJBQXVCO0FBRTNDLFVBQUksUUFBUSxLQUFLLFlBQVksUUFBUSxLQUFLO0FBRzFDLFVBQUksUUFBUTtBQUNSLGNBQU0sTUFBTSxRQUFRLHlCQUF5QixJQUFJO0FBRXJELFdBQUssWUFBWSxPQUFPLE9BQU8sQ0FBQztBQUNoQyxjQUFRLEtBQUssTUFBTSxRQUFRLE1BQU0sSUFBSTtBQUdyQyxVQUFJLFFBQVE7QUFDUixhQUFLLE1BQU0sT0FBTyxPQUFPLENBQUM7QUFFOUIsWUFBTSxTQUFTO0FBQ2YsYUFBTztBQUFBLElBQ1g7QUFLQSxVQUFNLFVBQVUsUUFBUSxTQUFTLE1BQU0sUUFBUTtBQUMzQyx1QkFBaUIsVUFBVSxNQUFNLEtBQUssTUFBTSxNQUFNO0FBQ2xELFVBQUlFLFFBQU87QUFFWCxlQUFTLElBQUksR0FBRyxJQUFJLEtBQUssTUFBTSxRQUFRLEVBQUUsR0FBRztBQUN4QyxZQUFJLFFBQVEsT0FBTyxJQUFJLEtBQUssTUFBTSxFQUFFO0FBQ3BDLFlBQUksU0FBUyxDQUFDLE1BQU0sUUFBUTtBQUN4QixnQkFBTSxTQUFTQTtBQUNmLFVBQUFBLE1BQUssWUFBWSxLQUFLLEtBQUs7QUFBQSxRQUMvQjtBQUFBLE1BQ0o7QUFFQSx3QkFBa0IsSUFBSTtBQUFBLElBQzFCO0FBS0EsVUFBTSxVQUFVLFdBQVcsU0FBUyxTQUFTLFFBQVE7QUFDakQsZUFBUyxJQUFJLEdBQUcsT0FBTyxJQUFJLEtBQUssWUFBWSxRQUFRLEVBQUU7QUFDbEQsYUFBSyxRQUFRLEtBQUssWUFBWSxJQUFJO0FBQzlCLGdCQUFNLE9BQU8sT0FBTyxLQUFLO0FBQ2pDLHVCQUFpQixVQUFVLFNBQVMsS0FBSyxNQUFNLE1BQU07QUFBQSxJQUN6RDtBQWtCQSxVQUFNLElBQUksU0FBUyxnQkFBZ0I7QUFDL0IsVUFBSSxhQUFhLElBQUksTUFBTSxVQUFVLE1BQU0sR0FDdkMsUUFBUTtBQUNaLGFBQU8sUUFBUSxVQUFVO0FBQ3JCLG1CQUFXLFNBQVMsVUFBVTtBQUNsQyxhQUFPLFNBQVMsZUFBZSxXQUFXLFdBQVc7QUFDakQsYUFBSyxhQUFhLFVBQVUsV0FBVyxFQUNsQyxJQUFJLElBQUksTUFBTSxXQUFXLFVBQVUsQ0FBQztBQUN6QyxlQUFPLGVBQWUsV0FBVyxXQUFXO0FBQUEsVUFDeEMsS0FBSyxLQUFLLFlBQVksVUFBVTtBQUFBLFVBQ2hDLEtBQUssS0FBSyxZQUFZLFVBQVU7QUFBQSxRQUNwQyxDQUFDO0FBQUEsTUFDTDtBQUFBLElBQ0o7QUFBQTtBQUFBOzs7QUMxTUE7QUFBQSw2Q0FBQUMsVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVO0FBR2pCLFFBQUksbUJBQW1CO0FBQ3ZCLE1BQUUsVUFBVSxZQUFZLE9BQU8sT0FBTyxpQkFBaUIsU0FBUyxHQUFHLGNBQWMsV0FBVyxZQUFZO0FBRXhHLFFBQUksUUFBVztBQUFmLFFBQ0ksT0FBVztBQURmLFFBRUksUUFBVztBQUVmLFFBQUk7QUFBSixRQUNJO0FBREosUUFFSTtBQXFCSixjQUFVLFdBQVcsU0FBUyxTQUFTQyxPQUFNLE1BQU07QUFDL0MsYUFBTyxJQUFJLFVBQVVBLE9BQU0sS0FBSyxPQUFPLEVBQUUsUUFBUSxLQUFLLE1BQU07QUFBQSxJQUNoRTtBQVNBLGFBQVMsWUFBWSxPQUFPLGVBQWU7QUFDdkMsVUFBSSxFQUFFLFNBQVMsTUFBTTtBQUNqQixlQUFPO0FBQ1gsVUFBSSxNQUFNLENBQUM7QUFDWCxlQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxFQUFFO0FBQ2hDLFlBQUksTUFBTSxHQUFHLFFBQVEsTUFBTSxHQUFHLE9BQU8sYUFBYTtBQUN0RCxhQUFPO0FBQUEsSUFDWDtBQUVBLGNBQVUsY0FBYztBQVF4QixjQUFVLGVBQWUsU0FBUyxhQUFhLFVBQVUsSUFBSTtBQUN6RCxVQUFJO0FBQ0EsaUJBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEVBQUU7QUFDbkMsY0FBSSxPQUFPLFNBQVMsT0FBTyxZQUFZLFNBQVMsR0FBRyxNQUFNLE1BQU0sU0FBUyxHQUFHLEtBQUs7QUFDNUUsbUJBQU87QUFBQTtBQUNuQixhQUFPO0FBQUEsSUFDWDtBQVFBLGNBQVUsaUJBQWlCLFNBQVMsZUFBZSxVQUFVQSxPQUFNO0FBQy9ELFVBQUk7QUFDQSxpQkFBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsRUFBRTtBQUNuQyxjQUFJLFNBQVMsT0FBT0E7QUFDaEIsbUJBQU87QUFBQTtBQUNuQixhQUFPO0FBQUEsSUFDWDtBQWFBLGFBQVMsVUFBVUEsT0FBTUMsVUFBUztBQUM5Qix1QkFBaUIsS0FBSyxNQUFNRCxPQUFNQyxRQUFPO0FBTXpDLFdBQUssU0FBUztBQU9kLFdBQUssZUFBZTtBQUFBLElBQ3hCO0FBRUEsYUFBUyxXQUFXLFdBQVc7QUFDM0IsZ0JBQVUsZUFBZTtBQUN6QixhQUFPO0FBQUEsSUFDWDtBQVFBLFdBQU8sZUFBZSxVQUFVLFdBQVcsZUFBZTtBQUFBLE1BQ3RELEtBQUssV0FBVztBQUNaLGVBQU8sS0FBSyxpQkFBaUIsS0FBSyxlQUFlLEtBQUssUUFBUSxLQUFLLE1BQU07QUFBQSxNQUM3RTtBQUFBLElBQ0osQ0FBQztBQTJCRCxjQUFVLFVBQVUsU0FBUyxTQUFTLE9BQU8sZUFBZTtBQUN4RCxhQUFPLEtBQUssU0FBUztBQUFBLFFBQ2pCO0FBQUEsUUFBWSxLQUFLO0FBQUEsUUFDakI7QUFBQSxRQUFZLFlBQVksS0FBSyxhQUFhLGFBQWE7QUFBQSxNQUMzRCxDQUFDO0FBQUEsSUFDTDtBQU9BLGNBQVUsVUFBVSxVQUFVLFNBQVMsUUFBUSxZQUFZO0FBQ3ZELFVBQUksS0FBSztBQUVULFVBQUksWUFBWTtBQUNaLGlCQUFTQyxTQUFRLE9BQU8sS0FBSyxVQUFVLEdBQUcsSUFBSSxHQUFHLFFBQVEsSUFBSUEsT0FBTSxRQUFRLEVBQUUsR0FBRztBQUM1RSxtQkFBUyxXQUFXQSxPQUFNO0FBQzFCLGFBQUc7QUFBQSxhQUNHLE9BQU8sV0FBVyxTQUNsQixLQUFLLFdBQ0wsT0FBTyxXQUFXLFNBQ2xCLEtBQUssV0FDTCxPQUFPLFlBQVksU0FDbkIsUUFBUSxXQUNSLE9BQU8sT0FBTyxTQUNkLE1BQU0sV0FDTixVQUFVLFVBQVdBLE9BQU0sSUFBSSxNQUFNO0FBQUEsVUFDM0M7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUNBLGFBQU87QUFBQSxJQUNYO0FBT0EsY0FBVSxVQUFVLE1BQU0sU0FBUyxJQUFJRixPQUFNO0FBQ3pDLGFBQU8sS0FBSyxVQUFVLEtBQUssT0FBT0EsVUFDM0I7QUFBQSxJQUNYO0FBU0EsY0FBVSxVQUFVLFVBQVUsU0FBUyxRQUFRQSxPQUFNO0FBQ2pELFVBQUksS0FBSyxVQUFVLEtBQUssT0FBT0Esa0JBQWlCO0FBQzVDLGVBQU8sS0FBSyxPQUFPQSxPQUFNO0FBQzdCLFlBQU0sTUFBTSxtQkFBbUJBLEtBQUk7QUFBQSxJQUN2QztBQVNBLGNBQVUsVUFBVSxNQUFNLFNBQVMsSUFBSSxRQUFRO0FBRTNDLFVBQUksRUFBRSxrQkFBa0IsU0FBUyxPQUFPLFdBQVcsVUFBYSxrQkFBa0IsUUFBUyxrQkFBa0IsU0FBUyxrQkFBa0IsUUFBUSxrQkFBa0IsV0FBVyxrQkFBa0I7QUFDM0wsY0FBTSxVQUFVLHNDQUFzQztBQUUxRCxVQUFJLENBQUMsS0FBSztBQUNOLGFBQUssU0FBUyxDQUFDO0FBQUEsV0FDZDtBQUNELFlBQUksT0FBTyxLQUFLLElBQUksT0FBTyxJQUFJO0FBQy9CLFlBQUksTUFBTTtBQUNOLGNBQUksZ0JBQWdCLGFBQWEsa0JBQWtCLGFBQWEsRUFBRSxnQkFBZ0IsUUFBUSxnQkFBZ0IsVUFBVTtBQUVoSCxnQkFBSSxTQUFTLEtBQUs7QUFDbEIscUJBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEVBQUU7QUFDakMscUJBQU8sSUFBSSxPQUFPLEVBQUU7QUFDeEIsaUJBQUssT0FBTyxJQUFJO0FBQ2hCLGdCQUFJLENBQUMsS0FBSztBQUNOLG1CQUFLLFNBQVMsQ0FBQztBQUNuQixtQkFBTyxXQUFXLEtBQUssU0FBUyxJQUFJO0FBQUEsVUFFeEM7QUFDSSxrQkFBTSxNQUFNLHFCQUFxQixPQUFPLE9BQU8sVUFBVSxJQUFJO0FBQUEsUUFDckU7QUFBQSxNQUNKO0FBQ0EsV0FBSyxPQUFPLE9BQU8sUUFBUTtBQUMzQixhQUFPLE1BQU0sSUFBSTtBQUNqQixhQUFPLFdBQVcsSUFBSTtBQUFBLElBQzFCO0FBU0EsY0FBVSxVQUFVLFNBQVMsU0FBUyxPQUFPLFFBQVE7QUFFakQsVUFBSSxFQUFFLGtCQUFrQjtBQUNwQixjQUFNLFVBQVUsbUNBQW1DO0FBQ3ZELFVBQUksT0FBTyxXQUFXO0FBQ2xCLGNBQU0sTUFBTSxTQUFTLHlCQUF5QixJQUFJO0FBRXRELGFBQU8sS0FBSyxPQUFPLE9BQU87QUFDMUIsVUFBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLE1BQU0sRUFBRTtBQUMxQixhQUFLLFNBQVM7QUFFbEIsYUFBTyxTQUFTLElBQUk7QUFDcEIsYUFBTyxXQUFXLElBQUk7QUFBQSxJQUMxQjtBQVFBLGNBQVUsVUFBVSxTQUFTLFNBQVNHLFFBQU9DLE9BQU0sTUFBTTtBQUVyRCxVQUFJLEtBQUssU0FBU0EsS0FBSTtBQUNsQixRQUFBQSxRQUFPQSxNQUFLLE1BQU0sR0FBRztBQUFBLGVBQ2hCLENBQUMsTUFBTSxRQUFRQSxLQUFJO0FBQ3hCLGNBQU0sVUFBVSxjQUFjO0FBQ2xDLFVBQUlBLFNBQVFBLE1BQUssVUFBVUEsTUFBSyxPQUFPO0FBQ25DLGNBQU0sTUFBTSx1QkFBdUI7QUFFdkMsVUFBSSxNQUFNO0FBQ1YsYUFBT0EsTUFBSyxTQUFTLEdBQUc7QUFDcEIsWUFBSSxPQUFPQSxNQUFLLE1BQU07QUFDdEIsWUFBSSxJQUFJLFVBQVUsSUFBSSxPQUFPLE9BQU87QUFDaEMsZ0JBQU0sSUFBSSxPQUFPO0FBQ2pCLGNBQUksRUFBRSxlQUFlO0FBQ2pCLGtCQUFNLE1BQU0sMkNBQTJDO0FBQUEsUUFDL0Q7QUFDSSxjQUFJLElBQUksTUFBTSxJQUFJLFVBQVUsSUFBSSxDQUFDO0FBQUEsTUFDekM7QUFDQSxVQUFJO0FBQ0EsWUFBSSxRQUFRLElBQUk7QUFDcEIsYUFBTztBQUFBLElBQ1g7QUFNQSxjQUFVLFVBQVUsYUFBYSxTQUFTLGFBQWE7QUFDbkQsVUFBSSxTQUFTLEtBQUssYUFBYSxJQUFJO0FBQ25DLGFBQU8sSUFBSSxPQUFPO0FBQ2QsWUFBSSxPQUFPLGNBQWM7QUFDckIsaUJBQU8sS0FBSyxXQUFXO0FBQUE7QUFFdkIsaUJBQU8sS0FBSyxRQUFRO0FBQzVCLGFBQU8sS0FBSyxRQUFRO0FBQUEsSUFDeEI7QUFTQSxjQUFVLFVBQVUsU0FBUyxTQUFTLE9BQU9BLE9BQU0sYUFBYSxzQkFBc0I7QUFHbEYsVUFBSSxPQUFPLGdCQUFnQixXQUFXO0FBQ2xDLCtCQUF1QjtBQUN2QixzQkFBYztBQUFBLE1BQ2xCLFdBQVcsZUFBZSxDQUFDLE1BQU0sUUFBUSxXQUFXO0FBQ2hELHNCQUFjLENBQUUsV0FBWTtBQUVoQyxVQUFJLEtBQUssU0FBU0EsS0FBSSxLQUFLQSxNQUFLLFFBQVE7QUFDcEMsWUFBSUEsVUFBUztBQUNULGlCQUFPLEtBQUs7QUFDaEIsUUFBQUEsUUFBT0EsTUFBSyxNQUFNLEdBQUc7QUFBQSxNQUN6QixXQUFXLENBQUNBLE1BQUs7QUFDYixlQUFPO0FBR1gsVUFBSUEsTUFBSyxPQUFPO0FBQ1osZUFBTyxLQUFLLEtBQUssT0FBT0EsTUFBSyxNQUFNLENBQUMsR0FBRyxXQUFXO0FBR3RELFVBQUksUUFBUSxLQUFLLElBQUlBLE1BQUssRUFBRTtBQUM1QixVQUFJLE9BQU87QUFDUCxZQUFJQSxNQUFLLFdBQVcsR0FBRztBQUNuQixjQUFJLENBQUMsZUFBZSxZQUFZLFFBQVEsTUFBTSxXQUFXLElBQUk7QUFDekQsbUJBQU87QUFBQSxRQUNmLFdBQVcsaUJBQWlCLGNBQWMsUUFBUSxNQUFNLE9BQU9BLE1BQUssTUFBTSxDQUFDLEdBQUcsYUFBYSxJQUFJO0FBQzNGLGlCQUFPO0FBQUEsTUFHZjtBQUNJLGlCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssWUFBWSxRQUFRLEVBQUU7QUFDM0MsY0FBSSxLQUFLLGFBQWEsY0FBYyxjQUFjLFFBQVEsS0FBSyxhQUFhLEdBQUcsT0FBT0EsT0FBTSxhQUFhLElBQUk7QUFDekcsbUJBQU87QUFHbkIsVUFBSSxLQUFLLFdBQVcsUUFBUTtBQUN4QixlQUFPO0FBQ1gsYUFBTyxLQUFLLE9BQU8sT0FBT0EsT0FBTSxXQUFXO0FBQUEsSUFDL0M7QUFvQkEsY0FBVSxVQUFVLGFBQWEsU0FBUyxXQUFXQSxPQUFNO0FBQ3ZELFVBQUksUUFBUSxLQUFLLE9BQU9BLE9BQU0sQ0FBRSxJQUFLLENBQUM7QUFDdEMsVUFBSSxDQUFDO0FBQ0QsY0FBTSxNQUFNLG1CQUFtQkEsS0FBSTtBQUN2QyxhQUFPO0FBQUEsSUFDWDtBQVNBLGNBQVUsVUFBVSxhQUFhLFNBQVMsV0FBV0EsT0FBTTtBQUN2RCxVQUFJLFFBQVEsS0FBSyxPQUFPQSxPQUFNLENBQUUsSUFBSyxDQUFDO0FBQ3RDLFVBQUksQ0FBQztBQUNELGNBQU0sTUFBTSxtQkFBbUJBLFFBQU8sVUFBVSxJQUFJO0FBQ3hELGFBQU87QUFBQSxJQUNYO0FBU0EsY0FBVSxVQUFVLG1CQUFtQixTQUFTLGlCQUFpQkEsT0FBTTtBQUNuRSxVQUFJLFFBQVEsS0FBSyxPQUFPQSxPQUFNLENBQUUsTUFBTSxJQUFLLENBQUM7QUFDNUMsVUFBSSxDQUFDO0FBQ0QsY0FBTSxNQUFNLDJCQUEyQkEsUUFBTyxVQUFVLElBQUk7QUFDaEUsYUFBTztBQUFBLElBQ1g7QUFTQSxjQUFVLFVBQVUsZ0JBQWdCLFNBQVMsY0FBY0EsT0FBTTtBQUM3RCxVQUFJLFFBQVEsS0FBSyxPQUFPQSxPQUFNLENBQUUsT0FBUSxDQUFDO0FBQ3pDLFVBQUksQ0FBQztBQUNELGNBQU0sTUFBTSxzQkFBc0JBLFFBQU8sVUFBVSxJQUFJO0FBQzNELGFBQU87QUFBQSxJQUNYO0FBR0EsY0FBVSxhQUFhLFNBQVMsT0FBTyxVQUFVLE9BQU87QUFDcEQsYUFBVTtBQUNWLGdCQUFVO0FBQ1YsYUFBVTtBQUFBLElBQ2Q7QUFBQTtBQUFBOzs7QUNqYkE7QUFBQSw0Q0FBQUMsVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVO0FBR2pCLFFBQUksUUFBUTtBQUNaLE1BQUUsU0FBUyxZQUFZLE9BQU8sT0FBTyxNQUFNLFNBQVMsR0FBRyxjQUFjLFVBQVUsWUFBWTtBQUUzRixRQUFJLFFBQVU7QUFBZCxRQUNJLE9BQVU7QUFjZCxhQUFTLFNBQVNDLE9BQU0sSUFBSSxTQUFTLE1BQU1DLFVBQVMsU0FBUztBQUN6RCxZQUFNLEtBQUssTUFBTUQsT0FBTSxJQUFJLE1BQU0sUUFBVyxRQUFXQyxVQUFTLE9BQU87QUFHdkUsVUFBSSxDQUFDLEtBQUssU0FBUyxPQUFPO0FBQ3RCLGNBQU0sVUFBVSwwQkFBMEI7QUFNOUMsV0FBSyxVQUFVO0FBTWYsV0FBSyxrQkFBa0I7QUFHdkIsV0FBSyxNQUFNO0FBQUEsSUFDZjtBQXVCQSxhQUFTLFdBQVcsU0FBUyxTQUFTRCxPQUFNLE1BQU07QUFDOUMsYUFBTyxJQUFJLFNBQVNBLE9BQU0sS0FBSyxJQUFJLEtBQUssU0FBUyxLQUFLLE1BQU0sS0FBSyxTQUFTLEtBQUssT0FBTztBQUFBLElBQzFGO0FBT0EsYUFBUyxVQUFVLFNBQVMsU0FBUyxPQUFPLGVBQWU7QUFDdkQsVUFBSSxlQUFlLGdCQUFnQixRQUFRLGNBQWMsWUFBWSxJQUFJO0FBQ3pFLGFBQU8sS0FBSyxTQUFTO0FBQUEsUUFDakI7QUFBQSxRQUFZLEtBQUs7QUFBQSxRQUNqQjtBQUFBLFFBQVksS0FBSztBQUFBLFFBQ2pCO0FBQUEsUUFBWSxLQUFLO0FBQUEsUUFDakI7QUFBQSxRQUFZLEtBQUs7QUFBQSxRQUNqQjtBQUFBLFFBQVksS0FBSztBQUFBLFFBQ2pCO0FBQUEsUUFBWSxlQUFlLEtBQUssVUFBVTtBQUFBLE1BQzlDLENBQUM7QUFBQSxJQUNMO0FBS0EsYUFBUyxVQUFVLFVBQVUsU0FBUyxVQUFVO0FBQzVDLFVBQUksS0FBSztBQUNMLGVBQU87QUFHWCxVQUFJLE1BQU0sT0FBTyxLQUFLLGFBQWE7QUFDL0IsY0FBTSxNQUFNLHVCQUF1QixLQUFLLE9BQU87QUFFbkQsYUFBTyxNQUFNLFVBQVUsUUFBUSxLQUFLLElBQUk7QUFBQSxJQUM1QztBQVlBLGFBQVMsSUFBSSxTQUFTLGlCQUFpQixTQUFTLGNBQWMsZ0JBQWdCO0FBRzFFLFVBQUksT0FBTyxtQkFBbUI7QUFDMUIseUJBQWlCLEtBQUssYUFBYSxjQUFjLEVBQUU7QUFBQSxlQUc5QyxrQkFBa0IsT0FBTyxtQkFBbUI7QUFDakQseUJBQWlCLEtBQUssYUFBYSxjQUFjLEVBQUU7QUFFdkQsYUFBTyxTQUFTLGtCQUFrQixXQUFXLFdBQVc7QUFDcEQsYUFBSyxhQUFhLFVBQVUsV0FBVyxFQUNsQyxJQUFJLElBQUksU0FBUyxXQUFXLFNBQVMsY0FBYyxjQUFjLENBQUM7QUFBQSxNQUMzRTtBQUFBLElBQ0o7QUFBQTtBQUFBOzs7QUM3SEE7QUFBQSwwQ0FBQUUsVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVO0FBR2pCLFFBQUksbUJBQW1CO0FBQ3ZCLE1BQUUsT0FBTyxZQUFZLE9BQU8sT0FBTyxpQkFBaUIsU0FBUyxHQUFHLGNBQWMsUUFBUSxZQUFZO0FBRWxHLFFBQUksT0FBTztBQWlCWCxhQUFTLE9BQU9DLE9BQU0sTUFBTSxhQUFhLGNBQWMsZUFBZSxnQkFBZ0JDLFVBQVMsU0FBUyxlQUFlO0FBR25ILFVBQUksS0FBSyxTQUFTLGFBQWEsR0FBRztBQUM5QixRQUFBQSxXQUFVO0FBQ1Ysd0JBQWdCLGlCQUFpQjtBQUFBLE1BQ3JDLFdBQVcsS0FBSyxTQUFTLGNBQWMsR0FBRztBQUN0QyxRQUFBQSxXQUFVO0FBQ1YseUJBQWlCO0FBQUEsTUFDckI7QUFHQSxVQUFJLEVBQUUsU0FBUyxVQUFhLEtBQUssU0FBUyxJQUFJO0FBQzFDLGNBQU0sVUFBVSx1QkFBdUI7QUFHM0MsVUFBSSxDQUFDLEtBQUssU0FBUyxXQUFXO0FBQzFCLGNBQU0sVUFBVSw4QkFBOEI7QUFHbEQsVUFBSSxDQUFDLEtBQUssU0FBUyxZQUFZO0FBQzNCLGNBQU0sVUFBVSwrQkFBK0I7QUFFbkQsdUJBQWlCLEtBQUssTUFBTUQsT0FBTUMsUUFBTztBQU16QyxXQUFLLE9BQU8sUUFBUTtBQU1wQixXQUFLLGNBQWM7QUFNbkIsV0FBSyxnQkFBZ0IsZ0JBQWdCLE9BQU87QUFNNUMsV0FBSyxlQUFlO0FBTXBCLFdBQUssaUJBQWlCLGlCQUFpQixPQUFPO0FBTTlDLFdBQUssc0JBQXNCO0FBTTNCLFdBQUssdUJBQXVCO0FBTTVCLFdBQUssVUFBVTtBQUtmLFdBQUssZ0JBQWdCO0FBQUEsSUFDekI7QUFzQkEsV0FBTyxXQUFXLFNBQVMsU0FBU0QsT0FBTSxNQUFNO0FBQzVDLGFBQU8sSUFBSSxPQUFPQSxPQUFNLEtBQUssTUFBTSxLQUFLLGFBQWEsS0FBSyxjQUFjLEtBQUssZUFBZSxLQUFLLGdCQUFnQixLQUFLLFNBQVMsS0FBSyxTQUFTLEtBQUssYUFBYTtBQUFBLElBQ25LO0FBT0EsV0FBTyxVQUFVLFNBQVMsU0FBUyxPQUFPLGVBQWU7QUFDckQsVUFBSSxlQUFlLGdCQUFnQixRQUFRLGNBQWMsWUFBWSxJQUFJO0FBQ3pFLGFBQU8sS0FBSyxTQUFTO0FBQUEsUUFDakI7QUFBQSxRQUFtQixLQUFLLFNBQVMsU0FBb0MsS0FBSyxRQUFRO0FBQUEsUUFDbEY7QUFBQSxRQUFtQixLQUFLO0FBQUEsUUFDeEI7QUFBQSxRQUFtQixLQUFLO0FBQUEsUUFDeEI7QUFBQSxRQUFtQixLQUFLO0FBQUEsUUFDeEI7QUFBQSxRQUFtQixLQUFLO0FBQUEsUUFDeEI7QUFBQSxRQUFtQixLQUFLO0FBQUEsUUFDeEI7QUFBQSxRQUFtQixlQUFlLEtBQUssVUFBVTtBQUFBLFFBQ2pEO0FBQUEsUUFBbUIsS0FBSztBQUFBLE1BQzVCLENBQUM7QUFBQSxJQUNMO0FBS0EsV0FBTyxVQUFVLFVBQVUsU0FBUyxVQUFVO0FBRzFDLFVBQUksS0FBSztBQUNMLGVBQU87QUFFWCxXQUFLLHNCQUFzQixLQUFLLE9BQU8sV0FBVyxLQUFLLFdBQVc7QUFDbEUsV0FBSyx1QkFBdUIsS0FBSyxPQUFPLFdBQVcsS0FBSyxZQUFZO0FBRXBFLGFBQU8saUJBQWlCLFVBQVUsUUFBUSxLQUFLLElBQUk7QUFBQSxJQUN2RDtBQUFBO0FBQUE7OztBQy9KQSxJQUFBRSxtQkFBQTtBQUFBLDJDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFHakIsUUFBSSxZQUFZO0FBQ2hCLE1BQUUsUUFBUSxZQUFZLE9BQU8sT0FBTyxVQUFVLFNBQVMsR0FBRyxjQUFjLFNBQVMsWUFBWTtBQUU3RixRQUFJLFNBQVM7QUFBYixRQUNJLE9BQVM7QUFEYixRQUVJLE1BQVM7QUFXYixhQUFTLFFBQVFDLE9BQU1DLFVBQVM7QUFDNUIsZ0JBQVUsS0FBSyxNQUFNRCxPQUFNQyxRQUFPO0FBTWxDLFdBQUssVUFBVSxDQUFDO0FBT2hCLFdBQUssZ0JBQWdCO0FBQUEsSUFDekI7QUFnQkEsWUFBUSxXQUFXLFNBQVMsU0FBU0QsT0FBTSxNQUFNO0FBQzdDLFVBQUksVUFBVSxJQUFJLFFBQVFBLE9BQU0sS0FBSyxPQUFPO0FBRTVDLFVBQUksS0FBSztBQUNMLGlCQUFTRSxTQUFRLE9BQU8sS0FBSyxLQUFLLE9BQU8sR0FBRyxJQUFJLEdBQUcsSUFBSUEsT0FBTSxRQUFRLEVBQUU7QUFDbkUsa0JBQVEsSUFBSSxPQUFPLFNBQVNBLE9BQU0sSUFBSSxLQUFLLFFBQVFBLE9BQU0sR0FBRyxDQUFDO0FBQ3JFLFVBQUksS0FBSztBQUNMLGdCQUFRLFFBQVEsS0FBSyxNQUFNO0FBQy9CLGNBQVEsVUFBVSxLQUFLO0FBQ3ZCLGFBQU87QUFBQSxJQUNYO0FBT0EsWUFBUSxVQUFVLFNBQVMsU0FBUyxPQUFPLGVBQWU7QUFDdEQsVUFBSSxZQUFZLFVBQVUsVUFBVSxPQUFPLEtBQUssTUFBTSxhQUFhO0FBQ25FLFVBQUksZUFBZSxnQkFBZ0IsUUFBUSxjQUFjLFlBQVksSUFBSTtBQUN6RSxhQUFPLEtBQUssU0FBUztBQUFBLFFBQ2pCO0FBQUEsUUFBWSxhQUFhLFVBQVUsV0FBVztBQUFBLFFBQzlDO0FBQUEsUUFBWSxVQUFVLFlBQVksS0FBSyxjQUFjLGFBQWEsS0FBZ0MsQ0FBQztBQUFBLFFBQ25HO0FBQUEsUUFBWSxhQUFhLFVBQVUsVUFBVTtBQUFBLFFBQzdDO0FBQUEsUUFBWSxlQUFlLEtBQUssVUFBVTtBQUFBLE1BQzlDLENBQUM7QUFBQSxJQUNMO0FBUUEsV0FBTyxlQUFlLFFBQVEsV0FBVyxnQkFBZ0I7QUFBQSxNQUNyRCxLQUFLLFdBQVc7QUFDWixlQUFPLEtBQUssa0JBQWtCLEtBQUssZ0JBQWdCLEtBQUssUUFBUSxLQUFLLE9BQU87QUFBQSxNQUNoRjtBQUFBLElBQ0osQ0FBQztBQUVELGFBQVMsV0FBVyxTQUFTO0FBQ3pCLGNBQVEsZ0JBQWdCO0FBQ3hCLGFBQU87QUFBQSxJQUNYO0FBS0EsWUFBUSxVQUFVLE1BQU0sU0FBUyxJQUFJRixPQUFNO0FBQ3ZDLGFBQU8sS0FBSyxRQUFRQSxVQUNiLFVBQVUsVUFBVSxJQUFJLEtBQUssTUFBTUEsS0FBSTtBQUFBLElBQ2xEO0FBS0EsWUFBUSxVQUFVLGFBQWEsU0FBUyxhQUFhO0FBQ2pELFVBQUlHLFdBQVUsS0FBSztBQUNuQixlQUFTLElBQUksR0FBRyxJQUFJQSxTQUFRLFFBQVEsRUFBRTtBQUNsQyxRQUFBQSxTQUFRLEdBQUcsUUFBUTtBQUN2QixhQUFPLFVBQVUsVUFBVSxRQUFRLEtBQUssSUFBSTtBQUFBLElBQ2hEO0FBS0EsWUFBUSxVQUFVLE1BQU0sU0FBUyxJQUFJLFFBQVE7QUFHekMsVUFBSSxLQUFLLElBQUksT0FBTyxJQUFJO0FBQ3BCLGNBQU0sTUFBTSxxQkFBcUIsT0FBTyxPQUFPLFVBQVUsSUFBSTtBQUVqRSxVQUFJLGtCQUFrQixRQUFRO0FBQzFCLGFBQUssUUFBUSxPQUFPLFFBQVE7QUFDNUIsZUFBTyxTQUFTO0FBQ2hCLGVBQU8sV0FBVyxJQUFJO0FBQUEsTUFDMUI7QUFDQSxhQUFPLFVBQVUsVUFBVSxJQUFJLEtBQUssTUFBTSxNQUFNO0FBQUEsSUFDcEQ7QUFLQSxZQUFRLFVBQVUsU0FBUyxTQUFTLE9BQU8sUUFBUTtBQUMvQyxVQUFJLGtCQUFrQixRQUFRO0FBRzFCLFlBQUksS0FBSyxRQUFRLE9BQU8sVUFBVTtBQUM5QixnQkFBTSxNQUFNLFNBQVMseUJBQXlCLElBQUk7QUFFdEQsZUFBTyxLQUFLLFFBQVEsT0FBTztBQUMzQixlQUFPLFNBQVM7QUFDaEIsZUFBTyxXQUFXLElBQUk7QUFBQSxNQUMxQjtBQUNBLGFBQU8sVUFBVSxVQUFVLE9BQU8sS0FBSyxNQUFNLE1BQU07QUFBQSxJQUN2RDtBQVNBLFlBQVEsVUFBVSxTQUFTLFNBQVNDLFFBQU8sU0FBUyxrQkFBa0IsbUJBQW1CO0FBQ3JGLFVBQUksYUFBYSxJQUFJLElBQUksUUFBUSxTQUFTLGtCQUFrQixpQkFBaUI7QUFDN0UsZUFBUyxJQUFJLEdBQUcsUUFBUSxJQUFzQixLQUFLLGFBQWEsUUFBUSxFQUFFLEdBQUc7QUFDekUsWUFBSSxhQUFhLEtBQUssU0FBUyxTQUFTLEtBQUssY0FBYyxJQUFJLFFBQVEsRUFBRSxJQUFJLEVBQUUsUUFBUSxZQUFZLEVBQUU7QUFDckcsbUJBQVcsY0FBYyxLQUFLLFFBQVEsQ0FBQyxLQUFJLEdBQUcsR0FBRyxLQUFLLFdBQVcsVUFBVSxJQUFJLGFBQWEsTUFBTSxVQUFVLEVBQUUsZ0NBQWdDLEVBQUU7QUFBQSxVQUM1SSxHQUFHO0FBQUEsVUFDSCxHQUFHLE9BQU8sb0JBQW9CO0FBQUEsVUFDOUIsR0FBRyxPQUFPLHFCQUFxQjtBQUFBLFFBQ25DLENBQUM7QUFBQSxNQUNMO0FBQ0EsYUFBTztBQUFBLElBQ1g7QUFBQTtBQUFBOzs7QUN0S0E7QUFBQSwyQ0FBQUMsVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVO0FBRWpCLFFBQUksT0FBTztBQVNYLGFBQVMsUUFBUSxZQUFZO0FBRXpCLFVBQUk7QUFDQSxpQkFBUyxPQUFPLE9BQU8sS0FBSyxVQUFVLEdBQUcsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEVBQUU7QUFDL0QsZUFBSyxLQUFLLE1BQU0sV0FBVyxLQUFLO0FBQUEsSUFDNUM7QUF5QkEsWUFBUSxTQUFTLFNBQVNDLFFBQU8sWUFBWTtBQUN6QyxhQUFPLEtBQUssTUFBTSxPQUFPLFVBQVU7QUFBQSxJQUN2QztBQVVBLFlBQVEsU0FBUyxTQUFTQyxRQUFPQyxVQUFTLFFBQVE7QUFDOUMsYUFBTyxLQUFLLE1BQU0sT0FBT0EsVUFBUyxNQUFNO0FBQUEsSUFDNUM7QUFVQSxZQUFRLGtCQUFrQixTQUFTLGdCQUFnQkEsVUFBUyxRQUFRO0FBQ2hFLGFBQU8sS0FBSyxNQUFNLGdCQUFnQkEsVUFBUyxNQUFNO0FBQUEsSUFDckQ7QUFXQSxZQUFRLFNBQVMsU0FBU0MsUUFBT0MsU0FBUTtBQUNyQyxhQUFPLEtBQUssTUFBTSxPQUFPQSxPQUFNO0FBQUEsSUFDbkM7QUFXQSxZQUFRLGtCQUFrQixTQUFTLGdCQUFnQkEsU0FBUTtBQUN2RCxhQUFPLEtBQUssTUFBTSxnQkFBZ0JBLE9BQU07QUFBQSxJQUM1QztBQVNBLFlBQVEsU0FBUyxTQUFTQyxRQUFPSCxVQUFTO0FBQ3RDLGFBQU8sS0FBSyxNQUFNLE9BQU9BLFFBQU87QUFBQSxJQUNwQztBQVNBLFlBQVEsYUFBYSxTQUFTLFdBQVcsUUFBUTtBQUM3QyxhQUFPLEtBQUssTUFBTSxXQUFXLE1BQU07QUFBQSxJQUN2QztBQVVBLFlBQVEsV0FBVyxTQUFTLFNBQVNBLFVBQVNJLFVBQVM7QUFDbkQsYUFBTyxLQUFLLE1BQU0sU0FBU0osVUFBU0ksUUFBTztBQUFBLElBQy9DO0FBTUEsWUFBUSxVQUFVLFNBQVMsU0FBUyxTQUFTO0FBQ3pDLGFBQU8sS0FBSyxNQUFNLFNBQVMsTUFBTSxLQUFLLGFBQWE7QUFBQSxJQUN2RDtBQUFBO0FBQUE7OztBQ3hJQTtBQUFBLDJDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFFakIsUUFBSSxPQUFVO0FBQWQsUUFDSSxRQUFVO0FBRGQsUUFFSSxPQUFVO0FBRWQsYUFBUyxRQUFRLE9BQU87QUFDcEIsYUFBTyx1QkFBdUIsTUFBTSxPQUFPO0FBQUEsSUFDL0M7QUFPQSxhQUFTLFFBQVEsT0FBTztBQUVwQixVQUFJLE1BQU0sS0FBSyxRQUFRLENBQUMsS0FBSyxHQUFHLEdBQUcsTUFBTSxPQUFPLFNBQVMsRUFDeEQsNEJBQTRCLEVBQ3hCLG9CQUFvQixFQUN4Qix1REFBdUQsTUFBTSxZQUFZLE9BQU8sU0FBU0MsUUFBTztBQUFFLGVBQU9BLE9BQU07QUFBQSxNQUFLLENBQUMsRUFBRSxTQUFTLGFBQWEsR0FBRyxFQUNoSixpQkFBaUIsRUFDYixrQkFBa0I7QUFDdkIsVUFBSSxNQUFNO0FBQU8sWUFDWixlQUFlLEVBQ1gsT0FBTztBQUNoQixVQUNLLGdCQUFnQjtBQUVyQixVQUFJLElBQUk7QUFDUixhQUFPLElBQXNCLE1BQU0sWUFBWSxRQUFRLEVBQUUsR0FBRztBQUN4RCxZQUFJLFFBQVEsTUFBTSxhQUFhLEdBQUcsUUFBUSxHQUN0QyxPQUFRLE1BQU0sd0JBQXdCLE9BQU8sVUFBVSxNQUFNLE1BQzdELE1BQVEsTUFBTSxLQUFLLFNBQVMsTUFBTSxJQUFJO0FBQUcsWUFDeEMsY0FBYyxNQUFNLEVBQUU7QUFHM0IsWUFBSSxNQUFNLEtBQUs7QUFBRSxjQUNSLDZCQUE2QixHQUFHLEVBQzVCLFNBQVMsR0FBRyxFQUNoQiwyQkFBMkI7QUFFaEMsY0FBSSxNQUFNLFNBQVMsTUFBTSxhQUFhO0FBQVcsZ0JBQzVDLFFBQVEsTUFBTSxTQUFTLE1BQU0sUUFBUTtBQUFBO0FBQ3JDLGdCQUNBLFFBQVE7QUFFYixjQUFJLE1BQU0sU0FBUyxVQUFVO0FBQVcsZ0JBQ25DLFlBQVksTUFBTSxTQUFTLEtBQUs7QUFBQTtBQUNoQyxnQkFDQSxZQUFZO0FBRWpCLGNBQ0ssa0JBQWtCLEVBQ2QscUJBQXFCLEVBQ3JCLG1CQUFtQixFQUNmLDJCQUEyQixNQUFNLE9BQU8sRUFDeEMsU0FBUztBQUV0QixjQUFJLE1BQU0sTUFBTSxVQUFVO0FBQVcsZ0JBQ3BCLHdDQUF3QyxDQUFDO0FBQUE7QUFDckQsZ0JBQ1ksZ0JBQWdCLElBQUk7QUFFckMsY0FDaUIsT0FBTyxFQUNYLFVBQVUsRUFDTixvQkFBb0IsRUFDcEIsT0FBTyxFQUNmLEdBQUcsRUFDUCxHQUFHO0FBRVIsY0FBSSxNQUFNLEtBQUssTUFBTSxhQUFhO0FBQVcsZ0JBQ3hDLHNEQUF3RCxHQUFHO0FBQUE7QUFDM0QsZ0JBQ0EsZUFBZSxHQUFHO0FBQUEsUUFHM0IsV0FBVyxNQUFNLFVBQVU7QUFBRSxjQUVwQix3QkFBd0IsS0FBSyxHQUFHLEVBQzVCLFNBQVMsR0FBRztBQUdyQixjQUFJLE1BQU0sT0FBTyxVQUFVO0FBQVcsZ0JBQ2pDLGdCQUFnQixFQUNaLHlCQUF5QixFQUN6QixpQkFBaUIsRUFDYixtQkFBbUIsS0FBSyxJQUFJLEVBQ3BDLE9BQU87QUFHWixjQUFJLE1BQU0sTUFBTSxVQUFVO0FBQVcsZ0JBQUksTUFBTSxhQUFhLFFBQ2xELGlDQUNBLDJDQUEyQyxLQUFLLENBQUM7QUFBQTtBQUN0RCxnQkFDSSxtQkFBbUIsS0FBSyxJQUFJO0FBQUEsUUFHekMsV0FBVyxNQUFNLE1BQU0sVUFBVTtBQUFXLGNBQUksTUFBTSxhQUFhLFFBQ3pELDJCQUNBLHFDQUFxQyxLQUFLLENBQUM7QUFBQTtBQUNoRCxjQUNJLGFBQWEsS0FBSyxJQUFJO0FBQy9CLFlBQ1MsT0FBTyxFQUNYLEdBQUc7QUFBQSxNQUVaO0FBQUUsVUFDTyxVQUFVLEVBQ04saUJBQWlCLEVBQ2pCLE9BQU8sRUFFZixHQUFHLEVBQ1AsR0FBRztBQUdKLFdBQUssSUFBSSxHQUFHLElBQUksTUFBTSxhQUFhLFFBQVEsRUFBRSxHQUFHO0FBQzVDLFlBQUksU0FBUyxNQUFNLGFBQWE7QUFDaEMsWUFBSSxPQUFPO0FBQVUsY0FDeEIsNkJBQTZCLE9BQU8sSUFBSSxFQUNwQyw2Q0FBNkMsUUFBUSxNQUFNLENBQUM7QUFBQSxNQUNqRTtBQUVBLGFBQU8sSUFDTixVQUFVO0FBQUEsSUFFZjtBQUFBO0FBQUE7OztBQ2hJQTtBQUFBLDRDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFFakIsUUFBSSxPQUFZO0FBQWhCLFFBQ0ksT0FBWTtBQUVoQixhQUFTLFFBQVEsT0FBTyxVQUFVO0FBQzlCLGFBQU8sTUFBTSxPQUFPLE9BQU8sWUFBWSxNQUFNLFlBQVksYUFBYSxVQUFVLE9BQU8sTUFBTSxPQUFPLGFBQWEsV0FBVyxRQUFNLE1BQU0sVUFBUSxNQUFNLE1BQU07QUFBQSxJQUNoSztBQVdBLGFBQVMsZUFBZSxLQUFLLE9BQU8sWUFBWSxLQUFLO0FBRWpELFVBQUksTUFBTSxjQUFjO0FBQ3BCLFlBQUksTUFBTSx3QkFBd0IsTUFBTTtBQUFFLGNBQ3JDLGVBQWUsR0FBRyxFQUNkLFVBQVUsRUFDTixZQUFZLFFBQVEsT0FBTyxZQUFZLENBQUM7QUFDakQsbUJBQVMsT0FBTyxPQUFPLEtBQUssTUFBTSxhQUFhLE1BQU0sR0FBRyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsRUFBRTtBQUFHLGdCQUNoRixZQUFZLE1BQU0sYUFBYSxPQUFPLEtBQUssR0FBRztBQUNuRCxjQUNTLE9BQU8sRUFDZixHQUFHO0FBQUEsUUFDUixPQUFPO0FBQ0gsY0FDQyxHQUFHLEVBQ0MsK0JBQStCLFlBQVksR0FBRyxFQUM5QyxPQUFPLEVBQ0gsY0FBYyxNQUFNLE9BQU8sR0FBRyxFQUN0QyxHQUFHO0FBQUEsUUFDUjtBQUFBLE1BQ0osT0FBTztBQUNILGdCQUFRLE1BQU07QUFBQSxlQUNMO0FBQUEsZUFDQTtBQUFBLGVBQ0E7QUFBQSxlQUNBO0FBQUEsZUFDQTtBQUFZLGdCQUNaLDJCQUEyQixHQUFHLEVBQzFCLFlBQVksUUFBUSxPQUFPLFNBQVMsQ0FBQztBQUMxQztBQUFBLGVBQ0M7QUFBQSxlQUNBO0FBQUEsZUFDQTtBQUFBLGVBQ0E7QUFBQSxlQUNBO0FBQVksZ0JBQ1osbUZBQW1GLEtBQUssS0FBSyxLQUFLLEdBQUcsRUFDakcsWUFBWSxRQUFRLE9BQU8sY0FBYyxDQUFDO0FBQy9DO0FBQUEsZUFDQztBQUFBLGVBQ0E7QUFBVSxnQkFDViw0QkFBOEIsR0FBRyxFQUM3QixZQUFZLFFBQVEsT0FBTyxRQUFRLENBQUM7QUFDekM7QUFBQSxlQUNDO0FBQVEsZ0JBQ1IsNkJBQStCLEdBQUcsRUFDOUIsWUFBWSxRQUFRLE9BQU8sU0FBUyxDQUFDO0FBQzFDO0FBQUEsZUFDQztBQUFVLGdCQUNWLDBCQUEwQixHQUFHLEVBQ3pCLFlBQVksUUFBUSxPQUFPLFFBQVEsQ0FBQztBQUN6QztBQUFBLGVBQ0M7QUFBUyxnQkFDVCw2REFBK0QsS0FBSyxLQUFLLEdBQUcsRUFDeEUsWUFBWSxRQUFRLE9BQU8sUUFBUSxDQUFDO0FBQ3pDO0FBQUE7QUFBQSxNQUVaO0FBQ0EsYUFBTztBQUFBLElBRVg7QUFVQSxhQUFTLGFBQWEsS0FBSyxPQUFPLEtBQUs7QUFFbkMsY0FBUSxNQUFNO0FBQUEsYUFDTDtBQUFBLGFBQ0E7QUFBQSxhQUNBO0FBQUEsYUFDQTtBQUFBLGFBQ0E7QUFBWSxjQUNaLDhCQUE4QixHQUFHLEVBQzdCLFlBQVksUUFBUSxPQUFPLGFBQWEsQ0FBQztBQUM5QztBQUFBLGFBQ0M7QUFBQSxhQUNBO0FBQUEsYUFDQTtBQUFBLGFBQ0E7QUFBQSxhQUNBO0FBQVksY0FDWiw4QkFBOEIsR0FBRyxFQUM3QixZQUFZLFFBQVEsT0FBTyxrQkFBa0IsQ0FBQztBQUNuRDtBQUFBLGFBQ0M7QUFBUSxjQUNSLDZCQUE2QixHQUFHLEVBQzVCLFlBQVksUUFBUSxPQUFPLGFBQWEsQ0FBQztBQUM5QztBQUFBO0FBRVIsYUFBTztBQUFBLElBRVg7QUFPQSxhQUFTLFNBQVMsT0FBTztBQUdyQixVQUFJLE1BQU0sS0FBSyxRQUFRLENBQUMsR0FBRyxHQUFHLE1BQU0sT0FBTyxTQUFTLEVBQ25ELG1DQUFxQyxFQUNqQyxZQUFZLGlCQUFpQjtBQUNsQyxVQUFJLFNBQVMsTUFBTSxhQUNmLGlCQUFpQixDQUFDO0FBQ3RCLFVBQUksT0FBTztBQUFRLFlBQ2xCLFVBQVU7QUFFWCxlQUFTLElBQUksR0FBRyxJQUFzQixNQUFNLFlBQVksUUFBUSxFQUFFLEdBQUc7QUFDakUsWUFBSSxRQUFRLE1BQU0sYUFBYSxHQUFHLFFBQVEsR0FDdEMsTUFBUSxNQUFNLEtBQUssU0FBUyxNQUFNLElBQUk7QUFFMUMsWUFBSSxNQUFNO0FBQVUsY0FDbkIsdUNBQXVDLEtBQUssTUFBTSxJQUFJO0FBR3ZELFlBQUksTUFBTSxLQUFLO0FBQUUsY0FDWiwwQkFBMEIsR0FBRyxFQUN6QixZQUFZLFFBQVEsT0FBTyxRQUFRLENBQUMsRUFDeEMseUJBQXlCLEdBQUcsRUFDNUIsOEJBQThCO0FBQzNCLHVCQUFhLEtBQUssT0FBTyxNQUFNO0FBQy9CLHlCQUFlLEtBQUssT0FBTyxHQUFHLE1BQU0sUUFBUSxFQUMvQyxHQUFHO0FBQUEsUUFHUixXQUFXLE1BQU0sVUFBVTtBQUFFLGNBQ3hCLDBCQUEwQixHQUFHLEVBQ3pCLFlBQVksUUFBUSxPQUFPLE9BQU8sQ0FBQyxFQUN2QyxpQ0FBaUMsR0FBRztBQUNqQyx5QkFBZSxLQUFLLE9BQU8sR0FBRyxNQUFNLEtBQUssRUFDNUMsR0FBRztBQUFBLFFBR1IsT0FBTztBQUNILGNBQUksTUFBTSxRQUFRO0FBQ2QsZ0JBQUksWUFBWSxLQUFLLFNBQVMsTUFBTSxPQUFPLElBQUk7QUFDL0MsZ0JBQUksZUFBZSxNQUFNLE9BQU8sVUFBVTtBQUFHLGtCQUNoRCxlQUFlLFNBQVMsRUFDcEIsWUFBWSxNQUFNLE9BQU8sT0FBTyxtQkFBbUI7QUFDcEQsMkJBQWUsTUFBTSxPQUFPLFFBQVE7QUFDcEMsZ0JBQ0gsU0FBUyxTQUFTO0FBQUEsVUFDbkI7QUFDQSx5QkFBZSxLQUFLLE9BQU8sR0FBRyxHQUFHO0FBQUEsUUFDckM7QUFDQSxZQUFJLE1BQU07QUFBVSxjQUNuQixHQUFHO0FBQUEsTUFDUjtBQUNBLGFBQU8sSUFDTixhQUFhO0FBQUEsSUFFbEI7QUFBQTtBQUFBOzs7QUNoTEE7QUFBQSw2Q0FBQUMsVUFBQTtBQUFBO0FBS0EsUUFBSSxZQUFZQTtBQUVoQixRQUFJLE9BQU87QUFBWCxRQUNJLE9BQU87QUFXWCxhQUFTLDJCQUEyQixLQUFLLE9BQU8sWUFBWSxNQUFNO0FBQzlELFVBQUksd0JBQXdCO0FBRTVCLFVBQUksTUFBTSxjQUFjO0FBQ3BCLFlBQUksTUFBTSx3QkFBd0IsTUFBTTtBQUFFLGNBQ3JDLGdCQUFnQixJQUFJO0FBQ3JCLG1CQUFTLFNBQVMsTUFBTSxhQUFhLFFBQVEsT0FBTyxPQUFPLEtBQUssTUFBTSxHQUFHLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxFQUFFLEdBQUc7QUFFbEcsZ0JBQUksT0FBTyxLQUFLLFFBQVEsTUFBTSxlQUFlLENBQUMsdUJBQXVCO0FBQUUsa0JBQ2xFLFVBQVUsRUFDTiw2Q0FBK0MsTUFBTSxNQUFNLElBQUk7QUFDcEUsa0JBQUksQ0FBQyxNQUFNO0FBQVUsb0JBRWhCLE9BQU87QUFDWixzQ0FBd0I7QUFBQSxZQUM1QjtBQUNBLGdCQUNDLFdBQVcsS0FBSyxFQUFFLEVBQ2xCLFlBQVksT0FBTyxLQUFLLEdBQUcsRUFDdkIsVUFBVSxNQUFNLE9BQU8sS0FBSyxHQUFHLEVBQy9CLE9BQU87QUFBQSxVQUNoQjtBQUFFLGNBQ0QsR0FBRztBQUFBLFFBQ1I7QUFBTyxjQUNGLDZCQUErQixJQUFJLEVBQy9CLHVCQUF1QixNQUFNLFdBQVcsbUJBQW1CLEVBQy9ELGlDQUFpQyxNQUFNLFlBQVksSUFBSTtBQUFBLE1BQ2hFLE9BQU87QUFDSCxZQUFJLGFBQWE7QUFDakIsZ0JBQVEsTUFBTTtBQUFBLGVBQ0w7QUFBQSxlQUNBO0FBQVMsZ0JBQ1QsbUJBQW1CLE1BQU0sSUFBSTtBQUM5QjtBQUFBLGVBQ0M7QUFBQSxlQUNBO0FBQVcsZ0JBQ1gsZUFBZSxNQUFNLElBQUk7QUFDMUI7QUFBQSxlQUNDO0FBQUEsZUFDQTtBQUFBLGVBQ0E7QUFBWSxnQkFDWixhQUFhLE1BQU0sSUFBSTtBQUN4QjtBQUFBLGVBQ0M7QUFDRCx5QkFBYTtBQUFBLGVBRVo7QUFBQSxlQUNBO0FBQUEsZUFDQTtBQUFBLGVBQ0E7QUFBWSxnQkFDWixlQUFlLEVBQ1gsOENBQThDLE1BQU0sTUFBTSxVQUFVLEVBQ3hFLGtDQUFvQyxJQUFJLEVBQ3BDLHdCQUF3QixNQUFNLElBQUksRUFDdEMsa0NBQW9DLElBQUksRUFDcEMsV0FBVyxNQUFNLElBQUksRUFDekIsa0NBQW9DLElBQUksRUFDcEMsZ0VBQWdFLE1BQU0sTUFBTSxNQUFNLGFBQWEsU0FBUyxFQUFFO0FBQy9HO0FBQUEsZUFDQztBQUFTLGdCQUNULDZCQUErQixJQUFJLEVBQy9CLHlFQUF5RSxNQUFNLE1BQU0sSUFBSSxFQUM3Riw0QkFBNEIsSUFBSSxFQUM1QixXQUFXLE1BQU0sSUFBSTtBQUMxQjtBQUFBLGVBQ0M7QUFBVSxnQkFDVixtQkFBbUIsTUFBTSxJQUFJO0FBQzlCO0FBQUEsZUFDQztBQUFRLGdCQUNSLG9CQUFvQixNQUFNLElBQUk7QUFDL0I7QUFBQTtBQUFBLE1BS1o7QUFDQSxhQUFPO0FBQUEsSUFFWDtBQU9BLGNBQVUsYUFBYSxTQUFTLFdBQVcsT0FBTztBQUU5QyxVQUFJLFNBQVMsTUFBTTtBQUNuQixVQUFJLE1BQU0sS0FBSyxRQUFRLENBQUMsR0FBRyxHQUFHLE1BQU0sT0FBTyxhQUFhLEVBQ3ZELDRCQUE0QixFQUN4QixVQUFVO0FBQ2YsVUFBSSxDQUFDLE9BQU87QUFBUSxlQUFPLElBQzFCLHNCQUFzQjtBQUN2QixVQUNDLHFCQUFxQjtBQUN0QixlQUFTLElBQUksR0FBRyxJQUFJLE9BQU8sUUFBUSxFQUFFLEdBQUc7QUFDcEMsWUFBSSxRQUFTLE9BQU8sR0FBRyxRQUFRLEdBQzNCLE9BQVMsS0FBSyxTQUFTLE1BQU0sSUFBSTtBQUdyQyxZQUFJLE1BQU0sS0FBSztBQUFFLGNBQ3BCLFlBQVksSUFBSSxFQUNaLDZCQUErQixJQUFJLEVBQy9CLHVCQUF1QixNQUFNLFdBQVcsbUJBQW1CLEVBQy9ELFVBQVUsSUFBSSxFQUNkLHFEQUFxRCxJQUFJO0FBQ3RELHFDQUEyQixLQUFLLE9BQXdCLEdBQUcsT0FBTyxTQUFTLEVBQzlFLEdBQUcsRUFDUCxHQUFHO0FBQUEsUUFHQSxXQUFXLE1BQU0sVUFBVTtBQUFFLGNBQ2hDLFlBQVksSUFBSSxFQUNaLDJCQUEyQixJQUFJLEVBQzNCLHVCQUF1QixNQUFNLFdBQVcsa0JBQWtCLEVBQzlELFVBQVUsSUFBSSxFQUNkLGtDQUFrQyxJQUFJO0FBQ25DLHFDQUEyQixLQUFLLE9BQXdCLEdBQUcsT0FBTyxLQUFLLEVBQzFFLEdBQUcsRUFDUCxHQUFHO0FBQUEsUUFHQSxPQUFPO0FBQ0gsY0FBSSxFQUFFLE1BQU0sd0JBQXdCO0FBQU8sZ0JBQ2xELGtCQUFrQixJQUFJO0FBQ25CLHFDQUEyQixLQUFLLE9BQXdCLEdBQUcsSUFBSTtBQUMzRCxjQUFJLEVBQUUsTUFBTSx3QkFBd0I7QUFBTyxnQkFDbEQsR0FBRztBQUFBLFFBQ0E7QUFBQSxNQUNKO0FBQUUsYUFBTyxJQUNSLFVBQVU7QUFBQSxJQUVmO0FBV0EsYUFBUyx5QkFBeUIsS0FBSyxPQUFPLFlBQVksTUFBTTtBQUU1RCxVQUFJLE1BQU0sY0FBYztBQUNwQixZQUFJLE1BQU0sd0JBQXdCO0FBQU0sY0FDbkMsMEZBQTBGLE1BQU0sWUFBWSxNQUFNLE1BQU0sWUFBWSxNQUFNLElBQUk7QUFBQTtBQUM5SSxjQUNBLGlDQUFpQyxNQUFNLFlBQVksSUFBSTtBQUFBLE1BQ2hFLE9BQU87QUFDSCxZQUFJLGFBQWE7QUFDakIsZ0JBQVEsTUFBTTtBQUFBLGVBQ0w7QUFBQSxlQUNBO0FBQVMsZ0JBQ2IsOENBQThDLE1BQU0sTUFBTSxNQUFNLElBQUk7QUFDakU7QUFBQSxlQUNDO0FBQ0QseUJBQWE7QUFBQSxlQUVaO0FBQUEsZUFDQTtBQUFBLGVBQ0E7QUFBQSxlQUNBO0FBQVksZ0JBQ2hCLDZCQUErQixJQUFJLEVBQy9CLHdDQUF3QyxNQUFNLE1BQU0sSUFBSSxFQUM1RCxNQUFNLEVBQ0YsNklBQTZJLE1BQU0sTUFBTSxNQUFNLE1BQU0sYUFBYSxTQUFRLElBQUksSUFBSTtBQUNuTTtBQUFBLGVBQ0M7QUFBUyxnQkFDYixpSEFBaUgsTUFBTSxNQUFNLE1BQU0sTUFBTSxJQUFJO0FBQzFJO0FBQUE7QUFDSyxnQkFDUixXQUFXLE1BQU0sSUFBSTtBQUNsQjtBQUFBO0FBQUEsTUFFWjtBQUNBLGFBQU87QUFBQSxJQUVYO0FBT0EsY0FBVSxXQUFXLFNBQVMsU0FBUyxPQUFPO0FBRTFDLFVBQUksU0FBUyxNQUFNLFlBQVksTUFBTSxFQUFFLEtBQUssS0FBSyxpQkFBaUI7QUFDbEUsVUFBSSxDQUFDLE9BQU87QUFDUixlQUFPLEtBQUssUUFBUSxFQUFFLFdBQVc7QUFDckMsVUFBSSxNQUFNLEtBQUssUUFBUSxDQUFDLEtBQUssR0FBRyxHQUFHLE1BQU0sT0FBTyxXQUFXLEVBQzFELFFBQVEsRUFDSixNQUFNLEVBQ1YsVUFBVTtBQUVYLFVBQUksaUJBQWlCLENBQUMsR0FDbEIsWUFBWSxDQUFDLEdBQ2IsZUFBZSxDQUFDLEdBQ2hCLElBQUk7QUFDUixhQUFPLElBQUksT0FBTyxRQUFRLEVBQUU7QUFDeEIsWUFBSSxDQUFDLE9BQU8sR0FBRztBQUNYLFdBQUUsT0FBTyxHQUFHLFFBQVEsRUFBRSxXQUFXLGlCQUMvQixPQUFPLEdBQUcsTUFBTSxZQUNoQixjQUFjLEtBQUssT0FBTyxFQUFFO0FBRXRDLFVBQUksZUFBZSxRQUFRO0FBQUUsWUFDNUIsMkJBQTJCO0FBQ3hCLGFBQUssSUFBSSxHQUFHLElBQUksZUFBZSxRQUFRLEVBQUU7QUFBRyxjQUMzQyxVQUFVLEtBQUssU0FBUyxlQUFlLEdBQUcsSUFBSSxDQUFDO0FBQ2hELFlBQ0gsR0FBRztBQUFBLE1BQ0o7QUFFQSxVQUFJLFVBQVUsUUFBUTtBQUFFLFlBQ3ZCLDRCQUE0QjtBQUN6QixhQUFLLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxFQUFFO0FBQUcsY0FDdEMsVUFBVSxLQUFLLFNBQVMsVUFBVSxHQUFHLElBQUksQ0FBQztBQUMzQyxZQUNILEdBQUc7QUFBQSxNQUNKO0FBRUEsVUFBSSxhQUFhLFFBQVE7QUFBRSxZQUMxQixpQkFBaUI7QUFDZCxhQUFLLElBQUksR0FBRyxJQUFJLGFBQWEsUUFBUSxFQUFFLEdBQUc7QUFDdEMsY0FBSSxRQUFRLGFBQWEsSUFDckIsT0FBUSxLQUFLLFNBQVMsTUFBTSxJQUFJO0FBQ3BDLGNBQUksTUFBTSx3QkFBd0I7QUFBTSxnQkFDM0MsOEJBQThCLE1BQU0sTUFBTSxhQUFhLFdBQVcsTUFBTSxjQUFjLE1BQU0sV0FBVztBQUFBLG1CQUMzRixNQUFNO0FBQU0sZ0JBQ3hCLGdCQUFnQixFQUNaLGlDQUFpQyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksTUFBTSxNQUFNLFlBQVksUUFBUSxFQUMxRyxxRUFBcUUsSUFBSSxFQUM3RSxPQUFPLEVBQ0gsOEJBQThCLE1BQU0sTUFBTSxZQUFZLFNBQVMsR0FBRyxNQUFNLFlBQVksU0FBUyxDQUFDO0FBQUEsbUJBQ3RGLE1BQU0sT0FBTztBQUNsQixnQkFBSSxlQUFlLE1BQU0sTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLFdBQVcsRUFBRSxLQUFLLEdBQUcsSUFBSTtBQUNuRixnQkFDUCw4QkFBOEIsTUFBTSxPQUFPLGFBQWEsTUFBTSxRQUFRLE1BQU0sV0FBVyxDQUFDLEVBQ3hGLE9BQU8sRUFDSCxVQUFVLE1BQU0sWUFBWSxFQUM1Qiw4Q0FBOEMsTUFBTSxJQUFJLEVBQzVELEdBQUc7QUFBQSxVQUNBO0FBQU8sZ0JBQ1YsVUFBVSxNQUFNLE1BQU0sV0FBVztBQUFBLFFBQ2xDO0FBQUUsWUFDTCxHQUFHO0FBQUEsTUFDSjtBQUNBLFVBQUksU0FBUztBQUNiLFdBQUssSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEVBQUUsR0FBRztBQUNoQyxZQUFJLFFBQVEsT0FBTyxJQUNmLFFBQVEsTUFBTSxhQUFhLFFBQVEsS0FBSyxHQUN4QyxPQUFRLEtBQUssU0FBUyxNQUFNLElBQUk7QUFDcEMsWUFBSSxNQUFNLEtBQUs7QUFDWCxjQUFJLENBQUMsUUFBUTtBQUFFLHFCQUFTO0FBQU0sZ0JBQ3JDLFNBQVM7QUFBQSxVQUNGO0FBQUUsY0FDVCwyQ0FBMkMsTUFBTSxJQUFJLEVBQ2pELFVBQVUsSUFBSSxFQUNkLGdDQUFnQztBQUM3QixtQ0FBeUIsS0FBSyxPQUFvQixPQUFPLE9BQU8sVUFBVSxFQUM3RSxHQUFHO0FBQUEsUUFDSixXQUFXLE1BQU0sVUFBVTtBQUFFLGNBQ2hDLHdCQUF3QixNQUFNLElBQUksRUFDOUIsVUFBVSxJQUFJLEVBQ2Qsa0NBQWtDLElBQUk7QUFDbkMsbUNBQXlCLEtBQUssT0FBb0IsT0FBTyxPQUFPLEtBQUssRUFDeEUsR0FBRztBQUFBLFFBQ0osT0FBTztBQUFFLGNBQ1osd0NBQXdDLE1BQU0sTUFBTSxJQUFJO0FBQ3JELG1DQUF5QixLQUFLLE9BQW9CLE9BQU8sSUFBSTtBQUM3RCxjQUFJLE1BQU07QUFBUSxnQkFDakIsY0FBYyxFQUNWLFVBQVUsS0FBSyxTQUFTLE1BQU0sT0FBTyxJQUFJLEdBQUcsTUFBTSxJQUFJO0FBQUEsUUFDM0Q7QUFDQSxZQUNILEdBQUc7QUFBQSxNQUNKO0FBQ0EsYUFBTyxJQUNOLFVBQVU7QUFBQSxJQUVmO0FBQUE7QUFBQTs7O0FDNVNBO0FBQUEsNENBQUFDLFVBQUE7QUFBQTtBQU9BLFFBQUksV0FBV0E7QUFFZixRQUFJLFVBQVU7QUE2QmQsYUFBUywwQkFBMEI7QUFBQSxNQUUvQixZQUFZLFNBQVMsUUFBUTtBQUd6QixZQUFJLFVBQVUsT0FBTyxVQUFVO0FBRTNCLGNBQUlDLFFBQU8sT0FBTyxTQUFTLFVBQVUsT0FBTyxTQUFTLFlBQVksR0FBRyxJQUFJLENBQUM7QUFDekUsY0FBSSxPQUFPLEtBQUssT0FBT0EsS0FBSTtBQUUzQixjQUFJLE1BQU07QUFFTixnQkFBSSxXQUFXLE9BQU8sU0FBUyxPQUFPLENBQUMsTUFBTSxNQUN6QyxPQUFPLFNBQVMsTUFBTSxDQUFDLElBQUksT0FBTztBQUV0QyxnQkFBSSxTQUFTLFFBQVEsR0FBRyxNQUFNLElBQUk7QUFDOUIseUJBQVcsTUFBTTtBQUFBLFlBQ3JCO0FBQ0EsbUJBQU8sS0FBSyxPQUFPO0FBQUEsY0FDZjtBQUFBLGNBQ0EsT0FBTyxLQUFLLE9BQU8sS0FBSyxXQUFXLE1BQU0sQ0FBQyxFQUFFLE9BQU87QUFBQSxZQUN2RCxDQUFDO0FBQUEsVUFDTDtBQUFBLFFBQ0o7QUFFQSxlQUFPLEtBQUssV0FBVyxNQUFNO0FBQUEsTUFDakM7QUFBQSxNQUVBLFVBQVUsU0FBU0MsVUFBU0MsVUFBUztBQUdqQyxZQUFJLFlBQVk7QUFDaEIsWUFBSSxTQUFTO0FBQ2IsWUFBSUYsUUFBTztBQUdYLFlBQUlFLFlBQVdBLFNBQVEsUUFBUUQsU0FBUSxZQUFZQSxTQUFRLE9BQU87QUFFOUQsVUFBQUQsUUFBT0MsU0FBUSxTQUFTLFVBQVVBLFNBQVEsU0FBUyxZQUFZLEdBQUcsSUFBSSxDQUFDO0FBRXZFLG1CQUFTQSxTQUFRLFNBQVMsVUFBVSxHQUFHQSxTQUFRLFNBQVMsWUFBWSxHQUFHLElBQUksQ0FBQztBQUM1RSxjQUFJLE9BQU8sS0FBSyxPQUFPRCxLQUFJO0FBRTNCLGNBQUk7QUFDQSxZQUFBQyxXQUFVLEtBQUssT0FBT0EsU0FBUSxLQUFLO0FBQUEsUUFDM0M7QUFHQSxZQUFJLEVBQUVBLG9CQUFtQixLQUFLLFNBQVNBLG9CQUFtQixTQUFTO0FBQy9ELGNBQUksU0FBU0EsU0FBUSxNQUFNLFNBQVNBLFVBQVNDLFFBQU87QUFDcEQsY0FBSSxjQUFjRCxTQUFRLE1BQU0sU0FBUyxPQUFPLE1BQzVDQSxTQUFRLE1BQU0sU0FBUyxNQUFNLENBQUMsSUFBSUEsU0FBUSxNQUFNO0FBRXBELGNBQUksV0FBVyxJQUFJO0FBQ2YscUJBQVM7QUFBQSxVQUNiO0FBQ0EsVUFBQUQsUUFBTyxTQUFTO0FBQ2hCLGlCQUFPLFdBQVdBO0FBQ2xCLGlCQUFPO0FBQUEsUUFDWDtBQUVBLGVBQU8sS0FBSyxTQUFTQyxVQUFTQyxRQUFPO0FBQUEsTUFDekM7QUFBQSxJQUNKO0FBQUE7QUFBQTs7O0FDckdBO0FBQUEsd0NBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVTtBQUdqQixRQUFJLFlBQVk7QUFDaEIsTUFBRSxLQUFLLFlBQVksT0FBTyxPQUFPLFVBQVUsU0FBUyxHQUFHLGNBQWMsTUFBTSxZQUFZO0FBRXZGLFFBQUksT0FBWTtBQUFoQixRQUNJLFFBQVk7QUFEaEIsUUFFSSxRQUFZO0FBRmhCLFFBR0ksV0FBWTtBQUhoQixRQUlJLFVBQVk7QUFKaEIsUUFLSSxVQUFZO0FBTGhCLFFBTUlDLFVBQVk7QUFOaEIsUUFPSUMsVUFBWTtBQVBoQixRQVFJLE9BQVk7QUFSaEIsUUFTSSxVQUFZO0FBVGhCLFFBVUksVUFBWTtBQVZoQixRQVdJLFdBQVk7QUFYaEIsUUFZSSxZQUFZO0FBWmhCLFFBYUksV0FBWTtBQVVoQixhQUFTLEtBQUtDLE9BQU1DLFVBQVM7QUFDekIsZ0JBQVUsS0FBSyxNQUFNRCxPQUFNQyxRQUFPO0FBTWxDLFdBQUssU0FBUyxDQUFDO0FBTWYsV0FBSyxTQUFTO0FBTWQsV0FBSyxhQUFhO0FBTWxCLFdBQUssV0FBVztBQU1oQixXQUFLLFFBQVE7QUFPYixXQUFLLGNBQWM7QUFPbkIsV0FBSyxlQUFlO0FBT3BCLFdBQUssZUFBZTtBQU9wQixXQUFLLFFBQVE7QUFBQSxJQUNqQjtBQUVBLFdBQU8saUJBQWlCLEtBQUssV0FBVztBQUFBLE1BUXBDLFlBQVk7QUFBQSxRQUNSLEtBQUssV0FBVztBQUdaLGNBQUksS0FBSztBQUNMLG1CQUFPLEtBQUs7QUFFaEIsZUFBSyxjQUFjLENBQUM7QUFDcEIsbUJBQVNDLFNBQVEsT0FBTyxLQUFLLEtBQUssTUFBTSxHQUFHLElBQUksR0FBRyxJQUFJQSxPQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3JFLGdCQUFJLFFBQVEsS0FBSyxPQUFPQSxPQUFNLEtBQzFCLEtBQUssTUFBTTtBQUdmLGdCQUFJLEtBQUssWUFBWTtBQUNqQixvQkFBTSxNQUFNLGtCQUFrQixLQUFLLFNBQVMsSUFBSTtBQUVwRCxpQkFBSyxZQUFZLE1BQU07QUFBQSxVQUMzQjtBQUNBLGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUFBLE1BQ0o7QUFBQSxNQVFBLGFBQWE7QUFBQSxRQUNULEtBQUssV0FBVztBQUNaLGlCQUFPLEtBQUssaUJBQWlCLEtBQUssZUFBZSxLQUFLLFFBQVEsS0FBSyxNQUFNO0FBQUEsUUFDN0U7QUFBQSxNQUNKO0FBQUEsTUFRQSxhQUFhO0FBQUEsUUFDVCxLQUFLLFdBQVc7QUFDWixpQkFBTyxLQUFLLGlCQUFpQixLQUFLLGVBQWUsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLFFBQzdFO0FBQUEsTUFDSjtBQUFBLE1BUUEsTUFBTTtBQUFBLFFBQ0YsS0FBSyxXQUFXO0FBQ1osaUJBQU8sS0FBSyxVQUFVLEtBQUssT0FBTyxLQUFLLG9CQUFvQixJQUFJLEVBQUU7QUFBQSxRQUNyRTtBQUFBLFFBQ0EsS0FBSyxTQUFTLE1BQU07QUFHaEIsY0FBSSxZQUFZLEtBQUs7QUFDckIsY0FBSSxFQUFFLHFCQUFxQixVQUFVO0FBQ2pDLGFBQUMsS0FBSyxZQUFZLElBQUksUUFBUSxHQUFHLGNBQWM7QUFDL0MsaUJBQUssTUFBTSxLQUFLLFdBQVcsU0FBUztBQUFBLFVBQ3hDO0FBR0EsZUFBSyxRQUFRLEtBQUssVUFBVSxRQUFRO0FBR3BDLGVBQUssTUFBTSxNQUFNLFNBQVMsSUFBSTtBQUU5QixlQUFLLFFBQVE7QUFHYixjQUFJLElBQUk7QUFDUixpQkFBTyxJQUFzQixLQUFLLFlBQVksUUFBUSxFQUFFO0FBQ3BELGlCQUFLLGFBQWEsR0FBRyxRQUFRO0FBR2pDLGNBQUksaUJBQWlCLENBQUM7QUFDdEIsZUFBSyxJQUFJLEdBQUcsSUFBc0IsS0FBSyxZQUFZLFFBQVEsRUFBRTtBQUN6RCwyQkFBZSxLQUFLLGFBQWEsR0FBRyxRQUFRLEVBQUUsUUFBUTtBQUFBLGNBQ2xELEtBQUssS0FBSyxZQUFZLEtBQUssYUFBYSxHQUFHLEtBQUs7QUFBQSxjQUNoRCxLQUFLLEtBQUssWUFBWSxLQUFLLGFBQWEsR0FBRyxLQUFLO0FBQUEsWUFDcEQ7QUFDSixjQUFJO0FBQ0EsbUJBQU8saUJBQWlCLEtBQUssV0FBVyxjQUFjO0FBQUEsUUFDOUQ7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBT0QsU0FBSyxzQkFBc0IsU0FBUyxvQkFBb0IsT0FBTztBQUUzRCxVQUFJLE1BQU0sS0FBSyxRQUFRLENBQUMsR0FBRyxHQUFHLE1BQU0sSUFBSTtBQUV4QyxlQUFTLElBQUksR0FBRyxPQUFPLElBQUksTUFBTSxZQUFZLFFBQVEsRUFBRTtBQUNuRCxhQUFLLFFBQVEsTUFBTSxhQUFhLElBQUk7QUFBSyxjQUNwQyxhQUFhLEtBQUssU0FBUyxNQUFNLElBQUksQ0FBQztBQUFBLGlCQUNsQyxNQUFNO0FBQVUsY0FDcEIsYUFBYSxLQUFLLFNBQVMsTUFBTSxJQUFJLENBQUM7QUFDL0MsYUFBTyxJQUNOLHVFQUF1RSxFQUNuRSxzQkFBc0I7QUFBQSxJQUUvQjtBQUVBLGFBQVMsV0FBVyxNQUFNO0FBQ3RCLFdBQUssY0FBYyxLQUFLLGVBQWUsS0FBSyxlQUFlO0FBQzNELGFBQU8sS0FBSztBQUNaLGFBQU8sS0FBSztBQUNaLGFBQU8sS0FBSztBQUNaLGFBQU87QUFBQSxJQUNYO0FBbUJBLFNBQUssV0FBVyxTQUFTLFNBQVNGLE9BQU0sTUFBTTtBQUMxQyxVQUFJLE9BQU8sSUFBSSxLQUFLQSxPQUFNLEtBQUssT0FBTztBQUN0QyxXQUFLLGFBQWEsS0FBSztBQUN2QixXQUFLLFdBQVcsS0FBSztBQUNyQixVQUFJRSxTQUFRLE9BQU8sS0FBSyxLQUFLLE1BQU0sR0FDL0IsSUFBSTtBQUNSLGFBQU8sSUFBSUEsT0FBTSxRQUFRLEVBQUU7QUFDdkIsYUFBSztBQUFBLFdBQ0MsT0FBTyxLQUFLLE9BQU9BLE9BQU0sSUFBSSxZQUFZLGNBQ3pDLFNBQVMsV0FDVCxNQUFNLFVBQVdBLE9BQU0sSUFBSSxLQUFLLE9BQU9BLE9BQU0sR0FBRztBQUFBLFFBQ3REO0FBQ0osVUFBSSxLQUFLO0FBQ0wsYUFBS0EsU0FBUSxPQUFPLEtBQUssS0FBSyxNQUFNLEdBQUcsSUFBSSxHQUFHLElBQUlBLE9BQU0sUUFBUSxFQUFFO0FBQzlELGVBQUssSUFBSSxNQUFNLFNBQVNBLE9BQU0sSUFBSSxLQUFLLE9BQU9BLE9BQU0sR0FBRyxDQUFDO0FBQ2hFLFVBQUksS0FBSztBQUNMLGFBQUtBLFNBQVEsT0FBTyxLQUFLLEtBQUssTUFBTSxHQUFHLElBQUksR0FBRyxJQUFJQSxPQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ2pFLGNBQUksU0FBUyxLQUFLLE9BQU9BLE9BQU07QUFDL0IsZUFBSztBQUFBLGFBQ0MsT0FBTyxPQUFPLFNBQ2QsTUFBTSxXQUNOLE9BQU8sV0FBVyxTQUNsQixLQUFLLFdBQ0wsT0FBTyxXQUFXLFNBQ2xCLEtBQUssV0FDTCxPQUFPLFlBQVksU0FDbkIsUUFBUSxXQUNSLFVBQVUsVUFBV0EsT0FBTSxJQUFJLE1BQU07QUFBQSxVQUMzQztBQUFBLFFBQ0o7QUFDSixVQUFJLEtBQUssY0FBYyxLQUFLLFdBQVc7QUFDbkMsYUFBSyxhQUFhLEtBQUs7QUFDM0IsVUFBSSxLQUFLLFlBQVksS0FBSyxTQUFTO0FBQy9CLGFBQUssV0FBVyxLQUFLO0FBQ3pCLFVBQUksS0FBSztBQUNMLGFBQUssUUFBUTtBQUNqQixVQUFJLEtBQUs7QUFDTCxhQUFLLFVBQVUsS0FBSztBQUN4QixhQUFPO0FBQUEsSUFDWDtBQU9BLFNBQUssVUFBVSxTQUFTLFNBQVMsT0FBTyxlQUFlO0FBQ25ELFVBQUksWUFBWSxVQUFVLFVBQVUsT0FBTyxLQUFLLE1BQU0sYUFBYTtBQUNuRSxVQUFJLGVBQWUsZ0JBQWdCLFFBQVEsY0FBYyxZQUFZLElBQUk7QUFDekUsYUFBTyxLQUFLLFNBQVM7QUFBQSxRQUNqQjtBQUFBLFFBQWUsYUFBYSxVQUFVLFdBQVc7QUFBQSxRQUNqRDtBQUFBLFFBQWUsVUFBVSxZQUFZLEtBQUssYUFBYSxhQUFhO0FBQUEsUUFDcEU7QUFBQSxRQUFlLFVBQVUsWUFBWSxLQUFLLFlBQVksT0FBTyxTQUFTLEtBQUs7QUFBRSxpQkFBTyxDQUFDLElBQUk7QUFBQSxRQUFnQixDQUFDLEdBQUcsYUFBYSxLQUFLLENBQUM7QUFBQSxRQUNoSTtBQUFBLFFBQWUsS0FBSyxjQUFjLEtBQUssV0FBVyxTQUFTLEtBQUssYUFBYTtBQUFBLFFBQzdFO0FBQUEsUUFBZSxLQUFLLFlBQVksS0FBSyxTQUFTLFNBQVMsS0FBSyxXQUFXO0FBQUEsUUFDdkU7QUFBQSxRQUFlLEtBQUssU0FBUztBQUFBLFFBQzdCO0FBQUEsUUFBZSxhQUFhLFVBQVUsVUFBVTtBQUFBLFFBQ2hEO0FBQUEsUUFBZSxlQUFlLEtBQUssVUFBVTtBQUFBLE1BQ2pELENBQUM7QUFBQSxJQUNMO0FBS0EsU0FBSyxVQUFVLGFBQWEsU0FBUyxhQUFhO0FBQzlDLFVBQUksU0FBUyxLQUFLLGFBQWEsSUFBSTtBQUNuQyxhQUFPLElBQUksT0FBTztBQUNkLGVBQU8sS0FBSyxRQUFRO0FBQ3hCLFVBQUksU0FBUyxLQUFLO0FBQWEsVUFBSTtBQUNuQyxhQUFPLElBQUksT0FBTztBQUNkLGVBQU8sS0FBSyxRQUFRO0FBQ3hCLGFBQU8sVUFBVSxVQUFVLFdBQVcsS0FBSyxJQUFJO0FBQUEsSUFDbkQ7QUFLQSxTQUFLLFVBQVUsTUFBTSxTQUFTLElBQUlGLE9BQU07QUFDcEMsYUFBTyxLQUFLLE9BQU9BLFVBQ1osS0FBSyxVQUFVLEtBQUssT0FBT0EsVUFDM0IsS0FBSyxVQUFVLEtBQUssT0FBT0EsVUFDM0I7QUFBQSxJQUNYO0FBU0EsU0FBSyxVQUFVLE1BQU0sU0FBUyxJQUFJLFFBQVE7QUFFdEMsVUFBSSxLQUFLLElBQUksT0FBTyxJQUFJO0FBQ3BCLGNBQU0sTUFBTSxxQkFBcUIsT0FBTyxPQUFPLFVBQVUsSUFBSTtBQUVqRSxVQUFJLGtCQUFrQixTQUFTLE9BQU8sV0FBVyxRQUFXO0FBTXhELFlBQUksS0FBSyxjQUF5QyxLQUFLLFlBQVksT0FBTyxNQUFNLEtBQUssV0FBVyxPQUFPO0FBQ25HLGdCQUFNLE1BQU0sa0JBQWtCLE9BQU8sS0FBSyxTQUFTLElBQUk7QUFDM0QsWUFBSSxLQUFLLGFBQWEsT0FBTyxFQUFFO0FBQzNCLGdCQUFNLE1BQU0sUUFBUSxPQUFPLEtBQUsscUJBQXFCLElBQUk7QUFDN0QsWUFBSSxLQUFLLGVBQWUsT0FBTyxJQUFJO0FBQy9CLGdCQUFNLE1BQU0sV0FBVyxPQUFPLE9BQU8sc0JBQXNCLElBQUk7QUFFbkUsWUFBSSxPQUFPO0FBQ1AsaUJBQU8sT0FBTyxPQUFPLE1BQU07QUFDL0IsYUFBSyxPQUFPLE9BQU8sUUFBUTtBQUMzQixlQUFPLFVBQVU7QUFDakIsZUFBTyxNQUFNLElBQUk7QUFDakIsZUFBTyxXQUFXLElBQUk7QUFBQSxNQUMxQjtBQUNBLFVBQUksa0JBQWtCLE9BQU87QUFDekIsWUFBSSxDQUFDLEtBQUs7QUFDTixlQUFLLFNBQVMsQ0FBQztBQUNuQixhQUFLLE9BQU8sT0FBTyxRQUFRO0FBQzNCLGVBQU8sTUFBTSxJQUFJO0FBQ2pCLGVBQU8sV0FBVyxJQUFJO0FBQUEsTUFDMUI7QUFDQSxhQUFPLFVBQVUsVUFBVSxJQUFJLEtBQUssTUFBTSxNQUFNO0FBQUEsSUFDcEQ7QUFTQSxTQUFLLFVBQVUsU0FBUyxTQUFTLE9BQU8sUUFBUTtBQUM1QyxVQUFJLGtCQUFrQixTQUFTLE9BQU8sV0FBVyxRQUFXO0FBSXhELFlBQUksQ0FBQyxLQUFLLFVBQVUsS0FBSyxPQUFPLE9BQU8sVUFBVTtBQUM3QyxnQkFBTSxNQUFNLFNBQVMseUJBQXlCLElBQUk7QUFFdEQsZUFBTyxLQUFLLE9BQU8sT0FBTztBQUMxQixlQUFPLFNBQVM7QUFDaEIsZUFBTyxTQUFTLElBQUk7QUFDcEIsZUFBTyxXQUFXLElBQUk7QUFBQSxNQUMxQjtBQUNBLFVBQUksa0JBQWtCLE9BQU87QUFHekIsWUFBSSxDQUFDLEtBQUssVUFBVSxLQUFLLE9BQU8sT0FBTyxVQUFVO0FBQzdDLGdCQUFNLE1BQU0sU0FBUyx5QkFBeUIsSUFBSTtBQUV0RCxlQUFPLEtBQUssT0FBTyxPQUFPO0FBQzFCLGVBQU8sU0FBUztBQUNoQixlQUFPLFNBQVMsSUFBSTtBQUNwQixlQUFPLFdBQVcsSUFBSTtBQUFBLE1BQzFCO0FBQ0EsYUFBTyxVQUFVLFVBQVUsT0FBTyxLQUFLLE1BQU0sTUFBTTtBQUFBLElBQ3ZEO0FBT0EsU0FBSyxVQUFVLGVBQWUsU0FBUyxhQUFhLElBQUk7QUFDcEQsYUFBTyxVQUFVLGFBQWEsS0FBSyxVQUFVLEVBQUU7QUFBQSxJQUNuRDtBQU9BLFNBQUssVUFBVSxpQkFBaUIsU0FBUyxlQUFlQSxPQUFNO0FBQzFELGFBQU8sVUFBVSxlQUFlLEtBQUssVUFBVUEsS0FBSTtBQUFBLElBQ3ZEO0FBT0EsU0FBSyxVQUFVLFNBQVMsU0FBU0csUUFBTyxZQUFZO0FBQ2hELGFBQU8sSUFBSSxLQUFLLEtBQUssVUFBVTtBQUFBLElBQ25DO0FBTUEsU0FBSyxVQUFVLFFBQVEsU0FBUyxRQUFRO0FBSXBDLFVBQUksV0FBVyxLQUFLLFVBQ2hCLFFBQVcsQ0FBQztBQUNoQixlQUFTLElBQUksR0FBRyxJQUFzQixLQUFLLFlBQVksUUFBUSxFQUFFO0FBQzdELGNBQU0sS0FBSyxLQUFLLGFBQWEsR0FBRyxRQUFRLEVBQUUsWUFBWTtBQUcxRCxXQUFLLFNBQVMsUUFBUSxJQUFJLEVBQUU7QUFBQSxRQUN4QixRQUFTSjtBQUFBLFFBQ1Q7QUFBQSxRQUNBO0FBQUEsTUFDSixDQUFDO0FBQ0QsV0FBSyxTQUFTLFFBQVEsSUFBSSxFQUFFO0FBQUEsUUFDeEIsUUFBU0Q7QUFBQSxRQUNUO0FBQUEsUUFDQTtBQUFBLE1BQ0osQ0FBQztBQUNELFdBQUssU0FBUyxTQUFTLElBQUksRUFBRTtBQUFBLFFBQ3pCO0FBQUEsUUFDQTtBQUFBLE1BQ0osQ0FBQztBQUNELFdBQUssYUFBYSxVQUFVLFdBQVcsSUFBSSxFQUFFO0FBQUEsUUFDekM7QUFBQSxRQUNBO0FBQUEsTUFDSixDQUFDO0FBQ0QsV0FBSyxXQUFXLFVBQVUsU0FBUyxJQUFJLEVBQUU7QUFBQSxRQUNyQztBQUFBLFFBQ0E7QUFBQSxNQUNKLENBQUM7QUFHRCxVQUFJLFVBQVUsU0FBUztBQUN2QixVQUFJLFNBQVM7QUFDVCxZQUFJLGVBQWUsT0FBTyxPQUFPLElBQUk7QUFFakMscUJBQWEsYUFBYSxLQUFLO0FBQy9CLGFBQUssYUFBYSxRQUFRLFdBQVcsS0FBSyxZQUFZO0FBR3RELHFCQUFhLFdBQVcsS0FBSztBQUM3QixhQUFLLFdBQVcsUUFBUSxTQUFTLEtBQUssWUFBWTtBQUFBLE1BRTFEO0FBRUEsYUFBTztBQUFBLElBQ1g7QUFRQSxTQUFLLFVBQVUsU0FBUyxTQUFTLGFBQWFNLFVBQVMsUUFBUTtBQUMzRCxhQUFPLEtBQUssTUFBTSxFQUFFLE9BQU9BLFVBQVMsTUFBTTtBQUFBLElBQzlDO0FBUUEsU0FBSyxVQUFVLGtCQUFrQixTQUFTLGdCQUFnQkEsVUFBUyxRQUFRO0FBQ3ZFLGFBQU8sS0FBSyxPQUFPQSxVQUFTLFVBQVUsT0FBTyxNQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sRUFBRSxPQUFPO0FBQUEsSUFDdEY7QUFVQSxTQUFLLFVBQVUsU0FBUyxTQUFTLGFBQWFDLFNBQVFDLFNBQVE7QUFDMUQsYUFBTyxLQUFLLE1BQU0sRUFBRSxPQUFPRCxTQUFRQyxPQUFNO0FBQUEsSUFDN0M7QUFTQSxTQUFLLFVBQVUsa0JBQWtCLFNBQVMsZ0JBQWdCRCxTQUFRO0FBQzlELFVBQUksRUFBRUEsbUJBQWtCUDtBQUNwQixRQUFBTyxVQUFTUCxRQUFPLE9BQU9PLE9BQU07QUFDakMsYUFBTyxLQUFLLE9BQU9BLFNBQVFBLFFBQU8sT0FBTyxDQUFDO0FBQUEsSUFDOUM7QUFPQSxTQUFLLFVBQVUsU0FBUyxTQUFTLGFBQWFELFVBQVM7QUFDbkQsYUFBTyxLQUFLLE1BQU0sRUFBRSxPQUFPQSxRQUFPO0FBQUEsSUFDdEM7QUFPQSxTQUFLLFVBQVUsYUFBYSxTQUFTLFdBQVcsUUFBUTtBQUNwRCxhQUFPLEtBQUssTUFBTSxFQUFFLFdBQVcsTUFBTTtBQUFBLElBQ3pDO0FBMkJBLFNBQUssVUFBVSxXQUFXLFNBQVMsU0FBU0EsVUFBU0gsVUFBUztBQUMxRCxhQUFPLEtBQUssTUFBTSxFQUFFLFNBQVNHLFVBQVNILFFBQU87QUFBQSxJQUNqRDtBQWlCQSxTQUFLLElBQUksU0FBUyxhQUFhLFVBQVU7QUFDckMsYUFBTyxTQUFTLGNBQWMsUUFBUTtBQUNsQyxhQUFLLGFBQWEsUUFBUSxRQUFRO0FBQUEsTUFDdEM7QUFBQSxJQUNKO0FBQUE7QUFBQTs7O0FDNWtCQTtBQUFBLHdDQUFBTSxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFHakIsUUFBSSxZQUFZO0FBQ2hCLE1BQUUsS0FBSyxZQUFZLE9BQU8sT0FBTyxVQUFVLFNBQVMsR0FBRyxjQUFjLE1BQU0sWUFBWTtBQUV2RixRQUFJLFFBQVU7QUFBZCxRQUNJLE9BQVU7QUFEZCxRQUVJLFFBQVU7QUFGZCxRQUdJLE9BQVU7QUFFZCxRQUFJO0FBQUosUUFDSTtBQURKLFFBRUk7QUFTSixhQUFTLEtBQUtDLFVBQVM7QUFDbkIsZ0JBQVUsS0FBSyxNQUFNLElBQUlBLFFBQU87QUFNaEMsV0FBSyxXQUFXLENBQUM7QUFNakIsV0FBSyxRQUFRLENBQUM7QUFBQSxJQUNsQjtBQVFBLFNBQUssV0FBVyxTQUFTLFNBQVMsTUFBTSxNQUFNO0FBQzFDLFVBQUksQ0FBQztBQUNELGVBQU8sSUFBSSxLQUFLO0FBQ3BCLFVBQUksS0FBSztBQUNMLGFBQUssV0FBVyxLQUFLLE9BQU87QUFDaEMsYUFBTyxLQUFLLFFBQVEsS0FBSyxNQUFNO0FBQUEsSUFDbkM7QUFVQSxTQUFLLFVBQVUsY0FBYyxLQUFLLEtBQUs7QUFVdkMsU0FBSyxVQUFVLFFBQVEsS0FBSztBQUk1QixhQUFTLE9BQU87QUFBQSxJQUFDO0FBU2pCLFNBQUssVUFBVSxPQUFPLFNBQVMsS0FBSyxVQUFVQSxVQUFTLFVBQVU7QUFDN0QsVUFBSSxPQUFPQSxhQUFZLFlBQVk7QUFDL0IsbUJBQVdBO0FBQ1gsUUFBQUEsV0FBVTtBQUFBLE1BQ2Q7QUFDQSxVQUFJQyxRQUFPO0FBQ1gsVUFBSSxDQUFDO0FBQ0QsZUFBTyxLQUFLLFVBQVUsTUFBTUEsT0FBTSxVQUFVRCxRQUFPO0FBRXZELFVBQUksT0FBTyxhQUFhO0FBR3hCLGVBQVMsT0FBTyxLQUFLLE1BQU07QUFFdkIsWUFBSSxDQUFDO0FBQ0Q7QUFDSixZQUFJLEtBQUs7QUFDVCxtQkFBVztBQUNYLFlBQUk7QUFDQSxnQkFBTTtBQUNWLFdBQUcsS0FBSyxJQUFJO0FBQUEsTUFDaEI7QUFHQSxlQUFTLG1CQUFtQkUsV0FBVTtBQUNsQyxZQUFJLE1BQU1BLFVBQVMsWUFBWSxrQkFBa0I7QUFDakQsWUFBSSxNQUFNLElBQUk7QUFDVixjQUFJLFVBQVVBLFVBQVMsVUFBVSxHQUFHO0FBQ3BDLGNBQUksV0FBVztBQUFRLG1CQUFPO0FBQUEsUUFDbEM7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUdBLGVBQVNDLFNBQVFELFdBQVUsUUFBUTtBQUMvQixZQUFJO0FBQ0EsY0FBSSxLQUFLLFNBQVMsTUFBTSxLQUFLLE9BQU8sT0FBTyxDQUFDLE1BQU07QUFDOUMscUJBQVMsS0FBSyxNQUFNLE1BQU07QUFDOUIsY0FBSSxDQUFDLEtBQUssU0FBUyxNQUFNO0FBQ3JCLFlBQUFELE1BQUssV0FBVyxPQUFPLE9BQU8sRUFBRSxRQUFRLE9BQU8sTUFBTTtBQUFBLGVBQ3BEO0FBQ0Qsa0JBQU0sV0FBV0M7QUFDakIsZ0JBQUksU0FBUyxNQUFNLFFBQVFELE9BQU1ELFFBQU8sR0FDcENJLFdBQ0FDLEtBQUk7QUFDUixnQkFBSSxPQUFPO0FBQ1AscUJBQU9BLEtBQUksT0FBTyxRQUFRLFFBQVEsRUFBRUE7QUFDaEMsb0JBQUlELFlBQVcsbUJBQW1CLE9BQU8sUUFBUUMsR0FBRSxLQUFLSixNQUFLLFlBQVlDLFdBQVUsT0FBTyxRQUFRRyxHQUFFO0FBQ2hHLHdCQUFNRCxTQUFRO0FBQUE7QUFDMUIsZ0JBQUksT0FBTztBQUNQLG1CQUFLQyxLQUFJLEdBQUdBLEtBQUksT0FBTyxZQUFZLFFBQVEsRUFBRUE7QUFDekMsb0JBQUlELFlBQVcsbUJBQW1CLE9BQU8sWUFBWUMsR0FBRSxLQUFLSixNQUFLLFlBQVlDLFdBQVUsT0FBTyxZQUFZRyxHQUFFO0FBQ3hHLHdCQUFNRCxXQUFVLElBQUk7QUFBQTtBQUFBLFVBQ3BDO0FBQUEsUUFDSixTQUFTLEtBQVA7QUFDRSxpQkFBTyxHQUFHO0FBQUEsUUFDZDtBQUNBLFlBQUksQ0FBQyxRQUFRLENBQUM7QUFDVixpQkFBTyxNQUFNSCxLQUFJO0FBQUEsTUFDekI7QUFHQSxlQUFTLE1BQU1DLFdBQVUsTUFBTTtBQUczQixZQUFJRCxNQUFLLE1BQU0sUUFBUUMsU0FBUSxJQUFJO0FBQy9CO0FBQ0osUUFBQUQsTUFBSyxNQUFNLEtBQUtDLFNBQVE7QUFHeEIsWUFBSUEsYUFBWSxRQUFRO0FBQ3BCLGNBQUk7QUFDQSxZQUFBQyxTQUFRRCxXQUFVLE9BQU9BLFVBQVM7QUFBQSxlQUNqQztBQUNELGNBQUU7QUFDRix1QkFBVyxXQUFXO0FBQ2xCLGdCQUFFO0FBQ0YsY0FBQUMsU0FBUUQsV0FBVSxPQUFPQSxVQUFTO0FBQUEsWUFDdEMsQ0FBQztBQUFBLFVBQ0w7QUFDQTtBQUFBLFFBQ0o7QUFHQSxZQUFJLE1BQU07QUFDTixjQUFJO0FBQ0osY0FBSTtBQUNBLHFCQUFTLEtBQUssR0FBRyxhQUFhQSxTQUFRLEVBQUUsU0FBUyxNQUFNO0FBQUEsVUFDM0QsU0FBUyxLQUFQO0FBQ0UsZ0JBQUksQ0FBQztBQUNELHFCQUFPLEdBQUc7QUFDZDtBQUFBLFVBQ0o7QUFDQSxVQUFBQyxTQUFRRCxXQUFVLE1BQU07QUFBQSxRQUM1QixPQUFPO0FBQ0gsWUFBRTtBQUNGLFVBQUFELE1BQUssTUFBTUMsV0FBVSxTQUFTLEtBQUtJLFNBQVE7QUFDdkMsY0FBRTtBQUVGLGdCQUFJLENBQUM7QUFDRDtBQUNKLGdCQUFJLEtBQUs7QUFFTCxrQkFBSSxDQUFDO0FBQ0QsdUJBQU8sR0FBRztBQUFBLHVCQUNMLENBQUM7QUFDTix1QkFBTyxNQUFNTCxLQUFJO0FBQ3JCO0FBQUEsWUFDSjtBQUNBLFlBQUFFLFNBQVFELFdBQVVJLE9BQU07QUFBQSxVQUM1QixDQUFDO0FBQUEsUUFDTDtBQUFBLE1BQ0o7QUFDQSxVQUFJLFNBQVM7QUFJYixVQUFJLEtBQUssU0FBUyxRQUFRO0FBQ3RCLG1CQUFXLENBQUUsUUFBUztBQUMxQixlQUFTLElBQUksR0FBRyxVQUFVLElBQUksU0FBUyxRQUFRLEVBQUU7QUFDN0MsWUFBSSxXQUFXTCxNQUFLLFlBQVksSUFBSSxTQUFTLEVBQUU7QUFDM0MsZ0JBQU0sUUFBUTtBQUV0QixVQUFJO0FBQ0EsZUFBT0E7QUFDWCxVQUFJLENBQUM7QUFDRCxlQUFPLE1BQU1BLEtBQUk7QUFDckIsYUFBTztBQUFBLElBQ1g7QUErQkEsU0FBSyxVQUFVLFdBQVcsU0FBUyxTQUFTLFVBQVVELFVBQVM7QUFDM0QsVUFBSSxDQUFDLEtBQUs7QUFDTixjQUFNLE1BQU0sZUFBZTtBQUMvQixhQUFPLEtBQUssS0FBSyxVQUFVQSxVQUFTLElBQUk7QUFBQSxJQUM1QztBQUtBLFNBQUssVUFBVSxhQUFhLFNBQVMsYUFBYTtBQUM5QyxVQUFJLEtBQUssU0FBUztBQUNkLGNBQU0sTUFBTSw4QkFBOEIsS0FBSyxTQUFTLElBQUksU0FBUyxPQUFPO0FBQ3hFLGlCQUFPLGFBQWEsTUFBTSxTQUFTLFVBQVUsTUFBTSxPQUFPO0FBQUEsUUFDOUQsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDO0FBQ2pCLGFBQU8sVUFBVSxVQUFVLFdBQVcsS0FBSyxJQUFJO0FBQUEsSUFDbkQ7QUFHQSxRQUFJLFdBQVc7QUFVZixhQUFTLG1CQUFtQixNQUFNLE9BQU87QUFDckMsVUFBSSxlQUFlLE1BQU0sT0FBTyxPQUFPLE1BQU0sTUFBTTtBQUNuRCxVQUFJLGNBQWM7QUFDZCxZQUFJLGNBQWMsSUFBSSxNQUFNLE1BQU0sVUFBVSxNQUFNLElBQUksTUFBTSxNQUFNLE1BQU0sTUFBTSxRQUFXLE1BQU0sT0FBTztBQUN0RyxvQkFBWSxpQkFBaUI7QUFDN0IsY0FBTSxpQkFBaUI7QUFDdkIscUJBQWEsSUFBSSxXQUFXO0FBQzVCLGVBQU87QUFBQSxNQUNYO0FBQ0EsYUFBTztBQUFBLElBQ1g7QUFRQSxTQUFLLFVBQVUsYUFBYSxTQUFTLFdBQVcsUUFBUTtBQUNwRCxVQUFJLGtCQUFrQixPQUFPO0FBRXpCLFlBQTJELE9BQU8sV0FBVyxVQUF1QyxDQUFDLE9BQU87QUFDeEgsY0FBSSxDQUFDLG1CQUFtQixNQUFNLE1BQU07QUFDaEMsaUJBQUssU0FBUyxLQUFLLE1BQU07QUFBQTtBQUFBLE1BRXJDLFdBQVcsa0JBQWtCLE1BQU07QUFFL0IsWUFBSSxTQUFTLEtBQUssT0FBTyxJQUFJO0FBQ3pCLGlCQUFPLE9BQU8sT0FBTyxRQUFRLE9BQU87QUFBQSxNQUU1QyxXQUFXLEVBQUUsa0JBQWtCLFFBQTZDO0FBRXhFLFlBQUksa0JBQWtCO0FBQ2xCLG1CQUFTLElBQUksR0FBRyxJQUFJLEtBQUssU0FBUztBQUM5QixnQkFBSSxtQkFBbUIsTUFBTSxLQUFLLFNBQVMsRUFBRTtBQUN6QyxtQkFBSyxTQUFTLE9BQU8sR0FBRyxDQUFDO0FBQUE7QUFFekIsZ0JBQUU7QUFDZCxpQkFBUyxJQUFJLEdBQUcsSUFBc0IsT0FBTyxZQUFZLFFBQVEsRUFBRTtBQUMvRCxlQUFLLFdBQVcsT0FBTyxhQUFhLEVBQUU7QUFDMUMsWUFBSSxTQUFTLEtBQUssT0FBTyxJQUFJO0FBQ3pCLGlCQUFPLE9BQU8sT0FBTyxRQUFRO0FBQUEsTUFDckM7QUFBQSxJQUtKO0FBUUEsU0FBSyxVQUFVLGdCQUFnQixTQUFTLGNBQWMsUUFBUTtBQUMxRCxVQUFJLGtCQUFrQixPQUFPO0FBRXpCLFlBQTZCLE9BQU8sV0FBVyxRQUFXO0FBQ3RELGNBQTBCLE9BQU8sZ0JBQWdCO0FBQzdDLG1CQUFPLGVBQWUsT0FBTyxPQUFPLE9BQU8sY0FBYztBQUN6RCxtQkFBTyxpQkFBaUI7QUFBQSxVQUM1QixPQUFPO0FBQ0gsZ0JBQUksUUFBUSxLQUFLLFNBQVMsUUFBUSxNQUFNO0FBRXhDLGdCQUFJLFFBQVE7QUFDUixtQkFBSyxTQUFTLE9BQU8sT0FBTyxDQUFDO0FBQUEsVUFDckM7QUFBQSxRQUNKO0FBQUEsTUFFSixXQUFXLGtCQUFrQixNQUFNO0FBRS9CLFlBQUksU0FBUyxLQUFLLE9BQU8sSUFBSTtBQUN6QixpQkFBTyxPQUFPLE9BQU8sT0FBTztBQUFBLE1BRXBDLFdBQVcsa0JBQWtCLFdBQVc7QUFFcEMsaUJBQVMsSUFBSSxHQUFHLElBQXNCLE9BQU8sWUFBWSxRQUFRLEVBQUU7QUFDL0QsZUFBSyxjQUFjLE9BQU8sYUFBYSxFQUFFO0FBRTdDLFlBQUksU0FBUyxLQUFLLE9BQU8sSUFBSTtBQUN6QixpQkFBTyxPQUFPLE9BQU8sT0FBTztBQUFBLE1BRXBDO0FBQUEsSUFDSjtBQUdBLFNBQUssYUFBYSxTQUFTLE9BQU8sUUFBUSxTQUFTO0FBQy9DLGFBQVM7QUFDVCxjQUFTO0FBQ1QsZUFBUztBQUFBLElBQ2I7QUFBQTtBQUFBOzs7QUMxV0E7QUFBQSx3Q0FBQU8sVUFBQUMsU0FBQTtBQUFBO0FBTUEsUUFBSSxPQUFPQSxRQUFPLFVBQVU7QUFFNUIsUUFBSSxRQUFRO0FBRVosUUFBSTtBQUFKLFFBQ0k7QUFFSixTQUFLLFVBQVU7QUFDZixTQUFLLFFBQVU7QUFDZixTQUFLLE9BQVU7QUFNZixTQUFLLEtBQUssS0FBSyxRQUFRLElBQUk7QUFPM0IsU0FBSyxVQUFVLFNBQVMsUUFBUSxRQUFRO0FBQ3BDLFVBQUksUUFBUTtBQUNSLFlBQUksT0FBUSxPQUFPLEtBQUssTUFBTSxHQUMxQixRQUFRLElBQUksTUFBTSxLQUFLLE1BQU0sR0FDN0IsUUFBUTtBQUNaLGVBQU8sUUFBUSxLQUFLO0FBQ2hCLGdCQUFNLFNBQVMsT0FBTyxLQUFLO0FBQy9CLGVBQU87QUFBQSxNQUNYO0FBQ0EsYUFBTyxDQUFDO0FBQUEsSUFDWjtBQU9BLFNBQUssV0FBVyxTQUFTLFNBQVMsT0FBTztBQUNyQyxVQUFJLFNBQVMsQ0FBQyxHQUNWLFFBQVM7QUFDYixhQUFPLFFBQVEsTUFBTSxRQUFRO0FBQ3pCLFlBQUksTUFBTSxNQUFNLFVBQ1osTUFBTSxNQUFNO0FBQ2hCLFlBQUksUUFBUTtBQUNSLGlCQUFPLE9BQU87QUFBQSxNQUN0QjtBQUNBLGFBQU87QUFBQSxJQUNYO0FBRUEsUUFBSSxzQkFBc0I7QUFBMUIsUUFDSSxrQkFBc0I7QUFPMUIsU0FBSyxhQUFhLFNBQVMsV0FBV0MsT0FBTTtBQUN4QyxhQUFPLHVUQUF1VCxLQUFLQSxLQUFJO0FBQUEsSUFDM1U7QUFPQSxTQUFLLFdBQVcsU0FBUyxTQUFTLE1BQU07QUFDcEMsVUFBSSxDQUFDLFlBQVksS0FBSyxJQUFJLEtBQUssS0FBSyxXQUFXLElBQUk7QUFDL0MsZUFBTyxPQUFRLEtBQUssUUFBUSxxQkFBcUIsTUFBTSxFQUFFLFFBQVEsaUJBQWlCLEtBQU0sSUFBSTtBQUNoRyxhQUFPLE1BQU07QUFBQSxJQUNqQjtBQU9BLFNBQUssVUFBVSxTQUFTLFFBQVEsS0FBSztBQUNqQyxhQUFPLElBQUksT0FBTyxDQUFDLEVBQUUsWUFBWSxJQUFJLElBQUksVUFBVSxDQUFDO0FBQUEsSUFDeEQ7QUFFQSxRQUFJLGNBQWM7QUFPbEIsU0FBSyxZQUFZLFNBQVMsVUFBVSxLQUFLO0FBQ3JDLGFBQU8sSUFBSSxVQUFVLEdBQUcsQ0FBQyxJQUNsQixJQUFJLFVBQVUsQ0FBQyxFQUNWLFFBQVEsYUFBYSxTQUFTLElBQUksSUFBSTtBQUFFLGVBQU8sR0FBRyxZQUFZO0FBQUEsTUFBRyxDQUFDO0FBQUEsSUFDbEY7QUFRQSxTQUFLLG9CQUFvQixTQUFTLGtCQUFrQixHQUFHLEdBQUc7QUFDdEQsYUFBTyxFQUFFLEtBQUssRUFBRTtBQUFBLElBQ3BCO0FBVUEsU0FBSyxlQUFlLFNBQVMsYUFBYSxNQUFNLFVBQVU7QUFHdEQsVUFBSSxLQUFLLE9BQU87QUFDWixZQUFJLFlBQVksS0FBSyxNQUFNLFNBQVMsVUFBVTtBQUMxQyxlQUFLLGFBQWEsT0FBTyxLQUFLLEtBQUs7QUFDbkMsZUFBSyxNQUFNLE9BQU87QUFDbEIsZUFBSyxhQUFhLElBQUksS0FBSyxLQUFLO0FBQUEsUUFDcEM7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNoQjtBQUdBLFVBQUksQ0FBQztBQUNELGVBQU87QUFFWCxVQUFJLE9BQU8sSUFBSSxLQUFLLFlBQVksS0FBSyxJQUFJO0FBQ3pDLFdBQUssYUFBYSxJQUFJLElBQUk7QUFDMUIsV0FBSyxPQUFPO0FBQ1osYUFBTyxlQUFlLE1BQU0sU0FBUyxFQUFFLE9BQU8sTUFBTSxZQUFZLE1BQU0sQ0FBQztBQUN2RSxhQUFPLGVBQWUsS0FBSyxXQUFXLFNBQVMsRUFBRSxPQUFPLE1BQU0sWUFBWSxNQUFNLENBQUM7QUFDakYsYUFBTztBQUFBLElBQ1g7QUFFQSxRQUFJLG9CQUFvQjtBQU94QixTQUFLLGVBQWUsU0FBUyxhQUFhLFFBQVE7QUFHOUMsVUFBSSxPQUFPO0FBQ1AsZUFBTyxPQUFPO0FBR2xCLFVBQUksQ0FBQztBQUNELGVBQU87QUFFWCxVQUFJLE1BQU0sSUFBSSxLQUFLLFNBQVMscUJBQXFCLE1BQU07QUFDdkQsV0FBSyxhQUFhLElBQUksR0FBRztBQUN6QixhQUFPLGVBQWUsUUFBUSxTQUFTLEVBQUUsT0FBTyxLQUFLLFlBQVksTUFBTSxDQUFDO0FBQ3hFLGFBQU87QUFBQSxJQUNYO0FBVUEsU0FBSyxjQUFjLFNBQVMsWUFBWSxLQUFLQyxPQUFNLE9BQU87QUFDdEQsZUFBUyxRQUFRQyxNQUFLRCxPQUFNRSxRQUFPO0FBQy9CLFlBQUksT0FBT0YsTUFBSyxNQUFNO0FBQ3RCLFlBQUksU0FBUyxhQUFhO0FBQ3hCLGlCQUFPQztBQUFBLFFBQ1Q7QUFDQSxZQUFJRCxNQUFLLFNBQVMsR0FBRztBQUNqQixVQUFBQyxLQUFJLFFBQVEsUUFBUUEsS0FBSSxTQUFTLENBQUMsR0FBR0QsT0FBTUUsTUFBSztBQUFBLFFBQ3BELE9BQU87QUFDSCxjQUFJLFlBQVlELEtBQUk7QUFDcEIsY0FBSTtBQUNBLFlBQUFDLFNBQVEsQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLE9BQU9BLE1BQUs7QUFDN0MsVUFBQUQsS0FBSSxRQUFRQztBQUFBLFFBQ2hCO0FBQ0EsZUFBT0Q7QUFBQSxNQUNYO0FBRUEsVUFBSSxPQUFPLFFBQVE7QUFDZixjQUFNLFVBQVUsdUJBQXVCO0FBQzNDLFVBQUksQ0FBQ0Q7QUFDRCxjQUFNLFVBQVUsd0JBQXdCO0FBRTVDLE1BQUFBLFFBQU9BLE1BQUssTUFBTSxHQUFHO0FBQ3JCLGFBQU8sUUFBUSxLQUFLQSxPQUFNLEtBQUs7QUFBQSxJQUNuQztBQVFBLFdBQU8sZUFBZSxNQUFNLGdCQUFnQjtBQUFBLE1BQ3hDLEtBQUssV0FBVztBQUNaLGVBQU8sTUFBTSxpQkFBaUIsTUFBTSxlQUFlLElBQUssaUJBQW1CO0FBQUEsTUFDL0U7QUFBQSxJQUNKLENBQUM7QUFBQTtBQUFBOzs7QUNuTkQ7QUFBQSwwQ0FBQUcsVUFBQUMsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVO0FBRWpCLHFCQUFpQixZQUFZO0FBRTdCLFFBQUksT0FBTztBQUVYLFFBQUk7QUFVSixhQUFTLGlCQUFpQkMsT0FBTUMsVUFBUztBQUVyQyxVQUFJLENBQUMsS0FBSyxTQUFTRCxLQUFJO0FBQ25CLGNBQU0sVUFBVSx1QkFBdUI7QUFFM0MsVUFBSUMsWUFBVyxDQUFDLEtBQUssU0FBU0EsUUFBTztBQUNqQyxjQUFNLFVBQVUsMkJBQTJCO0FBTS9DLFdBQUssVUFBVUE7QUFNZixXQUFLLGdCQUFnQjtBQU1yQixXQUFLLE9BQU9EO0FBTVosV0FBSyxTQUFTO0FBTWQsV0FBSyxXQUFXO0FBTWhCLFdBQUssVUFBVTtBQU1mLFdBQUssV0FBVztBQUFBLElBQ3BCO0FBRUEsV0FBTyxpQkFBaUIsaUJBQWlCLFdBQVc7QUFBQSxNQVFoRCxNQUFNO0FBQUEsUUFDRixLQUFLLFdBQVc7QUFDWixjQUFJLE1BQU07QUFDVixpQkFBTyxJQUFJLFdBQVc7QUFDbEIsa0JBQU0sSUFBSTtBQUNkLGlCQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFBQSxNQVFBLFVBQVU7QUFBQSxRQUNOLEtBQUssV0FBVztBQUNaLGNBQUlFLFFBQU8sQ0FBRSxLQUFLLElBQUssR0FDbkIsTUFBTSxLQUFLO0FBQ2YsaUJBQU8sS0FBSztBQUNSLFlBQUFBLE1BQUssUUFBUSxJQUFJLElBQUk7QUFDckIsa0JBQU0sSUFBSTtBQUFBLFVBQ2Q7QUFDQSxpQkFBT0EsTUFBSyxLQUFLLEdBQUc7QUFBQSxRQUN4QjtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFPRCxxQkFBaUIsVUFBVSxTQUFvQyxTQUFTLFNBQVM7QUFDN0UsWUFBTSxNQUFNO0FBQUEsSUFDaEI7QUFPQSxxQkFBaUIsVUFBVSxRQUFRLFNBQVMsTUFBTSxRQUFRO0FBQ3RELFVBQUksS0FBSyxVQUFVLEtBQUssV0FBVztBQUMvQixhQUFLLE9BQU8sT0FBTyxJQUFJO0FBQzNCLFdBQUssU0FBUztBQUNkLFdBQUssV0FBVztBQUNoQixVQUFJLE9BQU8sT0FBTztBQUNsQixVQUFJLGdCQUFnQjtBQUNoQixhQUFLLFdBQVcsSUFBSTtBQUFBLElBQzVCO0FBT0EscUJBQWlCLFVBQVUsV0FBVyxTQUFTLFNBQVMsUUFBUTtBQUM1RCxVQUFJLE9BQU8sT0FBTztBQUNsQixVQUFJLGdCQUFnQjtBQUNoQixhQUFLLGNBQWMsSUFBSTtBQUMzQixXQUFLLFNBQVM7QUFDZCxXQUFLLFdBQVc7QUFBQSxJQUNwQjtBQU1BLHFCQUFpQixVQUFVLFVBQVUsU0FBUyxVQUFVO0FBQ3BELFVBQUksS0FBSztBQUNMLGVBQU87QUFDWCxVQUFJLEtBQUssZ0JBQWdCO0FBQ3JCLGFBQUssV0FBVztBQUNwQixhQUFPO0FBQUEsSUFDWDtBQU9BLHFCQUFpQixVQUFVLFlBQVksU0FBUyxVQUFVRixPQUFNO0FBQzVELFVBQUksS0FBSztBQUNMLGVBQU8sS0FBSyxRQUFRQTtBQUN4QixhQUFPO0FBQUEsSUFDWDtBQVNBLHFCQUFpQixVQUFVLFlBQVksU0FBUyxVQUFVQSxPQUFNLE9BQU8sVUFBVTtBQUM3RSxVQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssV0FBVyxLQUFLLFFBQVFBLFdBQVU7QUFDckQsU0FBQyxLQUFLLFlBQVksS0FBSyxVQUFVLENBQUMsSUFBSUEsU0FBUTtBQUNsRCxhQUFPO0FBQUEsSUFDWDtBQVNBLHFCQUFpQixVQUFVLGtCQUFrQixTQUFTLGdCQUFnQkEsT0FBTSxPQUFPLFVBQVU7QUFDekYsVUFBSSxDQUFDLEtBQUssZUFBZTtBQUNyQixhQUFLLGdCQUFnQixDQUFDO0FBQUEsTUFDMUI7QUFDQSxVQUFJLGdCQUFnQixLQUFLO0FBQ3pCLFVBQUksVUFBVTtBQUdWLFlBQUksTUFBTSxjQUFjLEtBQUssU0FBVUcsTUFBSztBQUN4QyxpQkFBTyxPQUFPLFVBQVUsZUFBZSxLQUFLQSxNQUFLSCxLQUFJO0FBQUEsUUFDekQsQ0FBQztBQUNELFlBQUksS0FBSztBQUVMLGNBQUksV0FBVyxJQUFJQTtBQUNuQixlQUFLLFlBQVksVUFBVSxVQUFVLEtBQUs7QUFBQSxRQUM5QyxPQUFPO0FBRUgsZ0JBQU0sQ0FBQztBQUNQLGNBQUlBLFNBQVEsS0FBSyxZQUFZLENBQUMsR0FBRyxVQUFVLEtBQUs7QUFDaEQsd0JBQWMsS0FBSyxHQUFHO0FBQUEsUUFDMUI7QUFBQSxNQUNKLE9BQU87QUFFSCxZQUFJLFNBQVMsQ0FBQztBQUNkLGVBQU9BLFNBQVE7QUFDZixzQkFBYyxLQUFLLE1BQU07QUFBQSxNQUM3QjtBQUNBLGFBQU87QUFBQSxJQUNYO0FBUUEscUJBQWlCLFVBQVUsYUFBYSxTQUFTLFdBQVdDLFVBQVMsVUFBVTtBQUMzRSxVQUFJQTtBQUNBLGlCQUFTLE9BQU8sT0FBTyxLQUFLQSxRQUFPLEdBQUcsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEVBQUU7QUFDNUQsZUFBSyxVQUFVLEtBQUssSUFBSUEsU0FBUSxLQUFLLEtBQUssUUFBUTtBQUMxRCxhQUFPO0FBQUEsSUFDWDtBQU1BLHFCQUFpQixVQUFVLFdBQVcsU0FBU0csWUFBVztBQUN0RCxVQUFJLFlBQVksS0FBSyxZQUFZLFdBQzdCLFdBQVksS0FBSztBQUNyQixVQUFJLFNBQVM7QUFDVCxlQUFPLFlBQVksTUFBTTtBQUM3QixhQUFPO0FBQUEsSUFDWDtBQUdBLHFCQUFpQixhQUFhLFNBQVMsT0FBTztBQUMxQyxhQUFPO0FBQUEsSUFDWDtBQUFBO0FBQUE7OztBQ2xQQTtBQUFBLHdDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFHakIsUUFBSSxtQkFBbUI7QUFDdkIsTUFBRSxLQUFLLFlBQVksT0FBTyxPQUFPLGlCQUFpQixTQUFTLEdBQUcsY0FBYyxNQUFNLFlBQVk7QUFFOUYsUUFBSSxZQUFZO0FBQWhCLFFBQ0ksT0FBTztBQWNYLGFBQVMsS0FBS0MsT0FBTSxRQUFRQyxVQUFTLFNBQVMsVUFBVSxlQUFlO0FBQ25FLHVCQUFpQixLQUFLLE1BQU1ELE9BQU1DLFFBQU87QUFFekMsVUFBSSxVQUFVLE9BQU8sV0FBVztBQUM1QixjQUFNLFVBQVUsMEJBQTBCO0FBTTlDLFdBQUssYUFBYSxDQUFDO0FBTW5CLFdBQUssU0FBUyxPQUFPLE9BQU8sS0FBSyxVQUFVO0FBTTNDLFdBQUssVUFBVTtBQU1mLFdBQUssV0FBVyxZQUFZLENBQUM7QUFNN0IsV0FBSyxnQkFBZ0I7QUFNckIsV0FBSyxXQUFXO0FBTWhCLFVBQUk7QUFDQSxpQkFBUyxPQUFPLE9BQU8sS0FBSyxNQUFNLEdBQUcsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEVBQUU7QUFDM0QsY0FBSSxPQUFPLE9BQU8sS0FBSyxRQUFRO0FBQzNCLGlCQUFLLFdBQVksS0FBSyxPQUFPLEtBQUssTUFBTSxPQUFPLEtBQUssT0FBUSxLQUFLO0FBQUE7QUFBQSxJQUNqRjtBQWdCQSxTQUFLLFdBQVcsU0FBUyxTQUFTRCxPQUFNLE1BQU07QUFDMUMsVUFBSSxNQUFNLElBQUksS0FBS0EsT0FBTSxLQUFLLFFBQVEsS0FBSyxTQUFTLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFDL0UsVUFBSSxXQUFXLEtBQUs7QUFDcEIsYUFBTztBQUFBLElBQ1g7QUFPQSxTQUFLLFVBQVUsU0FBUyxTQUFTLE9BQU8sZUFBZTtBQUNuRCxVQUFJLGVBQWUsZ0JBQWdCLFFBQVEsY0FBYyxZQUFZLElBQUk7QUFDekUsYUFBTyxLQUFLLFNBQVM7QUFBQSxRQUNqQjtBQUFBLFFBQWtCLEtBQUs7QUFBQSxRQUN2QjtBQUFBLFFBQWtCLEtBQUs7QUFBQSxRQUN2QjtBQUFBLFFBQWtCLEtBQUs7QUFBQSxRQUN2QjtBQUFBLFFBQWtCLEtBQUssWUFBWSxLQUFLLFNBQVMsU0FBUyxLQUFLLFdBQVc7QUFBQSxRQUMxRTtBQUFBLFFBQWtCLGVBQWUsS0FBSyxVQUFVO0FBQUEsUUFDaEQ7QUFBQSxRQUFrQixlQUFlLEtBQUssV0FBVztBQUFBLE1BQ3JELENBQUM7QUFBQSxJQUNMO0FBWUEsU0FBSyxVQUFVLE1BQU0sU0FBUyxJQUFJQSxPQUFNLElBQUksU0FBU0MsVUFBUztBQUcxRCxVQUFJLENBQUMsS0FBSyxTQUFTRCxLQUFJO0FBQ25CLGNBQU0sVUFBVSx1QkFBdUI7QUFFM0MsVUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ2xCLGNBQU0sVUFBVSx1QkFBdUI7QUFFM0MsVUFBSSxLQUFLLE9BQU9BLFdBQVU7QUFDdEIsY0FBTSxNQUFNLHFCQUFxQkEsUUFBTyxVQUFVLElBQUk7QUFFMUQsVUFBSSxLQUFLLGFBQWEsRUFBRTtBQUNwQixjQUFNLE1BQU0sUUFBUSxLQUFLLHFCQUFxQixJQUFJO0FBRXRELFVBQUksS0FBSyxlQUFlQSxLQUFJO0FBQ3hCLGNBQU0sTUFBTSxXQUFXQSxRQUFPLHNCQUFzQixJQUFJO0FBRTVELFVBQUksS0FBSyxXQUFXLFFBQVEsUUFBVztBQUNuQyxZQUFJLEVBQUUsS0FBSyxXQUFXLEtBQUssUUFBUTtBQUMvQixnQkFBTSxNQUFNLGtCQUFrQixLQUFLLFNBQVMsSUFBSTtBQUNwRCxhQUFLLE9BQU9BLFNBQVE7QUFBQSxNQUN4QjtBQUNJLGFBQUssV0FBVyxLQUFLLE9BQU9BLFNBQVEsTUFBTUE7QUFFOUMsVUFBSUMsVUFBUztBQUNULFlBQUksS0FBSyxrQkFBa0I7QUFDdkIsZUFBSyxnQkFBZ0IsQ0FBQztBQUMxQixhQUFLLGNBQWNELFNBQVFDLFlBQVc7QUFBQSxNQUMxQztBQUVBLFdBQUssU0FBU0QsU0FBUSxXQUFXO0FBQ2pDLGFBQU87QUFBQSxJQUNYO0FBU0EsU0FBSyxVQUFVLFNBQVMsU0FBUyxPQUFPQSxPQUFNO0FBRTFDLFVBQUksQ0FBQyxLQUFLLFNBQVNBLEtBQUk7QUFDbkIsY0FBTSxVQUFVLHVCQUF1QjtBQUUzQyxVQUFJLE1BQU0sS0FBSyxPQUFPQTtBQUN0QixVQUFJLE9BQU87QUFDUCxjQUFNLE1BQU0sV0FBV0EsUUFBTyx5QkFBeUIsSUFBSTtBQUUvRCxhQUFPLEtBQUssV0FBVztBQUN2QixhQUFPLEtBQUssT0FBT0E7QUFDbkIsYUFBTyxLQUFLLFNBQVNBO0FBQ3JCLFVBQUksS0FBSztBQUNMLGVBQU8sS0FBSyxjQUFjQTtBQUU5QixhQUFPO0FBQUEsSUFDWDtBQU9BLFNBQUssVUFBVSxlQUFlLFNBQVMsYUFBYSxJQUFJO0FBQ3BELGFBQU8sVUFBVSxhQUFhLEtBQUssVUFBVSxFQUFFO0FBQUEsSUFDbkQ7QUFPQSxTQUFLLFVBQVUsaUJBQWlCLFNBQVMsZUFBZUEsT0FBTTtBQUMxRCxhQUFPLFVBQVUsZUFBZSxLQUFLLFVBQVVBLEtBQUk7QUFBQSxJQUN2RDtBQUFBO0FBQUE7OztBQ3JNQTtBQUFBLDJDQUFBRSxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFFakIsUUFBSSxPQUFXO0FBQWYsUUFDSSxRQUFXO0FBRGYsUUFFSSxPQUFXO0FBV2YsYUFBUyxlQUFlLEtBQUssT0FBTyxZQUFZLEtBQUs7QUFDakQsYUFBTyxNQUFNLGFBQWEsUUFDcEIsSUFBSSxnREFBZ0QsWUFBWSxNQUFNLE1BQU0sTUFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLE1BQU0sSUFBSSxPQUFPLENBQUMsSUFDekgsSUFBSSxxREFBcUQsWUFBWSxNQUFNLE1BQU0sTUFBTSxJQUFJLE9BQU8sQ0FBQztBQUFBLElBQzdHO0FBT0EsYUFBUyxRQUFRLE9BQU87QUFFcEIsVUFBSSxNQUFNLEtBQUssUUFBUSxDQUFDLEtBQUssR0FBRyxHQUFHLE1BQU0sT0FBTyxTQUFTLEVBQ3hELFFBQVEsRUFDSixtQkFBbUI7QUFFeEIsVUFBSSxHQUFHO0FBR1AsVUFBSSxTQUEyQixNQUFNLFlBQVksTUFBTSxFQUFFLEtBQUssS0FBSyxpQkFBaUI7QUFFcEYsZUFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsRUFBRSxHQUFHO0FBQ3BDLFlBQUksUUFBVyxPQUFPLEdBQUcsUUFBUSxHQUM3QixRQUFXLE1BQU0sYUFBYSxRQUFRLEtBQUssR0FDM0MsT0FBVyxNQUFNLHdCQUF3QixPQUFPLFVBQVUsTUFBTSxNQUNoRSxXQUFXLE1BQU0sTUFBTTtBQUN2QixjQUFXLE1BQU0sS0FBSyxTQUFTLE1BQU0sSUFBSTtBQUc3QyxZQUFJLE1BQU0sS0FBSztBQUNYLGNBQ1AsbURBQW1ELEtBQUssTUFBTSxJQUFJLEVBQzlELG9EQUFvRCxHQUFHLEVBQ25ELDZDQUE2QyxNQUFNLE1BQU0sSUFBSSxPQUFPLEdBQUcsSUFBSSxNQUFNLE9BQU8sTUFBTSxVQUFVLE1BQU0sT0FBTztBQUN0SCxjQUFJLGFBQWE7QUFBVyxnQkFDM0IscUVBQXFFLE9BQU8sR0FBRztBQUFBO0FBQzNFLGdCQUNKLHNDQUFzQyxLQUFLLFVBQVUsTUFBTSxHQUFHO0FBQy9ELGNBQ0gsR0FBRyxFQUNQLEdBQUc7QUFBQSxRQUdBLFdBQVcsTUFBTSxVQUFVO0FBQUUsY0FDaEMsNEJBQTRCLEtBQUssR0FBRztBQUc3QixjQUFJLE1BQU0sVUFBVSxNQUFNLE9BQU8sVUFBVSxRQUFXO0FBQUUsZ0JBRTNELHdCQUF3QixNQUFNLE1BQU0sSUFBSSxPQUFPLENBQUMsRUFDaEQsZ0NBQWdDLEdBQUcsRUFDL0IsZUFBZSxNQUFNLEdBQUcsRUFDNUIsWUFBWTtBQUFBLFVBR1QsT0FBTztBQUFFLGdCQUVaLGdDQUFnQyxHQUFHO0FBQzVCLGdCQUFJLGFBQWE7QUFDckIsNkJBQWUsS0FBSyxPQUFPLE9BQU8sTUFBTSxLQUFLO0FBQUE7QUFDcEMsa0JBQ1IsMkJBQTJCLE1BQU0sTUFBTSxJQUFJLGNBQWMsR0FBRyxNQUFNLEdBQUc7QUFBQSxVQUV0RTtBQUFFLGNBQ1QsR0FBRztBQUFBLFFBR0EsT0FBTztBQUNILGNBQUksTUFBTTtBQUFVLGdCQUMzQixrREFBa0QsS0FBSyxNQUFNLElBQUk7QUFFMUQsY0FBSSxhQUFhO0FBQ3JCLDJCQUFlLEtBQUssT0FBTyxPQUFPLEdBQUc7QUFBQTtBQUM1QixnQkFDUix3QkFBd0IsTUFBTSxNQUFNLElBQUksY0FBYyxHQUFHLE1BQU0sR0FBRztBQUFBLFFBRW5FO0FBQUEsTUFDSjtBQUVBLGFBQU8sSUFDTixVQUFVO0FBQUEsSUFFZjtBQUFBO0FBQUE7OztBQ25HQTtBQUFBLCtDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxRQUFJLFdBQVdBLFFBQU8sVUFBVTtBQUVoQyxhQUFTLFFBQVE7QUFtQmpCLGFBQVMsS0FBSyxVQUFVLE1BQU0sVUFBVTtBQUNwQyxVQUFJLE9BQU8sU0FBUyxZQUFZO0FBQzVCLG1CQUFXO0FBQ1gsZUFBTyxJQUFJLFNBQVMsS0FBSztBQUFBLE1BQzdCLFdBQVcsQ0FBQztBQUNSLGVBQU8sSUFBSSxTQUFTLEtBQUs7QUFDN0IsYUFBTyxLQUFLLEtBQUssVUFBVSxRQUFRO0FBQUEsSUFDdkM7QUEwQkEsYUFBUyxPQUFPO0FBVWhCLGFBQVMsU0FBUyxVQUFVLE1BQU07QUFDOUIsVUFBSSxDQUFDO0FBQ0QsZUFBTyxJQUFJLFNBQVMsS0FBSztBQUM3QixhQUFPLEtBQUssU0FBUyxRQUFRO0FBQUEsSUFDakM7QUFFQSxhQUFTLFdBQVc7QUFHcEIsYUFBUyxVQUFtQjtBQUM1QixhQUFTLFVBQW1CO0FBQzVCLGFBQVMsV0FBbUI7QUFDNUIsYUFBUyxZQUFtQjtBQUc1QixhQUFTLG1CQUFtQjtBQUM1QixhQUFTLFlBQW1CO0FBQzVCLGFBQVMsT0FBbUI7QUFDNUIsYUFBUyxPQUFtQjtBQUM1QixhQUFTLE9BQW1CO0FBQzVCLGFBQVMsUUFBbUI7QUFDNUIsYUFBUyxRQUFtQjtBQUM1QixhQUFTLFdBQW1CO0FBQzVCLGFBQVMsVUFBbUI7QUFDNUIsYUFBUyxTQUFtQjtBQUc1QixhQUFTLFVBQW1CO0FBQzVCLGFBQVMsV0FBbUI7QUFHNUIsYUFBUyxRQUFtQjtBQUM1QixhQUFTLE9BQW1CO0FBRzVCLGFBQVMsaUJBQWlCLFdBQVcsU0FBUyxJQUFJO0FBQ2xELGFBQVMsVUFBVSxXQUFXLFNBQVMsTUFBTSxTQUFTLFNBQVMsU0FBUyxJQUFJO0FBQzVFLGFBQVMsS0FBSyxXQUFXLFNBQVMsSUFBSTtBQUN0QyxhQUFTLE1BQU0sV0FBVyxTQUFTLElBQUk7QUFBQTtBQUFBOzs7QUN2R3ZDO0FBQUEsNENBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVTtBQUVqQixRQUFJLFVBQWlCO0FBQXJCLFFBQ0ksaUJBQWlCO0FBRHJCLFFBRUksaUJBQWlCO0FBRXJCLFFBQUksZUFBZTtBQUFuQixRQUNJLGtCQUFrQjtBQUR0QixRQUVJLG9CQUFvQjtBQUZ4QixRQUdJLGVBQWU7QUFIbkIsUUFJSSxhQUFhO0FBRWpCLFFBQUksY0FBYztBQUFBLE1BQ2QsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLElBQ1Q7QUFTQSxhQUFTQyxVQUFTLEtBQUs7QUFDbkIsYUFBTyxJQUFJLFFBQVEsWUFBWSxTQUFTLElBQUksSUFBSTtBQUM1QyxnQkFBUTtBQUFBLGVBQ0M7QUFBQSxlQUNBO0FBQ0QsbUJBQU87QUFBQTtBQUVQLG1CQUFPLFlBQVksT0FBTztBQUFBO0FBQUEsTUFFdEMsQ0FBQztBQUFBLElBQ0w7QUFFQSxhQUFTLFdBQVdBO0FBMkRwQixhQUFTLFNBQVMsUUFBUSxzQkFBc0I7QUFFNUMsZUFBUyxPQUFPLFNBQVM7QUFFekIsVUFBSSxTQUFTLEdBQ1RDLFVBQVMsT0FBTyxRQUNoQixPQUFPLEdBQ1Asa0JBQWtCLEdBQ2xCLFdBQVcsQ0FBQztBQUVoQixVQUFJLFFBQVEsQ0FBQztBQUViLFVBQUksY0FBYztBQVNsQixlQUFTLFFBQVEsU0FBUztBQUN0QixlQUFPLE1BQU0sYUFBYSxVQUFVLFlBQVksT0FBTyxHQUFHO0FBQUEsTUFDOUQ7QUFPQSxlQUFTLGFBQWE7QUFDbEIsWUFBSSxLQUFLLGdCQUFnQixNQUFNLGlCQUFpQjtBQUNoRCxXQUFHLFlBQVksU0FBUztBQUN4QixZQUFJLFFBQVEsR0FBRyxLQUFLLE1BQU07QUFDMUIsWUFBSSxDQUFDO0FBQ0QsZ0JBQU0sUUFBUSxRQUFRO0FBQzFCLGlCQUFTLEdBQUc7QUFDWixhQUFLLFdBQVc7QUFDaEIsc0JBQWM7QUFDZCxlQUFPRCxVQUFTLE1BQU0sRUFBRTtBQUFBLE1BQzVCO0FBUUEsZUFBUyxPQUFPLEtBQUs7QUFDakIsZUFBTyxPQUFPLE9BQU8sR0FBRztBQUFBLE1BQzVCO0FBVUEsZUFBUyxXQUFXLE9BQU8sS0FBSyxXQUFXO0FBQ3ZDLFlBQUksVUFBVTtBQUFBLFVBQ1YsTUFBTSxPQUFPLE9BQU8sT0FBTztBQUFBLFVBQzNCLFdBQVc7QUFBQSxVQUNYLFNBQVM7QUFBQSxRQUNiO0FBQ0EsWUFBSTtBQUNKLFlBQUksc0JBQXNCO0FBQ3RCLHFCQUFXO0FBQUEsUUFDZixPQUFPO0FBQ0gscUJBQVc7QUFBQSxRQUNmO0FBQ0EsWUFBSSxnQkFBZ0IsUUFBUSxVQUN4QjtBQUNKLFdBQUc7QUFDQyxjQUFJLEVBQUUsZ0JBQWdCLE1BQ2IsSUFBSSxPQUFPLE9BQU8sYUFBYSxPQUFPLE1BQU07QUFDakQsb0JBQVEsWUFBWTtBQUNwQjtBQUFBLFVBQ0o7QUFBQSxRQUNKLFNBQVMsTUFBTSxPQUFPLE1BQU07QUFDNUIsWUFBSSxRQUFRLE9BQ1AsVUFBVSxPQUFPLEdBQUcsRUFDcEIsTUFBTSxpQkFBaUI7QUFDNUIsaUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEVBQUU7QUFDaEMsZ0JBQU0sS0FBSyxNQUFNLEdBQ1osUUFBUSx1QkFBdUIsa0JBQWtCLGNBQWMsRUFBRSxFQUNqRSxLQUFLO0FBQ2QsZ0JBQVEsT0FBTyxNQUNWLEtBQUssSUFBSSxFQUNULEtBQUs7QUFFVixpQkFBUyxRQUFRO0FBQ2pCLDBCQUFrQjtBQUFBLE1BQ3RCO0FBRUEsZUFBUyx5QkFBeUIsYUFBYTtBQUMzQyxZQUFJLFlBQVksY0FBYyxXQUFXO0FBR3pDLFlBQUksV0FBVyxPQUFPLFVBQVUsYUFBYSxTQUFTO0FBR3RELFlBQUksWUFBWSxjQUFjLEtBQUssUUFBUTtBQUMzQyxlQUFPO0FBQUEsTUFDWDtBQUVBLGVBQVMsY0FBYyxRQUFRO0FBRTNCLFlBQUksWUFBWTtBQUNoQixlQUFPLFlBQVlDLFdBQVUsT0FBTyxTQUFTLE1BQU0sTUFBTTtBQUNyRDtBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQU9BLGVBQVMsT0FBTztBQUNaLFlBQUksTUFBTSxTQUFTO0FBQ2YsaUJBQU8sTUFBTSxNQUFNO0FBQ3ZCLFlBQUk7QUFDQSxpQkFBTyxXQUFXO0FBQ3RCLFlBQUksUUFDQSxNQUNBLE1BQ0EsT0FDQSxPQUNBLG1CQUFtQixXQUFXO0FBQ2xDLFdBQUc7QUFDQyxjQUFJLFdBQVdBO0FBQ1gsbUJBQU87QUFDWCxtQkFBUztBQUNULGlCQUFPLGFBQWEsS0FBSyxPQUFPLE9BQU8sTUFBTSxDQUFDLEdBQUc7QUFDN0MsZ0JBQUksU0FBUyxNQUFNO0FBQ2YsaUNBQW1CO0FBQ25CLGdCQUFFO0FBQUEsWUFDTjtBQUNBLGdCQUFJLEVBQUUsV0FBV0E7QUFDYixxQkFBTztBQUFBLFVBQ2Y7QUFFQSxjQUFJLE9BQU8sTUFBTSxNQUFNLEtBQUs7QUFDeEIsZ0JBQUksRUFBRSxXQUFXQSxTQUFRO0FBQ3JCLG9CQUFNLFFBQVEsU0FBUztBQUFBLFlBQzNCO0FBQ0EsZ0JBQUksT0FBTyxNQUFNLE1BQU0sS0FBSztBQUN4QixrQkFBSSxDQUFDLHNCQUFzQjtBQUV2Qix3QkFBUSxPQUFPLFFBQVEsU0FBUyxDQUFDLE1BQU07QUFFdkMsdUJBQU8sT0FBTyxFQUFFLE1BQU0sTUFBTSxNQUFNO0FBQzlCLHNCQUFJLFdBQVdBLFNBQVE7QUFDbkIsMkJBQU87QUFBQSxrQkFDWDtBQUFBLGdCQUNKO0FBQ0Esa0JBQUU7QUFDRixvQkFBSSxPQUFPO0FBQ1AsNkJBQVcsT0FBTyxTQUFTLEdBQUcsZ0JBQWdCO0FBRzlDLHFDQUFtQjtBQUFBLGdCQUN2QjtBQUNBLGtCQUFFO0FBQ0YseUJBQVM7QUFBQSxjQUNiLE9BQU87QUFFSCx3QkFBUTtBQUNSLHdCQUFRO0FBQ1Isb0JBQUkseUJBQXlCLE1BQU0sR0FBRztBQUNsQywwQkFBUTtBQUNSLHFCQUFHO0FBQ0MsNkJBQVMsY0FBYyxNQUFNO0FBQzdCLHdCQUFJLFdBQVdBLFNBQVE7QUFDbkI7QUFBQSxvQkFDSjtBQUNBO0FBQ0Esd0JBQUksQ0FBQyxrQkFBa0I7QUFFbkI7QUFBQSxvQkFDSjtBQUFBLGtCQUNKLFNBQVMseUJBQXlCLE1BQU07QUFBQSxnQkFDNUMsT0FBTztBQUNILDJCQUFTLEtBQUssSUFBSUEsU0FBUSxjQUFjLE1BQU0sSUFBSSxDQUFDO0FBQUEsZ0JBQ3ZEO0FBQ0Esb0JBQUksT0FBTztBQUNQLDZCQUFXLE9BQU8sUUFBUSxnQkFBZ0I7QUFDMUMscUNBQW1CO0FBQUEsZ0JBQ3ZCO0FBQ0E7QUFDQSx5QkFBUztBQUFBLGNBQ2I7QUFBQSxZQUNKLFlBQVksT0FBTyxPQUFPLE1BQU0sT0FBTyxLQUFLO0FBRXhDLHNCQUFRLFNBQVM7QUFDakIsc0JBQVEsd0JBQXdCLE9BQU8sS0FBSyxNQUFNO0FBQ2xELGlCQUFHO0FBQ0Msb0JBQUksU0FBUyxNQUFNO0FBQ2Ysb0JBQUU7QUFBQSxnQkFDTjtBQUNBLG9CQUFJLEVBQUUsV0FBV0EsU0FBUTtBQUNyQix3QkFBTSxRQUFRLFNBQVM7QUFBQSxnQkFDM0I7QUFDQSx1QkFBTztBQUNQLHVCQUFPLE9BQU8sTUFBTTtBQUFBLGNBQ3hCLFNBQVMsU0FBUyxPQUFPLFNBQVM7QUFDbEMsZ0JBQUU7QUFDRixrQkFBSSxPQUFPO0FBQ1AsMkJBQVcsT0FBTyxTQUFTLEdBQUcsZ0JBQWdCO0FBQzlDLG1DQUFtQjtBQUFBLGNBQ3ZCO0FBQ0EsdUJBQVM7QUFBQSxZQUNiLE9BQU87QUFDSCxxQkFBTztBQUFBLFlBQ1g7QUFBQSxVQUNKO0FBQUEsUUFDSixTQUFTO0FBSVQsWUFBSSxNQUFNO0FBQ1YsZ0JBQVEsWUFBWTtBQUNwQixZQUFJLFFBQVEsUUFBUSxLQUFLLE9BQU8sS0FBSyxDQUFDO0FBQ3RDLFlBQUksQ0FBQztBQUNELGlCQUFPLE1BQU1BLFdBQVUsQ0FBQyxRQUFRLEtBQUssT0FBTyxHQUFHLENBQUM7QUFDNUMsY0FBRTtBQUNWLFlBQUksUUFBUSxPQUFPLFVBQVUsUUFBUSxTQUFTLEdBQUc7QUFDakQsWUFBSSxVQUFVLE9BQVEsVUFBVTtBQUM1Qix3QkFBYztBQUNsQixlQUFPO0FBQUEsTUFDWDtBQVFBLGVBQVMsS0FBSyxPQUFPO0FBQ2pCLGNBQU0sS0FBSyxLQUFLO0FBQUEsTUFDcEI7QUFPQSxlQUFTLE9BQU87QUFDWixZQUFJLENBQUMsTUFBTSxRQUFRO0FBQ2YsY0FBSSxRQUFRLEtBQUs7QUFDakIsY0FBSSxVQUFVO0FBQ1YsbUJBQU87QUFDWCxlQUFLLEtBQUs7QUFBQSxRQUNkO0FBQ0EsZUFBTyxNQUFNO0FBQUEsTUFDakI7QUFVQSxlQUFTLEtBQUssVUFBVSxVQUFVO0FBQzlCLFlBQUksU0FBUyxLQUFLLEdBQ2RDLFVBQVMsV0FBVztBQUN4QixZQUFJQSxTQUFRO0FBQ1IsZUFBSztBQUNMLGlCQUFPO0FBQUEsUUFDWDtBQUNBLFlBQUksQ0FBQztBQUNELGdCQUFNLFFBQVEsWUFBWSxTQUFTLFNBQVMsV0FBVyxZQUFZO0FBQ3ZFLGVBQU87QUFBQSxNQUNYO0FBUUEsZUFBUyxLQUFLLGNBQWM7QUFDeEIsWUFBSSxNQUFNO0FBQ1YsWUFBSTtBQUNKLFlBQUksaUJBQWlCLFFBQVc7QUFDNUIsb0JBQVUsU0FBUyxPQUFPO0FBQzFCLGlCQUFPLFNBQVMsT0FBTztBQUN2QixjQUFJLFlBQVksd0JBQXdCLFFBQVEsU0FBUyxPQUFPLFFBQVEsWUFBWTtBQUNoRixrQkFBTSxRQUFRLFVBQVUsUUFBUSxPQUFPO0FBQUEsVUFDM0M7QUFBQSxRQUNKLE9BQU87QUFFSCxjQUFJLGtCQUFrQixjQUFjO0FBQ2hDLGlCQUFLO0FBQUEsVUFDVDtBQUNBLG9CQUFVLFNBQVM7QUFDbkIsaUJBQU8sU0FBUztBQUNoQixjQUFJLFdBQVcsQ0FBQyxRQUFRLGNBQWMsd0JBQXdCLFFBQVEsU0FBUyxNQUFNO0FBQ2pGLGtCQUFNLFFBQVEsVUFBVSxPQUFPLFFBQVE7QUFBQSxVQUMzQztBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUVBLGFBQU8sT0FBTyxlQUFlO0FBQUEsUUFDekI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDSixHQUFHLFFBQVE7QUFBQSxRQUNQLEtBQUssV0FBVztBQUFFLGlCQUFPO0FBQUEsUUFBTTtBQUFBLE1BQ25DLENBQUM7QUFBQSxJQUVMO0FBQUE7QUFBQTs7O0FDamFBO0FBQUEseUNBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQUNBLElBQUFBLFFBQU8sVUFBVTtBQUVqQixVQUFNLFdBQVc7QUFDakIsVUFBTSxXQUFXLEVBQUUsVUFBVSxNQUFNO0FBRW5DLFFBQUksV0FBWTtBQUFoQixRQUNJLE9BQVk7QUFEaEIsUUFFSSxPQUFZO0FBRmhCLFFBR0ksUUFBWTtBQUhoQixRQUlJLFdBQVk7QUFKaEIsUUFLSSxRQUFZO0FBTGhCLFFBTUksT0FBWTtBQU5oQixRQU9JLFVBQVk7QUFQaEIsUUFRSSxTQUFZO0FBUmhCLFFBU0ksUUFBWTtBQVRoQixRQVVJLE9BQVk7QUFFaEIsUUFBSSxXQUFjO0FBQWxCLFFBQ0ksY0FBYztBQURsQixRQUVJLFdBQWM7QUFGbEIsUUFHSSxjQUFjO0FBSGxCLFFBSUksVUFBYztBQUpsQixRQUtJLGFBQWM7QUFMbEIsUUFNSSxXQUFjO0FBTmxCLFFBT0ksU0FBYztBQVBsQixRQVFJLFlBQWM7QUFSbEIsUUFTSSxjQUFjO0FBbUNsQixhQUFTLE1BQU0sUUFBUSxNQUFNQyxVQUFTO0FBRWxDLFVBQUksRUFBRSxnQkFBZ0IsT0FBTztBQUN6QixRQUFBQSxXQUFVO0FBQ1YsZUFBTyxJQUFJLEtBQUs7QUFBQSxNQUNwQjtBQUNBLFVBQUksQ0FBQ0E7QUFDRCxRQUFBQSxXQUFVLE1BQU07QUFFcEIsVUFBSSx3QkFBd0JBLFNBQVEseUJBQXlCO0FBQzdELFVBQUksS0FBSyxTQUFTLFFBQVFBLFNBQVEsd0JBQXdCLEtBQUssR0FDM0QsT0FBTyxHQUFHLE1BQ1YsT0FBTyxHQUFHLE1BQ1YsT0FBTyxHQUFHLE1BQ1YsT0FBTyxHQUFHLE1BQ1YsT0FBTyxHQUFHO0FBRWQsVUFBSSxPQUFPLE1BQ1AsS0FDQSxTQUNBLGFBQ0EsUUFDQSxXQUFXO0FBRWYsVUFBSSxNQUFNO0FBRVYsVUFBSSxZQUFZQSxTQUFRLFdBQVcsU0FBU0MsT0FBTTtBQUFFLGVBQU9BO0FBQUEsTUFBTSxJQUFJLEtBQUs7QUFHMUUsZUFBUyxRQUFRQyxRQUFPRCxPQUFNLGdCQUFnQjtBQUMxQyxZQUFJLFdBQVcsTUFBTTtBQUNyQixZQUFJLENBQUM7QUFDRCxnQkFBTSxXQUFXO0FBQ3JCLGVBQU8sTUFBTSxjQUFjQSxTQUFRLFdBQVcsT0FBT0MsU0FBUSxTQUFTLFdBQVcsV0FBVyxPQUFPLE1BQU0sVUFBVSxHQUFHLE9BQU8sR0FBRztBQUFBLE1BQ3BJO0FBRUEsZUFBUyxhQUFhO0FBQ2xCLFlBQUksU0FBUyxDQUFDLEdBQ1ZBO0FBQ0osV0FBRztBQUVDLGVBQUtBLFNBQVEsS0FBSyxPQUFPLE9BQVFBLFdBQVU7QUFDdkMsa0JBQU0sUUFBUUEsTUFBSztBQUV2QixpQkFBTyxLQUFLLEtBQUssQ0FBQztBQUNsQixlQUFLQSxNQUFLO0FBQ1YsVUFBQUEsU0FBUSxLQUFLO0FBQUEsUUFDakIsU0FBU0EsV0FBVSxPQUFRQSxXQUFVO0FBQ3JDLGVBQU8sT0FBTyxLQUFLLEVBQUU7QUFBQSxNQUN6QjtBQUVBLGVBQVMsVUFBVSxlQUFlO0FBQzlCLFlBQUlBLFNBQVEsS0FBSztBQUNqQixnQkFBUUE7QUFBQSxlQUNDO0FBQUEsZUFDQTtBQUNELGlCQUFLQSxNQUFLO0FBQ1YsbUJBQU8sV0FBVztBQUFBLGVBQ2pCO0FBQUEsZUFBYTtBQUNkLG1CQUFPO0FBQUEsZUFDTjtBQUFBLGVBQWM7QUFDZixtQkFBTztBQUFBO0FBRWYsWUFBSTtBQUNBLGlCQUFPLFlBQVlBLFFBQTRCLElBQUk7QUFBQSxRQUN2RCxTQUFTLEdBQVA7QUFHRSxjQUFJLGlCQUFpQixVQUFVLEtBQUtBLE1BQUs7QUFDckMsbUJBQU9BO0FBR1gsZ0JBQU0sUUFBUUEsUUFBTyxPQUFPO0FBQUEsUUFDaEM7QUFBQSxNQUNKO0FBRUEsZUFBUyxXQUFXLFFBQVEsZUFBZTtBQUN2QyxZQUFJQSxRQUFPO0FBQ1gsV0FBRztBQUNDLGNBQUksbUJBQW1CQSxTQUFRLEtBQUssT0FBTyxPQUFRQSxXQUFVO0FBQ3pELG1CQUFPLEtBQUssV0FBVyxDQUFDO0FBQUE7QUFFeEIsbUJBQU8sS0FBSyxDQUFFLFFBQVEsUUFBUSxLQUFLLENBQUMsR0FBRyxLQUFLLE1BQU0sSUFBSSxJQUFJLFFBQVEsS0FBSyxDQUFDLElBQUksS0FBTSxDQUFDO0FBQUEsUUFDM0YsU0FBUyxLQUFLLEtBQUssSUFBSTtBQUN2QixhQUFLLEdBQUc7QUFBQSxNQUNaO0FBRUEsZUFBUyxZQUFZQSxRQUFPLGdCQUFnQjtBQUN4QyxZQUFJQyxRQUFPO0FBQ1gsWUFBSUQsT0FBTSxPQUFPLENBQUMsTUFBTSxLQUFLO0FBQ3pCLFVBQUFDLFFBQU87QUFDUCxVQUFBRCxTQUFRQSxPQUFNLFVBQVUsQ0FBQztBQUFBLFFBQzdCO0FBQ0EsZ0JBQVFBO0FBQUEsZUFDQztBQUFBLGVBQVk7QUFBQSxlQUFZO0FBQ3pCLG1CQUFPQyxRQUFPO0FBQUEsZUFDYjtBQUFBLGVBQVk7QUFBQSxlQUFZO0FBQUEsZUFBWTtBQUNyQyxtQkFBTztBQUFBLGVBQ047QUFDRCxtQkFBTztBQUFBO0FBRWYsWUFBSSxTQUFTLEtBQUtELE1BQUs7QUFDbkIsaUJBQU9DLFFBQU8sU0FBU0QsUUFBTyxFQUFFO0FBQ3BDLFlBQUksU0FBUyxLQUFLQSxNQUFLO0FBQ25CLGlCQUFPQyxRQUFPLFNBQVNELFFBQU8sRUFBRTtBQUNwQyxZQUFJLFFBQVEsS0FBS0EsTUFBSztBQUNsQixpQkFBT0MsUUFBTyxTQUFTRCxRQUFPLENBQUM7QUFHbkMsWUFBSSxTQUFTLEtBQUtBLE1BQUs7QUFDbkIsaUJBQU9DLFFBQU8sV0FBV0QsTUFBSztBQUdsQyxjQUFNLFFBQVFBLFFBQU8sVUFBVSxjQUFjO0FBQUEsTUFDakQ7QUFFQSxlQUFTLFFBQVFBLFFBQU8sZ0JBQWdCO0FBQ3BDLGdCQUFRQTtBQUFBLGVBQ0M7QUFBQSxlQUFZO0FBQUEsZUFBWTtBQUN6QixtQkFBTztBQUFBLGVBQ047QUFDRCxtQkFBTztBQUFBO0FBSWYsWUFBSSxDQUFDLGtCQUFrQkEsT0FBTSxPQUFPLENBQUMsTUFBTTtBQUN2QyxnQkFBTSxRQUFRQSxRQUFPLElBQUk7QUFFN0IsWUFBSSxZQUFZLEtBQUtBLE1BQUs7QUFDdEIsaUJBQU8sU0FBU0EsUUFBTyxFQUFFO0FBQzdCLFlBQUksWUFBWSxLQUFLQSxNQUFLO0FBQ3RCLGlCQUFPLFNBQVNBLFFBQU8sRUFBRTtBQUc3QixZQUFJLFdBQVcsS0FBS0EsTUFBSztBQUNyQixpQkFBTyxTQUFTQSxRQUFPLENBQUM7QUFHNUIsY0FBTSxRQUFRQSxRQUFPLElBQUk7QUFBQSxNQUM3QjtBQUVBLGVBQVMsZUFBZTtBQUdwQixZQUFJLFFBQVE7QUFDUixnQkFBTSxRQUFRLFNBQVM7QUFFM0IsY0FBTSxLQUFLO0FBR1gsWUFBSSxDQUFDLFVBQVUsS0FBSyxHQUFHO0FBQ25CLGdCQUFNLFFBQVEsS0FBSyxNQUFNO0FBRTdCLGNBQU0sSUFBSSxPQUFPLEdBQUc7QUFDcEIsYUFBSyxHQUFHO0FBQUEsTUFDWjtBQUVBLGVBQVMsY0FBYztBQUNuQixZQUFJQSxTQUFRLEtBQUs7QUFDakIsWUFBSTtBQUNKLGdCQUFRQTtBQUFBLGVBQ0M7QUFDRCwyQkFBZSxnQkFBZ0IsY0FBYyxDQUFDO0FBQzlDLGlCQUFLO0FBQ0w7QUFBQSxlQUNDO0FBQ0QsaUJBQUs7QUFBQTtBQUdMLDJCQUFlLFlBQVksVUFBVSxDQUFDO0FBQ3RDO0FBQUE7QUFFUixRQUFBQSxTQUFRLFdBQVc7QUFDbkIsYUFBSyxHQUFHO0FBQ1IscUJBQWEsS0FBS0EsTUFBSztBQUFBLE1BQzNCO0FBRUEsZUFBUyxjQUFjO0FBQ25CLGFBQUssR0FBRztBQUNSLGlCQUFTLFdBQVc7QUFDcEIsbUJBQVcsV0FBVztBQUd0QixZQUFJLENBQUMsWUFBWSxXQUFXO0FBQ3hCLGdCQUFNLFFBQVEsUUFBUSxRQUFRO0FBRWxDLGFBQUssR0FBRztBQUFBLE1BQ1o7QUFFQSxlQUFTLFlBQVksUUFBUUEsUUFBTztBQUNoQyxnQkFBUUE7QUFBQSxlQUVDO0FBQ0Qsd0JBQVksUUFBUUEsTUFBSztBQUN6QixpQkFBSyxHQUFHO0FBQ1IsbUJBQU87QUFBQSxlQUVOO0FBQ0Qsc0JBQVUsUUFBUUEsTUFBSztBQUN2QixtQkFBTztBQUFBLGVBRU47QUFDRCxzQkFBVSxRQUFRQSxNQUFLO0FBQ3ZCLG1CQUFPO0FBQUEsZUFFTjtBQUNELHlCQUFhLFFBQVFBLE1BQUs7QUFDMUIsbUJBQU87QUFBQSxlQUVOO0FBQ0QsMkJBQWUsUUFBUUEsTUFBSztBQUM1QixtQkFBTztBQUFBO0FBRWYsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLFFBQVEsS0FBSyxNQUFNLFFBQVE7QUFDaEMsWUFBSSxlQUFlLEdBQUc7QUFDdEIsWUFBSSxLQUFLO0FBQ0wsY0FBRyxPQUFPLElBQUksWUFBWSxVQUFVO0FBQ2xDLGdCQUFJLFVBQVUsS0FBSztBQUFBLFVBQ3JCO0FBQ0EsY0FBSSxXQUFXLE1BQU07QUFBQSxRQUN6QjtBQUNBLFlBQUksS0FBSyxLQUFLLElBQUksR0FBRztBQUNqQixjQUFJQTtBQUNKLGtCQUFRQSxTQUFRLEtBQUssT0FBTztBQUN4QixpQkFBS0EsTUFBSztBQUNkLGVBQUssS0FBSyxJQUFJO0FBQUEsUUFDbEIsT0FBTztBQUNILGNBQUk7QUFDQSxtQkFBTztBQUNYLGVBQUssR0FBRztBQUNSLGNBQUksUUFBUSxPQUFPLElBQUksWUFBWSxZQUFZO0FBQzNDLGdCQUFJLFVBQVUsS0FBSyxZQUFZLEtBQUssSUFBSTtBQUFBLFFBQ2hEO0FBQUEsTUFDSjtBQUVBLGVBQVMsVUFBVSxRQUFRQSxRQUFPO0FBRzlCLFlBQUksQ0FBQyxPQUFPLEtBQUtBLFNBQVEsS0FBSyxDQUFDO0FBQzNCLGdCQUFNLFFBQVFBLFFBQU8sV0FBVztBQUVwQyxZQUFJLE9BQU8sSUFBSSxLQUFLQSxNQUFLO0FBQ3pCLGdCQUFRLE1BQU0sU0FBUyxnQkFBZ0JBLFFBQU87QUFDMUMsY0FBSSxZQUFZLE1BQU1BLE1BQUs7QUFDdkI7QUFFSixrQkFBUUE7QUFBQSxpQkFFQztBQUNELDRCQUFjLE1BQU1BLE1BQUs7QUFDekI7QUFBQSxpQkFFQztBQUFBLGlCQUNBO0FBQ0QseUJBQVcsTUFBTUEsTUFBSztBQUN0QjtBQUFBLGlCQUVDO0FBRUQsa0JBQUksVUFBVTtBQUNWLDJCQUFXLE1BQU0saUJBQWlCO0FBQUEsY0FDdEMsT0FBTztBQUNILDJCQUFXLE1BQU0sVUFBVTtBQUFBLGNBQy9CO0FBQ0E7QUFBQSxpQkFFQztBQUNELHlCQUFXLE1BQU1BLE1BQUs7QUFDdEI7QUFBQSxpQkFFQztBQUNELHlCQUFXLEtBQUssZUFBZSxLQUFLLGFBQWEsQ0FBQyxFQUFFO0FBQ3BEO0FBQUEsaUJBRUM7QUFDRCx5QkFBVyxLQUFLLGFBQWEsS0FBSyxXQUFXLENBQUMsSUFBSSxJQUFJO0FBQ3REO0FBQUE7QUFJQSxrQkFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLEtBQUtBLE1BQUs7QUFDbEMsc0JBQU0sUUFBUUEsTUFBSztBQUV2QixtQkFBS0EsTUFBSztBQUNWLHlCQUFXLE1BQU0sVUFBVTtBQUMzQjtBQUFBO0FBQUEsUUFFWixDQUFDO0FBQ0QsZUFBTyxJQUFJLElBQUk7QUFBQSxNQUNuQjtBQUVBLGVBQVMsV0FBVyxRQUFRLE1BQU0sUUFBUTtBQUN0QyxZQUFJLE9BQU8sS0FBSztBQUNoQixZQUFJLFNBQVMsU0FBUztBQUNsQixxQkFBVyxRQUFRLElBQUk7QUFDdkI7QUFBQSxRQUNKO0FBR0EsWUFBSSxDQUFDLFVBQVUsS0FBSyxJQUFJO0FBQ3BCLGdCQUFNLFFBQVEsTUFBTSxNQUFNO0FBRTlCLFlBQUlELFFBQU8sS0FBSztBQUdoQixZQUFJLENBQUMsT0FBTyxLQUFLQSxLQUFJO0FBQ2pCLGdCQUFNLFFBQVFBLE9BQU0sTUFBTTtBQUU5QixRQUFBQSxRQUFPLFVBQVVBLEtBQUk7QUFDckIsYUFBSyxHQUFHO0FBRVIsWUFBSSxRQUFRLElBQUksTUFBTUEsT0FBTSxRQUFRLEtBQUssQ0FBQyxHQUFHLE1BQU0sTUFBTSxNQUFNO0FBQy9ELGdCQUFRLE9BQU8sU0FBUyxpQkFBaUJDLFFBQU87QUFHNUMsY0FBSUEsV0FBVSxVQUFVO0FBQ3BCLHdCQUFZLE9BQU9BLE1BQUs7QUFDeEIsaUJBQUssR0FBRztBQUFBLFVBQ1o7QUFDSSxrQkFBTSxRQUFRQSxNQUFLO0FBQUEsUUFFM0IsR0FBRyxTQUFTLGtCQUFrQjtBQUMxQiw2QkFBbUIsS0FBSztBQUFBLFFBQzVCLENBQUM7QUFFRCxZQUFJLFNBQVMsbUJBQW1CO0FBRTVCLGNBQUksUUFBUSxJQUFJLE1BQU0sTUFBTUQsS0FBSTtBQUNoQyxnQkFBTSxVQUFVLG1CQUFtQixJQUFJO0FBQ3ZDLGdCQUFNLElBQUksS0FBSztBQUNmLGlCQUFPLElBQUksS0FBSztBQUFBLFFBQ3BCLE9BQU87QUFDSCxpQkFBTyxJQUFJLEtBQUs7QUFBQSxRQUNwQjtBQUtBLFlBQUksQ0FBQyxZQUFZLE1BQU0sYUFBYSxNQUFNLE9BQU8sVUFBVSxVQUFhLE1BQU0sTUFBTSxVQUFVO0FBQzFGLGdCQUFNLFVBQVUsVUFBVSxPQUFzQixJQUFJO0FBQUEsTUFDNUQ7QUFFQSxlQUFTLFdBQVcsUUFBUSxNQUFNO0FBQzlCLFlBQUlBLFFBQU8sS0FBSztBQUdoQixZQUFJLENBQUMsT0FBTyxLQUFLQSxLQUFJO0FBQ2pCLGdCQUFNLFFBQVFBLE9BQU0sTUFBTTtBQUU5QixZQUFJLFlBQVksS0FBSyxRQUFRQSxLQUFJO0FBQ2pDLFlBQUlBLFVBQVM7QUFDVCxVQUFBQSxRQUFPLEtBQUssUUFBUUEsS0FBSTtBQUM1QixhQUFLLEdBQUc7QUFDUixZQUFJLEtBQUssUUFBUSxLQUFLLENBQUM7QUFDdkIsWUFBSSxPQUFPLElBQUksS0FBS0EsS0FBSTtBQUN4QixhQUFLLFFBQVE7QUFDYixZQUFJLFFBQVEsSUFBSSxNQUFNLFdBQVcsSUFBSUEsT0FBTSxJQUFJO0FBQy9DLGNBQU0sV0FBVyxNQUFNO0FBQ3ZCLGdCQUFRLE1BQU0sU0FBUyxpQkFBaUJDLFFBQU87QUFDM0Msa0JBQVFBO0FBQUEsaUJBRUM7QUFDRCwwQkFBWSxNQUFNQSxNQUFLO0FBQ3ZCLG1CQUFLLEdBQUc7QUFDUjtBQUFBLGlCQUVDO0FBQUEsaUJBQ0E7QUFDRCx5QkFBVyxNQUFNQSxNQUFLO0FBQ3RCO0FBQUEsaUJBRUM7QUFFRCxrQkFBSSxVQUFVO0FBQ1YsMkJBQVcsTUFBTSxpQkFBaUI7QUFBQSxjQUN0QyxPQUFPO0FBQ0gsMkJBQVcsTUFBTSxVQUFVO0FBQUEsY0FDL0I7QUFDQTtBQUFBLGlCQUVDO0FBQ0Qsd0JBQVUsTUFBTUEsTUFBSztBQUNyQjtBQUFBLGlCQUVDO0FBQ0Qsd0JBQVUsTUFBTUEsTUFBSztBQUNyQjtBQUFBO0FBSUEsb0JBQU0sUUFBUUEsTUFBSztBQUFBO0FBQUEsUUFFL0IsQ0FBQztBQUNELGVBQU8sSUFBSSxJQUFJLEVBQ1IsSUFBSSxLQUFLO0FBQUEsTUFDcEI7QUFFQSxlQUFTLGNBQWMsUUFBUTtBQUMzQixhQUFLLEdBQUc7QUFDUixZQUFJLFVBQVUsS0FBSztBQUduQixZQUFJLE1BQU0sT0FBTyxhQUFhO0FBQzFCLGdCQUFNLFFBQVEsU0FBUyxNQUFNO0FBRWpDLGFBQUssR0FBRztBQUNSLFlBQUksWUFBWSxLQUFLO0FBR3JCLFlBQUksQ0FBQyxVQUFVLEtBQUssU0FBUztBQUN6QixnQkFBTSxRQUFRLFdBQVcsTUFBTTtBQUVuQyxhQUFLLEdBQUc7QUFDUixZQUFJRCxRQUFPLEtBQUs7QUFHaEIsWUFBSSxDQUFDLE9BQU8sS0FBS0EsS0FBSTtBQUNqQixnQkFBTSxRQUFRQSxPQUFNLE1BQU07QUFFOUIsYUFBSyxHQUFHO0FBQ1IsWUFBSSxRQUFRLElBQUksU0FBUyxVQUFVQSxLQUFJLEdBQUcsUUFBUSxLQUFLLENBQUMsR0FBRyxTQUFTLFNBQVM7QUFDN0UsZ0JBQVEsT0FBTyxTQUFTLG9CQUFvQkMsUUFBTztBQUcvQyxjQUFJQSxXQUFVLFVBQVU7QUFDcEIsd0JBQVksT0FBT0EsTUFBSztBQUN4QixpQkFBSyxHQUFHO0FBQUEsVUFDWjtBQUNJLGtCQUFNLFFBQVFBLE1BQUs7QUFBQSxRQUUzQixHQUFHLFNBQVMscUJBQXFCO0FBQzdCLDZCQUFtQixLQUFLO0FBQUEsUUFDNUIsQ0FBQztBQUNELGVBQU8sSUFBSSxLQUFLO0FBQUEsTUFDcEI7QUFFQSxlQUFTLFdBQVcsUUFBUUEsUUFBTztBQUcvQixZQUFJLENBQUMsT0FBTyxLQUFLQSxTQUFRLEtBQUssQ0FBQztBQUMzQixnQkFBTSxRQUFRQSxRQUFPLE1BQU07QUFFL0IsWUFBSSxRQUFRLElBQUksTUFBTSxVQUFVQSxNQUFLLENBQUM7QUFDdEMsZ0JBQVEsT0FBTyxTQUFTLGlCQUFpQkEsUUFBTztBQUM1QyxjQUFJQSxXQUFVLFVBQVU7QUFDcEIsd0JBQVksT0FBT0EsTUFBSztBQUN4QixpQkFBSyxHQUFHO0FBQUEsVUFDWixPQUFPO0FBQ0gsaUJBQUtBLE1BQUs7QUFDVix1QkFBVyxPQUFPLFVBQVU7QUFBQSxVQUNoQztBQUFBLFFBQ0osQ0FBQztBQUNELGVBQU8sSUFBSSxLQUFLO0FBQUEsTUFDcEI7QUFFQSxlQUFTLFVBQVUsUUFBUUEsUUFBTztBQUc5QixZQUFJLENBQUMsT0FBTyxLQUFLQSxTQUFRLEtBQUssQ0FBQztBQUMzQixnQkFBTSxRQUFRQSxRQUFPLE1BQU07QUFFL0IsWUFBSSxNQUFNLElBQUksS0FBS0EsTUFBSztBQUN4QixnQkFBUSxLQUFLLFNBQVMsZ0JBQWdCQSxRQUFPO0FBQzNDLGtCQUFPQTtBQUFBLGlCQUNBO0FBQ0gsMEJBQVksS0FBS0EsTUFBSztBQUN0QixtQkFBSyxHQUFHO0FBQ1I7QUFBQSxpQkFFRztBQUNILHlCQUFXLElBQUksYUFBYSxJQUFJLFdBQVcsQ0FBQyxJQUFJLElBQUk7QUFDcEQ7QUFBQTtBQUdBLDZCQUFlLEtBQUtBLE1BQUs7QUFBQTtBQUFBLFFBRS9CLENBQUM7QUFDRCxlQUFPLElBQUksR0FBRztBQUFBLE1BQ2xCO0FBRUEsZUFBUyxlQUFlLFFBQVFBLFFBQU87QUFHbkMsWUFBSSxDQUFDLE9BQU8sS0FBS0EsTUFBSztBQUNsQixnQkFBTSxRQUFRQSxRQUFPLE1BQU07QUFFL0IsYUFBSyxHQUFHO0FBQ1IsWUFBSSxRQUFRLFFBQVEsS0FBSyxHQUFHLElBQUksR0FDNUIsUUFBUTtBQUFBLFVBQ0osU0FBUztBQUFBLFFBQ2I7QUFDSixjQUFNLFlBQVksU0FBU0QsT0FBTUcsUUFBTztBQUNwQyxjQUFJLEtBQUssWUFBWTtBQUNqQixpQkFBSyxVQUFVLENBQUM7QUFDcEIsZUFBSyxRQUFRSCxTQUFRRztBQUFBLFFBQ3pCO0FBQ0EsZ0JBQVEsT0FBTyxTQUFTLHFCQUFxQkYsUUFBTztBQUdoRCxjQUFJQSxXQUFVLFVBQVU7QUFDcEIsd0JBQVksT0FBT0EsTUFBSztBQUN4QixpQkFBSyxHQUFHO0FBQUEsVUFDWjtBQUNJLGtCQUFNLFFBQVFBLE1BQUs7QUFBQSxRQUUzQixHQUFHLFNBQVMsc0JBQXNCO0FBQzlCLDZCQUFtQixLQUFLO0FBQUEsUUFDNUIsQ0FBQztBQUNELGVBQU8sSUFBSUEsUUFBTyxPQUFPLE1BQU0sU0FBUyxNQUFNLE9BQU87QUFBQSxNQUN6RDtBQUVBLGVBQVMsWUFBWSxRQUFRQSxRQUFPO0FBQ2hDLFlBQUksV0FBVyxLQUFLLEtBQUssSUFBSTtBQUc3QixZQUFJLENBQUMsVUFBVSxLQUFLQSxTQUFRLEtBQUssQ0FBQztBQUM5QixnQkFBTSxRQUFRQSxRQUFPLE1BQU07QUFFL0IsWUFBSUQsUUFBT0M7QUFDWCxZQUFJLFNBQVNEO0FBQ2IsWUFBSTtBQUVKLFlBQUksVUFBVTtBQUNWLGVBQUssR0FBRztBQUNSLFVBQUFBLFFBQU8sTUFBTUEsUUFBTztBQUNwQixtQkFBU0E7QUFDVCxVQUFBQyxTQUFRLEtBQUs7QUFDYixjQUFJLFlBQVksS0FBS0EsTUFBSyxHQUFHO0FBQ3pCLHVCQUFXQSxPQUFNLE1BQU0sQ0FBQztBQUN4QixZQUFBRCxTQUFRQztBQUNSLGlCQUFLO0FBQUEsVUFDVDtBQUFBLFFBQ0o7QUFDQSxhQUFLLEdBQUc7QUFDUixZQUFJLGNBQWMsaUJBQWlCLFFBQVFELEtBQUk7QUFDL0Msd0JBQWdCLFFBQVEsUUFBUSxhQUFhLFFBQVE7QUFBQSxNQUN6RDtBQUVBLGVBQVMsaUJBQWlCLFFBQVFBLE9BQU07QUFFcEMsWUFBSSxLQUFLLEtBQUssSUFBSSxHQUFHO0FBQ2pCLGNBQUksZUFBZSxDQUFDO0FBRXBCLGlCQUFPLENBQUMsS0FBSyxLQUFLLElBQUksR0FBRztBQUVyQixnQkFBSSxDQUFDLE9BQU8sS0FBSyxRQUFRLEtBQUssQ0FBQyxHQUFHO0FBQzlCLG9CQUFNLFFBQVEsT0FBTyxNQUFNO0FBQUEsWUFDL0I7QUFFQSxnQkFBSTtBQUNKLGdCQUFJLFdBQVc7QUFFZixpQkFBSyxLQUFLLElBQUk7QUFFZCxnQkFBSSxLQUFLLE1BQU07QUFDWCxzQkFBUSxpQkFBaUIsUUFBUUEsUUFBTyxNQUFNLEtBQUs7QUFBQSxxQkFDOUMsS0FBSyxNQUFNLEtBQUs7QUFJckIsc0JBQVEsQ0FBQztBQUNULGtCQUFJO0FBQ0osa0JBQUksS0FBSyxLQUFLLElBQUksR0FBRztBQUNqQixtQkFBRztBQUNDLDhCQUFZLFVBQVUsSUFBSTtBQUMxQix3QkFBTSxLQUFLLFNBQVM7QUFBQSxnQkFDeEIsU0FBUyxLQUFLLEtBQUssSUFBSTtBQUN2QixxQkFBSyxHQUFHO0FBQ1Isb0JBQUksT0FBTyxjQUFjLGFBQWE7QUFDbEMsNEJBQVUsUUFBUUEsUUFBTyxNQUFNLE9BQU8sU0FBUztBQUFBLGdCQUNuRDtBQUFBLGNBQ0o7QUFBQSxZQUNKLE9BQU87QUFDSCxzQkFBUSxVQUFVLElBQUk7QUFDdEIsd0JBQVUsUUFBUUEsUUFBTyxNQUFNLE9BQU8sS0FBSztBQUFBLFlBQy9DO0FBRUEsZ0JBQUksWUFBWSxhQUFhO0FBRTdCLGdCQUFJO0FBQ0Esc0JBQVEsQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLE9BQU8sS0FBSztBQUU3Qyx5QkFBYSxZQUFZO0FBR3pCLGlCQUFLLEtBQUssSUFBSTtBQUNkLGlCQUFLLEtBQUssSUFBSTtBQUFBLFVBQ2xCO0FBRUEsaUJBQU87QUFBQSxRQUNYO0FBRUEsWUFBSSxjQUFjLFVBQVUsSUFBSTtBQUNoQyxrQkFBVSxRQUFRQSxPQUFNLFdBQVc7QUFDbkMsZUFBTztBQUFBLE1BRVg7QUFFQSxlQUFTLFVBQVUsUUFBUUEsT0FBTSxPQUFPO0FBQ3BDLFlBQUksT0FBTztBQUNQLGlCQUFPLFVBQVVBLE9BQU0sS0FBSztBQUFBLE1BQ3BDO0FBRUEsZUFBUyxnQkFBZ0IsUUFBUUEsT0FBTSxPQUFPLFVBQVU7QUFDcEQsWUFBSSxPQUFPO0FBQ1AsaUJBQU8sZ0JBQWdCQSxPQUFNLE9BQU8sUUFBUTtBQUFBLE1BQ3BEO0FBRUEsZUFBUyxtQkFBbUIsUUFBUTtBQUNoQyxZQUFJLEtBQUssS0FBSyxJQUFJLEdBQUc7QUFDakIsYUFBRztBQUNDLHdCQUFZLFFBQVEsUUFBUTtBQUFBLFVBQ2hDLFNBQVMsS0FBSyxLQUFLLElBQUk7QUFDdkIsZUFBSyxHQUFHO0FBQUEsUUFDWjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxhQUFhLFFBQVFDLFFBQU87QUFHakMsWUFBSSxDQUFDLE9BQU8sS0FBS0EsU0FBUSxLQUFLLENBQUM7QUFDM0IsZ0JBQU0sUUFBUUEsUUFBTyxjQUFjO0FBRXZDLFlBQUksVUFBVSxJQUFJLFFBQVFBLE1BQUs7QUFDL0IsZ0JBQVEsU0FBUyxTQUFTLG1CQUFtQkEsUUFBTztBQUNoRCxjQUFJLFlBQVksU0FBU0EsTUFBSztBQUMxQjtBQUdKLGNBQUlBLFdBQVU7QUFDVix3QkFBWSxTQUFTQSxNQUFLO0FBQUE7QUFFMUIsa0JBQU0sUUFBUUEsTUFBSztBQUFBLFFBQzNCLENBQUM7QUFDRCxlQUFPLElBQUksT0FBTztBQUFBLE1BQ3RCO0FBRUEsZUFBUyxZQUFZLFFBQVFBLFFBQU87QUFHaEMsWUFBSSxjQUFjLEtBQUs7QUFFdkIsWUFBSSxPQUFPQTtBQUdYLFlBQUksQ0FBQyxPQUFPLEtBQUtBLFNBQVEsS0FBSyxDQUFDO0FBQzNCLGdCQUFNLFFBQVFBLFFBQU8sTUFBTTtBQUUvQixZQUFJRCxRQUFPQyxRQUNQLGFBQWEsZUFDYixjQUFjO0FBRWxCLGFBQUssR0FBRztBQUNSLFlBQUksS0FBSyxVQUFVLElBQUk7QUFDbkIsMEJBQWdCO0FBR3BCLFlBQUksQ0FBQyxVQUFVLEtBQUtBLFNBQVEsS0FBSyxDQUFDO0FBQzlCLGdCQUFNLFFBQVFBLE1BQUs7QUFFdkIsc0JBQWNBO0FBQ2QsYUFBSyxHQUFHO0FBQUcsYUFBSyxTQUFTO0FBQUcsYUFBSyxHQUFHO0FBQ3BDLFlBQUksS0FBSyxVQUFVLElBQUk7QUFDbkIsMkJBQWlCO0FBR3JCLFlBQUksQ0FBQyxVQUFVLEtBQUtBLFNBQVEsS0FBSyxDQUFDO0FBQzlCLGdCQUFNLFFBQVFBLE1BQUs7QUFFdkIsdUJBQWVBO0FBQ2YsYUFBSyxHQUFHO0FBRVIsWUFBSSxTQUFTLElBQUksT0FBT0QsT0FBTSxNQUFNLGFBQWEsY0FBYyxlQUFlLGNBQWM7QUFDNUYsZUFBTyxVQUFVO0FBQ2pCLGdCQUFRLFFBQVEsU0FBUyxrQkFBa0JDLFFBQU87QUFHOUMsY0FBSUEsV0FBVSxVQUFVO0FBQ3BCLHdCQUFZLFFBQVFBLE1BQUs7QUFDekIsaUJBQUssR0FBRztBQUFBLFVBQ1o7QUFDSSxrQkFBTSxRQUFRQSxNQUFLO0FBQUEsUUFFM0IsQ0FBQztBQUNELGVBQU8sSUFBSSxNQUFNO0FBQUEsTUFDckI7QUFFQSxlQUFTLGVBQWUsUUFBUUEsUUFBTztBQUduQyxZQUFJLENBQUMsVUFBVSxLQUFLQSxTQUFRLEtBQUssQ0FBQztBQUM5QixnQkFBTSxRQUFRQSxRQUFPLFdBQVc7QUFFcEMsWUFBSSxZQUFZQTtBQUNoQixnQkFBUSxNQUFNLFNBQVMscUJBQXFCQSxRQUFPO0FBQy9DLGtCQUFRQTtBQUFBLGlCQUVDO0FBQUEsaUJBQ0E7QUFDRCx5QkFBVyxRQUFRQSxRQUFPLFNBQVM7QUFDbkM7QUFBQSxpQkFFQztBQUVELGtCQUFJLFVBQVU7QUFDViwyQkFBVyxRQUFRLG1CQUFtQixTQUFTO0FBQUEsY0FDbkQsT0FBTztBQUNILDJCQUFXLFFBQVEsWUFBWSxTQUFTO0FBQUEsY0FDNUM7QUFDQTtBQUFBO0FBSUEsa0JBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxLQUFLQSxNQUFLO0FBQ2xDLHNCQUFNLFFBQVFBLE1BQUs7QUFDdkIsbUJBQUtBLE1BQUs7QUFDVix5QkFBVyxRQUFRLFlBQVksU0FBUztBQUN4QztBQUFBO0FBQUEsUUFFWixDQUFDO0FBQUEsTUFDTDtBQUVBLFVBQUk7QUFDSixjQUFRLFFBQVEsS0FBSyxPQUFPLE1BQU07QUFDOUIsZ0JBQVE7QUFBQSxlQUVDO0FBR0QsZ0JBQUksQ0FBQztBQUNELG9CQUFNLFFBQVEsS0FBSztBQUV2Qix5QkFBYTtBQUNiO0FBQUEsZUFFQztBQUdELGdCQUFJLENBQUM7QUFDRCxvQkFBTSxRQUFRLEtBQUs7QUFFdkIsd0JBQVk7QUFDWjtBQUFBLGVBRUM7QUFHRCxnQkFBSSxDQUFDO0FBQ0Qsb0JBQU0sUUFBUSxLQUFLO0FBRXZCLHdCQUFZO0FBQ1o7QUFBQSxlQUVDO0FBRUQsd0JBQVksS0FBSyxLQUFLO0FBQ3RCLGlCQUFLLEdBQUc7QUFDUjtBQUFBO0FBS0EsZ0JBQUksWUFBWSxLQUFLLEtBQUssR0FBRztBQUN6QixxQkFBTztBQUNQO0FBQUEsWUFDSjtBQUdBLGtCQUFNLFFBQVEsS0FBSztBQUFBO0FBQUEsTUFFL0I7QUFFQSxZQUFNLFdBQVc7QUFDakIsYUFBTztBQUFBLFFBQ0gsV0FBZ0I7QUFBQSxRQUNoQixXQUFnQjtBQUFBLFFBQ2Y7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0w7QUFBQSxJQUNKO0FBQUE7QUFBQTs7O0FDOTBCQTtBQUFBLDBDQUFBRyxVQUFBQyxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVU7QUFFakIsUUFBSSxXQUFXO0FBc0JmLGFBQVMsT0FBT0MsT0FBTSxNQUFNO0FBQ3hCLFVBQUksQ0FBQyxTQUFTLEtBQUtBLEtBQUksR0FBRztBQUN0QixRQUFBQSxRQUFPLHFCQUFxQkEsUUFBTztBQUNuQyxlQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLFFBQVEsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQUEsTUFDNUU7QUFDQSxhQUFPQSxTQUFRO0FBQUEsSUFDbkI7QUFXQSxXQUFPLE9BQU87QUFBQSxNQVVWLEtBQUs7QUFBQSxRQUNELFFBQVE7QUFBQSxVQUNKLFVBQVU7QUFBQSxZQUNOLE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsVUFDQSxPQUFPO0FBQUEsWUFDSCxNQUFNO0FBQUEsWUFDTixJQUFJO0FBQUEsVUFDUjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsUUFBSTtBQUVKLFdBQU8sWUFBWTtBQUFBLE1BVWYsVUFBVSxXQUFXO0FBQUEsUUFDakIsUUFBUTtBQUFBLFVBQ0osU0FBUztBQUFBLFlBQ0wsTUFBTTtBQUFBLFlBQ04sSUFBSTtBQUFBLFVBQ1I7QUFBQSxVQUNBLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFFRCxXQUFPLGFBQWE7QUFBQSxNQVVoQixXQUFXO0FBQUEsSUFDZixDQUFDO0FBRUQsV0FBTyxTQUFTO0FBQUEsTUFPWixPQUFPO0FBQUEsUUFDSCxRQUFRLENBQUM7QUFBQSxNQUNiO0FBQUEsSUFDSixDQUFDO0FBRUQsV0FBTyxVQUFVO0FBQUEsTUFTYixRQUFRO0FBQUEsUUFDSixRQUFRO0FBQUEsVUFDSixRQUFRO0FBQUEsWUFDSixTQUFTO0FBQUEsWUFDVCxNQUFNO0FBQUEsWUFDTixJQUFJO0FBQUEsVUFDUjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFlQSxPQUFPO0FBQUEsUUFDSCxRQUFRO0FBQUEsVUFDSixNQUFNO0FBQUEsWUFDRixPQUFPO0FBQUEsY0FDSDtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsWUFDSjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQUEsUUFDQSxRQUFRO0FBQUEsVUFDSixXQUFXO0FBQUEsWUFDUCxNQUFNO0FBQUEsWUFDTixJQUFJO0FBQUEsVUFDUjtBQUFBLFVBQ0EsYUFBYTtBQUFBLFlBQ1QsTUFBTTtBQUFBLFlBQ04sSUFBSTtBQUFBLFVBQ1I7QUFBQSxVQUNBLGFBQWE7QUFBQSxZQUNULE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsVUFDQSxXQUFXO0FBQUEsWUFDUCxNQUFNO0FBQUEsWUFDTixJQUFJO0FBQUEsVUFDUjtBQUFBLFVBQ0EsYUFBYTtBQUFBLFlBQ1QsTUFBTTtBQUFBLFlBQ04sSUFBSTtBQUFBLFVBQ1I7QUFBQSxVQUNBLFdBQVc7QUFBQSxZQUNQLE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUVBLFdBQVc7QUFBQSxRQUNQLFFBQVE7QUFBQSxVQUNKLFlBQVk7QUFBQSxRQUNoQjtBQUFBLE1BQ0o7QUFBQSxNQVNBLFdBQVc7QUFBQSxRQUNQLFFBQVE7QUFBQSxVQUNKLFFBQVE7QUFBQSxZQUNKLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFFRCxXQUFPLFlBQVk7QUFBQSxNQVNmLGFBQWE7QUFBQSxRQUNULFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQVNBLFlBQVk7QUFBQSxRQUNSLFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQVNBLFlBQVk7QUFBQSxRQUNSLFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQVNBLGFBQWE7QUFBQSxRQUNULFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQVNBLFlBQVk7QUFBQSxRQUNSLFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQVNBLGFBQWE7QUFBQSxRQUNULFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQVNBLFdBQVc7QUFBQSxRQUNQLFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQVNBLGFBQWE7QUFBQSxRQUNULFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQVNBLFlBQVk7QUFBQSxRQUNSLFFBQVE7QUFBQSxVQUNKLE9BQU87QUFBQSxZQUNILE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFFRCxXQUFPLGNBQWM7QUFBQSxNQVNqQixXQUFXO0FBQUEsUUFDUCxRQUFRO0FBQUEsVUFDSixPQUFPO0FBQUEsWUFDSCxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUEsWUFDTixJQUFJO0FBQUEsVUFDUjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBaUJELFdBQU8sTUFBTSxTQUFTLElBQUksTUFBTTtBQUM1QixhQUFPLE9BQU8sU0FBUztBQUFBLElBQzNCO0FBQUE7QUFBQTs7O0FDOVlBO0FBQUEseUNBQUFDLFVBQUFDLFNBQUE7QUFBQTtBQUNBLFFBQUksV0FBV0EsUUFBTyxVQUFVO0FBRWhDLGFBQVMsUUFBUTtBQUdqQixhQUFTLFdBQW1CO0FBQzVCLGFBQVMsUUFBbUI7QUFDNUIsYUFBUyxTQUFtQjtBQUc1QixhQUFTLEtBQUssV0FBVyxTQUFTLE1BQU0sU0FBUyxPQUFPLFNBQVMsTUFBTTtBQUFBO0FBQUE7OztBQ1h2RTtBQUFBLHFDQUFBQyxVQUFBQyxTQUFBO0FBQUE7QUFHQSxJQUFBQSxRQUFPLFVBQVU7QUFBQTtBQUFBOzs7QUNnQlgsU0FBVSxjQUFtQixLQUFrQyxPQUFlO0FBQ2xGLFFBQU1DLFVBQVMsT0FBTyxPQUFPLGVBQWUsYUFBYSxNQUFNLElBQUksU0FBUSxDQUFFO0FBRzdFLFNBQU8sTUFBTSxPQUFPQSxPQUFNO0FBQzVCO0FBdEJBLHVCQUVNLFFBR0E7QUFMTjs7d0JBQWU7QUFFZixJQUFNLFNBQVMsa0JBQUFDLFFBQUc7QUFHbEIsSUFBTSxVQUFVO01BQ2Q7TUFBVTtNQUFTO01BQVU7TUFBVzs7QUFFMUMsWUFBUSxRQUFRLFlBQVM7QUFFdkIsWUFBTSxXQUFXLE9BQU8sVUFBVTtBQUVsQyxhQUFPLFVBQVUsVUFBVSxXQUFBO0FBQ3pCLGVBQU8sT0FBTyxTQUFTLEtBQUssSUFBSSxFQUFFLFNBQVEsQ0FBRTtNQUM5QztJQUNGLENBQUM7Ozs7O0FDQ0ssU0FBVSxjQUFtQkMsVUFBWSxPQUFlO0FBQzVELFFBQU0sSUFBSSxPQUFPLE9BQU07QUFHdkIsUUFBTSxPQUFPQSxVQUFTLEdBQUc7SUFDdkIsaUJBQWlCO0dBQ2xCO0FBRUQsU0FBTyxFQUFFLE9BQU07QUFDakI7QUExQkEsSUFBQUMsb0JBRU0sUUFHQUM7QUFMTjs7SUFBQUQscUJBQWU7QUFFZixJQUFNLFNBQVMsbUJBQUFFLFFBQUc7QUFHbEIsSUFBTUQsV0FBVTtNQUNkO01BQVU7TUFBUztNQUFVO01BQVc7O0FBRTFDLElBQUFBLFNBQVEsUUFBUSxZQUFTO0FBRXZCLFlBQU0sV0FBVyxPQUFPLFVBQVU7QUFFbEMsYUFBTyxVQUFVLFVBQVUsU0FBVSxLQUFXO0FBQzlDLGVBQU8sU0FBUyxLQUFLLE1BQU0sSUFBSSxTQUFRLENBQUU7TUFDM0M7SUFDRixDQUFDOzs7OztBQ2VLLFNBQVVFLGFBQWlCQyxPQUFjLE1BQW1CQyxTQUEyQkMsU0FBeUI7QUFDcEgsU0FBTztJQUNMLE1BQUFGO0lBQ0E7SUFDQSxRQUFBQztJQUNBLFFBQUFDOztBQUVKO0FBcENBLElBQ1k7QUFEWjs7QUFDQSxLQUFBLFNBQVlDLGNBQVc7QUFDckIsTUFBQUEsYUFBQUEsYUFBQSxZQUFBLEtBQUE7QUFDQSxNQUFBQSxhQUFBQSxhQUFBLFdBQUEsS0FBQTtBQUNBLE1BQUFBLGFBQUFBLGFBQUEsc0JBQUEsS0FBQTtBQUNBLE1BQUFBLGFBQUFBLGFBQUEsaUJBQUEsS0FBQTtBQUNBLE1BQUFBLGFBQUFBLGFBQUEsZUFBQSxLQUFBO0FBQ0EsTUFBQUEsYUFBQUEsYUFBQSxXQUFBLEtBQUE7SUFDRixHQVBZLGdCQUFBLGNBQVcsQ0FBQSxFQUFBOzs7OztBQ0NqQixTQUFVLFlBQWlCLEdBQU07QUFDckMsV0FBUyxVQUFXLEtBQW9CO0FBR3RDLFFBQUksRUFBRSxJQUFJLFNBQVEsTUFBTyxNQUFNO0FBQzdCLFlBQU0sSUFBSSxNQUFNLG9CQUFvQjs7QUFHdEMsV0FBTyxFQUFFO0VBQ1g7QUFFQSxRQUFNQyxVQUEwQyxTQUFTLFdBQVksS0FBSyxRQUFNO0FBQzlFLFVBQU0sWUFBWSxVQUFVLEdBQUc7QUFFL0IsV0FBTyxNQUFNLFNBQVM7RUFDeEI7QUFFQSxRQUFNQyxVQUEwQyxTQUFTLFdBQVlDLFNBQU07QUFDekUsVUFBTSxNQUFNQSxRQUFPLE9BQU07QUFFekIsV0FBTyxVQUFVLEdBQUc7RUFDdEI7QUFHQSxTQUFPQyxhQUFZLFFBQVEsWUFBWSxRQUFRSCxTQUFRQyxPQUFNO0FBQy9EO0FBNUJBOzs7Ozs7O0FDT00sU0FBVSxRQUFhRyxTQUFnRUMsU0FBOEM7QUFDekksU0FBT0MsYUFBWSxXQUFXLFlBQVksa0JBQWtCRixTQUFRQyxPQUFNO0FBQzVFO0FBVkE7Ozs7Ozs7QUNVQSxJQUFBRSxZQUFBOzs7QUFJQTtBQUlBO0FBQ0E7Ozs7O0FDbkJBOzs7Ozs7SUFPWSxTQU1QLGlCQWdCWSxXQWdGQTtBQTdHakI7O0FBR0EsSUFBQUM7QUFJQSxLQUFBLFNBQVlDLFVBQU87QUFDakIsTUFBQUEsU0FBQSxTQUFBO0FBQ0EsTUFBQUEsU0FBQSxhQUFBO0FBQ0EsTUFBQUEsU0FBQSxlQUFBO0lBQ0YsR0FKWSxZQUFBLFVBQU8sQ0FBQSxFQUFBO0FBTW5CLEtBQUEsU0FBS0Msa0JBQWU7QUFDbEIsTUFBQUEsaUJBQUFBLGlCQUFBLFNBQUEsS0FBQTtBQUNBLE1BQUFBLGlCQUFBQSxpQkFBQSxhQUFBLEtBQUE7QUFDQSxNQUFBQSxpQkFBQUEsaUJBQUEsZUFBQSxLQUFBO0lBQ0YsR0FKSyxvQkFBQSxrQkFBZSxDQUFBLEVBQUE7QUFNcEIsS0FBQSxTQUFpQkQsVUFBTztBQUNULE1BQUFBLFNBQUEsUUFBUSxNQUFLO0FBQ3hCLGVBQU8sWUFBcUIsZUFBZTtNQUM3QztJQUNGLEdBSmlCLFlBQUEsVUFBTyxDQUFBLEVBQUE7QUFVeEIsS0FBQSxTQUFpQkUsWUFBUztBQUN4QixVQUFJO0FBRVMsTUFBQUEsV0FBQSxRQUFRLE1BQXVCO0FBQzFDLFlBQUksVUFBVSxNQUFNO0FBQ2xCLG1CQUFTLFFBQW1CLENBQUMsS0FBSyxRQUFRLE9BQU8sQ0FBQSxNQUFNO0FBQ3JELGdCQUFJLEtBQUssb0JBQW9CLE9BQU87QUFDbEMscUJBQU8sS0FBSTs7QUFHYixnQkFBSSxJQUFJLFFBQVEsTUFBTTtBQUNwQixxQkFBTyxPQUFPLENBQUM7QUFDZixzQkFBUSxNQUFLLEVBQUcsT0FBTyxJQUFJLE1BQU0sTUFBTTttQkFDbEM7QUFDTCxvQkFBTSxJQUFJLE1BQU0sK0RBQStEOztBQUdqRixnQkFBSSxJQUFJLFFBQVEsTUFBTTtBQUNwQixxQkFBTyxPQUFPLEVBQUU7QUFDaEIscUJBQU8sTUFBTSxJQUFJLElBQUk7bUJBQ2hCO0FBQ0wsb0JBQU0sSUFBSSxNQUFNLCtEQUErRDs7QUFHakYsZ0JBQUksS0FBSyxvQkFBb0IsT0FBTztBQUNsQyxxQkFBTyxPQUFNOztVQUVqQixHQUFHLENBQUNDLFNBQVFDLFlBQVU7QUFDcEIsa0JBQU0sTUFBVztjQUNmLE1BQU0sUUFBUTtjQUNkLE1BQU0sSUFBSSxXQUFXLENBQUM7O0FBR3hCLGtCQUFNLE1BQU1BLFdBQVUsT0FBT0QsUUFBTyxNQUFNQSxRQUFPLE1BQU1DO0FBRXZELG1CQUFPRCxRQUFPLE1BQU0sS0FBSztBQUN2QixvQkFBTSxNQUFNQSxRQUFPLE9BQU07QUFFekIsc0JBQVEsUUFBUTtxQkFDVDtBQUNILHNCQUFJLE9BQU8sUUFBUSxNQUFLLEVBQUcsT0FBT0EsT0FBTTtBQUN4QztxQkFDRztBQUNILHNCQUFJLE9BQU9BLFFBQU8sTUFBSztBQUN2Qjs7QUFFQSxrQkFBQUEsUUFBTyxTQUFTLE1BQU0sQ0FBQztBQUN2Qjs7O0FBSU4sZ0JBQUksSUFBSSxRQUFRLE1BQU07QUFDcEIsb0JBQU0sSUFBSSxNQUFNLDJFQUEyRTs7QUFHN0YsZ0JBQUksSUFBSSxRQUFRLE1BQU07QUFDcEIsb0JBQU0sSUFBSSxNQUFNLDJFQUEyRTs7QUFHN0YsbUJBQU87VUFDVCxDQUFDOztBQUdILGVBQU87TUFDVDtBQUVhLE1BQUFELFdBQUEsU0FBUyxDQUFDLFFBQThCO0FBQ25ELGVBQU8sY0FBYyxLQUFLQSxXQUFVLE1BQUssQ0FBRTtNQUM3QztBQUVhLE1BQUFBLFdBQUEsU0FBUyxDQUFDLFFBQStDO0FBQ3BFLGVBQU8sY0FBYyxLQUFLQSxXQUFVLE1BQUssQ0FBRTtNQUM3QztJQUNGLEdBekVpQixjQUFBLFlBQVMsQ0FBQSxFQUFBO0FBZ0YxQixLQUFBLFNBQWlCRyxhQUFVO0FBQ3pCLFVBQUk7QUFFUyxNQUFBQSxZQUFBLFFBQVEsTUFBd0I7QUFDM0MsWUFBSSxVQUFVLE1BQU07QUFDbEIsbUJBQVMsUUFBb0IsQ0FBQyxLQUFLLFFBQVEsT0FBTyxDQUFBLE1BQU07QUFDdEQsZ0JBQUksS0FBSyxvQkFBb0IsT0FBTztBQUNsQyxxQkFBTyxLQUFJOztBQUdiLGdCQUFJLElBQUksUUFBUSxNQUFNO0FBQ3BCLHFCQUFPLE9BQU8sQ0FBQztBQUNmLHNCQUFRLE1BQUssRUFBRyxPQUFPLElBQUksTUFBTSxNQUFNO21CQUNsQztBQUNMLG9CQUFNLElBQUksTUFBTSwrREFBK0Q7O0FBR2pGLGdCQUFJLElBQUksUUFBUSxNQUFNO0FBQ3BCLHFCQUFPLE9BQU8sRUFBRTtBQUNoQixxQkFBTyxNQUFNLElBQUksSUFBSTttQkFDaEI7QUFDTCxvQkFBTSxJQUFJLE1BQU0sK0RBQStEOztBQUdqRixnQkFBSSxLQUFLLG9CQUFvQixPQUFPO0FBQ2xDLHFCQUFPLE9BQU07O1VBRWpCLEdBQUcsQ0FBQ0YsU0FBUUMsWUFBVTtBQUNwQixrQkFBTSxNQUFXO2NBQ2YsTUFBTSxRQUFRO2NBQ2QsTUFBTSxJQUFJLFdBQVcsQ0FBQzs7QUFHeEIsa0JBQU0sTUFBTUEsV0FBVSxPQUFPRCxRQUFPLE1BQU1BLFFBQU8sTUFBTUM7QUFFdkQsbUJBQU9ELFFBQU8sTUFBTSxLQUFLO0FBQ3ZCLG9CQUFNLE1BQU1BLFFBQU8sT0FBTTtBQUV6QixzQkFBUSxRQUFRO3FCQUNUO0FBQ0gsc0JBQUksT0FBTyxRQUFRLE1BQUssRUFBRyxPQUFPQSxPQUFNO0FBQ3hDO3FCQUNHO0FBQ0gsc0JBQUksT0FBT0EsUUFBTyxNQUFLO0FBQ3ZCOztBQUVBLGtCQUFBQSxRQUFPLFNBQVMsTUFBTSxDQUFDO0FBQ3ZCOzs7QUFJTixnQkFBSSxJQUFJLFFBQVEsTUFBTTtBQUNwQixvQkFBTSxJQUFJLE1BQU0sMkVBQTJFOztBQUc3RixnQkFBSSxJQUFJLFFBQVEsTUFBTTtBQUNwQixvQkFBTSxJQUFJLE1BQU0sMkVBQTJFOztBQUc3RixtQkFBTztVQUNULENBQUM7O0FBR0gsZUFBTztNQUNUO0FBRWEsTUFBQUUsWUFBQSxTQUFTLENBQUMsUUFBK0I7QUFDcEQsZUFBTyxjQUFjLEtBQUtBLFlBQVcsTUFBSyxDQUFFO01BQzlDO0FBRWEsTUFBQUEsWUFBQSxTQUFTLENBQUMsUUFBZ0Q7QUFDckUsZUFBTyxjQUFjLEtBQUtBLFlBQVcsTUFBSyxDQUFFO01BQzlDO0lBQ0YsR0F6RWlCLGVBQUEsYUFBVSxDQUFBLEVBQUE7Ozs7O0FDN0czQjtBQUFBLHlDQUFBQyxVQUFBQyxTQUFBO0FBT0EsSUFBQUEsUUFBTyxVQUFVO0FBQUEsTUFFZixTQUFTO0FBQUEsUUFDUCxtQkFBbUI7QUFBQSxNQUNyQjtBQUFBLElBQ0Y7QUFBQTtBQUFBOzs7QUNaQTtBQUFBLHlDQUFBQyxVQUFBQyxTQUFBO0FBOEJBLFFBQUksTUFBTSxDQUFDO0FBQ1gsSUFBQUEsUUFBTyxVQUFVO0FBR2pCLFFBQUksb0JBQW9CLENBQUM7QUFXekIsUUFBSSxTQUFTLFNBQVMsT0FBT0MsV0FBVSxTQUFTO0FBQzlDLFVBQUcsT0FBT0EsY0FBYSxVQUFVO0FBQy9CLGNBQU0sSUFBSSxVQUFVLDhCQUE4QjtBQUFBLE1BQ3BEO0FBQ0EsVUFBRyxZQUFZLFVBQWEsT0FBTyxZQUFZLFVBQVU7QUFDdkQsY0FBTSxJQUFJLFVBQVUsNkJBQTZCO0FBQUEsTUFDbkQ7QUFFQSxVQUFJLFNBQVM7QUFFYixVQUFHLEVBQUUsaUJBQWlCLGFBQWE7QUFFakMsaUJBQVMsc0JBQXNCLE9BQU9BLFNBQVE7QUFBQSxNQUNoRCxPQUFPO0FBQ0wsWUFBSSxJQUFJO0FBQ1IsWUFBSUMsUUFBT0QsVUFBUztBQUNwQixZQUFJLFFBQVFBLFVBQVMsT0FBTyxDQUFDO0FBQzdCLFlBQUksU0FBUyxDQUFDLENBQUM7QUFDZixhQUFJLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxFQUFFLEdBQUc7QUFDaEMsbUJBQVEsSUFBSSxHQUFHLFFBQVEsTUFBTSxJQUFJLElBQUksT0FBTyxRQUFRLEVBQUUsR0FBRztBQUN2RCxxQkFBUyxPQUFPLE1BQU07QUFDdEIsbUJBQU8sS0FBSyxRQUFRQztBQUNwQixvQkFBUyxRQUFRQSxRQUFRO0FBQUEsVUFDM0I7QUFFQSxpQkFBTSxRQUFRLEdBQUc7QUFDZixtQkFBTyxLQUFLLFFBQVFBLEtBQUk7QUFDeEIsb0JBQVMsUUFBUUEsUUFBUTtBQUFBLFVBQzNCO0FBQUEsUUFDRjtBQUdBLGFBQUksSUFBSSxHQUFHLE1BQU0sT0FBTyxLQUFLLElBQUksTUFBTSxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQ3RELG9CQUFVO0FBQUEsUUFDWjtBQUVBLGFBQUksSUFBSSxPQUFPLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQ3RDLG9CQUFVRCxVQUFTLE9BQU87QUFBQSxRQUM1QjtBQUFBLE1BQ0Y7QUFFQSxVQUFHLFNBQVM7QUFDVixZQUFJLFFBQVEsSUFBSSxPQUFPLFNBQVMsVUFBVSxLQUFLLEdBQUc7QUFDbEQsaUJBQVMsT0FBTyxNQUFNLEtBQUssRUFBRSxLQUFLLE1BQU07QUFBQSxNQUMxQztBQUVBLGFBQU87QUFBQSxJQUNUO0FBVUEsUUFBSSxTQUFTLFNBQVMsT0FBT0EsV0FBVTtBQUNyQyxVQUFHLE9BQU8sVUFBVSxVQUFVO0FBQzVCLGNBQU0sSUFBSSxVQUFVLDJCQUEyQjtBQUFBLE1BQ2pEO0FBQ0EsVUFBRyxPQUFPQSxjQUFhLFVBQVU7QUFDL0IsY0FBTSxJQUFJLFVBQVUsOEJBQThCO0FBQUEsTUFDcEQ7QUFFQSxVQUFJRSxTQUFRLGtCQUFrQkY7QUFDOUIsVUFBRyxDQUFDRSxRQUFPO0FBRVQsUUFBQUEsU0FBUSxrQkFBa0JGLGFBQVksQ0FBQztBQUN2QyxpQkFBUSxJQUFJLEdBQUcsSUFBSUEsVUFBUyxRQUFRLEVBQUUsR0FBRztBQUN2QyxVQUFBRSxPQUFNRixVQUFTLFdBQVcsQ0FBQyxLQUFLO0FBQUEsUUFDbEM7QUFBQSxNQUNGO0FBR0EsY0FBUSxNQUFNLFFBQVEsT0FBTyxFQUFFO0FBRS9CLFVBQUlDLFFBQU9ELFVBQVM7QUFDcEIsVUFBSSxRQUFRQSxVQUFTLE9BQU8sQ0FBQztBQUM3QixVQUFJLFFBQVEsQ0FBQyxDQUFDO0FBQ2QsZUFBUSxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNwQyxZQUFJLFFBQVFFLE9BQU0sTUFBTSxXQUFXLENBQUM7QUFDcEMsWUFBRyxVQUFVLFFBQVc7QUFDdEI7QUFBQSxRQUNGO0FBRUEsaUJBQVEsSUFBSSxHQUFHLFFBQVEsT0FBTyxJQUFJLE1BQU0sUUFBUSxFQUFFLEdBQUc7QUFDbkQsbUJBQVMsTUFBTSxLQUFLRDtBQUNwQixnQkFBTSxLQUFLLFFBQVE7QUFDbkIsb0JBQVU7QUFBQSxRQUNaO0FBRUEsZUFBTSxRQUFRLEdBQUc7QUFDZixnQkFBTSxLQUFLLFFBQVEsR0FBSTtBQUN2QixvQkFBVTtBQUFBLFFBQ1o7QUFBQSxNQUNGO0FBR0EsZUFBUSxJQUFJLEdBQUcsTUFBTSxPQUFPLFNBQVMsSUFBSSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDOUQsY0FBTSxLQUFLLENBQUM7QUFBQSxNQUNkO0FBRUEsVUFBRyxPQUFPLFdBQVcsYUFBYTtBQUNoQyxlQUFPLE9BQU8sS0FBSyxNQUFNLFFBQVEsQ0FBQztBQUFBLE1BQ3BDO0FBRUEsYUFBTyxJQUFJLFdBQVcsTUFBTSxRQUFRLENBQUM7QUFBQSxJQUN2QztBQUVBLGFBQVMsc0JBQXNCLE9BQU9ELFdBQVU7QUFDOUMsVUFBSSxJQUFJO0FBQ1IsVUFBSUMsUUFBT0QsVUFBUztBQUNwQixVQUFJLFFBQVFBLFVBQVMsT0FBTyxDQUFDO0FBQzdCLFVBQUksU0FBUyxDQUFDLENBQUM7QUFDZixXQUFJLElBQUksR0FBRyxJQUFJLE1BQU0sT0FBTyxHQUFHLEVBQUUsR0FBRztBQUNsQyxpQkFBUSxJQUFJLEdBQUcsUUFBUSxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUksT0FBTyxRQUFRLEVBQUUsR0FBRztBQUMxRCxtQkFBUyxPQUFPLE1BQU07QUFDdEIsaUJBQU8sS0FBSyxRQUFRQztBQUNwQixrQkFBUyxRQUFRQSxRQUFRO0FBQUEsUUFDM0I7QUFFQSxlQUFNLFFBQVEsR0FBRztBQUNmLGlCQUFPLEtBQUssUUFBUUEsS0FBSTtBQUN4QixrQkFBUyxRQUFRQSxRQUFRO0FBQUEsUUFDM0I7QUFBQSxNQUNGO0FBRUEsVUFBSSxTQUFTO0FBR2IsV0FBSSxJQUFJLEdBQUcsTUFBTSxHQUFHLENBQUMsTUFBTSxLQUFLLElBQUksTUFBTSxPQUFPLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDM0Qsa0JBQVU7QUFBQSxNQUNaO0FBRUEsV0FBSSxJQUFJLE9BQU8sU0FBUyxHQUFHLEtBQUssR0FBRyxFQUFFLEdBQUc7QUFDdEMsa0JBQVVELFVBQVMsT0FBTztBQUFBLE1BQzVCO0FBRUEsYUFBTztBQUFBLElBQ1Q7QUFBQTtBQUFBOzs7QUN6TEEsSUFBQUcsZ0JBQUE7QUFBQSx3Q0FBQUMsVUFBQUMsU0FBQTtBQU9BLFFBQUlDLFNBQVE7QUFDWixRQUFJLFFBQVE7QUFHWixRQUFJLE9BQU9ELFFBQU8sVUFBVUMsT0FBTSxPQUFPQSxPQUFNLFFBQVEsQ0FBQztBQUd4RCxLQUFDLFdBQVc7QUFJVixVQUFHLE9BQU8sWUFBWSxlQUFlLFFBQVEsWUFBWSxDQUFDLFFBQVEsU0FBUztBQUN6RSxhQUFLLFdBQVcsUUFBUTtBQUN4QixZQUFHLE9BQU8saUJBQWlCLFlBQVk7QUFDckMsZUFBSyxlQUFlO0FBQUEsUUFDdEIsT0FBTztBQUdMLGVBQUssZUFBZSxLQUFLO0FBQUEsUUFDM0I7QUFDQTtBQUFBLE1BQ0Y7QUFHQSxVQUFHLE9BQU8saUJBQWlCLFlBQVk7QUFDckMsYUFBSyxlQUFlLFdBQVc7QUFBRSxpQkFBTyxhQUFhLE1BQU0sUUFBVyxTQUFTO0FBQUEsUUFBRztBQUNsRixhQUFLLFdBQVcsU0FBUyxVQUFVO0FBQ2pDLGlCQUFPLGFBQWEsUUFBUTtBQUFBLFFBQzlCO0FBQ0E7QUFBQSxNQUNGO0FBUUEsV0FBSyxlQUFlLFNBQVMsVUFBVTtBQUNyQyxtQkFBVyxVQUFVLENBQUM7QUFBQSxNQUN4QjtBQUdBLFVBQUcsT0FBTyxXQUFXLGVBQ25CLE9BQU8sT0FBTyxnQkFBZ0IsWUFBWTtBQVcxQyxZQUFTQyxXQUFULFNBQWlCLE9BQU87QUFDdEIsY0FBRyxNQUFNLFdBQVcsVUFBVSxNQUFNLFNBQVMsS0FBSztBQUNoRCxrQkFBTSxnQkFBZ0I7QUFDdEIsZ0JBQUksT0FBTyxVQUFVLE1BQU07QUFDM0Isc0JBQVUsU0FBUztBQUNuQixpQkFBSyxRQUFRLFNBQVMsVUFBVTtBQUM5Qix1QkFBUztBQUFBLFlBQ1gsQ0FBQztBQUFBLFVBQ0g7QUFBQSxRQUNGO0FBVFMsc0JBQUFBO0FBVlQsWUFBSSxNQUFNO0FBQ1YsWUFBSSxZQUFZLENBQUM7QUFDakIsYUFBSyxlQUFlLFNBQVMsVUFBVTtBQUNyQyxvQkFBVSxLQUFLLFFBQVE7QUFHdkIsY0FBRyxVQUFVLFdBQVcsR0FBRztBQUN6QixtQkFBTyxZQUFZLEtBQUssR0FBRztBQUFBLFVBQzdCO0FBQUEsUUFDRjtBQVdBLGVBQU8saUJBQWlCLFdBQVdBLFVBQVMsSUFBSTtBQUFBLE1BQ2xEO0FBR0EsVUFBRyxPQUFPLHFCQUFxQixhQUFhO0FBRTFDLFlBQUksTUFBTSxLQUFLLElBQUk7QUFDbkIsWUFBSSxPQUFPO0FBQ1gsWUFBSSxNQUFNLFNBQVMsY0FBYyxLQUFLO0FBQ3RDLFlBQUksWUFBWSxDQUFDO0FBQ2pCLFlBQUksaUJBQWlCLFdBQVc7QUFDOUIsY0FBSSxPQUFPLFVBQVUsTUFBTTtBQUMzQixvQkFBVSxTQUFTO0FBQ25CLGVBQUssUUFBUSxTQUFTLFVBQVU7QUFDOUIscUJBQVM7QUFBQSxVQUNYLENBQUM7QUFBQSxRQUNILENBQUMsRUFBRSxRQUFRLEtBQUssRUFBQyxZQUFZLEtBQUksQ0FBQztBQUNsQyxZQUFJLGtCQUFrQixLQUFLO0FBQzNCLGFBQUssZUFBZSxTQUFTLFVBQVU7QUFDckMsY0FBRyxLQUFLLElBQUksSUFBSSxNQUFNLElBQUk7QUFDeEIsa0JBQU0sS0FBSyxJQUFJO0FBQ2YsNEJBQWdCLFFBQVE7QUFBQSxVQUMxQixPQUFPO0FBQ0wsc0JBQVUsS0FBSyxRQUFRO0FBR3ZCLGdCQUFHLFVBQVUsV0FBVyxHQUFHO0FBQ3pCLGtCQUFJLGFBQWEsS0FBSyxPQUFPLENBQUMsSUFBSTtBQUFBLFlBQ3BDO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUEsV0FBSyxXQUFXLEtBQUs7QUFBQSxJQUN2QixHQUFHO0FBR0gsU0FBSyxXQUNILE9BQU8sWUFBWSxlQUFlLFFBQVEsWUFBWSxRQUFRLFNBQVM7QUFPekUsU0FBSyxjQUFlLFdBQVc7QUFDN0IsVUFBRyxLQUFLLFVBQVU7QUFDaEIsZUFBTztBQUFBLE1BQ1Q7QUFFQSxhQUFPLE9BQU8sU0FBUyxjQUFjLFNBQVM7QUFBQSxJQUNoRCxFQUFHO0FBR0gsU0FBSyxVQUFVLE1BQU0sV0FBVyxTQUFTLEdBQUc7QUFDMUMsYUFBTyxPQUFPLFVBQVUsU0FBUyxLQUFLLENBQUMsTUFBTTtBQUFBLElBQy9DO0FBR0EsU0FBSyxnQkFBZ0IsU0FBUyxHQUFHO0FBQy9CLGFBQU8sT0FBTyxnQkFBZ0IsZUFBZSxhQUFhO0FBQUEsSUFDNUQ7QUFHQSxTQUFLLG9CQUFvQixTQUFTLEdBQUc7QUFDbkMsYUFBTyxLQUFLLEtBQUssY0FBYyxFQUFFLE1BQU0sS0FBSyxFQUFFLGVBQWU7QUFBQSxJQUMvRDtBQVdBLGFBQVMsZ0JBQWdCLEdBQUc7QUFDMUIsVUFBRyxFQUFFLE1BQU0sS0FBSyxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sS0FBSztBQUNqRCxjQUFNLElBQUksTUFBTSwyQ0FBMkMsQ0FBQztBQUFBLE1BQzlEO0FBQUEsSUFDRjtBQUdBLFNBQUssYUFBYTtBQVVsQixhQUFTLGlCQUFpQixHQUFHO0FBSTNCLFdBQUssT0FBTztBQUVaLFdBQUssT0FBTztBQUVaLFVBQUcsT0FBTyxNQUFNLFVBQVU7QUFDeEIsYUFBSyxPQUFPO0FBQUEsTUFDZCxXQUFVLEtBQUssY0FBYyxDQUFDLEtBQUssS0FBSyxrQkFBa0IsQ0FBQyxHQUFHO0FBQzVELFlBQUcsT0FBTyxXQUFXLGVBQWUsYUFBYSxRQUFRO0FBQ3ZELGVBQUssT0FBTyxFQUFFLFNBQVMsUUFBUTtBQUFBLFFBQ2pDLE9BQU87QUFHTCxjQUFJLE1BQU0sSUFBSSxXQUFXLENBQUM7QUFDMUIsY0FBSTtBQUNGLGlCQUFLLE9BQU8sT0FBTyxhQUFhLE1BQU0sTUFBTSxHQUFHO0FBQUEsVUFDakQsU0FBUSxHQUFOO0FBQ0EscUJBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUUsR0FBRztBQUNsQyxtQkFBSyxRQUFRLElBQUksRUFBRTtBQUFBLFlBQ3JCO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGLFdBQVUsYUFBYSxvQkFDcEIsT0FBTyxNQUFNLFlBQVksT0FBTyxFQUFFLFNBQVMsWUFDNUMsT0FBTyxFQUFFLFNBQVMsVUFBVztBQUU3QixhQUFLLE9BQU8sRUFBRTtBQUNkLGFBQUssT0FBTyxFQUFFO0FBQUEsTUFDaEI7QUFHQSxXQUFLLDJCQUEyQjtBQUFBLElBQ2xDO0FBQ0EsU0FBSyxtQkFBbUI7QUFZeEIsUUFBSSxpQ0FBaUM7QUFDckMsU0FBSyxpQkFBaUIsVUFBVSw2QkFBNkIsU0FBUyxHQUFHO0FBQ3ZFLFdBQUssNEJBQTRCO0FBQ2pDLFVBQUcsS0FBSywyQkFBMkIsZ0NBQWdDO0FBRWpFLGFBQUssS0FBSyxPQUFPLEdBQUcsQ0FBQztBQUNyQixhQUFLLDJCQUEyQjtBQUFBLE1BQ2xDO0FBQUEsSUFDRjtBQU9BLFNBQUssaUJBQWlCLFVBQVUsU0FBUyxXQUFXO0FBQ2xELGFBQU8sS0FBSyxLQUFLLFNBQVMsS0FBSztBQUFBLElBQ2pDO0FBT0EsU0FBSyxpQkFBaUIsVUFBVSxVQUFVLFdBQVc7QUFDbkQsYUFBTyxLQUFLLE9BQU8sS0FBSztBQUFBLElBQzFCO0FBU0EsU0FBSyxpQkFBaUIsVUFBVSxVQUFVLFNBQVMsR0FBRztBQUNwRCxhQUFPLEtBQUssU0FBUyxPQUFPLGFBQWEsQ0FBQyxDQUFDO0FBQUEsSUFDN0M7QUFVQSxTQUFLLGlCQUFpQixVQUFVLGVBQWUsU0FBUyxHQUFHLEdBQUc7QUFDNUQsVUFBSSxPQUFPLGFBQWEsQ0FBQztBQUN6QixVQUFJLElBQUksS0FBSztBQUNiLGFBQU0sSUFBSSxHQUFHO0FBQ1gsWUFBRyxJQUFJLEdBQUc7QUFDUixlQUFLO0FBQUEsUUFDUDtBQUNBLGVBQU87QUFDUCxZQUFHLElBQUksR0FBRztBQUNSLGVBQUs7QUFBQSxRQUNQO0FBQUEsTUFDRjtBQUNBLFdBQUssT0FBTztBQUNaLFdBQUssMkJBQTJCLENBQUM7QUFDakMsYUFBTztBQUFBLElBQ1Q7QUFTQSxTQUFLLGlCQUFpQixVQUFVLFdBQVcsU0FBUyxPQUFPO0FBQ3pELFdBQUssUUFBUTtBQUNiLFdBQUssMkJBQTJCLE1BQU0sTUFBTTtBQUM1QyxhQUFPO0FBQUEsSUFDVDtBQVNBLFNBQUssaUJBQWlCLFVBQVUsWUFBWSxTQUFTLEtBQUs7QUFDeEQsYUFBTyxLQUFLLFNBQVMsS0FBSyxXQUFXLEdBQUcsQ0FBQztBQUFBLElBQzNDO0FBU0EsU0FBSyxpQkFBaUIsVUFBVSxXQUFXLFNBQVMsR0FBRztBQUNyRCxhQUFPLEtBQUs7QUFBQSxRQUNWLE9BQU8sYUFBYSxLQUFLLElBQUksR0FBSSxJQUNqQyxPQUFPLGFBQWEsSUFBSSxHQUFJO0FBQUEsTUFBQztBQUFBLElBQ2pDO0FBU0EsU0FBSyxpQkFBaUIsVUFBVSxXQUFXLFNBQVMsR0FBRztBQUNyRCxhQUFPLEtBQUs7QUFBQSxRQUNWLE9BQU8sYUFBYSxLQUFLLEtBQUssR0FBSSxJQUNsQyxPQUFPLGFBQWEsS0FBSyxJQUFJLEdBQUksSUFDakMsT0FBTyxhQUFhLElBQUksR0FBSTtBQUFBLE1BQUM7QUFBQSxJQUNqQztBQVNBLFNBQUssaUJBQWlCLFVBQVUsV0FBVyxTQUFTLEdBQUc7QUFDckQsYUFBTyxLQUFLO0FBQUEsUUFDVixPQUFPLGFBQWEsS0FBSyxLQUFLLEdBQUksSUFDbEMsT0FBTyxhQUFhLEtBQUssS0FBSyxHQUFJLElBQ2xDLE9BQU8sYUFBYSxLQUFLLElBQUksR0FBSSxJQUNqQyxPQUFPLGFBQWEsSUFBSSxHQUFJO0FBQUEsTUFBQztBQUFBLElBQ2pDO0FBU0EsU0FBSyxpQkFBaUIsVUFBVSxhQUFhLFNBQVMsR0FBRztBQUN2RCxhQUFPLEtBQUs7QUFBQSxRQUNWLE9BQU8sYUFBYSxJQUFJLEdBQUksSUFDNUIsT0FBTyxhQUFhLEtBQUssSUFBSSxHQUFJO0FBQUEsTUFBQztBQUFBLElBQ3RDO0FBU0EsU0FBSyxpQkFBaUIsVUFBVSxhQUFhLFNBQVMsR0FBRztBQUN2RCxhQUFPLEtBQUs7QUFBQSxRQUNWLE9BQU8sYUFBYSxJQUFJLEdBQUksSUFDNUIsT0FBTyxhQUFhLEtBQUssSUFBSSxHQUFJLElBQ2pDLE9BQU8sYUFBYSxLQUFLLEtBQUssR0FBSTtBQUFBLE1BQUM7QUFBQSxJQUN2QztBQVNBLFNBQUssaUJBQWlCLFVBQVUsYUFBYSxTQUFTLEdBQUc7QUFDdkQsYUFBTyxLQUFLO0FBQUEsUUFDVixPQUFPLGFBQWEsSUFBSSxHQUFJLElBQzVCLE9BQU8sYUFBYSxLQUFLLElBQUksR0FBSSxJQUNqQyxPQUFPLGFBQWEsS0FBSyxLQUFLLEdBQUksSUFDbEMsT0FBTyxhQUFhLEtBQUssS0FBSyxHQUFJO0FBQUEsTUFBQztBQUFBLElBQ3ZDO0FBVUEsU0FBSyxpQkFBaUIsVUFBVSxTQUFTLFNBQVMsR0FBRyxHQUFHO0FBQ3RELHNCQUFnQixDQUFDO0FBQ2pCLFVBQUksUUFBUTtBQUNaLFNBQUc7QUFDRCxhQUFLO0FBQ0wsaUJBQVMsT0FBTyxhQUFjLEtBQUssSUFBSyxHQUFJO0FBQUEsTUFDOUMsU0FBUSxJQUFJO0FBQ1osYUFBTyxLQUFLLFNBQVMsS0FBSztBQUFBLElBQzVCO0FBV0EsU0FBSyxpQkFBaUIsVUFBVSxlQUFlLFNBQVMsR0FBRyxHQUFHO0FBRTVELFVBQUcsSUFBSSxHQUFHO0FBQ1IsYUFBSyxLQUFNLElBQUk7QUFBQSxNQUNqQjtBQUNBLGFBQU8sS0FBSyxPQUFPLEdBQUcsQ0FBQztBQUFBLElBQ3pCO0FBU0EsU0FBSyxpQkFBaUIsVUFBVSxZQUFZLFNBQVMsUUFBUTtBQUMzRCxhQUFPLEtBQUssU0FBUyxPQUFPLFNBQVMsQ0FBQztBQUFBLElBQ3hDO0FBT0EsU0FBSyxpQkFBaUIsVUFBVSxVQUFVLFdBQVc7QUFDbkQsYUFBTyxLQUFLLEtBQUssV0FBVyxLQUFLLE1BQU07QUFBQSxJQUN6QztBQVFBLFNBQUssaUJBQWlCLFVBQVUsV0FBVyxXQUFXO0FBQ3BELFVBQUksT0FDRixLQUFLLEtBQUssV0FBVyxLQUFLLElBQUksS0FBSyxJQUNuQyxLQUFLLEtBQUssV0FBVyxLQUFLLE9BQU8sQ0FBQztBQUNwQyxXQUFLLFFBQVE7QUFDYixhQUFPO0FBQUEsSUFDVDtBQVFBLFNBQUssaUJBQWlCLFVBQVUsV0FBVyxXQUFXO0FBQ3BELFVBQUksT0FDRixLQUFLLEtBQUssV0FBVyxLQUFLLElBQUksS0FBSyxLQUNuQyxLQUFLLEtBQUssV0FBVyxLQUFLLE9BQU8sQ0FBQyxLQUFLLElBQ3ZDLEtBQUssS0FBSyxXQUFXLEtBQUssT0FBTyxDQUFDO0FBQ3BDLFdBQUssUUFBUTtBQUNiLGFBQU87QUFBQSxJQUNUO0FBUUEsU0FBSyxpQkFBaUIsVUFBVSxXQUFXLFdBQVc7QUFDcEQsVUFBSSxPQUNGLEtBQUssS0FBSyxXQUFXLEtBQUssSUFBSSxLQUFLLEtBQ25DLEtBQUssS0FBSyxXQUFXLEtBQUssT0FBTyxDQUFDLEtBQUssS0FDdkMsS0FBSyxLQUFLLFdBQVcsS0FBSyxPQUFPLENBQUMsS0FBSyxJQUN2QyxLQUFLLEtBQUssV0FBVyxLQUFLLE9BQU8sQ0FBQztBQUNwQyxXQUFLLFFBQVE7QUFDYixhQUFPO0FBQUEsSUFDVDtBQVFBLFNBQUssaUJBQWlCLFVBQVUsYUFBYSxXQUFXO0FBQ3RELFVBQUksT0FDRixLQUFLLEtBQUssV0FBVyxLQUFLLElBQUksSUFDOUIsS0FBSyxLQUFLLFdBQVcsS0FBSyxPQUFPLENBQUMsS0FBSztBQUN6QyxXQUFLLFFBQVE7QUFDYixhQUFPO0FBQUEsSUFDVDtBQVFBLFNBQUssaUJBQWlCLFVBQVUsYUFBYSxXQUFXO0FBQ3RELFVBQUksT0FDRixLQUFLLEtBQUssV0FBVyxLQUFLLElBQUksSUFDOUIsS0FBSyxLQUFLLFdBQVcsS0FBSyxPQUFPLENBQUMsS0FBSyxJQUN2QyxLQUFLLEtBQUssV0FBVyxLQUFLLE9BQU8sQ0FBQyxLQUFLO0FBQ3pDLFdBQUssUUFBUTtBQUNiLGFBQU87QUFBQSxJQUNUO0FBUUEsU0FBSyxpQkFBaUIsVUFBVSxhQUFhLFdBQVc7QUFDdEQsVUFBSSxPQUNGLEtBQUssS0FBSyxXQUFXLEtBQUssSUFBSSxJQUM5QixLQUFLLEtBQUssV0FBVyxLQUFLLE9BQU8sQ0FBQyxLQUFLLElBQ3ZDLEtBQUssS0FBSyxXQUFXLEtBQUssT0FBTyxDQUFDLEtBQUssS0FDdkMsS0FBSyxLQUFLLFdBQVcsS0FBSyxPQUFPLENBQUMsS0FBSztBQUN6QyxXQUFLLFFBQVE7QUFDYixhQUFPO0FBQUEsSUFDVDtBQVVBLFNBQUssaUJBQWlCLFVBQVUsU0FBUyxTQUFTLEdBQUc7QUFDbkQsc0JBQWdCLENBQUM7QUFDakIsVUFBSSxPQUFPO0FBQ1gsU0FBRztBQUVELGdCQUFRLFFBQVEsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLE1BQU07QUFDckQsYUFBSztBQUFBLE1BQ1AsU0FBUSxJQUFJO0FBQ1osYUFBTztBQUFBLElBQ1Q7QUFVQSxTQUFLLGlCQUFpQixVQUFVLGVBQWUsU0FBUyxHQUFHO0FBRXpELFVBQUksSUFBSSxLQUFLLE9BQU8sQ0FBQztBQUNyQixVQUFJLE1BQU0sS0FBTSxJQUFJO0FBQ3BCLFVBQUcsS0FBSyxLQUFLO0FBQ1gsYUFBSyxPQUFPO0FBQUEsTUFDZDtBQUNBLGFBQU87QUFBQSxJQUNUO0FBV0EsU0FBSyxpQkFBaUIsVUFBVSxXQUFXLFNBQVMsT0FBTztBQUN6RCxVQUFJO0FBQ0osVUFBRyxPQUFPO0FBRVIsZ0JBQVEsS0FBSyxJQUFJLEtBQUssT0FBTyxHQUFHLEtBQUs7QUFDckMsZUFBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUs7QUFDbkQsYUFBSyxRQUFRO0FBQUEsTUFDZixXQUFVLFVBQVUsR0FBRztBQUNyQixlQUFPO0FBQUEsTUFDVCxPQUFPO0FBRUwsZUFBUSxLQUFLLFNBQVMsSUFBSyxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxJQUFJO0FBQ2hFLGFBQUssTUFBTTtBQUFBLE1BQ2I7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQVVBLFNBQUssaUJBQWlCLFVBQVUsUUFBUSxTQUFTLE9BQU87QUFDdEQsYUFBUSxPQUFPLFVBQVcsY0FDeEIsS0FBSyxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQ3pCLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSztBQUFBLElBQ2hEO0FBU0EsU0FBSyxpQkFBaUIsVUFBVSxLQUFLLFNBQVMsR0FBRztBQUMvQyxhQUFPLEtBQUssS0FBSyxXQUFXLEtBQUssT0FBTyxDQUFDO0FBQUEsSUFDM0M7QUFVQSxTQUFLLGlCQUFpQixVQUFVLFFBQVEsU0FBUyxHQUFHLEdBQUc7QUFDckQsV0FBSyxPQUFPLEtBQUssS0FBSyxPQUFPLEdBQUcsS0FBSyxPQUFPLENBQUMsSUFDM0MsT0FBTyxhQUFhLENBQUMsSUFDckIsS0FBSyxLQUFLLE9BQU8sS0FBSyxPQUFPLElBQUksQ0FBQztBQUNwQyxhQUFPO0FBQUEsSUFDVDtBQU9BLFNBQUssaUJBQWlCLFVBQVUsT0FBTyxXQUFXO0FBQ2hELGFBQU8sS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFNBQVMsQ0FBQztBQUFBLElBQ2xEO0FBT0EsU0FBSyxpQkFBaUIsVUFBVSxPQUFPLFdBQVc7QUFDaEQsVUFBSSxJQUFJLEtBQUssYUFBYSxLQUFLLElBQUk7QUFDbkMsUUFBRSxPQUFPLEtBQUs7QUFDZCxhQUFPO0FBQUEsSUFDVDtBQU9BLFNBQUssaUJBQWlCLFVBQVUsVUFBVSxXQUFXO0FBQ25ELFVBQUcsS0FBSyxPQUFPLEdBQUc7QUFDaEIsYUFBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssSUFBSTtBQUNyQyxhQUFLLE9BQU87QUFBQSxNQUNkO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFPQSxTQUFLLGlCQUFpQixVQUFVLFFBQVEsV0FBVztBQUNqRCxXQUFLLE9BQU87QUFDWixXQUFLLE9BQU87QUFDWixhQUFPO0FBQUEsSUFDVDtBQVNBLFNBQUssaUJBQWlCLFVBQVUsV0FBVyxTQUFTLE9BQU87QUFDekQsVUFBSSxNQUFNLEtBQUssSUFBSSxHQUFHLEtBQUssT0FBTyxJQUFJLEtBQUs7QUFDM0MsV0FBSyxPQUFPLEtBQUssS0FBSyxPQUFPLEtBQUssTUFBTSxHQUFHO0FBQzNDLFdBQUssT0FBTztBQUNaLGFBQU87QUFBQSxJQUNUO0FBT0EsU0FBSyxpQkFBaUIsVUFBVSxRQUFRLFdBQVc7QUFDakQsVUFBSSxPQUFPO0FBQ1gsZUFBUSxJQUFJLEtBQUssTUFBTSxJQUFJLEtBQUssS0FBSyxRQUFRLEVBQUUsR0FBRztBQUNoRCxZQUFJLElBQUksS0FBSyxLQUFLLFdBQVcsQ0FBQztBQUM5QixZQUFHLElBQUksSUFBSTtBQUNULGtCQUFRO0FBQUEsUUFDVjtBQUNBLGdCQUFRLEVBQUUsU0FBUyxFQUFFO0FBQUEsTUFDdkI7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQU9BLFNBQUssaUJBQWlCLFVBQVUsV0FBVyxXQUFXO0FBQ3BELGFBQU8sS0FBSyxXQUFXLEtBQUssTUFBTSxDQUFDO0FBQUEsSUFDckM7QUFrQ0EsYUFBUyxXQUFXLEdBQUdDLFVBQVM7QUFFOUIsTUFBQUEsV0FBVUEsWUFBVyxDQUFDO0FBR3RCLFdBQUssT0FBT0EsU0FBUSxjQUFjO0FBQ2xDLFdBQUssV0FBV0EsU0FBUSxZQUFZO0FBRXBDLFVBQUksZ0JBQWdCLEtBQUssY0FBYyxDQUFDO0FBQ3hDLFVBQUksb0JBQW9CLEtBQUssa0JBQWtCLENBQUM7QUFDaEQsVUFBRyxpQkFBaUIsbUJBQW1CO0FBRXJDLFlBQUcsZUFBZTtBQUNoQixlQUFLLE9BQU8sSUFBSSxTQUFTLENBQUM7QUFBQSxRQUM1QixPQUFPO0FBSUwsZUFBSyxPQUFPLElBQUksU0FBUyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsVUFBVTtBQUFBLFFBQy9EO0FBQ0EsYUFBSyxRQUFTLGlCQUFpQkEsV0FDN0JBLFNBQVEsY0FBYyxLQUFLLEtBQUs7QUFDbEM7QUFBQSxNQUNGO0FBR0EsV0FBSyxPQUFPLElBQUksU0FBUyxJQUFJLFlBQVksQ0FBQyxDQUFDO0FBQzNDLFdBQUssUUFBUTtBQUViLFVBQUcsTUFBTSxRQUFRLE1BQU0sUUFBVztBQUNoQyxhQUFLLFNBQVMsQ0FBQztBQUFBLE1BQ2pCO0FBRUEsVUFBRyxpQkFBaUJBLFVBQVM7QUFDM0IsYUFBSyxRQUFRQSxTQUFRO0FBQUEsTUFDdkI7QUFBQSxJQUNGO0FBQ0EsU0FBSyxhQUFhO0FBT2xCLFNBQUssV0FBVyxVQUFVLFNBQVMsV0FBVztBQUM1QyxhQUFPLEtBQUssUUFBUSxLQUFLO0FBQUEsSUFDM0I7QUFPQSxTQUFLLFdBQVcsVUFBVSxVQUFVLFdBQVc7QUFDN0MsYUFBTyxLQUFLLE9BQU8sS0FBSztBQUFBLElBQzFCO0FBYUEsU0FBSyxXQUFXLFVBQVUsY0FBYyxTQUFTLFFBQVEsVUFBVTtBQUNqRSxVQUFHLEtBQUssT0FBTyxLQUFLLFFBQVE7QUFDMUIsZUFBTztBQUFBLE1BQ1Q7QUFDQSxpQkFBVyxLQUFLLElBQUksWUFBWSxLQUFLLFVBQVUsTUFBTTtBQUdyRCxVQUFJQyxPQUFNLElBQUk7QUFBQSxRQUNaLEtBQUssS0FBSztBQUFBLFFBQVEsS0FBSyxLQUFLO0FBQUEsUUFBWSxLQUFLLEtBQUs7QUFBQSxNQUFVO0FBQzlELFVBQUksTUFBTSxJQUFJLFdBQVcsS0FBSyxPQUFPLElBQUksUUFBUTtBQUNqRCxVQUFJLElBQUlBLElBQUc7QUFDWCxXQUFLLE9BQU8sSUFBSSxTQUFTLElBQUksTUFBTTtBQUVuQyxhQUFPO0FBQUEsSUFDVDtBQVNBLFNBQUssV0FBVyxVQUFVLFVBQVUsU0FBUyxHQUFHO0FBQzlDLFdBQUssWUFBWSxDQUFDO0FBQ2xCLFdBQUssS0FBSyxTQUFTLEtBQUssU0FBUyxDQUFDO0FBQ2xDLGFBQU87QUFBQSxJQUNUO0FBVUEsU0FBSyxXQUFXLFVBQVUsZUFBZSxTQUFTLEdBQUcsR0FBRztBQUN0RCxXQUFLLFlBQVksQ0FBQztBQUNsQixlQUFRLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3pCLGFBQUssS0FBSyxTQUFTLENBQUM7QUFBQSxNQUN0QjtBQUNBLGFBQU87QUFBQSxJQUNUO0FBWUEsU0FBSyxXQUFXLFVBQVUsV0FBVyxTQUFTLE9BQU8sVUFBVTtBQUM3RCxVQUFHLEtBQUssa0JBQWtCLEtBQUssR0FBRztBQUNoQyxZQUFJQSxPQUFNLElBQUksV0FBVyxNQUFNLFFBQVEsTUFBTSxZQUFZLE1BQU0sVUFBVTtBQUN6RSxZQUFJLE1BQU1BLEtBQUksYUFBYUEsS0FBSTtBQUMvQixhQUFLLFlBQVksR0FBRztBQUNwQixZQUFJLE1BQU0sSUFBSSxXQUFXLEtBQUssS0FBSyxRQUFRLEtBQUssS0FBSztBQUNyRCxZQUFJLElBQUlBLElBQUc7QUFDWCxhQUFLLFNBQVM7QUFDZCxlQUFPO0FBQUEsTUFDVDtBQUVBLFVBQUcsS0FBSyxjQUFjLEtBQUssR0FBRztBQUM1QixZQUFJQSxPQUFNLElBQUksV0FBVyxLQUFLO0FBQzlCLGFBQUssWUFBWUEsS0FBSSxVQUFVO0FBQy9CLFlBQUksTUFBTSxJQUFJLFdBQVcsS0FBSyxLQUFLLE1BQU07QUFDekMsWUFBSSxJQUFJQSxNQUFLLEtBQUssS0FBSztBQUN2QixhQUFLLFNBQVNBLEtBQUk7QUFDbEIsZUFBTztBQUFBLE1BQ1Q7QUFHQSxVQUFHLGlCQUFpQixLQUFLLGNBQ3RCLE9BQU8sVUFBVSxZQUNsQixPQUFPLE1BQU0sU0FBUyxZQUFZLE9BQU8sTUFBTSxVQUFVLFlBQ3pELEtBQUssa0JBQWtCLE1BQU0sSUFBSSxHQUFJO0FBQ3JDLFlBQUlBLE9BQU0sSUFBSSxXQUFXLE1BQU0sS0FBSyxZQUFZLE1BQU0sTUFBTSxNQUFNLE9BQU8sQ0FBQztBQUMxRSxhQUFLLFlBQVlBLEtBQUksVUFBVTtBQUMvQixZQUFJLE1BQU0sSUFBSSxXQUFXLE1BQU0sS0FBSyxZQUFZLEtBQUssS0FBSztBQUMxRCxZQUFJLElBQUlBLElBQUc7QUFDWCxhQUFLLFNBQVNBLEtBQUk7QUFDbEIsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFHLGlCQUFpQixLQUFLLGtCQUFrQjtBQUV6QyxnQkFBUSxNQUFNO0FBQ2QsbUJBQVc7QUFBQSxNQUNiO0FBR0EsaUJBQVcsWUFBWTtBQUN2QixVQUFHLE9BQU8sVUFBVSxVQUFVO0FBQzVCLFlBQUk7QUFHSixZQUFHLGFBQWEsT0FBTztBQUNyQixlQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sU0FBUyxDQUFDLENBQUM7QUFDNUMsaUJBQU8sSUFBSSxXQUFXLEtBQUssS0FBSyxRQUFRLEtBQUssS0FBSztBQUNsRCxlQUFLLFNBQVMsS0FBSyxPQUFPLElBQUksT0FBTyxPQUFPLE1BQU0sS0FBSyxLQUFLO0FBQzVELGlCQUFPO0FBQUEsUUFDVDtBQUNBLFlBQUcsYUFBYSxVQUFVO0FBQ3hCLGVBQUssWUFBWSxLQUFLLEtBQUssTUFBTSxTQUFTLENBQUMsSUFBSSxDQUFDO0FBQ2hELGlCQUFPLElBQUksV0FBVyxLQUFLLEtBQUssUUFBUSxLQUFLLEtBQUs7QUFDbEQsZUFBSyxTQUFTLEtBQUssT0FBTyxPQUFPLE9BQU8sT0FBTyxNQUFNLEtBQUssS0FBSztBQUMvRCxpQkFBTztBQUFBLFFBQ1Q7QUFHQSxZQUFHLGFBQWEsUUFBUTtBQUV0QixrQkFBUSxLQUFLLFdBQVcsS0FBSztBQUM3QixxQkFBVztBQUFBLFFBQ2I7QUFHQSxZQUFHLGFBQWEsWUFBWSxhQUFhLE9BQU87QUFFOUMsZUFBSyxZQUFZLE1BQU0sTUFBTTtBQUM3QixpQkFBTyxJQUFJLFdBQVcsS0FBSyxLQUFLLFFBQVEsS0FBSyxLQUFLO0FBQ2xELGVBQUssU0FBUyxLQUFLLE9BQU8sSUFBSSxPQUFPLElBQUk7QUFDekMsaUJBQU87QUFBQSxRQUNUO0FBR0EsWUFBRyxhQUFhLFNBQVM7QUFFdkIsZUFBSyxZQUFZLE1BQU0sU0FBUyxDQUFDO0FBQ2pDLGlCQUFPLElBQUksWUFBWSxLQUFLLEtBQUssUUFBUSxLQUFLLEtBQUs7QUFDbkQsZUFBSyxTQUFTLEtBQUssS0FBSyxNQUFNLE9BQU8sSUFBSTtBQUN6QyxpQkFBTztBQUFBLFFBQ1Q7QUFFQSxjQUFNLElBQUksTUFBTSx1QkFBdUIsUUFBUTtBQUFBLE1BQ2pEO0FBRUEsWUFBTSxNQUFNLHdCQUF3QixLQUFLO0FBQUEsSUFDM0M7QUFTQSxTQUFLLFdBQVcsVUFBVSxZQUFZLFNBQVMsUUFBUTtBQUNyRCxXQUFLLFNBQVMsTUFBTTtBQUNwQixhQUFPLE1BQU07QUFDYixhQUFPO0FBQUEsSUFDVDtBQVVBLFNBQUssV0FBVyxVQUFVLFlBQVksU0FBUyxLQUFLO0FBQ2xELGFBQU8sS0FBSyxTQUFTLEtBQUssT0FBTztBQUFBLElBQ25DO0FBU0EsU0FBSyxXQUFXLFVBQVUsV0FBVyxTQUFTLEdBQUc7QUFDL0MsV0FBSyxZQUFZLENBQUM7QUFDbEIsV0FBSyxLQUFLLFNBQVMsS0FBSyxPQUFPLENBQUM7QUFDaEMsV0FBSyxTQUFTO0FBQ2QsYUFBTztBQUFBLElBQ1Q7QUFTQSxTQUFLLFdBQVcsVUFBVSxXQUFXLFNBQVMsR0FBRztBQUMvQyxXQUFLLFlBQVksQ0FBQztBQUNsQixXQUFLLEtBQUssU0FBUyxLQUFLLE9BQU8sS0FBSyxJQUFJLEtBQU07QUFDOUMsV0FBSyxLQUFLLFFBQVEsS0FBSyxPQUFPLEtBQUssS0FBSyxHQUFJO0FBQzVDLFdBQUssU0FBUztBQUNkLGFBQU87QUFBQSxJQUNUO0FBU0EsU0FBSyxXQUFXLFVBQVUsV0FBVyxTQUFTLEdBQUc7QUFDL0MsV0FBSyxZQUFZLENBQUM7QUFDbEIsV0FBSyxLQUFLLFNBQVMsS0FBSyxPQUFPLENBQUM7QUFDaEMsV0FBSyxTQUFTO0FBQ2QsYUFBTztBQUFBLElBQ1Q7QUFTQSxTQUFLLFdBQVcsVUFBVSxhQUFhLFNBQVMsR0FBRztBQUNqRCxXQUFLLFlBQVksQ0FBQztBQUNsQixXQUFLLEtBQUssU0FBUyxLQUFLLE9BQU8sR0FBRyxJQUFJO0FBQ3RDLFdBQUssU0FBUztBQUNkLGFBQU87QUFBQSxJQUNUO0FBU0EsU0FBSyxXQUFXLFVBQVUsYUFBYSxTQUFTLEdBQUc7QUFDakQsV0FBSyxZQUFZLENBQUM7QUFDbEIsV0FBSyxLQUFLLFFBQVEsS0FBSyxPQUFPLEtBQUssS0FBSyxHQUFJO0FBQzVDLFdBQUssS0FBSyxTQUFTLEtBQUssT0FBTyxLQUFLLElBQUksT0FBUSxJQUFJO0FBQ3BELFdBQUssU0FBUztBQUNkLGFBQU87QUFBQSxJQUNUO0FBU0EsU0FBSyxXQUFXLFVBQVUsYUFBYSxTQUFTLEdBQUc7QUFDakQsV0FBSyxZQUFZLENBQUM7QUFDbEIsV0FBSyxLQUFLLFNBQVMsS0FBSyxPQUFPLEdBQUcsSUFBSTtBQUN0QyxXQUFLLFNBQVM7QUFDZCxhQUFPO0FBQUEsSUFDVDtBQVVBLFNBQUssV0FBVyxVQUFVLFNBQVMsU0FBUyxHQUFHLEdBQUc7QUFDaEQsc0JBQWdCLENBQUM7QUFDakIsV0FBSyxZQUFZLElBQUksQ0FBQztBQUN0QixTQUFHO0FBQ0QsYUFBSztBQUNMLGFBQUssS0FBSyxRQUFRLEtBQUssU0FBVSxLQUFLLElBQUssR0FBSTtBQUFBLE1BQ2pELFNBQVEsSUFBSTtBQUNaLGFBQU87QUFBQSxJQUNUO0FBV0EsU0FBSyxXQUFXLFVBQVUsZUFBZSxTQUFTLEdBQUcsR0FBRztBQUN0RCxzQkFBZ0IsQ0FBQztBQUNqQixXQUFLLFlBQVksSUFBSSxDQUFDO0FBQ3RCLFVBQUcsSUFBSSxHQUFHO0FBQ1IsYUFBSyxLQUFNLElBQUk7QUFBQSxNQUNqQjtBQUNBLGFBQU8sS0FBSyxPQUFPLEdBQUcsQ0FBQztBQUFBLElBQ3pCO0FBT0EsU0FBSyxXQUFXLFVBQVUsVUFBVSxXQUFXO0FBQzdDLGFBQU8sS0FBSyxLQUFLLFFBQVEsS0FBSyxNQUFNO0FBQUEsSUFDdEM7QUFRQSxTQUFLLFdBQVcsVUFBVSxXQUFXLFdBQVc7QUFDOUMsVUFBSSxPQUFPLEtBQUssS0FBSyxTQUFTLEtBQUssSUFBSTtBQUN2QyxXQUFLLFFBQVE7QUFDYixhQUFPO0FBQUEsSUFDVDtBQVFBLFNBQUssV0FBVyxVQUFVLFdBQVcsV0FBVztBQUM5QyxVQUFJLE9BQ0YsS0FBSyxLQUFLLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFDakMsS0FBSyxLQUFLLFFBQVEsS0FBSyxPQUFPLENBQUM7QUFDakMsV0FBSyxRQUFRO0FBQ2IsYUFBTztBQUFBLElBQ1Q7QUFRQSxTQUFLLFdBQVcsVUFBVSxXQUFXLFdBQVc7QUFDOUMsVUFBSSxPQUFPLEtBQUssS0FBSyxTQUFTLEtBQUssSUFBSTtBQUN2QyxXQUFLLFFBQVE7QUFDYixhQUFPO0FBQUEsSUFDVDtBQVFBLFNBQUssV0FBVyxVQUFVLGFBQWEsV0FBVztBQUNoRCxVQUFJLE9BQU8sS0FBSyxLQUFLLFNBQVMsS0FBSyxNQUFNLElBQUk7QUFDN0MsV0FBSyxRQUFRO0FBQ2IsYUFBTztBQUFBLElBQ1Q7QUFRQSxTQUFLLFdBQVcsVUFBVSxhQUFhLFdBQVc7QUFDaEQsVUFBSSxPQUNGLEtBQUssS0FBSyxRQUFRLEtBQUssSUFBSSxJQUMzQixLQUFLLEtBQUssU0FBUyxLQUFLLE9BQU8sR0FBRyxJQUFJLEtBQUs7QUFDN0MsV0FBSyxRQUFRO0FBQ2IsYUFBTztBQUFBLElBQ1Q7QUFRQSxTQUFLLFdBQVcsVUFBVSxhQUFhLFdBQVc7QUFDaEQsVUFBSSxPQUFPLEtBQUssS0FBSyxTQUFTLEtBQUssTUFBTSxJQUFJO0FBQzdDLFdBQUssUUFBUTtBQUNiLGFBQU87QUFBQSxJQUNUO0FBVUEsU0FBSyxXQUFXLFVBQVUsU0FBUyxTQUFTLEdBQUc7QUFDN0Msc0JBQWdCLENBQUM7QUFDakIsVUFBSSxPQUFPO0FBQ1gsU0FBRztBQUVELGdCQUFRLFFBQVEsS0FBSyxLQUFLLEtBQUssUUFBUSxLQUFLLE1BQU07QUFDbEQsYUFBSztBQUFBLE1BQ1AsU0FBUSxJQUFJO0FBQ1osYUFBTztBQUFBLElBQ1Q7QUFVQSxTQUFLLFdBQVcsVUFBVSxlQUFlLFNBQVMsR0FBRztBQUVuRCxVQUFJLElBQUksS0FBSyxPQUFPLENBQUM7QUFDckIsVUFBSSxNQUFNLEtBQU0sSUFBSTtBQUNwQixVQUFHLEtBQUssS0FBSztBQUNYLGFBQUssT0FBTztBQUFBLE1BQ2Q7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQVVBLFNBQUssV0FBVyxVQUFVLFdBQVcsU0FBUyxPQUFPO0FBSW5ELFVBQUk7QUFDSixVQUFHLE9BQU87QUFFUixnQkFBUSxLQUFLLElBQUksS0FBSyxPQUFPLEdBQUcsS0FBSztBQUNyQyxlQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSztBQUNuRCxhQUFLLFFBQVE7QUFBQSxNQUNmLFdBQVUsVUFBVSxHQUFHO0FBQ3JCLGVBQU87QUFBQSxNQUNULE9BQU87QUFFTCxlQUFRLEtBQUssU0FBUyxJQUFLLEtBQUssT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLElBQUk7QUFDaEUsYUFBSyxNQUFNO0FBQUEsTUFDYjtBQUNBLGFBQU87QUFBQSxJQUNUO0FBVUEsU0FBSyxXQUFXLFVBQVUsUUFBUSxTQUFTLE9BQU87QUFFaEQsYUFBUSxPQUFPLFVBQVcsY0FDeEIsS0FBSyxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQ3pCLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSztBQUFBLElBQ2hEO0FBU0EsU0FBSyxXQUFXLFVBQVUsS0FBSyxTQUFTLEdBQUc7QUFDekMsYUFBTyxLQUFLLEtBQUssU0FBUyxLQUFLLE9BQU8sQ0FBQztBQUFBLElBQ3pDO0FBVUEsU0FBSyxXQUFXLFVBQVUsUUFBUSxTQUFTLEdBQUcsR0FBRztBQUMvQyxXQUFLLEtBQUssU0FBUyxHQUFHLENBQUM7QUFDdkIsYUFBTztBQUFBLElBQ1Q7QUFPQSxTQUFLLFdBQVcsVUFBVSxPQUFPLFdBQVc7QUFDMUMsYUFBTyxLQUFLLEtBQUssU0FBUyxLQUFLLFFBQVEsQ0FBQztBQUFBLElBQzFDO0FBT0EsU0FBSyxXQUFXLFVBQVUsT0FBTyxXQUFXO0FBQzFDLGFBQU8sSUFBSSxLQUFLLFdBQVcsSUFBSTtBQUFBLElBQ2pDO0FBT0EsU0FBSyxXQUFXLFVBQVUsVUFBVSxXQUFXO0FBQzdDLFVBQUcsS0FBSyxPQUFPLEdBQUc7QUFDaEIsWUFBSUEsT0FBTSxJQUFJLFdBQVcsS0FBSyxLQUFLLFFBQVEsS0FBSyxJQUFJO0FBQ3BELFlBQUksTUFBTSxJQUFJLFdBQVdBLEtBQUksVUFBVTtBQUN2QyxZQUFJLElBQUlBLElBQUc7QUFDWCxhQUFLLE9BQU8sSUFBSSxTQUFTLEdBQUc7QUFDNUIsYUFBSyxTQUFTLEtBQUs7QUFDbkIsYUFBSyxPQUFPO0FBQUEsTUFDZDtBQUNBLGFBQU87QUFBQSxJQUNUO0FBT0EsU0FBSyxXQUFXLFVBQVUsUUFBUSxXQUFXO0FBQzNDLFdBQUssT0FBTyxJQUFJLFNBQVMsSUFBSSxZQUFZLENBQUMsQ0FBQztBQUMzQyxXQUFLLE9BQU8sS0FBSyxRQUFRO0FBQ3pCLGFBQU87QUFBQSxJQUNUO0FBU0EsU0FBSyxXQUFXLFVBQVUsV0FBVyxTQUFTLE9BQU87QUFDbkQsV0FBSyxRQUFRLEtBQUssSUFBSSxHQUFHLEtBQUssT0FBTyxJQUFJLEtBQUs7QUFDOUMsV0FBSyxPQUFPLEtBQUssSUFBSSxLQUFLLE1BQU0sS0FBSyxLQUFLO0FBQzFDLGFBQU87QUFBQSxJQUNUO0FBT0EsU0FBSyxXQUFXLFVBQVUsUUFBUSxXQUFXO0FBQzNDLFVBQUksT0FBTztBQUNYLGVBQVEsSUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLLEtBQUssWUFBWSxFQUFFLEdBQUc7QUFDcEQsWUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLENBQUM7QUFDNUIsWUFBRyxJQUFJLElBQUk7QUFDVCxrQkFBUTtBQUFBLFFBQ1Y7QUFDQSxnQkFBUSxFQUFFLFNBQVMsRUFBRTtBQUFBLE1BQ3ZCO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFXQSxTQUFLLFdBQVcsVUFBVSxXQUFXLFNBQVMsVUFBVTtBQUN0RCxVQUFJLE9BQU8sSUFBSSxXQUFXLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxPQUFPLENBQUM7QUFDN0QsaUJBQVcsWUFBWTtBQUd2QixVQUFHLGFBQWEsWUFBWSxhQUFhLE9BQU87QUFDOUMsZUFBTyxLQUFLLE9BQU8sSUFBSSxPQUFPLElBQUk7QUFBQSxNQUNwQztBQUNBLFVBQUcsYUFBYSxPQUFPO0FBQ3JCLGVBQU8sS0FBSyxPQUFPLElBQUksT0FBTyxJQUFJO0FBQUEsTUFDcEM7QUFDQSxVQUFHLGFBQWEsVUFBVTtBQUN4QixlQUFPLEtBQUssT0FBTyxPQUFPLE9BQU8sSUFBSTtBQUFBLE1BQ3ZDO0FBR0EsVUFBRyxhQUFhLFFBQVE7QUFDdEIsZUFBTyxLQUFLLEtBQUssS0FBSyxPQUFPLElBQUk7QUFBQSxNQUNuQztBQUNBLFVBQUcsYUFBYSxTQUFTO0FBQ3ZCLGVBQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxJQUFJO0FBQUEsTUFDcEM7QUFFQSxZQUFNLElBQUksTUFBTSx1QkFBdUIsUUFBUTtBQUFBLElBQ2pEO0FBY0EsU0FBSyxlQUFlLFNBQVMsT0FBTyxVQUFVO0FBRTVDLGlCQUFXLFlBQVk7QUFDdkIsVUFBRyxVQUFVLFVBQWEsYUFBYSxRQUFRO0FBQzdDLGdCQUFRLEtBQUssV0FBVyxLQUFLO0FBQUEsTUFDL0I7QUFDQSxhQUFPLElBQUksS0FBSyxXQUFXLEtBQUs7QUFBQSxJQUNsQztBQVlBLFNBQUssYUFBYSxTQUFTLEdBQUcsR0FBRztBQUMvQixVQUFJLElBQUk7QUFDUixhQUFNLElBQUksR0FBRztBQUNYLFlBQUcsSUFBSSxHQUFHO0FBQ1IsZUFBSztBQUFBLFFBQ1A7QUFDQSxlQUFPO0FBQ1AsWUFBRyxJQUFJLEdBQUc7QUFDUixlQUFLO0FBQUEsUUFDUDtBQUFBLE1BQ0Y7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQVlBLFNBQUssV0FBVyxTQUFTLElBQUksSUFBSSxHQUFHO0FBQ2xDLFVBQUksS0FBSztBQUNULFVBQUksSUFBSTtBQUNSLFVBQUksSUFBSTtBQUNSLFVBQUksSUFBSTtBQUNSLFVBQUksSUFBSTtBQUNSLGFBQU0sSUFBSSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUc7QUFDckIsWUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDO0FBQ3RDLFlBQUcsS0FBSyxJQUFJO0FBQ1YsZ0JBQU07QUFDTixjQUFJO0FBQ0osY0FBSTtBQUFBLFFBQ047QUFDQSxhQUFLLE9BQU8sYUFBYSxDQUFDO0FBQzFCLFVBQUU7QUFBQSxNQUNKO0FBQ0EsWUFBTTtBQUNOLGFBQU87QUFBQSxJQUNUO0FBU0EsU0FBSyxhQUFhLFNBQVMsS0FBSztBQUU5QixVQUFJLE9BQU87QUFDWCxVQUFJLElBQUk7QUFDUixVQUFHLElBQUksU0FBUyxNQUFRO0FBRXRCLFlBQUk7QUFDSixnQkFBUSxPQUFPLGFBQWEsU0FBUyxJQUFJLElBQUksRUFBRSxDQUFDO0FBQUEsTUFDbEQ7QUFFQSxhQUFNLElBQUksSUFBSSxRQUFRLEtBQUssR0FBRztBQUM1QixnQkFBUSxPQUFPLGFBQWEsU0FBUyxJQUFJLE9BQU8sR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQUEsTUFDNUQ7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQVNBLFNBQUssYUFBYSxTQUFTLE9BQU87QUFFaEMsYUFBTyxLQUFLLGFBQWEsS0FBSyxFQUFFLE1BQU07QUFBQSxJQUN4QztBQVNBLFNBQUssZUFBZSxTQUFTLEdBQUc7QUFDOUIsYUFDRSxPQUFPLGFBQWEsS0FBSyxLQUFLLEdBQUksSUFDbEMsT0FBTyxhQUFhLEtBQUssS0FBSyxHQUFJLElBQ2xDLE9BQU8sYUFBYSxLQUFLLElBQUksR0FBSSxJQUNqQyxPQUFPLGFBQWEsSUFBSSxHQUFJO0FBQUEsSUFDaEM7QUFHQSxRQUFJLFVBQ0Y7QUFDRixRQUFJLGFBQWE7QUFBQSxNQUdkO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BR2hCO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFHckM7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUl2QjtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUc7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BRy9DO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFJakQ7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BSW5CO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFHaEQ7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxNQUFJO0FBQUEsTUFBSTtBQUFBLE1BQUk7QUFBQSxJQUNuRDtBQUdBLFFBQUksVUFBVTtBQVdkLFNBQUssV0FBVyxTQUFTLE9BQU8sU0FBUztBQUV2QyxVQUFJLE9BQU87QUFDWCxVQUFJLFNBQVM7QUFDYixVQUFJLE1BQU0sTUFBTTtBQUNoQixVQUFJLElBQUk7QUFDUixhQUFNLElBQUksTUFBTSxRQUFRO0FBQ3RCLGVBQU8sTUFBTSxXQUFXLEdBQUc7QUFDM0IsZUFBTyxNQUFNLFdBQVcsR0FBRztBQUMzQixlQUFPLE1BQU0sV0FBVyxHQUFHO0FBRzNCLGdCQUFRLFFBQVEsT0FBTyxRQUFRLENBQUM7QUFDaEMsZ0JBQVEsUUFBUSxRQUFTLE9BQU8sTUFBTSxJQUFNLFFBQVEsQ0FBRTtBQUN0RCxZQUFHLE1BQU0sSUFBSSxHQUFHO0FBQ2Qsa0JBQVE7QUFBQSxRQUNWLE9BQU87QUFDTCxrQkFBUSxRQUFRLFFBQVMsT0FBTyxPQUFPLElBQU0sUUFBUSxDQUFFO0FBQ3ZELGtCQUFRLE1BQU0sSUFBSSxJQUFJLE1BQU0sUUFBUSxPQUFPLE9BQU8sRUFBRTtBQUFBLFFBQ3REO0FBRUEsWUFBRyxXQUFXLEtBQUssU0FBUyxTQUFTO0FBQ25DLG9CQUFVLEtBQUssT0FBTyxHQUFHLE9BQU8sSUFBSTtBQUNwQyxpQkFBTyxLQUFLLE9BQU8sT0FBTztBQUFBLFFBQzVCO0FBQUEsTUFDRjtBQUNBLGdCQUFVO0FBQ1YsYUFBTztBQUFBLElBQ1Q7QUFTQSxTQUFLLFdBQVcsU0FBUyxPQUFPO0FBSTlCLGNBQVEsTUFBTSxRQUFRLHVCQUF1QixFQUFFO0FBRS9DLFVBQUksU0FBUztBQUNiLFVBQUksTUFBTSxNQUFNLE1BQU07QUFDdEIsVUFBSSxJQUFJO0FBRVIsYUFBTSxJQUFJLE1BQU0sUUFBUTtBQUN0QixlQUFPLFdBQVcsTUFBTSxXQUFXLEdBQUcsSUFBSTtBQUMxQyxlQUFPLFdBQVcsTUFBTSxXQUFXLEdBQUcsSUFBSTtBQUMxQyxlQUFPLFdBQVcsTUFBTSxXQUFXLEdBQUcsSUFBSTtBQUMxQyxlQUFPLFdBQVcsTUFBTSxXQUFXLEdBQUcsSUFBSTtBQUUxQyxrQkFBVSxPQUFPLGFBQWMsUUFBUSxJQUFNLFFBQVEsQ0FBRTtBQUN2RCxZQUFHLFNBQVMsSUFBSTtBQUVkLG9CQUFVLE9BQU8sY0FBZSxPQUFPLE9BQU8sSUFBTSxRQUFRLENBQUU7QUFDOUQsY0FBRyxTQUFTLElBQUk7QUFFZCxzQkFBVSxPQUFPLGNBQWUsT0FBTyxNQUFNLElBQUssSUFBSTtBQUFBLFVBQ3hEO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQVlBLFNBQUssYUFBYSxTQUFTLEtBQUs7QUFDOUIsYUFBTyxTQUFTLG1CQUFtQixHQUFHLENBQUM7QUFBQSxJQUN6QztBQVdBLFNBQUssYUFBYSxTQUFTLEtBQUs7QUFDOUIsYUFBTyxtQkFBbUIsT0FBTyxHQUFHLENBQUM7QUFBQSxJQUN2QztBQUlBLFNBQUssU0FBUztBQUFBLE1BQ1osS0FBSyxDQUFDO0FBQUEsTUFDTixLQUFLLENBQUM7QUFBQSxNQUNOLFFBQVEsQ0FBQztBQUFBLE1BQ1QsUUFBUSxDQUFDO0FBQUEsTUFDVCxPQUFRO0FBQUEsUUFDTixRQUFRLE1BQU07QUFBQSxRQUNkLFFBQVEsTUFBTTtBQUFBLE1BQ2hCO0FBQUEsSUFDRjtBQVVBLFNBQUssT0FBTyxJQUFJLFNBQVMsU0FBUyxPQUFPO0FBQ3ZDLGFBQU8sT0FBTyxhQUFhLE1BQU0sTUFBTSxLQUFLO0FBQUEsSUFDOUM7QUFhQSxTQUFLLE9BQU8sSUFBSSxTQUFTLFNBQVMsS0FBSyxRQUFRLFFBQVE7QUFDckQsVUFBSSxNQUFNO0FBQ1YsVUFBRyxDQUFDLEtBQUs7QUFDUCxjQUFNLElBQUksV0FBVyxJQUFJLE1BQU07QUFBQSxNQUNqQztBQUNBLGVBQVMsVUFBVTtBQUNuQixVQUFJLElBQUk7QUFDUixlQUFRLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDbEMsWUFBSSxPQUFPLElBQUksV0FBVyxDQUFDO0FBQUEsTUFDN0I7QUFDQSxhQUFPLFNBQVUsSUFBSSxTQUFVO0FBQUEsSUFDakM7QUFVQSxTQUFLLE9BQU8sSUFBSSxTQUFTLEtBQUs7QUFZOUIsU0FBSyxPQUFPLElBQUksU0FBUyxTQUFTLEtBQUssUUFBUSxRQUFRO0FBQ3JELFVBQUksTUFBTTtBQUNWLFVBQUcsQ0FBQyxLQUFLO0FBQ1AsY0FBTSxJQUFJLFdBQVcsS0FBSyxLQUFLLElBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxNQUNoRDtBQUNBLGVBQVMsVUFBVTtBQUNuQixVQUFJLElBQUksR0FBRyxJQUFJO0FBQ2YsVUFBRyxJQUFJLFNBQVMsR0FBRztBQUVqQixZQUFJO0FBQ0osWUFBSSxPQUFPLFNBQVMsSUFBSSxJQUFJLEVBQUU7QUFBQSxNQUNoQztBQUVBLGFBQU0sSUFBSSxJQUFJLFFBQVEsS0FBSyxHQUFHO0FBQzVCLFlBQUksT0FBTyxTQUFTLElBQUksT0FBTyxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQUEsTUFDMUM7QUFDQSxhQUFPLFNBQVUsSUFBSSxTQUFVO0FBQUEsSUFDakM7QUFXQSxTQUFLLE9BQU8sT0FBTyxTQUFTLFNBQVMsT0FBTyxTQUFTO0FBQ25ELFVBQUksT0FBTztBQUNYLFVBQUksU0FBUztBQUNiLFVBQUksTUFBTSxNQUFNO0FBQ2hCLFVBQUksSUFBSTtBQUNSLGFBQU0sSUFBSSxNQUFNLFlBQVk7QUFDMUIsZUFBTyxNQUFNO0FBQ2IsZUFBTyxNQUFNO0FBQ2IsZUFBTyxNQUFNO0FBR2IsZ0JBQVEsUUFBUSxPQUFPLFFBQVEsQ0FBQztBQUNoQyxnQkFBUSxRQUFRLFFBQVMsT0FBTyxNQUFNLElBQU0sUUFBUSxDQUFFO0FBQ3RELFlBQUcsTUFBTSxJQUFJLEdBQUc7QUFDZCxrQkFBUTtBQUFBLFFBQ1YsT0FBTztBQUNMLGtCQUFRLFFBQVEsUUFBUyxPQUFPLE9BQU8sSUFBTSxRQUFRLENBQUU7QUFDdkQsa0JBQVEsTUFBTSxJQUFJLElBQUksTUFBTSxRQUFRLE9BQU8sT0FBTyxFQUFFO0FBQUEsUUFDdEQ7QUFFQSxZQUFHLFdBQVcsS0FBSyxTQUFTLFNBQVM7QUFDbkMsb0JBQVUsS0FBSyxPQUFPLEdBQUcsT0FBTyxJQUFJO0FBQ3BDLGlCQUFPLEtBQUssT0FBTyxPQUFPO0FBQUEsUUFDNUI7QUFBQSxNQUNGO0FBQ0EsZ0JBQVU7QUFDVixhQUFPO0FBQUEsSUFDVDtBQVlBLFNBQUssT0FBTyxPQUFPLFNBQVMsU0FBUyxPQUFPLFFBQVEsUUFBUTtBQUMxRCxVQUFJLE1BQU07QUFDVixVQUFHLENBQUMsS0FBSztBQUNQLGNBQU0sSUFBSSxXQUFXLEtBQUssS0FBSyxNQUFNLFNBQVMsQ0FBQyxJQUFJLENBQUM7QUFBQSxNQUN0RDtBQUdBLGNBQVEsTUFBTSxRQUFRLHVCQUF1QixFQUFFO0FBRS9DLGVBQVMsVUFBVTtBQUNuQixVQUFJLE1BQU0sTUFBTSxNQUFNO0FBQ3RCLFVBQUksSUFBSSxHQUFHLElBQUk7QUFFZixhQUFNLElBQUksTUFBTSxRQUFRO0FBQ3RCLGVBQU8sV0FBVyxNQUFNLFdBQVcsR0FBRyxJQUFJO0FBQzFDLGVBQU8sV0FBVyxNQUFNLFdBQVcsR0FBRyxJQUFJO0FBQzFDLGVBQU8sV0FBVyxNQUFNLFdBQVcsR0FBRyxJQUFJO0FBQzFDLGVBQU8sV0FBVyxNQUFNLFdBQVcsR0FBRyxJQUFJO0FBRTFDLFlBQUksT0FBUSxRQUFRLElBQU0sUUFBUTtBQUNsQyxZQUFHLFNBQVMsSUFBSTtBQUVkLGNBQUksUUFBUyxPQUFPLE9BQU8sSUFBTSxRQUFRO0FBQ3pDLGNBQUcsU0FBUyxJQUFJO0FBRWQsZ0JBQUksUUFBUyxPQUFPLE1BQU0sSUFBSztBQUFBLFVBQ2pDO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFHQSxhQUFPLFNBQVUsSUFBSSxTQUFVLElBQUksU0FBUyxHQUFHLENBQUM7QUFBQSxJQUNsRDtBQUdBLFNBQUssT0FBTyxPQUFPLFNBQVMsU0FBUyxPQUFPLFNBQVM7QUFDbkQsYUFBTyxLQUFLLE9BQU8sTUFBTSxPQUFPLE9BQU8sU0FBUyxPQUFPO0FBQUEsSUFDekQ7QUFDQSxTQUFLLE9BQU8sT0FBTyxTQUFTLFNBQVMsT0FBTyxTQUFTO0FBQ25ELGFBQU8sS0FBSyxPQUFPLE1BQU0sT0FBTyxPQUFPLFNBQVMsT0FBTztBQUFBLElBQ3pEO0FBSUEsU0FBSyxPQUFPO0FBQUEsTUFDVixNQUFNLENBQUM7QUFBQSxNQUNQLE9BQU8sQ0FBQztBQUFBLElBQ1Y7QUFZQSxTQUFLLEtBQUssS0FBSyxTQUFTLFNBQVMsS0FBSyxRQUFRLFFBQVE7QUFDcEQsWUFBTSxLQUFLLFdBQVcsR0FBRztBQUN6QixVQUFJLE1BQU07QUFDVixVQUFHLENBQUMsS0FBSztBQUNQLGNBQU0sSUFBSSxXQUFXLElBQUksTUFBTTtBQUFBLE1BQ2pDO0FBQ0EsZUFBUyxVQUFVO0FBQ25CLFVBQUksSUFBSTtBQUNSLGVBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUUsR0FBRztBQUNsQyxZQUFJLE9BQU8sSUFBSSxXQUFXLENBQUM7QUFBQSxNQUM3QjtBQUNBLGFBQU8sU0FBVSxJQUFJLFNBQVU7QUFBQSxJQUNqQztBQVNBLFNBQUssS0FBSyxLQUFLLFNBQVMsU0FBUyxPQUFPO0FBQ3RDLGFBQU8sS0FBSyxXQUFXLE9BQU8sYUFBYSxNQUFNLE1BQU0sS0FBSyxDQUFDO0FBQUEsSUFDL0Q7QUFZQSxTQUFLLEtBQUssTUFBTSxTQUFTLFNBQVMsS0FBSyxRQUFRLFFBQVE7QUFDckQsVUFBSSxNQUFNO0FBQ1YsVUFBRyxDQUFDLEtBQUs7QUFDUCxjQUFNLElBQUksV0FBVyxJQUFJLFNBQVMsQ0FBQztBQUFBLE1BQ3JDO0FBQ0EsVUFBSSxPQUFPLElBQUksWUFBWSxJQUFJLE1BQU07QUFDckMsZUFBUyxVQUFVO0FBQ25CLFVBQUksSUFBSTtBQUNSLFVBQUksSUFBSTtBQUNSLGVBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUUsR0FBRztBQUNsQyxhQUFLLE9BQU8sSUFBSSxXQUFXLENBQUM7QUFDNUIsYUFBSztBQUFBLE1BQ1A7QUFDQSxhQUFPLFNBQVUsSUFBSSxTQUFVO0FBQUEsSUFDakM7QUFTQSxTQUFLLEtBQUssTUFBTSxTQUFTLFNBQVMsT0FBTztBQUN2QyxhQUFPLE9BQU8sYUFBYSxNQUFNLE1BQU0sSUFBSSxZQUFZLE1BQU0sTUFBTSxDQUFDO0FBQUEsSUFDdEU7QUFZQSxTQUFLLFVBQVUsU0FBUyxLQUFLLE9BQU8sS0FBSztBQUN2QyxjQUFRLEtBQUssU0FBUyxJQUFJLFFBQVEsS0FBSyxTQUFTLEtBQUssQ0FBQyxFQUFFLElBQUk7QUFHNUQsVUFBRyxLQUFLO0FBSU4sWUFBSSxRQUFRO0FBQ1osWUFBSSxNQUFNLE1BQU0sV0FBVyxDQUFDO0FBQzVCLFlBQUcsTUFBTSxJQUFNO0FBQ2Isa0JBQVE7QUFBQSxRQUNWO0FBRUEsZ0JBQVEsTUFBTSxVQUFVLE9BQU8sTUFBTSxTQUFTLENBQUM7QUFBQSxNQUNqRDtBQUVBLGFBQU87QUFBQSxJQUNUO0FBWUEsU0FBSyxVQUFVLFNBQVMsS0FBSyxPQUFPLEtBQUs7QUFFdkMsVUFBSSxPQUFPLElBQUksUUFBUSxLQUFLLFNBQVMsS0FBSyxDQUFDLEVBQUU7QUFDN0MsYUFBUSxTQUFTLE9BQVEsT0FBTyxLQUFLLFNBQVMsSUFBSTtBQUFBLElBQ3BEO0FBU0EsUUFBSSxvQkFBb0IsU0FBUyxLQUFLLElBQUksS0FBSztBQUM3QyxVQUFHLENBQUMsS0FBSztBQUNQLGNBQU0sSUFBSSxNQUFNLDJCQUEyQjtBQUFBLE1BQzdDO0FBRUEsVUFBSTtBQUNKLFVBQUcsUUFBUSxNQUFNO0FBQ2YsZUFBTyxJQUFJLFdBQVcsRUFBRTtBQUFBLE1BQzFCLE9BQU87QUFFTCxjQUFNLEtBQUssU0FBUyxLQUFLLFVBQVUsR0FBRyxDQUFDO0FBQ3ZDLGVBQU8sSUFBSSxRQUFRLElBQUksR0FBRztBQUFBLE1BQzVCO0FBR0EsVUFBRyxPQUFPLFNBQVUsZUFBZSxLQUFLLFNBQVMsTUFBTTtBQUNyRCxZQUFJLFFBQVEsSUFBSSxNQUFNLEtBQUssTUFBTSxPQUFPO0FBQ3hDLGNBQU0sS0FBSyxLQUFLLE1BQU07QUFDdEIsY0FBTSxPQUFPLEtBQUssTUFBTTtBQUN4QixjQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFVQSxRQUFJLG9CQUFvQixTQUFTLEtBQUssSUFBSTtBQUN4QyxVQUFHLENBQUMsS0FBSztBQUNQLGNBQU0sSUFBSSxNQUFNLDJCQUEyQjtBQUFBLE1BQzdDO0FBR0EsVUFBSSxPQUFPLElBQUksUUFBUSxFQUFFO0FBUXpCLFVBQUcsSUFBSSxNQUFNO0FBQ1gsWUFBRyxLQUFLLFNBQVMsTUFBTTtBQUNyQixjQUFHLEtBQUssT0FBTztBQUNiLGdCQUFJLFFBQVEsSUFBSSxNQUFNLEtBQUssTUFBTSxPQUFPO0FBQ3hDLGtCQUFNLEtBQUssS0FBSyxNQUFNO0FBQ3RCLGtCQUFNLE9BQU8sS0FBSyxNQUFNO0FBQ3hCLGtCQUFNO0FBQUEsVUFDUjtBQUVBLGlCQUFPO0FBQUEsUUFDVCxPQUFPO0FBQ0wsaUJBQU8sS0FBSztBQUFBLFFBQ2Q7QUFBQSxNQUNGO0FBR0EsVUFBRyxTQUFTLE1BQU07QUFFaEIsZUFBTyxLQUFLLE1BQU0sS0FBSyxTQUFTLElBQUksQ0FBQztBQUFBLE1BQ3ZDO0FBRUEsYUFBTztBQUFBLElBQ1Q7QUFVQSxRQUFJLFdBQVcsU0FBUyxLQUFLLElBQUksS0FBSyxNQUFNO0FBRTFDLFVBQUksTUFBTSxrQkFBa0IsS0FBSyxFQUFFO0FBQ25DLFVBQUcsUUFBUSxNQUFNO0FBRWYsY0FBTSxDQUFDO0FBQUEsTUFDVDtBQUVBLFVBQUksT0FBTztBQUdYLHdCQUFrQixLQUFLLElBQUksR0FBRztBQUFBLElBQ2hDO0FBV0EsUUFBSSxXQUFXLFNBQVMsS0FBSyxJQUFJLEtBQUs7QUFFcEMsVUFBSSxPQUFPLGtCQUFrQixLQUFLLEVBQUU7QUFDcEMsVUFBRyxTQUFTLE1BQU07QUFFaEIsZUFBUSxPQUFPLE9BQVEsS0FBSyxPQUFPO0FBQUEsTUFDckM7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQVNBLFFBQUksY0FBYyxTQUFTLEtBQUssSUFBSSxLQUFLO0FBRXZDLFVBQUksTUFBTSxrQkFBa0IsS0FBSyxFQUFFO0FBQ25DLFVBQUcsUUFBUSxRQUFRLE9BQU8sS0FBSztBQUU3QixlQUFPLElBQUk7QUFHWCxZQUFJQyxTQUFRO0FBQ1osaUJBQVEsUUFBUSxLQUFLO0FBQ25CLFVBQUFBLFNBQVE7QUFDUjtBQUFBLFFBQ0Y7QUFDQSxZQUFHQSxRQUFPO0FBRVIsZ0JBQU07QUFBQSxRQUNSO0FBR0EsMEJBQWtCLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDaEM7QUFBQSxJQUNGO0FBUUEsUUFBSSxjQUFjLFNBQVMsS0FBSyxJQUFJO0FBQ2xDLHdCQUFrQixLQUFLLElBQUksSUFBSTtBQUFBLElBQ2pDO0FBV0EsUUFBSSx1QkFBdUIsU0FBUyxNQUFNLE1BQU0sVUFBVTtBQUN4RCxVQUFJLE9BQU87QUFHWCxVQUFHLE9BQU8sYUFBYyxhQUFhO0FBQ25DLG1CQUFXLENBQUMsT0FBTyxPQUFPO0FBQUEsTUFDNUI7QUFHQSxVQUFJO0FBQ0osVUFBSSxPQUFPO0FBQ1gsVUFBSSxZQUFZO0FBQ2hCLGVBQVEsT0FBTyxVQUFVO0FBQ3ZCLGVBQU8sU0FBUztBQUNoQixZQUFJO0FBQ0YsY0FBRyxTQUFTLFdBQVcsU0FBUyxRQUFRO0FBQ3RDLGdCQUFHLEtBQUssT0FBTyxNQUFNO0FBQ25CLG9CQUFNLElBQUksTUFBTSxvQ0FBb0M7QUFBQSxZQUN0RDtBQUNBLG1CQUFPLEtBQUssTUFBTSxNQUFNLElBQUk7QUFDNUIsbUJBQVEsU0FBUztBQUFBLFVBQ25CO0FBQ0EsY0FBRyxTQUFTLFNBQVMsU0FBUyxRQUFRO0FBQ3BDLGlCQUFLLEtBQUs7QUFDVixtQkFBTyxLQUFLLE1BQU0sTUFBTSxJQUFJO0FBQzVCLG1CQUFPO0FBQUEsVUFDVDtBQUFBLFFBQ0YsU0FBUSxJQUFOO0FBQ0Esc0JBQVk7QUFBQSxRQUNkO0FBQ0EsWUFBRyxNQUFNO0FBQ1A7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLFVBQUcsQ0FBQyxNQUFNO0FBQ1IsY0FBTTtBQUFBLE1BQ1I7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQThCQSxTQUFLLFVBQVUsU0FBUyxLQUFLLElBQUksS0FBSyxNQUFNLFVBQVU7QUFDcEQsMkJBQXFCLFVBQVUsV0FBVyxRQUFRO0FBQUEsSUFDcEQ7QUFjQSxTQUFLLFVBQVUsU0FBUyxLQUFLLElBQUksS0FBSyxVQUFVO0FBQzlDLGFBQU8scUJBQXFCLFVBQVUsV0FBVyxRQUFRO0FBQUEsSUFDM0Q7QUFZQSxTQUFLLGFBQWEsU0FBUyxLQUFLLElBQUksS0FBSyxVQUFVO0FBQ2pELDJCQUFxQixhQUFhLFdBQVcsUUFBUTtBQUFBLElBQ3ZEO0FBV0EsU0FBSyxhQUFhLFNBQVMsS0FBSyxJQUFJLFVBQVU7QUFDNUMsMkJBQXFCLGFBQWEsV0FBVyxRQUFRO0FBQUEsSUFDdkQ7QUFVQSxTQUFLLFVBQVUsU0FBUyxLQUFLO0FBQzNCLGVBQVEsUUFBUSxLQUFLO0FBQ25CLFlBQUcsSUFBSSxlQUFlLElBQUksR0FBRztBQUMzQixpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFXQSxTQUFLLFNBQVMsU0FBUyxRQUFRO0FBQzdCLFVBQUksS0FBSztBQUVULFVBQUk7QUFFSixVQUFJO0FBRUosVUFBSSxPQUFPO0FBRVgsVUFBSSxRQUFRLENBQUM7QUFFYixVQUFJLE9BQU87QUFFWCxhQUFPLFFBQVEsR0FBRyxLQUFLLE1BQU0sR0FBSTtBQUMvQixlQUFPLE9BQU8sVUFBVSxNQUFNLEdBQUcsWUFBWSxDQUFDO0FBRTlDLFlBQUcsS0FBSyxTQUFTLEdBQUc7QUFDbEIsZ0JBQU0sS0FBSyxJQUFJO0FBQUEsUUFDakI7QUFDQSxlQUFPLEdBQUc7QUFFVixZQUFJQyxRQUFPLE1BQU0sR0FBRztBQUNwQixnQkFBT0E7QUFBQSxlQUNGO0FBQUEsZUFDQTtBQUVILGdCQUFHLE9BQU8sVUFBVSxRQUFRO0FBQzFCLG9CQUFNLEtBQUssVUFBVSxTQUFTLEVBQUU7QUFBQSxZQUNsQyxPQUFPO0FBQ0wsb0JBQU0sS0FBSyxLQUFLO0FBQUEsWUFDbEI7QUFDQTtBQUFBLGVBSUc7QUFDSCxrQkFBTSxLQUFLLEdBQUc7QUFDZDtBQUFBO0FBRUEsa0JBQU0sS0FBSyxPQUFPQSxRQUFPLElBQUk7QUFBQTtBQUFBLE1BRWpDO0FBRUEsWUFBTSxLQUFLLE9BQU8sVUFBVSxJQUFJLENBQUM7QUFDakMsYUFBTyxNQUFNLEtBQUssRUFBRTtBQUFBLElBQ3RCO0FBT0EsU0FBSyxlQUFlLFNBQVMsUUFBUSxVQUFVLFdBQVcsZUFBZTtBQVd2RSxVQUFJLElBQUksUUFBUSxJQUFJLE1BQU0sV0FBVyxLQUFLLElBQUksUUFBUSxDQUFDLElBQUksSUFBSTtBQUMvRCxVQUFJLElBQUksY0FBYyxTQUFZLE1BQU07QUFDeEMsVUFBSSxJQUFJLGtCQUFrQixTQUN6QixNQUFNLGVBQWUsSUFBSSxJQUFJLElBQUksTUFBTTtBQUN4QyxVQUFJLElBQUksU0FBVSxJQUFJLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLFFBQVEsQ0FBQyxHQUFJLEVBQUUsSUFBSTtBQUMzRCxVQUFJLElBQUssRUFBRSxTQUFTLElBQUssRUFBRSxTQUFTLElBQUk7QUFDeEMsYUFBTyxLQUFLLElBQUksRUFBRSxPQUFPLEdBQUcsQ0FBQyxJQUFJLElBQUksTUFDbkMsRUFBRSxPQUFPLENBQUMsRUFBRSxRQUFRLGtCQUFrQixPQUFPLENBQUMsS0FDN0MsSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsRUFBRSxRQUFRLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSTtBQUFBLElBQ25EO0FBT0EsU0FBSyxhQUFhLFNBQVMsTUFBTTtBQUMvQixVQUFHLFFBQVEsWUFBWTtBQUNyQixlQUFPLEtBQUssYUFBYSxPQUFPLFlBQVksR0FBRyxLQUFLLEVBQUUsSUFBSTtBQUFBLE1BQzVELFdBQVUsUUFBUSxTQUFTO0FBQ3pCLGVBQU8sS0FBSyxhQUFhLE9BQU8sU0FBUyxHQUFHLEtBQUssRUFBRSxJQUFJO0FBQUEsTUFDekQsV0FBVSxRQUFRLE1BQU07QUFDdEIsZUFBTyxLQUFLLGFBQWEsT0FBTyxNQUFNLENBQUMsSUFBSTtBQUFBLE1BQzdDLE9BQU87QUFDTCxlQUFPLEtBQUssYUFBYSxNQUFNLENBQUMsSUFBSTtBQUFBLE1BQ3RDO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFVQSxTQUFLLGNBQWMsU0FBUyxJQUFJO0FBQzlCLFVBQUcsR0FBRyxRQUFRLEdBQUcsTUFBTSxJQUFJO0FBQ3pCLGVBQU8sS0FBSyxjQUFjLEVBQUU7QUFBQSxNQUM5QjtBQUNBLFVBQUcsR0FBRyxRQUFRLEdBQUcsTUFBTSxJQUFJO0FBQ3pCLGVBQU8sS0FBSyxjQUFjLEVBQUU7QUFBQSxNQUM5QjtBQUNBLGFBQU87QUFBQSxJQUNUO0FBU0EsU0FBSyxnQkFBZ0IsU0FBUyxJQUFJO0FBQ2hDLFdBQUssR0FBRyxNQUFNLEdBQUc7QUFDakIsVUFBRyxHQUFHLFdBQVcsR0FBRztBQUNsQixlQUFPO0FBQUEsTUFDVDtBQUNBLFVBQUksSUFBSSxLQUFLLGFBQWE7QUFDMUIsZUFBUSxJQUFJLEdBQUcsSUFBSSxHQUFHLFFBQVEsRUFBRSxHQUFHO0FBQ2pDLFlBQUksTUFBTSxTQUFTLEdBQUcsSUFBSSxFQUFFO0FBQzVCLFlBQUcsTUFBTSxHQUFHLEdBQUc7QUFDYixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxVQUFFLFFBQVEsR0FBRztBQUFBLE1BQ2Y7QUFDQSxhQUFPLEVBQUUsU0FBUztBQUFBLElBQ3BCO0FBU0EsU0FBSyxnQkFBZ0IsU0FBUyxJQUFJO0FBQ2hDLFVBQUksU0FBUztBQUNiLFdBQUssR0FBRyxNQUFNLEdBQUcsRUFBRSxPQUFPLFNBQVMsR0FBRztBQUNwQyxZQUFHLEVBQUUsV0FBVztBQUFHLFlBQUU7QUFDckIsZUFBTztBQUFBLE1BQ1QsQ0FBQztBQUNELFVBQUksU0FBUyxJQUFJLEdBQUcsU0FBUyxVQUFVO0FBQ3ZDLFVBQUksSUFBSSxLQUFLLGFBQWE7QUFDMUIsZUFBUSxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUN6QixZQUFHLENBQUMsR0FBRyxNQUFNLEdBQUcsR0FBRyxXQUFXLEdBQUc7QUFDL0IsWUFBRSxhQUFhLEdBQUcsS0FBSztBQUN2QixrQkFBUTtBQUNSO0FBQUEsUUFDRjtBQUNBLFlBQUksUUFBUSxLQUFLLFdBQVcsR0FBRyxFQUFFO0FBQ2pDLFlBQUcsTUFBTSxTQUFTLEdBQUc7QUFDbkIsWUFBRSxRQUFRLENBQUM7QUFBQSxRQUNiO0FBQ0EsVUFBRSxTQUFTLEtBQUs7QUFBQSxNQUNsQjtBQUNBLGFBQU8sRUFBRSxTQUFTO0FBQUEsSUFDcEI7QUFXQSxTQUFLLFlBQVksU0FBUyxPQUFPO0FBQy9CLFVBQUcsTUFBTSxXQUFXLEdBQUc7QUFDckIsZUFBTyxLQUFLLFlBQVksS0FBSztBQUFBLE1BQy9CO0FBQ0EsVUFBRyxNQUFNLFdBQVcsSUFBSTtBQUN0QixlQUFPLEtBQUssWUFBWSxLQUFLO0FBQUEsTUFDL0I7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQVVBLFNBQUssY0FBYyxTQUFTLE9BQU87QUFDakMsVUFBRyxNQUFNLFdBQVcsR0FBRztBQUNyQixlQUFPO0FBQUEsTUFDVDtBQUNBLFVBQUksS0FBSyxDQUFDO0FBQ1YsZUFBUSxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3BDLFdBQUcsS0FBSyxNQUFNLFdBQVcsQ0FBQyxDQUFDO0FBQUEsTUFDN0I7QUFDQSxhQUFPLEdBQUcsS0FBSyxHQUFHO0FBQUEsSUFDcEI7QUFVQSxTQUFLLGNBQWMsU0FBUyxPQUFPO0FBQ2pDLFVBQUcsTUFBTSxXQUFXLElBQUk7QUFDdEIsZUFBTztBQUFBLE1BQ1Q7QUFDQSxVQUFJLEtBQUssQ0FBQztBQUNWLFVBQUksYUFBYSxDQUFDO0FBQ2xCLFVBQUksZUFBZTtBQUNuQixlQUFRLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDdkMsWUFBSSxNQUFNLEtBQUssV0FBVyxNQUFNLEtBQUssTUFBTSxJQUFJLEVBQUU7QUFFakQsZUFBTSxJQUFJLE9BQU8sT0FBTyxRQUFRLEtBQUs7QUFDbkMsZ0JBQU0sSUFBSSxPQUFPLENBQUM7QUFBQSxRQUNwQjtBQUNBLFlBQUcsUUFBUSxLQUFLO0FBQ2QsY0FBSSxPQUFPLFdBQVcsV0FBVyxTQUFTO0FBQzFDLGNBQUksTUFBTSxHQUFHO0FBQ2IsY0FBRyxDQUFDLFFBQVEsUUFBUSxLQUFLLE1BQU0sR0FBRztBQUNoQyx1QkFBVyxLQUFLLEVBQUMsT0FBTyxLQUFLLEtBQUssSUFBRyxDQUFDO0FBQUEsVUFDeEMsT0FBTztBQUNMLGlCQUFLLE1BQU07QUFDWCxnQkFBSSxLQUFLLE1BQU0sS0FBSyxRQUNqQixXQUFXLGNBQWMsTUFBTSxXQUFXLGNBQWMsT0FBUTtBQUNqRSw2QkFBZSxXQUFXLFNBQVM7QUFBQSxZQUNyQztBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQ0EsV0FBRyxLQUFLLEdBQUc7QUFBQSxNQUNiO0FBQ0EsVUFBRyxXQUFXLFNBQVMsR0FBRztBQUN4QixZQUFJLFFBQVEsV0FBVztBQUV2QixZQUFHLE1BQU0sTUFBTSxNQUFNLFFBQVEsR0FBRztBQUM5QixhQUFHLE9BQU8sTUFBTSxPQUFPLE1BQU0sTUFBTSxNQUFNLFFBQVEsR0FBRyxFQUFFO0FBQ3RELGNBQUcsTUFBTSxVQUFVLEdBQUc7QUFDcEIsZUFBRyxRQUFRLEVBQUU7QUFBQSxVQUNmO0FBQ0EsY0FBRyxNQUFNLFFBQVEsR0FBRztBQUNsQixlQUFHLEtBQUssRUFBRTtBQUFBLFVBQ1o7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUNBLGFBQU8sR0FBRyxLQUFLLEdBQUc7QUFBQSxJQUNwQjtBQVdBLFNBQUssZ0JBQWdCLFNBQVNILFVBQVMsVUFBVTtBQUMvQyxVQUFHLE9BQU9BLGFBQVksWUFBWTtBQUNoQyxtQkFBV0E7QUFDWCxRQUFBQSxXQUFVLENBQUM7QUFBQSxNQUNiO0FBQ0EsTUFBQUEsV0FBVUEsWUFBVyxDQUFDO0FBQ3RCLFVBQUcsV0FBVyxRQUFRLENBQUNBLFNBQVEsUUFBUTtBQUNyQyxlQUFPLFNBQVMsTUFBTSxLQUFLLEtBQUs7QUFBQSxNQUNsQztBQUNBLFVBQUcsT0FBTyxjQUFjLGVBQ3RCLHlCQUF5QixhQUN6QixVQUFVLHNCQUFzQixHQUFHO0FBQ25DLGFBQUssUUFBUSxVQUFVO0FBQ3ZCLGVBQU8sU0FBUyxNQUFNLEtBQUssS0FBSztBQUFBLE1BQ2xDO0FBQ0EsVUFBRyxPQUFPLFdBQVcsYUFBYTtBQUVoQyxhQUFLLFFBQVE7QUFDYixlQUFPLFNBQVMsTUFBTSxLQUFLLEtBQUs7QUFBQSxNQUNsQztBQUNBLFVBQUcsT0FBTyxTQUFTLGFBQWE7QUFFOUIsYUFBSyxRQUFRO0FBQ2IsZUFBTyxTQUFTLE1BQU0sS0FBSyxLQUFLO0FBQUEsTUFDbEM7QUFHQSxVQUFJLFVBQVUsSUFBSSxnQkFBZ0IsSUFBSSxLQUFLO0FBQUEsUUFBQztBQUFBLFFBQzFDLFdBQVc7QUFDVCxlQUFLLGlCQUFpQixXQUFXLFNBQVMsR0FBRztBQUUzQyxnQkFBSSxLQUFLLEtBQUssSUFBSTtBQUNsQixnQkFBSSxLQUFLLEtBQUs7QUFDZCxtQkFBTSxLQUFLLElBQUksSUFBSTtBQUFHO0FBQ3RCLGlCQUFLLFlBQVksRUFBQyxJQUFRLEdBQU0sQ0FBQztBQUFBLFVBQ25DLENBQUM7QUFBQSxRQUNILEVBQUUsU0FBUztBQUFBLFFBQ2I7QUFBQSxNQUFLLEdBQUcsRUFBQyxNQUFNLHlCQUF3QixDQUFDLENBQUM7QUFHekMsYUFBTyxDQUFDLEdBQUcsR0FBRyxFQUFFO0FBRWhCLGVBQVMsT0FBTyxLQUFLLFNBQVMsWUFBWTtBQUN4QyxZQUFHLFlBQVksR0FBRztBQUVoQixjQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksT0FBTyxTQUFTSSxNQUFLLEdBQUc7QUFDL0MsbUJBQU9BLE9BQU07QUFBQSxVQUNmLEdBQUcsQ0FBQyxJQUFJLElBQUksTUFBTTtBQUNsQixlQUFLLFFBQVEsS0FBSyxJQUFJLEdBQUcsR0FBRztBQUM1QixjQUFJLGdCQUFnQixPQUFPO0FBQzNCLGlCQUFPLFNBQVMsTUFBTSxLQUFLLEtBQUs7QUFBQSxRQUNsQztBQUNBLFFBQUFDLEtBQUksWUFBWSxTQUFTLEtBQUssU0FBUztBQUNyQyxjQUFJLEtBQUssT0FBTyxZQUFZLE9BQU8sQ0FBQztBQUNwQyxpQkFBTyxLQUFLLFVBQVUsR0FBRyxVQUFVO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0g7QUFFQSxlQUFTQSxLQUFJLFlBQVlDLFdBQVU7QUFDakMsWUFBSSxVQUFVLENBQUM7QUFDZixZQUFJLFVBQVUsQ0FBQztBQUNmLGlCQUFRLElBQUksR0FBRyxJQUFJLFlBQVksRUFBRSxHQUFHO0FBQ2xDLGNBQUksU0FBUyxJQUFJLE9BQU8sT0FBTztBQUMvQixpQkFBTyxpQkFBaUIsV0FBVyxTQUFTLEdBQUc7QUFDN0Msb0JBQVEsS0FBSyxFQUFFLElBQUk7QUFDbkIsZ0JBQUcsUUFBUSxXQUFXLFlBQVk7QUFDaEMsdUJBQVFDLEtBQUksR0FBR0EsS0FBSSxZQUFZLEVBQUVBLElBQUc7QUFDbEMsd0JBQVFBLElBQUcsVUFBVTtBQUFBLGNBQ3ZCO0FBQ0EsY0FBQUQsVUFBUyxNQUFNLE9BQU87QUFBQSxZQUN4QjtBQUFBLFVBQ0YsQ0FBQztBQUNELGtCQUFRLEtBQUssTUFBTTtBQUFBLFFBQ3JCO0FBQ0EsaUJBQVEsSUFBSSxHQUFHLElBQUksWUFBWSxFQUFFLEdBQUc7QUFDbEMsa0JBQVEsR0FBRyxZQUFZLENBQUM7QUFBQSxRQUMxQjtBQUFBLE1BQ0Y7QUFFQSxlQUFTLE9BQU8sWUFBWSxTQUFTO0FBRW5DLFlBQUksV0FBVyxDQUFDO0FBQ2hCLGlCQUFRLElBQUksR0FBRyxJQUFJLFlBQVksRUFBRSxHQUFHO0FBQ2xDLGNBQUksS0FBSyxRQUFRO0FBQ2pCLGNBQUksVUFBVSxTQUFTLEtBQUssQ0FBQztBQUM3QixtQkFBUSxJQUFJLEdBQUcsSUFBSSxZQUFZLEVBQUUsR0FBRztBQUNsQyxnQkFBRyxNQUFNLEdBQUc7QUFDVjtBQUFBLFlBQ0Y7QUFDQSxnQkFBSSxLQUFLLFFBQVE7QUFDakIsZ0JBQUksR0FBRyxLQUFLLEdBQUcsTUFBTSxHQUFHLEtBQUssR0FBRyxNQUM3QixHQUFHLEtBQUssR0FBRyxNQUFNLEdBQUcsS0FBSyxHQUFHLElBQUs7QUFDbEMsc0JBQVEsS0FBSyxDQUFDO0FBQUEsWUFDaEI7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUlBLGVBQU8sU0FBUyxPQUFPLFNBQVMsS0FBS0UsVUFBUztBQUM1QyxpQkFBTyxLQUFLLElBQUksS0FBS0EsU0FBUSxNQUFNO0FBQUEsUUFDckMsR0FBRyxDQUFDO0FBQUEsTUFDTjtBQUFBLElBQ0Y7QUFBQTtBQUFBOzs7QUMzbEZBO0FBQUEsd0NBQUFDLFVBQUFDLFNBQUE7QUFPQSxRQUFJQyxTQUFRO0FBRVosSUFBQUEsT0FBTSxNQUFNQSxPQUFNLE9BQU8sQ0FBQztBQUMxQixRQUFJLE9BQU9ELFFBQU8sVUFBVUMsT0FBTSxJQUFJLE9BQU9BLE9BQU0sT0FBT0EsT0FBTSxRQUFRLENBQUM7QUFHekUsYUFBUyxJQUFJLElBQUlDLE9BQU07QUFDckIsV0FBSyxNQUFNQTtBQUNYLFdBQUtBLFNBQVE7QUFBQSxJQUNmO0FBRUEsYUFBUyxJQUFJLElBQUlBLE9BQU07QUFDckIsV0FBSyxNQUFNQTtBQUFBLElBQ2I7QUFHQSxRQUFJLHdCQUF3QixlQUFlO0FBSTNDLFFBQUksd0JBQXdCLHNCQUFzQjtBQUNsRCxRQUFJLHdCQUF3Qix1QkFBdUI7QUFDbkQsUUFBSSx3QkFBd0IsWUFBWTtBQUN4QyxRQUFJLHdCQUF3QixNQUFNO0FBQ2xDLFFBQUksd0JBQXdCLFlBQVk7QUFDeEMsUUFBSSx5QkFBeUIsWUFBWTtBQUN6QyxRQUFJLHlCQUF5Qix5QkFBeUI7QUFDdEQsUUFBSSx5QkFBeUIseUJBQXlCO0FBQ3RELFFBQUkseUJBQXlCLHlCQUF5QjtBQUV0RCxRQUFJLGVBQWUsWUFBWTtBQUUvQixRQUFJLHFCQUFxQixlQUFlO0FBRXhDLFFBQUksZ0JBQWdCLFFBQVE7QUFFNUIsUUFBSSxpQkFBaUIsTUFBTTtBQUUzQixRQUFJLGlCQUFpQixzQkFBc0I7QUFDM0MsUUFBSSwwQkFBMEIsUUFBUTtBQUN0QyxRQUFJLDBCQUEwQixRQUFRO0FBQ3RDLFFBQUksMEJBQTBCLFFBQVE7QUFDdEMsUUFBSSwwQkFBMEIsUUFBUTtBQUN0QyxRQUFJLDBCQUEwQixZQUFZO0FBQzFDLFFBQUksMEJBQTBCLFlBQVk7QUFDMUMsUUFBSSxzQkFBc0IsS0FBSztBQUMvQixRQUFJLHNCQUFzQixLQUFLO0FBRy9CLFFBQUksd0JBQXdCLE1BQU07QUFDbEMsUUFBSSx3QkFBd0IsWUFBWTtBQUN4QyxRQUFJLHdCQUF3QixlQUFlO0FBQzNDLFFBQUksd0JBQXdCLHdCQUF3QjtBQUNwRCxRQUFJLHdCQUF3QixjQUFjO0FBQzFDLFFBQUksd0JBQXdCLGVBQWU7QUFHM0MsUUFBSSx3QkFBd0IsY0FBYztBQUMxQyxRQUFJLHdCQUF3QixrQkFBa0I7QUFDOUMsUUFBSSx3QkFBd0IsYUFBYTtBQUN6QyxRQUFJLHdCQUF3QixlQUFlO0FBQzNDLFFBQUksd0JBQXdCLGFBQWE7QUFDekMsUUFBSSx3QkFBd0Isa0JBQWtCO0FBQzlDLFFBQUksd0JBQXdCLG1CQUFtQjtBQUMvQyxRQUFJLHdCQUF3QixxQkFBcUI7QUFDakQsUUFBSSx5QkFBeUIsa0JBQWtCO0FBRS9DLFFBQUkseUJBQXlCLGNBQWM7QUFDM0MsUUFBSSx5QkFBeUIsWUFBWTtBQUN6QyxRQUFJLDJCQUEyQixpQkFBaUI7QUFHaEQsUUFBSSw4QkFBOEIsUUFBUTtBQUMxQyxRQUFJLDhCQUE4QixxQkFBcUI7QUFDdkQsUUFBSSw4QkFBOEIsU0FBUztBQUMzQyxRQUFJLDhCQUE4QixRQUFRO0FBQzFDLFFBQUksOEJBQThCLFdBQVc7QUFDN0MsUUFBSSw4QkFBOEIsaUJBQWlCO0FBR25ELFFBQUkseUJBQXlCLFlBQVk7QUFDekMsUUFBSSx5QkFBeUIsYUFBYTtBQUUxQyxRQUFJLDJCQUEyQix3QkFBd0I7QUFDdkQsUUFBSSwyQkFBMkIsdUJBQXVCO0FBQ3RELFFBQUksMkJBQTJCLGlDQUFpQztBQUNoRSxRQUFJLDJCQUEyQixpQ0FBaUM7QUFDaEUsUUFBSSwyQkFBMkIsNEJBQTRCO0FBQzNELFFBQUksMkJBQTJCLDJCQUEyQjtBQUcxRCxRQUFJLHNCQUFzQixjQUFjO0FBQ3hDLFFBQUksc0JBQXNCLGdCQUFnQjtBQUMxQyxRQUFJLHNCQUFzQixnQkFBZ0I7QUFDMUMsUUFBSSx1QkFBdUIsZ0JBQWdCO0FBQzNDLFFBQUksdUJBQXVCLGdCQUFnQjtBQUczQyxRQUFJLHNCQUFzQixjQUFjO0FBQ3hDLFFBQUksMEJBQTBCLFlBQVk7QUFDMUMsUUFBSSwyQkFBMkIsWUFBWTtBQUMzQyxRQUFJLDJCQUEyQixZQUFZO0FBRzNDLFFBQUksV0FBVyxZQUFZO0FBQzNCLFFBQUksV0FBVyxTQUFTO0FBQ3hCLFFBQUksV0FBVyxjQUFjO0FBQzdCLFFBQUksV0FBVyxhQUFhO0FBQzVCLFFBQUksV0FBVyxjQUFjO0FBQzdCLFFBQUksV0FBVyxxQkFBcUI7QUFDcEMsUUFBSSxXQUFXLGVBQWU7QUFDOUIsUUFBSSxZQUFZLGtCQUFrQjtBQUNsQyxRQUFJLFlBQVksd0JBQXdCO0FBQ3hDLFFBQUksWUFBWSxPQUFPO0FBQ3ZCLFFBQUksWUFBWSxhQUFhO0FBQzdCLFFBQUksWUFBWSxrQkFBa0I7QUFDbEMsUUFBSSxZQUFZLFlBQVk7QUFDNUIsUUFBSSxZQUFZLFdBQVc7QUFDM0IsUUFBSSw0QkFBNEIsZ0RBQWdEO0FBQ2hGLFFBQUksNEJBQTRCLHdDQUF3QztBQUd4RSxRQUFJLHlCQUF5QixZQUFZO0FBQ3pDLFFBQUksMEJBQTBCLFdBQVc7QUFDekMsUUFBSSxZQUFZLHdCQUF3QjtBQUN4QyxRQUFJLFlBQVksZUFBZTtBQUMvQixRQUFJLFlBQVkscUJBQXFCO0FBQ3JDLFFBQUksWUFBWSxxQkFBcUI7QUFDckMsUUFBSSxZQUFZLGVBQWU7QUFDL0IsUUFBSSxZQUFZLG9CQUFvQjtBQUNwQyxRQUFJLFlBQVksZ0JBQWdCO0FBQ2hDLFFBQUksWUFBWSxlQUFlO0FBQy9CLFFBQUksWUFBWSw0QkFBNEI7QUFDNUMsUUFBSSxhQUFhLGtCQUFrQjtBQUNuQyxRQUFJLGFBQWEsaUJBQWlCO0FBQ2xDLFFBQUksYUFBYSxtQkFBbUI7QUFDcEMsUUFBSSxhQUFhLGtCQUFrQjtBQUNuQyxRQUFJLGFBQWEsc0JBQXNCO0FBQ3ZDLFFBQUksYUFBYSxVQUFVO0FBQzNCLFFBQUksYUFBYSx1QkFBdUI7QUFDeEMsUUFBSSxhQUFhLGdCQUFnQjtBQUNqQyxRQUFJLGFBQWEsZUFBZTtBQUNoQyxRQUFJLGFBQWEsa0JBQWtCO0FBQ25DLFFBQUksYUFBYSxXQUFXO0FBQzVCLFFBQUksYUFBYSxXQUFXO0FBQzVCLFFBQUksYUFBYSxnQkFBZ0I7QUFDakMsUUFBSSxhQUFhLGlCQUFpQjtBQUNsQyxRQUFJLGFBQWEsZ0JBQWdCO0FBQ2pDLFFBQUksYUFBYSx1QkFBdUI7QUFDeEMsUUFBSSxhQUFhLDBCQUEwQjtBQUMzQyxRQUFJLGFBQWEsbUJBQW1CO0FBQ3BDLFFBQUksYUFBYSwwQkFBMEI7QUFDM0MsUUFBSSxhQUFhLG1CQUFtQjtBQUNwQyxRQUFJLGFBQWEsaUJBQWlCO0FBQ2xDLFFBQUksYUFBYSx1QkFBdUI7QUFDeEMsUUFBSSxhQUFhLHFCQUFxQjtBQUN0QyxRQUFJLGFBQWEsZ0JBQWdCO0FBQ2pDLFFBQUksYUFBYSxtQkFBbUI7QUFDcEMsUUFBSSxhQUFhLHdCQUF3QjtBQUN6QyxRQUFJLGFBQWEsbUJBQW1CO0FBQ3BDLFFBQUksYUFBYSxhQUFhO0FBQzlCLFFBQUksYUFBYSxhQUFhO0FBQzlCLFFBQUksYUFBYSxrQkFBa0I7QUFHbkMsUUFBSSwyQkFBMkIsZUFBZTtBQUM5QyxRQUFJLHFCQUFxQixxQkFBcUI7QUFDOUMsUUFBSSxxQkFBcUIsWUFBWTtBQUNyQyxRQUFJLHFCQUFxQixZQUFZO0FBQ3JDLFFBQUkscUJBQXFCLGFBQWE7QUFDdEMsUUFBSSxxQkFBcUIsaUJBQWlCO0FBQzFDLFFBQUkscUJBQXFCLGNBQWM7QUFBQTtBQUFBOzs7QUNsTHZDO0FBQUEsd0NBQUFDLFVBQUFDLFNBQUE7QUF1SUEsUUFBSUMsU0FBUTtBQUNaO0FBQ0E7QUFHQSxRQUFJLE9BQU9ELFFBQU8sVUFBVUMsT0FBTSxPQUFPQSxPQUFNLFFBQVEsQ0FBQztBQUt4RCxTQUFLLFFBQVE7QUFBQSxNQUNYLFdBQWtCO0FBQUEsTUFDbEIsYUFBa0I7QUFBQSxNQUNsQixrQkFBa0I7QUFBQSxNQUNsQixTQUFrQjtBQUFBLElBQ3BCO0FBTUEsU0FBSyxPQUFPO0FBQUEsTUFDVixNQUFrQjtBQUFBLE1BQ2xCLFNBQWtCO0FBQUEsTUFDbEIsU0FBa0I7QUFBQSxNQUNsQixXQUFrQjtBQUFBLE1BQ2xCLGFBQWtCO0FBQUEsTUFDbEIsTUFBa0I7QUFBQSxNQUNsQixLQUFrQjtBQUFBLE1BQ2xCLE9BQWtCO0FBQUEsTUFDbEIsVUFBa0I7QUFBQSxNQUNsQixNQUFrQjtBQUFBLE1BQ2xCLFlBQWlCO0FBQUEsTUFDakIsVUFBaUI7QUFBQSxNQUNqQixNQUFpQjtBQUFBLE1BQ2pCLE1BQWlCO0FBQUEsTUFDakIsVUFBaUI7QUFBQSxNQUNqQixLQUFpQjtBQUFBLE1BQ2pCLGlCQUFpQjtBQUFBLE1BQ2pCLFdBQWlCO0FBQUEsTUFDakIsU0FBaUI7QUFBQSxNQUNqQixpQkFBaUI7QUFBQSxNQUNqQixXQUFpQjtBQUFBLElBQ25CO0FBZUEsU0FBSyxTQUFTLFNBQVMsVUFBVSxNQUFNLGFBQWEsT0FBT0MsVUFBUztBQVFsRSxVQUFHRCxPQUFNLEtBQUssUUFBUSxLQUFLLEdBQUc7QUFDNUIsWUFBSSxNQUFNLENBQUM7QUFDWCxpQkFBUSxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3BDLGNBQUcsTUFBTSxPQUFPLFFBQVc7QUFDekIsZ0JBQUksS0FBSyxNQUFNLEVBQUU7QUFBQSxVQUNuQjtBQUFBLFFBQ0Y7QUFDQSxnQkFBUTtBQUFBLE1BQ1Y7QUFFQSxVQUFJLE1BQU07QUFBQSxRQUNSO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBLFVBQVUsZUFBZUEsT0FBTSxLQUFLLFFBQVEsS0FBSztBQUFBLFFBQ2pEO0FBQUEsTUFDRjtBQUNBLFVBQUdDLFlBQVcsdUJBQXVCQSxVQUFTO0FBRTVDLFlBQUksb0JBQW9CQSxTQUFRO0FBR2hDLFlBQUksV0FBVyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFXQSxTQUFLLE9BQU8sU0FBUyxLQUFLQSxVQUFTO0FBQ2pDLFVBQUk7QUFFSixVQUFHRCxPQUFNLEtBQUssUUFBUSxHQUFHLEdBQUc7QUFDMUIsZUFBTyxDQUFDO0FBQ1IsaUJBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUUsR0FBRztBQUNsQyxlQUFLLEtBQUssS0FBSyxLQUFLLElBQUksSUFBSUMsUUFBTyxDQUFDO0FBQUEsUUFDdEM7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUVBLFVBQUcsT0FBTyxRQUFRLFVBQVU7QUFFMUIsZUFBTztBQUFBLE1BQ1Q7QUFFQSxhQUFPO0FBQUEsUUFDTCxVQUFVLElBQUk7QUFBQSxRQUNkLE1BQU0sSUFBSTtBQUFBLFFBQ1YsYUFBYSxJQUFJO0FBQUEsUUFDakIsVUFBVSxJQUFJO0FBQUEsUUFDZCxPQUFPLEtBQUssS0FBSyxJQUFJLE9BQU9BLFFBQU87QUFBQSxNQUNyQztBQUNBLFVBQUdBLFlBQVcsQ0FBQ0EsU0FBUSwwQkFBMEI7QUFFL0MsYUFBSyxvQkFBb0IsSUFBSTtBQUFBLE1BQy9CO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFjQSxTQUFLLFNBQVMsU0FBUyxNQUFNLE1BQU1BLFVBQVM7QUFDMUMsVUFBR0QsT0FBTSxLQUFLLFFBQVEsSUFBSSxHQUFHO0FBQzNCLFlBQUcsQ0FBQ0EsT0FBTSxLQUFLLFFBQVEsSUFBSSxHQUFHO0FBQzVCLGlCQUFPO0FBQUEsUUFDVDtBQUNBLFlBQUcsS0FBSyxXQUFXLEtBQUssUUFBUTtBQUM5QixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxpQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsRUFBRSxHQUFHO0FBQ25DLGNBQUcsQ0FBQyxLQUFLLE9BQU8sS0FBSyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQ2pDLG1CQUFPO0FBQUEsVUFDVDtBQUFBLFFBQ0Y7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUVBLFVBQUcsT0FBTyxTQUFTLE9BQU8sTUFBTTtBQUM5QixlQUFPO0FBQUEsTUFDVDtBQUVBLFVBQUcsT0FBTyxTQUFTLFVBQVU7QUFDM0IsZUFBTyxTQUFTO0FBQUEsTUFDbEI7QUFFQSxVQUFJLFFBQVEsS0FBSyxhQUFhLEtBQUssWUFDakMsS0FBSyxTQUFTLEtBQUssUUFDbkIsS0FBSyxnQkFBZ0IsS0FBSyxlQUMxQixLQUFLLGFBQWEsS0FBSyxZQUN2QixLQUFLLE9BQU8sS0FBSyxPQUFPLEtBQUssS0FBSztBQUNwQyxVQUFHQyxZQUFXQSxTQUFRLDBCQUEwQjtBQUM5QyxnQkFBUSxTQUFVLEtBQUssc0JBQXNCLEtBQUs7QUFBQSxNQUNwRDtBQUVBLGFBQU87QUFBQSxJQUNUO0FBWUEsU0FBSyxvQkFBb0IsU0FBUyxHQUFHO0FBR25DLFVBQUksS0FBSyxFQUFFLFFBQVE7QUFDbkIsVUFBRyxPQUFPLEtBQU07QUFDZCxlQUFPO0FBQUEsTUFDVDtBQUdBLFVBQUlDO0FBQ0osVUFBSSxXQUFXLEtBQUs7QUFDcEIsVUFBRyxDQUFDLFVBQVU7QUFFWixRQUFBQSxVQUFTO0FBQUEsTUFDWCxPQUFPO0FBR0wsUUFBQUEsVUFBUyxFQUFFLFFBQVEsS0FBSyxRQUFTLENBQUM7QUFBQSxNQUNwQztBQUNBLGFBQU9BO0FBQUEsSUFDVDtBQVNBLGFBQVMsbUJBQW1CLE9BQU8sV0FBVyxHQUFHO0FBQy9DLFVBQUcsSUFBSSxXQUFXO0FBQ2hCLFlBQUksUUFBUSxJQUFJLE1BQU0sNkJBQTZCO0FBQ25ELGNBQU0sWUFBWSxNQUFNLE9BQU87QUFDL0IsY0FBTSxZQUFZO0FBQ2xCLGNBQU0sWUFBWTtBQUNsQixjQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFZQSxRQUFJLGtCQUFrQixTQUFTLE9BQU8sV0FBVztBQUkvQyxVQUFJLEtBQUssTUFBTSxRQUFRO0FBQ3ZCO0FBQ0EsVUFBRyxPQUFPLEtBQU07QUFDZCxlQUFPO0FBQUEsTUFDVDtBQUdBLFVBQUlBO0FBQ0osVUFBSSxXQUFXLEtBQUs7QUFDcEIsVUFBRyxDQUFDLFVBQVU7QUFFWixRQUFBQSxVQUFTO0FBQUEsTUFDWCxPQUFPO0FBR0wsWUFBSSxnQkFBZ0IsS0FBSztBQUN6QiwyQkFBbUIsT0FBTyxXQUFXLGFBQWE7QUFDbEQsUUFBQUEsVUFBUyxNQUFNLE9BQU8saUJBQWlCLENBQUM7QUFBQSxNQUMxQztBQUVBLFVBQUdBLFVBQVMsR0FBRztBQUNiLGNBQU0sSUFBSSxNQUFNLHNCQUFzQkEsT0FBTTtBQUFBLE1BQzlDO0FBQ0EsYUFBT0E7QUFBQSxJQUNUO0FBd0JBLFNBQUssVUFBVSxTQUFTLE9BQU9ELFVBQVM7QUFDdEMsVUFBR0EsYUFBWSxRQUFXO0FBQ3hCLFFBQUFBLFdBQVU7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLGVBQWU7QUFBQSxVQUNmLGtCQUFrQjtBQUFBLFFBQ3BCO0FBQUEsTUFDRjtBQUNBLFVBQUcsT0FBT0EsYUFBWSxXQUFXO0FBQy9CLFFBQUFBLFdBQVU7QUFBQSxVQUNSLFFBQVFBO0FBQUEsVUFDUixlQUFlO0FBQUEsVUFDZixrQkFBa0I7QUFBQSxRQUNwQjtBQUFBLE1BQ0Y7QUFDQSxVQUFHLEVBQUUsWUFBWUEsV0FBVTtBQUN6QixRQUFBQSxTQUFRLFNBQVM7QUFBQSxNQUNuQjtBQUNBLFVBQUcsRUFBRSxtQkFBbUJBLFdBQVU7QUFDaEMsUUFBQUEsU0FBUSxnQkFBZ0I7QUFBQSxNQUMxQjtBQUNBLFVBQUcsRUFBRSxzQkFBc0JBLFdBQVU7QUFDbkMsUUFBQUEsU0FBUSxtQkFBbUI7QUFBQSxNQUM3QjtBQUdBLFVBQUcsT0FBTyxVQUFVLFVBQVU7QUFDNUIsZ0JBQVFELE9BQU0sS0FBSyxhQUFhLEtBQUs7QUFBQSxNQUN2QztBQUVBLFVBQUksWUFBWSxNQUFNLE9BQU87QUFDN0IsVUFBSSxRQUFRLFNBQVMsT0FBTyxNQUFNLE9BQU8sR0FBRyxHQUFHQyxRQUFPO0FBQ3RELFVBQUdBLFNBQVEsaUJBQWlCLE1BQU0sT0FBTyxNQUFNLEdBQUc7QUFDaEQsWUFBSSxRQUFRLElBQUksTUFBTSxnREFBZ0Q7QUFDdEUsY0FBTSxZQUFZO0FBQ2xCLGNBQU0sWUFBWSxNQUFNLE9BQU87QUFDL0IsY0FBTTtBQUFBLE1BQ1I7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQVlBLGFBQVMsU0FBUyxPQUFPLFdBQVcsT0FBT0EsVUFBUztBQUVsRCxVQUFJO0FBR0oseUJBQW1CLE9BQU8sV0FBVyxDQUFDO0FBR3RDLFVBQUksS0FBSyxNQUFNLFFBQVE7QUFFdkI7QUFHQSxVQUFJLFdBQVksS0FBSztBQUdyQixVQUFJLE9BQU8sS0FBSztBQUdoQixjQUFRLE1BQU0sT0FBTztBQUNyQixVQUFJQyxVQUFTLGdCQUFnQixPQUFPLFNBQVM7QUFDN0MsbUJBQWEsUUFBUSxNQUFNLE9BQU87QUFHbEMsVUFBR0EsWUFBVyxVQUFhQSxVQUFTLFdBQVc7QUFDN0MsWUFBR0QsU0FBUSxRQUFRO0FBQ2pCLGNBQUksUUFBUSxJQUFJLE1BQU0sb0NBQW9DO0FBQzFELGdCQUFNLFlBQVksTUFBTSxPQUFPO0FBQy9CLGdCQUFNLFlBQVk7QUFDbEIsZ0JBQU0sWUFBWUM7QUFDbEIsZ0JBQU07QUFBQSxRQUNSO0FBRUEsUUFBQUEsVUFBUztBQUFBLE1BQ1g7QUFHQSxVQUFJO0FBRUosVUFBSTtBQUdKLFVBQUksZUFBZ0IsS0FBSyxRQUFVO0FBQ25DLFVBQUcsYUFBYTtBQUVkLGdCQUFRLENBQUM7QUFDVCxZQUFHQSxZQUFXLFFBQVc7QUFFdkIscUJBQVE7QUFDTiwrQkFBbUIsT0FBTyxXQUFXLENBQUM7QUFDdEMsZ0JBQUcsTUFBTSxNQUFNLENBQUMsTUFBTSxPQUFPLGFBQWEsR0FBRyxDQUFDLEdBQUc7QUFDL0Msb0JBQU0sU0FBUyxDQUFDO0FBQ2hCLDJCQUFhO0FBQ2I7QUFBQSxZQUNGO0FBQ0Esb0JBQVEsTUFBTSxPQUFPO0FBQ3JCLGtCQUFNLEtBQUssU0FBUyxPQUFPLFdBQVcsUUFBUSxHQUFHRCxRQUFPLENBQUM7QUFDekQseUJBQWEsUUFBUSxNQUFNLE9BQU87QUFBQSxVQUNwQztBQUFBLFFBQ0YsT0FBTztBQUVMLGlCQUFNQyxVQUFTLEdBQUc7QUFDaEIsb0JBQVEsTUFBTSxPQUFPO0FBQ3JCLGtCQUFNLEtBQUssU0FBUyxPQUFPQSxTQUFRLFFBQVEsR0FBR0QsUUFBTyxDQUFDO0FBQ3RELHlCQUFhLFFBQVEsTUFBTSxPQUFPO0FBQ2xDLFlBQUFDLFdBQVUsUUFBUSxNQUFNLE9BQU87QUFBQSxVQUNqQztBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBR0EsVUFBRyxVQUFVLFVBQWEsYUFBYSxLQUFLLE1BQU0sYUFDaEQsU0FBUyxLQUFLLEtBQUssV0FBVztBQUM5Qiw0QkFBb0IsTUFBTSxNQUFNQSxPQUFNO0FBQUEsTUFDeEM7QUFLQSxVQUFHLFVBQVUsVUFBYUQsU0FBUSxvQkFDaEMsYUFBYSxLQUFLLE1BQU0sYUFHdkIsU0FBUyxLQUFLLEtBQUssYUFDcEJDLFVBQVMsR0FBRztBQUVaLFlBQUksWUFBWSxNQUFNO0FBQ3RCLFlBQUksaUJBQWlCO0FBQ3JCLFlBQUksU0FBUztBQUNiLFlBQUcsU0FBUyxLQUFLLEtBQUssV0FBVztBQU8vQiw2QkFBbUIsT0FBTyxXQUFXLENBQUM7QUFDdEMsbUJBQVMsTUFBTSxRQUFRO0FBQ3ZCO0FBQUEsUUFDRjtBQUVBLFlBQUcsV0FBVyxHQUFHO0FBQ2YsY0FBSTtBQUdGLG9CQUFRLE1BQU0sT0FBTztBQUNyQixnQkFBSSxhQUFhO0FBQUEsY0FFZixRQUFRO0FBQUEsY0FDUixrQkFBa0I7QUFBQSxZQUNwQjtBQUNBLGdCQUFJLFdBQVcsU0FBUyxPQUFPLFdBQVcsUUFBUSxHQUFHLFVBQVU7QUFDL0QsZ0JBQUksT0FBTyxRQUFRLE1BQU0sT0FBTztBQUNoQyx5QkFBYTtBQUNiLGdCQUFHLFFBQVEsS0FBSyxLQUFLLFdBQVc7QUFDOUI7QUFBQSxZQUNGO0FBSUEsZ0JBQUksS0FBSyxTQUFTO0FBQ2xCLGdCQUFHLFNBQVNBLFlBQ1QsT0FBTyxLQUFLLE1BQU0sYUFBYSxPQUFPLEtBQUssTUFBTSxtQkFBbUI7QUFDckUsc0JBQVEsQ0FBQyxRQUFRO0FBQUEsWUFDbkI7QUFBQSxVQUNGLFNBQVEsSUFBTjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQ0EsWUFBRyxVQUFVLFFBQVc7QUFFdEIsZ0JBQU0sT0FBTztBQUNiLHNCQUFZO0FBQUEsUUFDZDtBQUFBLE1BQ0Y7QUFFQSxVQUFHLFVBQVUsUUFBVztBQUl0QixZQUFHQSxZQUFXLFFBQVc7QUFDdkIsY0FBR0QsU0FBUSxRQUFRO0FBQ2pCLGtCQUFNLElBQUksTUFBTSxvREFBb0Q7QUFBQSxVQUN0RTtBQUVBLFVBQUFDLFVBQVM7QUFBQSxRQUNYO0FBRUEsWUFBRyxTQUFTLEtBQUssS0FBSyxXQUFXO0FBQy9CLGtCQUFRO0FBQ1IsaUJBQU1BLFVBQVMsR0FBR0EsV0FBVSxHQUFHO0FBQzdCLCtCQUFtQixPQUFPLFdBQVcsQ0FBQztBQUN0QyxxQkFBUyxPQUFPLGFBQWEsTUFBTSxTQUFTLENBQUM7QUFDN0MseUJBQWE7QUFBQSxVQUNmO0FBQUEsUUFDRixPQUFPO0FBQ0wsa0JBQVEsTUFBTSxTQUFTQSxPQUFNO0FBQzdCLHVCQUFhQTtBQUFBLFFBQ2Y7QUFBQSxNQUNGO0FBR0EsVUFBSSxjQUFjLHNCQUFzQixTQUFZLE9BQU87QUFBQSxRQUN6RDtBQUFBLE1BQ0Y7QUFHQSxhQUFPLEtBQUssT0FBTyxVQUFVLE1BQU0sYUFBYSxPQUFPLFdBQVc7QUFBQSxJQUNwRTtBQVNBLFNBQUssUUFBUSxTQUFTLEtBQUs7QUFDekIsVUFBSSxRQUFRRixPQUFNLEtBQUssYUFBYTtBQUdwQyxVQUFJLEtBQUssSUFBSSxXQUFXLElBQUk7QUFHNUIsVUFBSSxRQUFRQSxPQUFNLEtBQUssYUFBYTtBQUdwQyxVQUFJLHVCQUF1QjtBQUMzQixVQUFHLHVCQUF1QixLQUFLO0FBQzdCLCtCQUF1QjtBQUN2QixZQUFHLElBQUksVUFBVTtBQUNmLGlDQUF1QixLQUFLLE9BQU8sS0FBSyxJQUFJLFFBQVE7QUFBQSxRQUN0RDtBQUFBLE1BQ0Y7QUFFQSxVQUFHLHNCQUFzQjtBQUN2QixjQUFNLFNBQVMsSUFBSSxpQkFBaUI7QUFBQSxNQUN0QyxXQUFVLElBQUksVUFBVTtBQUl0QixZQUFHLElBQUksYUFBYTtBQUNsQixnQkFBTTtBQUFBLFFBQ1IsT0FBTztBQUVMLGdCQUFNLFFBQVEsQ0FBSTtBQUFBLFFBQ3BCO0FBR0EsaUJBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3hDLGNBQUcsSUFBSSxNQUFNLE9BQU8sUUFBVztBQUM3QixrQkFBTSxVQUFVLEtBQUssTUFBTSxJQUFJLE1BQU0sRUFBRSxDQUFDO0FBQUEsVUFDMUM7QUFBQSxRQUNGO0FBQUEsTUFDRixPQUFPO0FBRUwsWUFBRyxJQUFJLFNBQVMsS0FBSyxLQUFLLFdBQVc7QUFDbkMsbUJBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3hDLGtCQUFNLFNBQVMsSUFBSSxNQUFNLFdBQVcsQ0FBQyxDQUFDO0FBQUEsVUFDeEM7QUFBQSxRQUNGLE9BQU87QUFJTCxjQUFHLElBQUksU0FBUyxLQUFLLEtBQUssV0FDeEIsSUFBSSxNQUFNLFNBQVMsTUFFakIsSUFBSSxNQUFNLFdBQVcsQ0FBQyxNQUFNLE1BQzdCLElBQUksTUFBTSxXQUFXLENBQUMsSUFBSSxTQUFVLEtBRXBDLElBQUksTUFBTSxXQUFXLENBQUMsTUFBTSxRQUM1QixJQUFJLE1BQU0sV0FBVyxDQUFDLElBQUksU0FBVSxNQUFRO0FBQzdDLGtCQUFNLFNBQVMsSUFBSSxNQUFNLE9BQU8sQ0FBQyxDQUFDO0FBQUEsVUFDcEMsT0FBTztBQUNMLGtCQUFNLFNBQVMsSUFBSSxLQUFLO0FBQUEsVUFDMUI7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUdBLFlBQU0sUUFBUSxFQUFFO0FBR2hCLFVBQUcsTUFBTSxPQUFPLEtBQUssS0FBSztBQUd4QixjQUFNLFFBQVEsTUFBTSxPQUFPLElBQUksR0FBSTtBQUFBLE1BQ3JDLE9BQU87QUFLTCxZQUFJLE1BQU0sTUFBTSxPQUFPO0FBQ3ZCLFlBQUksV0FBVztBQUNmLFdBQUc7QUFDRCxzQkFBWSxPQUFPLGFBQWEsTUFBTSxHQUFJO0FBQzFDLGdCQUFNLFFBQVE7QUFBQSxRQUNoQixTQUFRLE1BQU07QUFJZCxjQUFNLFFBQVEsU0FBUyxTQUFTLEdBQUk7QUFJcEMsaUJBQVEsSUFBSSxTQUFTLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQzVDLGdCQUFNLFFBQVEsU0FBUyxXQUFXLENBQUMsQ0FBQztBQUFBLFFBQ3RDO0FBQUEsTUFDRjtBQUdBLFlBQU0sVUFBVSxLQUFLO0FBQ3JCLGFBQU87QUFBQSxJQUNUO0FBVUEsU0FBSyxXQUFXLFNBQVMsS0FBSztBQUU1QixVQUFJLFNBQVMsSUFBSSxNQUFNLEdBQUc7QUFDMUIsVUFBSSxRQUFRQSxPQUFNLEtBQUssYUFBYTtBQUdwQyxZQUFNLFFBQVEsS0FBSyxTQUFTLE9BQU8sSUFBSSxFQUFFLElBQUksU0FBUyxPQUFPLElBQUksRUFBRSxDQUFDO0FBR3BFLFVBQUksTUFBTSxZQUFZLE9BQU87QUFDN0IsZUFBUSxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsRUFBRSxHQUFHO0FBR3JDLGVBQU87QUFDUCxxQkFBYSxDQUFDO0FBQ2QsZ0JBQVEsU0FBUyxPQUFPLElBQUksRUFBRTtBQUM5QixXQUFHO0FBQ0QsY0FBSSxRQUFRO0FBQ1osa0JBQVEsVUFBVTtBQUVsQixjQUFHLENBQUMsTUFBTTtBQUNSLGlCQUFLO0FBQUEsVUFDUDtBQUNBLHFCQUFXLEtBQUssQ0FBQztBQUNqQixpQkFBTztBQUFBLFFBQ1QsU0FBUSxRQUFRO0FBR2hCLGlCQUFRLElBQUksV0FBVyxTQUFTLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUM5QyxnQkFBTSxRQUFRLFdBQVcsRUFBRTtBQUFBLFFBQzdCO0FBQUEsTUFDRjtBQUVBLGFBQU87QUFBQSxJQUNUO0FBV0EsU0FBSyxXQUFXLFNBQVMsT0FBTztBQUM5QixVQUFJO0FBR0osVUFBRyxPQUFPLFVBQVUsVUFBVTtBQUM1QixnQkFBUUEsT0FBTSxLQUFLLGFBQWEsS0FBSztBQUFBLE1BQ3ZDO0FBR0EsVUFBSSxJQUFJLE1BQU0sUUFBUTtBQUN0QixZQUFNLEtBQUssTUFBTSxJQUFJLEVBQUUsSUFBSSxNQUFPLElBQUk7QUFJdEMsVUFBSSxRQUFRO0FBQ1osYUFBTSxNQUFNLE9BQU8sSUFBSSxHQUFHO0FBQ3hCLFlBQUksTUFBTSxRQUFRO0FBQ2xCLGdCQUFRLFNBQVM7QUFFakIsWUFBRyxJQUFJLEtBQU07QUFDWCxtQkFBUyxJQUFJO0FBQUEsUUFDZixPQUFPO0FBRUwsaUJBQU8sT0FBTyxRQUFRO0FBQ3RCLGtCQUFRO0FBQUEsUUFDVjtBQUFBLE1BQ0Y7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQVlBLFNBQUssZ0JBQWdCLFNBQVMsS0FBSztBQXNCakMsVUFBSSxPQUFPLElBQUksS0FBSztBQUdwQixVQUFJLE9BQU8sU0FBUyxJQUFJLE9BQU8sR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUN4QyxhQUFRLFFBQVEsS0FBTSxPQUFPLE9BQU8sTUFBTztBQUMzQyxVQUFJLEtBQUssU0FBUyxJQUFJLE9BQU8sR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJO0FBQzFDLFVBQUksS0FBSyxTQUFTLElBQUksT0FBTyxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLFVBQUksS0FBSyxTQUFTLElBQUksT0FBTyxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLFVBQUksS0FBSyxTQUFTLElBQUksT0FBTyxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RDLFVBQUksS0FBSztBQUdULFVBQUcsSUFBSSxTQUFTLElBQUk7QUFFbEIsWUFBSSxJQUFJLElBQUksT0FBTyxFQUFFO0FBQ3JCLFlBQUksTUFBTTtBQUdWLFlBQUcsTUFBTSxPQUFPLE1BQU0sS0FBSztBQUV6QixlQUFLLFNBQVMsSUFBSSxPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDbkMsaUJBQU87QUFBQSxRQUNUO0FBQUEsTUFDRjtBQUdBLFdBQUssZUFBZSxNQUFNLElBQUksRUFBRTtBQUNoQyxXQUFLLFlBQVksSUFBSSxJQUFJLElBQUksQ0FBQztBQUU5QixVQUFHLEtBQUs7QUFFTixZQUFJLElBQUksT0FBTyxHQUFHO0FBQ2xCLFlBQUcsTUFBTSxPQUFPLE1BQU0sS0FBSztBQUV6QixjQUFJLFdBQVcsU0FBUyxJQUFJLE9BQU8sTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ2xELGNBQUksV0FBVyxTQUFTLElBQUksT0FBTyxNQUFNLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFHbEQsY0FBSSxTQUFTLFdBQVcsS0FBSztBQUM3QixvQkFBVTtBQUdWLGNBQUcsTUFBTSxLQUFLO0FBQ1osaUJBQUssUUFBUSxDQUFDLE9BQU8sTUFBTTtBQUFBLFVBQzdCLE9BQU87QUFDTCxpQkFBSyxRQUFRLENBQUMsT0FBTyxNQUFNO0FBQUEsVUFDN0I7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLGFBQU87QUFBQSxJQUNUO0FBU0EsU0FBSyx3QkFBd0IsU0FBUyxTQUFTO0FBeUI3QyxVQUFJLE9BQU8sSUFBSSxLQUFLO0FBRXBCLFVBQUksT0FBTyxTQUFTLFFBQVEsT0FBTyxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQzVDLFVBQUksS0FBSyxTQUFTLFFBQVEsT0FBTyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUk7QUFDOUMsVUFBSSxLQUFLLFNBQVMsUUFBUSxPQUFPLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDMUMsVUFBSSxLQUFLLFNBQVMsUUFBUSxPQUFPLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDMUMsVUFBSSxLQUFLLFNBQVMsUUFBUSxPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDM0MsVUFBSSxLQUFLLFNBQVMsUUFBUSxPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDM0MsVUFBSSxNQUFNO0FBQ1YsVUFBSSxTQUFTO0FBQ2IsVUFBSSxRQUFRO0FBRVosVUFBRyxRQUFRLE9BQU8sUUFBUSxTQUFTLENBQUMsTUFBTSxLQUFLO0FBQzdDLGdCQUFRO0FBQUEsTUFDVjtBQUVBLFVBQUksTUFBTSxRQUFRLFNBQVMsR0FBRyxJQUFJLFFBQVEsT0FBTyxHQUFHO0FBQ3BELFVBQUcsTUFBTSxPQUFPLE1BQU0sS0FBSztBQUV6QixZQUFJLFdBQVcsU0FBUyxRQUFRLE9BQU8sTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RELFlBQUksV0FBVyxTQUFTLFFBQVEsT0FBTyxNQUFNLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFHdEQsaUJBQVMsV0FBVyxLQUFLO0FBQ3pCLGtCQUFVO0FBR1YsWUFBRyxNQUFNLEtBQUs7QUFDWixvQkFBVTtBQUFBLFFBQ1o7QUFFQSxnQkFBUTtBQUFBLE1BQ1Y7QUFHQSxVQUFHLFFBQVEsT0FBTyxFQUFFLE1BQU0sS0FBSztBQUM3QixjQUFNLFdBQVcsUUFBUSxPQUFPLEVBQUUsR0FBRyxFQUFFLElBQUk7QUFBQSxNQUM3QztBQUVBLFVBQUcsT0FBTztBQUNSLGFBQUssZUFBZSxNQUFNLElBQUksRUFBRTtBQUNoQyxhQUFLLFlBQVksSUFBSSxJQUFJLElBQUksR0FBRztBQUdoQyxhQUFLLFFBQVEsQ0FBQyxPQUFPLE1BQU07QUFBQSxNQUM3QixPQUFPO0FBQ0wsYUFBSyxZQUFZLE1BQU0sSUFBSSxFQUFFO0FBQzdCLGFBQUssU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUEsTUFDL0I7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQWFBLFNBQUssZ0JBQWdCLFNBQVMsTUFBTTtBQUVsQyxVQUFHLE9BQU8sU0FBUyxVQUFVO0FBQzNCLGVBQU87QUFBQSxNQUNUO0FBRUEsVUFBSSxPQUFPO0FBR1gsVUFBSSxTQUFTLENBQUM7QUFDZCxhQUFPLE1BQU0sS0FBSyxLQUFLLGVBQWUsR0FBRyxPQUFPLENBQUMsQ0FBQztBQUNsRCxhQUFPLEtBQUssTUFBTSxLQUFLLFlBQVksSUFBSSxFQUFFO0FBQ3pDLGFBQU8sS0FBSyxLQUFLLEtBQUssV0FBVyxDQUFDO0FBQ2xDLGFBQU8sS0FBSyxLQUFLLEtBQUssWUFBWSxDQUFDO0FBQ25DLGFBQU8sS0FBSyxLQUFLLEtBQUssY0FBYyxDQUFDO0FBQ3JDLGFBQU8sS0FBSyxLQUFLLEtBQUssY0FBYyxDQUFDO0FBR3JDLGVBQVEsSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEVBQUUsR0FBRztBQUNyQyxZQUFHLE9BQU8sR0FBRyxTQUFTLEdBQUc7QUFDdkIsa0JBQVE7QUFBQSxRQUNWO0FBQ0EsZ0JBQVEsT0FBTztBQUFBLE1BQ2pCO0FBQ0EsY0FBUTtBQUVSLGFBQU87QUFBQSxJQUNUO0FBU0EsU0FBSyx3QkFBd0IsU0FBUyxNQUFNO0FBRTFDLFVBQUcsT0FBTyxTQUFTLFVBQVU7QUFDM0IsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLE9BQU87QUFHWCxVQUFJLFNBQVMsQ0FBQztBQUNkLGFBQU8sS0FBSyxLQUFLLEtBQUssZUFBZSxDQUFDO0FBQ3RDLGFBQU8sS0FBSyxNQUFNLEtBQUssWUFBWSxJQUFJLEVBQUU7QUFDekMsYUFBTyxLQUFLLEtBQUssS0FBSyxXQUFXLENBQUM7QUFDbEMsYUFBTyxLQUFLLEtBQUssS0FBSyxZQUFZLENBQUM7QUFDbkMsYUFBTyxLQUFLLEtBQUssS0FBSyxjQUFjLENBQUM7QUFDckMsYUFBTyxLQUFLLEtBQUssS0FBSyxjQUFjLENBQUM7QUFHckMsZUFBUSxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsRUFBRSxHQUFHO0FBQ3JDLFlBQUcsT0FBTyxHQUFHLFNBQVMsR0FBRztBQUN2QixrQkFBUTtBQUFBLFFBQ1Y7QUFDQSxnQkFBUSxPQUFPO0FBQUEsTUFDakI7QUFDQSxjQUFRO0FBRVIsYUFBTztBQUFBLElBQ1Q7QUFVQSxTQUFLLGVBQWUsU0FBUyxHQUFHO0FBQzlCLFVBQUksT0FBT0EsT0FBTSxLQUFLLGFBQWE7QUFDbkMsVUFBRyxLQUFLLFFBQVMsSUFBSSxLQUFNO0FBQ3pCLGVBQU8sS0FBSyxhQUFhLEdBQUcsQ0FBQztBQUFBLE1BQy9CO0FBQ0EsVUFBRyxLQUFLLFVBQVcsSUFBSSxPQUFRO0FBQzdCLGVBQU8sS0FBSyxhQUFhLEdBQUcsRUFBRTtBQUFBLE1BQ2hDO0FBQ0EsVUFBRyxLQUFLLFlBQWEsSUFBSSxTQUFVO0FBQ2pDLGVBQU8sS0FBSyxhQUFhLEdBQUcsRUFBRTtBQUFBLE1BQ2hDO0FBQ0EsVUFBRyxLQUFLLGVBQWUsSUFBSSxZQUFZO0FBQ3JDLGVBQU8sS0FBSyxhQUFhLEdBQUcsRUFBRTtBQUFBLE1BQ2hDO0FBQ0EsVUFBSSxRQUFRLElBQUksTUFBTSxvQ0FBb0M7QUFDMUQsWUFBTSxVQUFVO0FBQ2hCLFlBQU07QUFBQSxJQUNSO0FBVUEsU0FBSyxlQUFlLFNBQVMsT0FBTztBQUVsQyxVQUFHLE9BQU8sVUFBVSxVQUFVO0FBQzVCLGdCQUFRQSxPQUFNLEtBQUssYUFBYSxLQUFLO0FBQUEsTUFDdkM7QUFFQSxVQUFJLElBQUksTUFBTSxPQUFPLElBQUk7QUFDekIsVUFBRyxJQUFJLElBQUk7QUFDVCxjQUFNLElBQUksTUFBTSxvQ0FBb0M7QUFBQSxNQUN0RDtBQUNBLGFBQU8sTUFBTSxhQUFhLENBQUM7QUFBQSxJQUM3QjtBQXlCQSxTQUFLLFdBQVcsU0FBUyxLQUFLLEdBQUcsU0FBUyxRQUFRO0FBQ2hELFVBQUksT0FBTztBQUdYLFdBQUksSUFBSSxhQUFhLEVBQUUsWUFBWSxPQUFPLEVBQUUsYUFBYyxpQkFDdkQsSUFBSSxTQUFTLEVBQUUsUUFBUSxPQUFPLEVBQUUsU0FBVSxjQUFjO0FBRXpELFlBQUcsSUFBSSxnQkFBZ0IsRUFBRSxlQUN2QixPQUFPLEVBQUUsZ0JBQWlCLGFBQWE7QUFDdkMsaUJBQU87QUFHUCxjQUFHLEVBQUUsU0FBU0EsT0FBTSxLQUFLLFFBQVEsRUFBRSxLQUFLLEdBQUc7QUFDekMsZ0JBQUksSUFBSTtBQUNSLHFCQUFRLElBQUksR0FBRyxRQUFRLElBQUksRUFBRSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQzlDLHFCQUFPLEVBQUUsTUFBTSxHQUFHLFlBQVk7QUFDOUIsa0JBQUcsSUFBSSxNQUFNLElBQUk7QUFDZix1QkFBTyxLQUFLLFNBQVMsSUFBSSxNQUFNLElBQUksRUFBRSxNQUFNLElBQUksU0FBUyxNQUFNO0FBQzlELG9CQUFHLE1BQU07QUFDUCxvQkFBRTtBQUFBLGdCQUNKLFdBQVUsRUFBRSxNQUFNLEdBQUcsVUFBVTtBQUM3Qix5QkFBTztBQUFBLGdCQUNUO0FBQUEsY0FDRjtBQUNBLGtCQUFHLENBQUMsUUFBUSxRQUFRO0FBQ2xCLHVCQUFPO0FBQUEsa0JBQ0wsTUFBTSxFQUFFLE9BQU8sa0JBQ0MsRUFBRSxXQUFXLGNBQzdCLEVBQUUsT0FBTyw4QkFDVCxFQUFFLE1BQU0sU0FBUyxhQUNqQixJQUFJLE1BQU0sU0FBUztBQUFBLGdCQUFHO0FBQUEsY0FDMUI7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUVBLGNBQUcsUUFBUSxTQUFTO0FBQ2xCLGdCQUFHLEVBQUUsU0FBUztBQUNaLHNCQUFRLEVBQUUsV0FBVyxJQUFJO0FBQUEsWUFDM0I7QUFDQSxnQkFBRyxFQUFFLGFBQWE7QUFDaEIsc0JBQVEsRUFBRSxlQUFlO0FBQUEsWUFDM0I7QUFDQSxnQkFBRyxFQUFFLDRCQUE0Qix1QkFBdUIsS0FBSztBQUMzRCxzQkFBUSxFQUFFLDRCQUE0QixJQUFJO0FBQUEsWUFDNUM7QUFDQSxnQkFBRyxFQUFFLHlCQUF5Qix1QkFBdUIsS0FBSztBQUN4RCxrQkFBSTtBQUNKLGtCQUFHLElBQUksa0JBQWtCLFNBQVMsR0FBRztBQUNuQyx3QkFBUSxFQUFFLHlCQUF5QjtBQUFBLGNBQ3JDLE9BQU87QUFFTCxvQkFBSSxTQUFTLElBQUksa0JBQWtCLFdBQVcsQ0FBQztBQUMvQyxvQkFBRyxXQUFXLEdBQUc7QUFDZix3QkFBTSxJQUFJO0FBQUEsb0JBQ1I7QUFBQSxrQkFBMkQ7QUFBQSxnQkFDL0Q7QUFDQSx3QkFBUSxFQUFFLHlCQUF5QixJQUFJLGtCQUFrQixNQUFNLENBQUM7QUFBQSxjQUNsRTtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQUEsUUFDRixXQUFVLFFBQVE7QUFDaEIsaUJBQU87QUFBQSxZQUNMLE1BQU0sRUFBRSxPQUFPLDZCQUNZLEVBQUUsY0FBYyxhQUMzQyxJQUFJLGNBQWM7QUFBQSxVQUFHO0FBQUEsUUFDekI7QUFBQSxNQUNGLFdBQVUsUUFBUTtBQUNoQixZQUFHLElBQUksYUFBYSxFQUFFLFVBQVU7QUFDOUIsaUJBQU87QUFBQSxZQUNMLE1BQU0sRUFBRSxPQUFPLDJCQUNVLEVBQUUsV0FBVyxhQUN0QyxJQUFJLFdBQVc7QUFBQSxVQUFHO0FBQUEsUUFDdEI7QUFDQSxZQUFHLElBQUksU0FBUyxFQUFFLE1BQU07QUFDdEIsaUJBQU87QUFBQSxZQUNMLE1BQU0sRUFBRSxPQUFPLHNCQUNLLEVBQUUsT0FBTyxhQUFhLElBQUksT0FBTztBQUFBLFVBQUc7QUFBQSxRQUM1RDtBQUFBLE1BQ0Y7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUdBLFFBQUksaUJBQWlCO0FBV3JCLFNBQUssY0FBYyxTQUFTLEtBQUssT0FBTyxhQUFhO0FBQ25ELFVBQUksT0FBTztBQUdYLGNBQVEsU0FBUztBQUNqQixvQkFBYyxlQUFlO0FBRzdCLFVBQUcsUUFBUSxHQUFHO0FBQ1osZ0JBQVE7QUFBQSxNQUNWO0FBR0EsVUFBSSxTQUFTO0FBQ2IsZUFBUSxJQUFJLEdBQUcsSUFBSSxRQUFRLGFBQWEsRUFBRSxHQUFHO0FBQzNDLGtCQUFVO0FBQUEsTUFDWjtBQUdBLGNBQVEsU0FBUztBQUNqQixjQUFPLElBQUk7QUFBQSxhQUNOLEtBQUssTUFBTTtBQUNkLGtCQUFRO0FBQ1I7QUFBQSxhQUNHLEtBQUssTUFBTTtBQUNkLGtCQUFRO0FBQ1I7QUFBQSxhQUNHLEtBQUssTUFBTTtBQUNkLGtCQUFRO0FBQ1I7QUFBQSxhQUNHLEtBQUssTUFBTTtBQUNkLGtCQUFRO0FBQ1I7QUFBQTtBQUdGLFVBQUcsSUFBSSxhQUFhLEtBQUssTUFBTSxXQUFXO0FBQ3hDLGdCQUFRLElBQUk7QUFHWixnQkFBTyxJQUFJO0FBQUEsZUFDTixLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUEsZUFDRyxLQUFLLEtBQUs7QUFDYixvQkFBUTtBQUNSO0FBQUE7QUFBQSxNQUVKLE9BQU87QUFDTCxnQkFBUSxJQUFJO0FBQUEsTUFDZDtBQUVBLGNBQVE7QUFDUixjQUFRLFNBQVMsa0JBQWtCLElBQUksY0FBYztBQUVyRCxVQUFHLElBQUksVUFBVTtBQUNmLFlBQUksWUFBWTtBQUNoQixZQUFJLE1BQU07QUFDVixpQkFBUSxJQUFJLEdBQUcsSUFBSSxJQUFJLE1BQU0sUUFBUSxFQUFFLEdBQUc7QUFDeEMsY0FBRyxJQUFJLE1BQU0sT0FBTyxRQUFXO0FBQzdCLHlCQUFhO0FBQ2IsbUJBQU8sS0FBSyxZQUFZLElBQUksTUFBTSxJQUFJLFFBQVEsR0FBRyxXQUFXO0FBQzVELGdCQUFJLElBQUksSUFBSyxJQUFJLE1BQU0sUUFBUTtBQUM3QixxQkFBTztBQUFBLFlBQ1Q7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUNBLGdCQUFRLFNBQVMsaUJBQWlCLFlBQVk7QUFBQSxNQUNoRCxPQUFPO0FBQ0wsZ0JBQVEsU0FBUztBQUNqQixZQUFHLElBQUksU0FBUyxLQUFLLEtBQUssS0FBSztBQUM3QixjQUFJLE1BQU0sS0FBSyxTQUFTLElBQUksS0FBSztBQUNqQyxrQkFBUTtBQUNSLGNBQUdBLE9BQU0sT0FBT0EsT0FBTSxJQUFJLE1BQU07QUFDOUIsZ0JBQUcsT0FBT0EsT0FBTSxJQUFJLE1BQU07QUFDeEIsc0JBQVEsT0FBT0EsT0FBTSxJQUFJLEtBQUssT0FBTztBQUFBLFlBQ3ZDO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxZQUFHLElBQUksU0FBUyxLQUFLLEtBQUssU0FBUztBQUNqQyxjQUFJO0FBQ0Ysb0JBQVEsS0FBSyxhQUFhLElBQUksS0FBSztBQUFBLFVBQ3JDLFNBQVEsSUFBTjtBQUNBLG9CQUFRLE9BQU9BLE9BQU0sS0FBSyxXQUFXLElBQUksS0FBSztBQUFBLFVBQ2hEO0FBQUEsUUFDRixXQUFVLElBQUksU0FBUyxLQUFLLEtBQUssV0FBVztBQUUxQyxjQUFHLElBQUksTUFBTSxTQUFTLEdBQUc7QUFFdkIsb0JBQVEsT0FBT0EsT0FBTSxLQUFLLFdBQVcsSUFBSSxNQUFNLE1BQU0sQ0FBQyxDQUFDO0FBQUEsVUFDekQsT0FBTztBQUNMLG9CQUFRO0FBQUEsVUFDVjtBQUVBLGNBQUcsSUFBSSxNQUFNLFNBQVMsR0FBRztBQUN2QixnQkFBSSxTQUFTLElBQUksTUFBTSxXQUFXLENBQUM7QUFDbkMsZ0JBQUcsVUFBVSxHQUFHO0FBQ2Qsc0JBQVE7QUFBQSxZQUNWLFdBQVUsU0FBUyxHQUFHO0FBQ3BCLHNCQUFRLE9BQU8sU0FBUztBQUFBLFlBQzFCO0FBQUEsVUFDRjtBQUFBLFFBQ0YsV0FBVSxJQUFJLFNBQVMsS0FBSyxLQUFLLGFBQWE7QUFDNUMsY0FBRyxDQUFDLGVBQWUsS0FBSyxJQUFJLEtBQUssR0FBRztBQUNsQyxvQkFBUSxNQUFNLElBQUksUUFBUTtBQUFBLFVBQzVCO0FBQ0Esa0JBQVEsT0FBT0EsT0FBTSxLQUFLLFdBQVcsSUFBSSxLQUFLO0FBQUEsUUFDaEQsV0FBVSxJQUFJLFNBQVMsS0FBSyxLQUFLLE1BQU07QUFDckMsY0FBSTtBQUNGLG9CQUFRQSxPQUFNLEtBQUssV0FBVyxJQUFJLEtBQUs7QUFBQSxVQUN6QyxTQUFRLEdBQU47QUFDQSxnQkFBRyxFQUFFLFlBQVksaUJBQWlCO0FBQ2hDLHNCQUNFLE9BQU9BLE9BQU0sS0FBSyxXQUFXLElBQUksS0FBSyxJQUFJO0FBQUEsWUFDOUMsT0FBTztBQUNMLG9CQUFNO0FBQUEsWUFDUjtBQUFBLFVBQ0Y7QUFBQSxRQUNGLFdBQVUsSUFBSSxTQUFTLEtBQUssS0FBSyxtQkFDL0IsSUFBSSxTQUFTLEtBQUssS0FBSyxXQUFXO0FBQ2xDLGtCQUFRLElBQUk7QUFBQSxRQUNkLFdBQVUsZUFBZSxLQUFLLElBQUksS0FBSyxHQUFHO0FBQ3hDLGtCQUFRLE9BQU9BLE9BQU0sS0FBSyxXQUFXLElBQUksS0FBSztBQUFBLFFBQ2hELFdBQVUsSUFBSSxNQUFNLFdBQVcsR0FBRztBQUNoQyxrQkFBUTtBQUFBLFFBQ1YsT0FBTztBQUNMLGtCQUFRLElBQUk7QUFBQSxRQUNkO0FBQUEsTUFDRjtBQUVBLGFBQU87QUFBQSxJQUNUO0FBQUE7QUFBQTs7O0FDejVDQTtBQUFBLDBDQUFBRyxVQUFBQyxTQUFBO0FBT0EsUUFBSUMsU0FBUTtBQUNaO0FBRUEsSUFBQUQsUUFBTyxVQUFVQyxPQUFNLFNBQVNBLE9BQU0sVUFBVSxDQUFDO0FBR2pELElBQUFBLE9BQU0sT0FBTyxhQUFhQSxPQUFNLE9BQU8sY0FBYyxDQUFDO0FBZXRELElBQUFBLE9BQU0sT0FBTyxlQUFlLFNBQVMsV0FBVyxLQUFLO0FBQ25ELFVBQUksTUFBTTtBQUNWLFVBQUcsT0FBTyxRQUFRLFVBQVU7QUFDMUIsY0FBTUEsT0FBTSxPQUFPLGFBQWEsR0FBRztBQUNuQyxZQUFHLEtBQUs7QUFDTixnQkFBTSxJQUFJO0FBQUEsUUFDWjtBQUFBLE1BQ0Y7QUFDQSxVQUFHLENBQUMsS0FBSztBQUNQLGNBQU0sSUFBSSxNQUFNLDRCQUE0QixTQUFTO0FBQUEsTUFDdkQ7QUFHQSxhQUFPLElBQUlBLE9BQU0sT0FBTyxZQUFZO0FBQUEsUUFDbEMsV0FBVztBQUFBLFFBQ1g7QUFBQSxRQUNBLFNBQVM7QUFBQSxNQUNYLENBQUM7QUFBQSxJQUNIO0FBZUEsSUFBQUEsT0FBTSxPQUFPLGlCQUFpQixTQUFTLFdBQVcsS0FBSztBQUNyRCxVQUFJLE1BQU07QUFDVixVQUFHLE9BQU8sUUFBUSxVQUFVO0FBQzFCLGNBQU1BLE9BQU0sT0FBTyxhQUFhLEdBQUc7QUFDbkMsWUFBRyxLQUFLO0FBQ04sZ0JBQU0sSUFBSTtBQUFBLFFBQ1o7QUFBQSxNQUNGO0FBQ0EsVUFBRyxDQUFDLEtBQUs7QUFDUCxjQUFNLElBQUksTUFBTSw0QkFBNEIsU0FBUztBQUFBLE1BQ3ZEO0FBR0EsYUFBTyxJQUFJQSxPQUFNLE9BQU8sWUFBWTtBQUFBLFFBQ2xDLFdBQVc7QUFBQSxRQUNYO0FBQUEsUUFDQSxTQUFTO0FBQUEsTUFDWCxDQUFDO0FBQUEsSUFDSDtBQVNBLElBQUFBLE9BQU0sT0FBTyxvQkFBb0IsU0FBU0MsT0FBTSxXQUFXO0FBQ3pELE1BQUFBLFFBQU9BLE1BQUssWUFBWTtBQUN4QixNQUFBRCxPQUFNLE9BQU8sV0FBV0MsU0FBUTtBQUFBLElBQ2xDO0FBU0EsSUFBQUQsT0FBTSxPQUFPLGVBQWUsU0FBU0MsT0FBTTtBQUN6QyxNQUFBQSxRQUFPQSxNQUFLLFlBQVk7QUFDeEIsVUFBR0EsU0FBUUQsT0FBTSxPQUFPLFlBQVk7QUFDbEMsZUFBT0EsT0FBTSxPQUFPLFdBQVdDO0FBQUEsTUFDakM7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUVBLFFBQUksY0FBY0QsT0FBTSxPQUFPLGNBQWMsU0FBU0UsVUFBUztBQUM3RCxXQUFLLFlBQVlBLFNBQVE7QUFDekIsV0FBSyxPQUFPLEtBQUssVUFBVTtBQUMzQixXQUFLLFlBQVksS0FBSyxLQUFLO0FBQzNCLFdBQUssVUFBVTtBQUNmLFdBQUssU0FBUztBQUNkLFdBQUssU0FBUztBQUNkLFdBQUssTUFBTUEsU0FBUSxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSztBQUMzRCxXQUFLLFdBQVdBLFNBQVE7QUFDeEIsV0FBSyxVQUFVLFdBQVdBLFFBQU87QUFBQSxJQUNuQztBQTZCQSxnQkFBWSxVQUFVLFFBQVEsU0FBU0EsVUFBUztBQUM5QyxNQUFBQSxXQUFVQSxZQUFXLENBQUM7QUFDdEIsVUFBSSxPQUFPLENBQUM7QUFDWixlQUFRLE9BQU9BLFVBQVM7QUFDdEIsYUFBSyxPQUFPQSxTQUFRO0FBQUEsTUFDdEI7QUFDQSxXQUFLLFVBQVUsS0FBSztBQUNwQixXQUFLLFVBQVU7QUFDZixXQUFLLFNBQVNGLE9BQU0sS0FBSyxhQUFhO0FBQ3RDLFdBQUssU0FBU0UsU0FBUSxVQUFVRixPQUFNLEtBQUssYUFBYTtBQUN4RCxXQUFLLEtBQUssTUFBTSxJQUFJO0FBQUEsSUFDdEI7QUFPQSxnQkFBWSxVQUFVLFNBQVMsU0FBUyxPQUFPO0FBQzdDLFVBQUcsT0FBTztBQUVSLGFBQUssT0FBTyxVQUFVLEtBQUs7QUFBQSxNQUM3QjtBQUdBLGFBQU0sQ0FBQyxLQUFLLElBQUksS0FBSyxLQUFLLE1BQU0sS0FBSyxRQUFRLEtBQUssUUFBUSxLQUFLLE9BQU8sS0FDcEUsQ0FBQyxLQUFLLFNBQVM7QUFBQSxNQUFDO0FBR2xCLFdBQUssT0FBTyxRQUFRO0FBQUEsSUFDdEI7QUFVQSxnQkFBWSxVQUFVLFNBQVMsU0FBUyxLQUFLO0FBRzNDLFVBQUcsUUFBUSxLQUFLLEtBQUssU0FBUyxTQUFTLEtBQUssS0FBSyxTQUFTLFFBQVE7QUFDaEUsYUFBSyxLQUFLLE1BQU0sU0FBUyxPQUFPO0FBQzlCLGlCQUFPLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSztBQUFBLFFBQ3pDO0FBQ0EsYUFBSyxLQUFLLFFBQVEsU0FBUyxRQUFRO0FBQ2pDLGlCQUFPLElBQUksS0FBSyxXQUFXLFFBQVEsSUFBSTtBQUFBLFFBQ3pDO0FBQUEsTUFDRjtBQUdBLFVBQUlFLFdBQVUsQ0FBQztBQUNmLE1BQUFBLFNBQVEsVUFBVSxLQUFLO0FBR3ZCLE1BQUFBLFNBQVEsV0FBVyxLQUFLLE9BQU8sT0FBTyxJQUFJLEtBQUs7QUFFL0MsVUFBRyxDQUFDLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSztBQUNsQyxZQUFHLENBQUMsS0FBSyxLQUFLLElBQUksS0FBSyxRQUFRQSxRQUFPLEdBQUc7QUFDdkMsaUJBQU87QUFBQSxRQUNUO0FBQUEsTUFDRjtBQUdBLFdBQUssVUFBVTtBQUNmLFdBQUssT0FBTztBQUVaLFVBQUcsS0FBSyxZQUFZLEtBQUssS0FBSyxPQUFPO0FBQ25DLFlBQUcsQ0FBQyxLQUFLLEtBQUssTUFBTSxLQUFLLFFBQVFBLFFBQU8sR0FBRztBQUN6QyxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBRUEsVUFBRyxLQUFLLEtBQUssYUFBYTtBQUN4QixZQUFHLENBQUMsS0FBSyxLQUFLLFlBQVksS0FBSyxRQUFRQSxRQUFPLEdBQUc7QUFDL0MsaUJBQU87QUFBQSxRQUNUO0FBQUEsTUFDRjtBQUVBLGFBQU87QUFBQSxJQUNUO0FBQUE7QUFBQTs7O0FDck9BO0FBQUEsK0NBQUFDLFVBQUFDLFNBQUE7QUFPQSxRQUFJQyxTQUFRO0FBQ1o7QUFFQSxJQUFBQSxPQUFNLFNBQVNBLE9BQU0sVUFBVSxDQUFDO0FBR2hDLFFBQUksUUFBUUQsUUFBTyxVQUFVQyxPQUFNLE9BQU8sUUFBUUEsT0FBTSxPQUFPLFNBQVMsQ0FBQztBQUl6RSxVQUFNLE1BQU0sU0FBU0MsVUFBUztBQUM1QixNQUFBQSxXQUFVQSxZQUFXLENBQUM7QUFDdEIsV0FBSyxPQUFPO0FBQ1osV0FBSyxTQUFTQSxTQUFRO0FBQ3RCLFdBQUssWUFBWUEsU0FBUSxhQUFhO0FBQ3RDLFdBQUssUUFBUSxLQUFLLFlBQVk7QUFDOUIsV0FBSyxXQUFXLElBQUksTUFBTSxLQUFLLEtBQUs7QUFDcEMsV0FBSyxZQUFZLElBQUksTUFBTSxLQUFLLEtBQUs7QUFBQSxJQUN2QztBQUVBLFVBQU0sSUFBSSxVQUFVLFFBQVEsU0FBU0EsVUFBUztBQUFBLElBQUM7QUFFL0MsVUFBTSxJQUFJLFVBQVUsVUFBVSxTQUFTLE9BQU8sUUFBUSxRQUFRO0FBRTVELFVBQUcsTUFBTSxPQUFPLElBQUksS0FBSyxhQUFhLEVBQUUsVUFBVSxNQUFNLE9BQU8sSUFBSSxJQUFJO0FBQ3JFLGVBQU87QUFBQSxNQUNUO0FBR0EsZUFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGFBQUssU0FBUyxLQUFLLE1BQU0sU0FBUztBQUFBLE1BQ3BDO0FBR0EsV0FBSyxPQUFPLFFBQVEsS0FBSyxVQUFVLEtBQUssU0FBUztBQUdqRCxlQUFRLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxFQUFFLEdBQUc7QUFDbEMsZUFBTyxTQUFTLEtBQUssVUFBVSxFQUFFO0FBQUEsTUFDbkM7QUFBQSxJQUNGO0FBRUEsVUFBTSxJQUFJLFVBQVUsVUFBVSxTQUFTLE9BQU8sUUFBUSxRQUFRO0FBRTVELFVBQUcsTUFBTSxPQUFPLElBQUksS0FBSyxhQUFhLEVBQUUsVUFBVSxNQUFNLE9BQU8sSUFBSSxJQUFJO0FBQ3JFLGVBQU87QUFBQSxNQUNUO0FBR0EsZUFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGFBQUssU0FBUyxLQUFLLE1BQU0sU0FBUztBQUFBLE1BQ3BDO0FBR0EsV0FBSyxPQUFPLFFBQVEsS0FBSyxVQUFVLEtBQUssU0FBUztBQUdqRCxlQUFRLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxFQUFFLEdBQUc7QUFDbEMsZUFBTyxTQUFTLEtBQUssVUFBVSxFQUFFO0FBQUEsTUFDbkM7QUFBQSxJQUNGO0FBRUEsVUFBTSxJQUFJLFVBQVUsTUFBTSxTQUFTLE9BQU9BLFVBQVM7QUFHakQsVUFBSUMsV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLFlBQ3JDLEtBQUssWUFBYSxLQUFLLFlBQVksTUFBTSxPQUFPO0FBQ2xELFlBQU0sYUFBYUEsVUFBU0EsUUFBTztBQUNuQyxhQUFPO0FBQUEsSUFDVDtBQUVBLFVBQU0sSUFBSSxVQUFVLFFBQVEsU0FBUyxRQUFRRCxVQUFTO0FBRXBELFVBQUdBLFNBQVEsV0FBVyxHQUFHO0FBQ3ZCLGVBQU87QUFBQSxNQUNUO0FBR0EsVUFBSSxNQUFNLE9BQU8sT0FBTztBQUN4QixVQUFJLFFBQVEsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUM3QixVQUFHLFFBQVMsS0FBSyxhQUFhLEdBQUk7QUFDaEMsZUFBTztBQUFBLE1BQ1Q7QUFHQSxhQUFPLFNBQVMsS0FBSztBQUNyQixhQUFPO0FBQUEsSUFDVDtBQUlBLFVBQU0sTUFBTSxTQUFTQSxVQUFTO0FBQzVCLE1BQUFBLFdBQVVBLFlBQVcsQ0FBQztBQUN0QixXQUFLLE9BQU87QUFDWixXQUFLLFNBQVNBLFNBQVE7QUFDdEIsV0FBSyxZQUFZQSxTQUFRLGFBQWE7QUFDdEMsV0FBSyxRQUFRLEtBQUssWUFBWTtBQUM5QixXQUFLLFdBQVcsSUFBSSxNQUFNLEtBQUssS0FBSztBQUNwQyxXQUFLLFlBQVksSUFBSSxNQUFNLEtBQUssS0FBSztBQUFBLElBQ3ZDO0FBRUEsVUFBTSxJQUFJLFVBQVUsUUFBUSxTQUFTQSxVQUFTO0FBRzVDLFVBQUdBLFNBQVEsT0FBTyxNQUFNO0FBRXRCLFlBQUcsQ0FBQyxLQUFLLE9BQU87QUFDZCxnQkFBTSxJQUFJLE1BQU0sdUJBQXVCO0FBQUEsUUFDekM7QUFDQSxhQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU0sQ0FBQztBQUFBLE1BQy9CLFdBQVUsRUFBRSxRQUFRQSxXQUFVO0FBQzVCLGNBQU0sSUFBSSxNQUFNLHVCQUF1QjtBQUFBLE1BQ3pDLE9BQU87QUFFTCxhQUFLLE1BQU0sWUFBWUEsU0FBUSxJQUFJLEtBQUssU0FBUztBQUNqRCxhQUFLLFFBQVEsS0FBSyxJQUFJLE1BQU0sQ0FBQztBQUFBLE1BQy9CO0FBQUEsSUFDRjtBQUVBLFVBQU0sSUFBSSxVQUFVLFVBQVUsU0FBUyxPQUFPLFFBQVEsUUFBUTtBQUU1RCxVQUFHLE1BQU0sT0FBTyxJQUFJLEtBQUssYUFBYSxFQUFFLFVBQVUsTUFBTSxPQUFPLElBQUksSUFBSTtBQUNyRSxlQUFPO0FBQUEsTUFDVDtBQUlBLGVBQVEsSUFBSSxHQUFHLElBQUksS0FBSyxPQUFPLEVBQUUsR0FBRztBQUNsQyxhQUFLLFNBQVMsS0FBSyxLQUFLLE1BQU0sS0FBSyxNQUFNLFNBQVM7QUFBQSxNQUNwRDtBQUdBLFdBQUssT0FBTyxRQUFRLEtBQUssVUFBVSxLQUFLLFNBQVM7QUFHakQsZUFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGVBQU8sU0FBUyxLQUFLLFVBQVUsRUFBRTtBQUFBLE1BQ25DO0FBQ0EsV0FBSyxRQUFRLEtBQUs7QUFBQSxJQUNwQjtBQUVBLFVBQU0sSUFBSSxVQUFVLFVBQVUsU0FBUyxPQUFPLFFBQVEsUUFBUTtBQUU1RCxVQUFHLE1BQU0sT0FBTyxJQUFJLEtBQUssYUFBYSxFQUFFLFVBQVUsTUFBTSxPQUFPLElBQUksSUFBSTtBQUNyRSxlQUFPO0FBQUEsTUFDVDtBQUdBLGVBQVEsSUFBSSxHQUFHLElBQUksS0FBSyxPQUFPLEVBQUUsR0FBRztBQUNsQyxhQUFLLFNBQVMsS0FBSyxNQUFNLFNBQVM7QUFBQSxNQUNwQztBQUdBLFdBQUssT0FBTyxRQUFRLEtBQUssVUFBVSxLQUFLLFNBQVM7QUFJakQsZUFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGVBQU8sU0FBUyxLQUFLLE1BQU0sS0FBSyxLQUFLLFVBQVUsRUFBRTtBQUFBLE1BQ25EO0FBQ0EsV0FBSyxRQUFRLEtBQUssU0FBUyxNQUFNLENBQUM7QUFBQSxJQUNwQztBQUVBLFVBQU0sSUFBSSxVQUFVLE1BQU0sU0FBUyxPQUFPQSxVQUFTO0FBR2pELFVBQUlDLFdBQVcsTUFBTSxPQUFPLE1BQU0sS0FBSyxZQUNyQyxLQUFLLFlBQWEsS0FBSyxZQUFZLE1BQU0sT0FBTztBQUNsRCxZQUFNLGFBQWFBLFVBQVNBLFFBQU87QUFDbkMsYUFBTztBQUFBLElBQ1Q7QUFFQSxVQUFNLElBQUksVUFBVSxRQUFRLFNBQVMsUUFBUUQsVUFBUztBQUVwRCxVQUFHQSxTQUFRLFdBQVcsR0FBRztBQUN2QixlQUFPO0FBQUEsTUFDVDtBQUdBLFVBQUksTUFBTSxPQUFPLE9BQU87QUFDeEIsVUFBSSxRQUFRLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDN0IsVUFBRyxRQUFTLEtBQUssYUFBYSxHQUFJO0FBQ2hDLGVBQU87QUFBQSxNQUNUO0FBR0EsYUFBTyxTQUFTLEtBQUs7QUFDckIsYUFBTztBQUFBLElBQ1Q7QUFJQSxVQUFNLE1BQU0sU0FBU0EsVUFBUztBQUM1QixNQUFBQSxXQUFVQSxZQUFXLENBQUM7QUFDdEIsV0FBSyxPQUFPO0FBQ1osV0FBSyxTQUFTQSxTQUFRO0FBQ3RCLFdBQUssWUFBWUEsU0FBUSxhQUFhO0FBQ3RDLFdBQUssUUFBUSxLQUFLLFlBQVk7QUFDOUIsV0FBSyxXQUFXO0FBQ2hCLFdBQUssWUFBWSxJQUFJLE1BQU0sS0FBSyxLQUFLO0FBQ3JDLFdBQUssZ0JBQWdCLElBQUksTUFBTSxLQUFLLEtBQUs7QUFDekMsV0FBSyxpQkFBaUJELE9BQU0sS0FBSyxhQUFhO0FBQzlDLFdBQUssZ0JBQWdCO0FBQUEsSUFDdkI7QUFFQSxVQUFNLElBQUksVUFBVSxRQUFRLFNBQVNDLFVBQVM7QUFDNUMsVUFBRyxFQUFFLFFBQVFBLFdBQVU7QUFDckIsY0FBTSxJQUFJLE1BQU0sdUJBQXVCO0FBQUEsTUFDekM7QUFFQSxXQUFLLE1BQU0sWUFBWUEsU0FBUSxJQUFJLEtBQUssU0FBUztBQUNqRCxXQUFLLFdBQVcsS0FBSyxJQUFJLE1BQU0sQ0FBQztBQUNoQyxXQUFLLGdCQUFnQjtBQUFBLElBQ3ZCO0FBRUEsVUFBTSxJQUFJLFVBQVUsVUFBVSxTQUFTLE9BQU8sUUFBUSxRQUFRO0FBRTVELFVBQUksY0FBYyxNQUFNLE9BQU87QUFDL0IsVUFBRyxnQkFBZ0IsR0FBRztBQUNwQixlQUFPO0FBQUEsTUFDVDtBQUdBLFdBQUssT0FBTyxRQUFRLEtBQUssVUFBVSxLQUFLLFNBQVM7QUFHakQsVUFBRyxLQUFLLGtCQUFrQixLQUFLLGVBQWUsS0FBSyxXQUFXO0FBRTVELGlCQUFRLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxFQUFFLEdBQUc7QUFDbEMsZUFBSyxTQUFTLEtBQUssTUFBTSxTQUFTLElBQUksS0FBSyxVQUFVO0FBQ3JELGlCQUFPLFNBQVMsS0FBSyxTQUFTLEVBQUU7QUFBQSxRQUNsQztBQUNBO0FBQUEsTUFDRjtBQUdBLFVBQUksZ0JBQWdCLEtBQUssWUFBWSxlQUFlLEtBQUs7QUFDekQsVUFBRyxlQUFlLEdBQUc7QUFDbkIsdUJBQWUsS0FBSyxZQUFZO0FBQUEsTUFDbEM7QUFHQSxXQUFLLGVBQWUsTUFBTTtBQUMxQixlQUFRLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxFQUFFLEdBQUc7QUFDbEMsYUFBSyxjQUFjLEtBQUssTUFBTSxTQUFTLElBQUksS0FBSyxVQUFVO0FBQzFELGFBQUssZUFBZSxTQUFTLEtBQUssY0FBYyxFQUFFO0FBQUEsTUFDcEQ7QUFFQSxVQUFHLGVBQWUsR0FBRztBQUVuQixjQUFNLFFBQVEsS0FBSztBQUFBLE1BQ3JCLE9BQU87QUFFTCxpQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGVBQUssU0FBUyxLQUFLLEtBQUssY0FBYztBQUFBLFFBQ3hDO0FBQUEsTUFDRjtBQUdBLFVBQUcsS0FBSyxnQkFBZ0IsR0FBRztBQUN6QixhQUFLLGVBQWUsU0FBUyxLQUFLLGFBQWE7QUFBQSxNQUNqRDtBQUVBLFVBQUcsZUFBZSxLQUFLLENBQUMsUUFBUTtBQUM5QixlQUFPLFNBQVMsS0FBSyxlQUFlO0FBQUEsVUFDbEMsZUFBZSxLQUFLO0FBQUEsUUFBYSxDQUFDO0FBQ3BDLGFBQUssZ0JBQWdCO0FBQ3JCLGVBQU87QUFBQSxNQUNUO0FBRUEsYUFBTyxTQUFTLEtBQUssZUFBZTtBQUFBLFFBQ2xDLGNBQWMsS0FBSztBQUFBLE1BQWEsQ0FBQztBQUNuQyxXQUFLLGdCQUFnQjtBQUFBLElBQ3ZCO0FBRUEsVUFBTSxJQUFJLFVBQVUsVUFBVSxTQUFTLE9BQU8sUUFBUSxRQUFRO0FBRTVELFVBQUksY0FBYyxNQUFNLE9BQU87QUFDL0IsVUFBRyxnQkFBZ0IsR0FBRztBQUNwQixlQUFPO0FBQUEsTUFDVDtBQUdBLFdBQUssT0FBTyxRQUFRLEtBQUssVUFBVSxLQUFLLFNBQVM7QUFHakQsVUFBRyxLQUFLLGtCQUFrQixLQUFLLGVBQWUsS0FBSyxXQUFXO0FBRTVELGlCQUFRLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxFQUFFLEdBQUc7QUFDbEMsZUFBSyxTQUFTLEtBQUssTUFBTSxTQUFTO0FBQ2xDLGlCQUFPLFNBQVMsS0FBSyxTQUFTLEtBQUssS0FBSyxVQUFVLEVBQUU7QUFBQSxRQUN0RDtBQUNBO0FBQUEsTUFDRjtBQUdBLFVBQUksZ0JBQWdCLEtBQUssWUFBWSxlQUFlLEtBQUs7QUFDekQsVUFBRyxlQUFlLEdBQUc7QUFDbkIsdUJBQWUsS0FBSyxZQUFZO0FBQUEsTUFDbEM7QUFHQSxXQUFLLGVBQWUsTUFBTTtBQUMxQixlQUFRLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxFQUFFLEdBQUc7QUFDbEMsYUFBSyxjQUFjLEtBQUssTUFBTSxTQUFTO0FBQ3ZDLGFBQUssZUFBZSxTQUFTLEtBQUssY0FBYyxLQUFLLEtBQUssVUFBVSxFQUFFO0FBQUEsTUFDeEU7QUFFQSxVQUFHLGVBQWUsR0FBRztBQUVuQixjQUFNLFFBQVEsS0FBSztBQUFBLE1BQ3JCLE9BQU87QUFFTCxpQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGVBQUssU0FBUyxLQUFLLEtBQUssY0FBYztBQUFBLFFBQ3hDO0FBQUEsTUFDRjtBQUdBLFVBQUcsS0FBSyxnQkFBZ0IsR0FBRztBQUN6QixhQUFLLGVBQWUsU0FBUyxLQUFLLGFBQWE7QUFBQSxNQUNqRDtBQUVBLFVBQUcsZUFBZSxLQUFLLENBQUMsUUFBUTtBQUM5QixlQUFPLFNBQVMsS0FBSyxlQUFlO0FBQUEsVUFDbEMsZUFBZSxLQUFLO0FBQUEsUUFBYSxDQUFDO0FBQ3BDLGFBQUssZ0JBQWdCO0FBQ3JCLGVBQU87QUFBQSxNQUNUO0FBRUEsYUFBTyxTQUFTLEtBQUssZUFBZTtBQUFBLFFBQ2xDLGNBQWMsS0FBSztBQUFBLE1BQWEsQ0FBQztBQUNuQyxXQUFLLGdCQUFnQjtBQUFBLElBQ3ZCO0FBSUEsVUFBTSxNQUFNLFNBQVNBLFVBQVM7QUFDNUIsTUFBQUEsV0FBVUEsWUFBVyxDQUFDO0FBQ3RCLFdBQUssT0FBTztBQUNaLFdBQUssU0FBU0EsU0FBUTtBQUN0QixXQUFLLFlBQVlBLFNBQVEsYUFBYTtBQUN0QyxXQUFLLFFBQVEsS0FBSyxZQUFZO0FBQzlCLFdBQUssV0FBVztBQUNoQixXQUFLLFlBQVksSUFBSSxNQUFNLEtBQUssS0FBSztBQUNyQyxXQUFLLGlCQUFpQkQsT0FBTSxLQUFLLGFBQWE7QUFDOUMsV0FBSyxnQkFBZ0I7QUFBQSxJQUN2QjtBQUVBLFVBQU0sSUFBSSxVQUFVLFFBQVEsU0FBU0MsVUFBUztBQUM1QyxVQUFHLEVBQUUsUUFBUUEsV0FBVTtBQUNyQixjQUFNLElBQUksTUFBTSx1QkFBdUI7QUFBQSxNQUN6QztBQUVBLFdBQUssTUFBTSxZQUFZQSxTQUFRLElBQUksS0FBSyxTQUFTO0FBQ2pELFdBQUssV0FBVyxLQUFLLElBQUksTUFBTSxDQUFDO0FBQ2hDLFdBQUssZ0JBQWdCO0FBQUEsSUFDdkI7QUFFQSxVQUFNLElBQUksVUFBVSxVQUFVLFNBQVMsT0FBTyxRQUFRLFFBQVE7QUFFNUQsVUFBSSxjQUFjLE1BQU0sT0FBTztBQUMvQixVQUFHLE1BQU0sT0FBTyxNQUFNLEdBQUc7QUFDdkIsZUFBTztBQUFBLE1BQ1Q7QUFHQSxXQUFLLE9BQU8sUUFBUSxLQUFLLFVBQVUsS0FBSyxTQUFTO0FBR2pELFVBQUcsS0FBSyxrQkFBa0IsS0FBSyxlQUFlLEtBQUssV0FBVztBQUU1RCxpQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGlCQUFPLFNBQVMsTUFBTSxTQUFTLElBQUksS0FBSyxVQUFVLEVBQUU7QUFDcEQsZUFBSyxTQUFTLEtBQUssS0FBSyxVQUFVO0FBQUEsUUFDcEM7QUFDQTtBQUFBLE1BQ0Y7QUFHQSxVQUFJLGdCQUFnQixLQUFLLFlBQVksZUFBZSxLQUFLO0FBQ3pELFVBQUcsZUFBZSxHQUFHO0FBQ25CLHVCQUFlLEtBQUssWUFBWTtBQUFBLE1BQ2xDO0FBR0EsV0FBSyxlQUFlLE1BQU07QUFDMUIsZUFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGFBQUssZUFBZSxTQUFTLE1BQU0sU0FBUyxJQUFJLEtBQUssVUFBVSxFQUFFO0FBQUEsTUFDbkU7QUFFQSxVQUFHLGVBQWUsR0FBRztBQUVuQixjQUFNLFFBQVEsS0FBSztBQUFBLE1BQ3JCLE9BQU87QUFFTCxpQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGVBQUssU0FBUyxLQUFLLEtBQUssVUFBVTtBQUFBLFFBQ3BDO0FBQUEsTUFDRjtBQUdBLFVBQUcsS0FBSyxnQkFBZ0IsR0FBRztBQUN6QixhQUFLLGVBQWUsU0FBUyxLQUFLLGFBQWE7QUFBQSxNQUNqRDtBQUVBLFVBQUcsZUFBZSxLQUFLLENBQUMsUUFBUTtBQUM5QixlQUFPLFNBQVMsS0FBSyxlQUFlO0FBQUEsVUFDbEMsZUFBZSxLQUFLO0FBQUEsUUFBYSxDQUFDO0FBQ3BDLGFBQUssZ0JBQWdCO0FBQ3JCLGVBQU87QUFBQSxNQUNUO0FBRUEsYUFBTyxTQUFTLEtBQUssZUFBZTtBQUFBLFFBQ2xDLGNBQWMsS0FBSztBQUFBLE1BQWEsQ0FBQztBQUNuQyxXQUFLLGdCQUFnQjtBQUFBLElBQ3ZCO0FBRUEsVUFBTSxJQUFJLFVBQVUsVUFBVSxNQUFNLElBQUksVUFBVTtBQUlsRCxVQUFNLE1BQU0sU0FBU0EsVUFBUztBQUM1QixNQUFBQSxXQUFVQSxZQUFXLENBQUM7QUFDdEIsV0FBSyxPQUFPO0FBQ1osV0FBSyxTQUFTQSxTQUFRO0FBQ3RCLFdBQUssWUFBWUEsU0FBUSxhQUFhO0FBQ3RDLFdBQUssUUFBUSxLQUFLLFlBQVk7QUFDOUIsV0FBSyxXQUFXO0FBQ2hCLFdBQUssWUFBWSxJQUFJLE1BQU0sS0FBSyxLQUFLO0FBQ3JDLFdBQUssaUJBQWlCRCxPQUFNLEtBQUssYUFBYTtBQUM5QyxXQUFLLGdCQUFnQjtBQUFBLElBQ3ZCO0FBRUEsVUFBTSxJQUFJLFVBQVUsUUFBUSxTQUFTQyxVQUFTO0FBQzVDLFVBQUcsRUFBRSxRQUFRQSxXQUFVO0FBQ3JCLGNBQU0sSUFBSSxNQUFNLHVCQUF1QjtBQUFBLE1BQ3pDO0FBRUEsV0FBSyxNQUFNLFlBQVlBLFNBQVEsSUFBSSxLQUFLLFNBQVM7QUFDakQsV0FBSyxXQUFXLEtBQUssSUFBSSxNQUFNLENBQUM7QUFDaEMsV0FBSyxnQkFBZ0I7QUFBQSxJQUN2QjtBQUVBLFVBQU0sSUFBSSxVQUFVLFVBQVUsU0FBUyxPQUFPLFFBQVEsUUFBUTtBQUU1RCxVQUFJLGNBQWMsTUFBTSxPQUFPO0FBQy9CLFVBQUcsZ0JBQWdCLEdBQUc7QUFDcEIsZUFBTztBQUFBLE1BQ1Q7QUFHQSxXQUFLLE9BQU8sUUFBUSxLQUFLLFVBQVUsS0FBSyxTQUFTO0FBR2pELFVBQUcsS0FBSyxrQkFBa0IsS0FBSyxlQUFlLEtBQUssV0FBVztBQUU1RCxpQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGlCQUFPLFNBQVMsTUFBTSxTQUFTLElBQUksS0FBSyxVQUFVLEVBQUU7QUFBQSxRQUN0RDtBQUFBLE1BQ0YsT0FBTztBQUVMLFlBQUksZ0JBQWdCLEtBQUssWUFBWSxlQUFlLEtBQUs7QUFDekQsWUFBRyxlQUFlLEdBQUc7QUFDbkIseUJBQWUsS0FBSyxZQUFZO0FBQUEsUUFDbEM7QUFHQSxhQUFLLGVBQWUsTUFBTTtBQUMxQixpQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGVBQUssZUFBZSxTQUFTLE1BQU0sU0FBUyxJQUFJLEtBQUssVUFBVSxFQUFFO0FBQUEsUUFDbkU7QUFFQSxZQUFHLGVBQWUsR0FBRztBQUVuQixnQkFBTSxRQUFRLEtBQUs7QUFBQSxRQUNyQjtBQUdBLFlBQUcsS0FBSyxnQkFBZ0IsR0FBRztBQUN6QixlQUFLLGVBQWUsU0FBUyxLQUFLLGFBQWE7QUFBQSxRQUNqRDtBQUVBLFlBQUcsZUFBZSxLQUFLLENBQUMsUUFBUTtBQUM5QixpQkFBTyxTQUFTLEtBQUssZUFBZTtBQUFBLFlBQ2xDLGVBQWUsS0FBSztBQUFBLFVBQWEsQ0FBQztBQUNwQyxlQUFLLGdCQUFnQjtBQUNyQixpQkFBTztBQUFBLFFBQ1Q7QUFFQSxlQUFPLFNBQVMsS0FBSyxlQUFlO0FBQUEsVUFDbEMsY0FBYyxLQUFLO0FBQUEsUUFBYSxDQUFDO0FBQ25DLGFBQUssZ0JBQWdCO0FBQUEsTUFDdkI7QUFHQSxZQUFNLEtBQUssUUFBUTtBQUFBLElBQ3JCO0FBRUEsVUFBTSxJQUFJLFVBQVUsVUFBVSxNQUFNLElBQUksVUFBVTtBQUlsRCxVQUFNLE1BQU0sU0FBU0EsVUFBUztBQUM1QixNQUFBQSxXQUFVQSxZQUFXLENBQUM7QUFDdEIsV0FBSyxPQUFPO0FBQ1osV0FBSyxTQUFTQSxTQUFRO0FBQ3RCLFdBQUssWUFBWUEsU0FBUSxhQUFhO0FBQ3RDLFdBQUssUUFBUSxLQUFLLFlBQVk7QUFDOUIsV0FBSyxXQUFXLElBQUksTUFBTSxLQUFLLEtBQUs7QUFDcEMsV0FBSyxZQUFZLElBQUksTUFBTSxLQUFLLEtBQUs7QUFDckMsV0FBSyxpQkFBaUJELE9BQU0sS0FBSyxhQUFhO0FBQzlDLFdBQUssZ0JBQWdCO0FBS3JCLFdBQUssS0FBSztBQUFBLElBQ1o7QUFFQSxVQUFNLElBQUksVUFBVSxRQUFRLFNBQVNDLFVBQVM7QUFDNUMsVUFBRyxFQUFFLFFBQVFBLFdBQVU7QUFDckIsY0FBTSxJQUFJLE1BQU0sdUJBQXVCO0FBQUEsTUFDekM7QUFFQSxVQUFJLEtBQUtELE9BQU0sS0FBSyxhQUFhQyxTQUFRLEVBQUU7QUFHM0MsV0FBSyxnQkFBZ0I7QUFHckIsVUFBSTtBQUNKLFVBQUcsb0JBQW9CQSxVQUFTO0FBQzlCLHlCQUFpQkQsT0FBTSxLQUFLLGFBQWFDLFNBQVEsY0FBYztBQUFBLE1BQ2pFLE9BQU87QUFDTCx5QkFBaUJELE9BQU0sS0FBSyxhQUFhO0FBQUEsTUFDM0M7QUFHQSxVQUFHLGVBQWVDLFVBQVM7QUFDekIsYUFBSyxhQUFhQSxTQUFRO0FBQUEsTUFDNUIsT0FBTztBQUNMLGFBQUssYUFBYTtBQUFBLE1BQ3BCO0FBR0EsV0FBSyxPQUFPO0FBQ1osVUFBR0EsU0FBUSxTQUFTO0FBRWxCLGFBQUssT0FBT0QsT0FBTSxLQUFLLGFBQWFDLFNBQVEsR0FBRyxFQUFFLFNBQVM7QUFDMUQsWUFBRyxLQUFLLEtBQUssV0FBWSxLQUFLLGFBQWEsR0FBSTtBQUM3QyxnQkFBTSxJQUFJLE1BQU0sK0NBQStDO0FBQUEsUUFDakU7QUFBQSxNQUNGO0FBR0EsV0FBSyxhQUFhLElBQUksTUFBTSxLQUFLLEtBQUs7QUFHdEMsV0FBSyxNQUFNO0FBSVgsV0FBSyxjQUFjLElBQUksTUFBTSxLQUFLLEtBQUs7QUFDdkMsV0FBSyxPQUFPLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSyxXQUFXO0FBTWxELFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssS0FBSyxLQUFLLGtCQUFrQixLQUFLLGFBQWEsS0FBSyxhQUFhO0FBS3JFLFVBQUksV0FBVyxHQUFHLE9BQU87QUFDekIsVUFBRyxhQUFhLElBQUk7QUFFbEIsYUFBSyxNQUFNLENBQUMsR0FBRyxTQUFTLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxTQUFTLEdBQUcsQ0FBQztBQUFBLE1BQzVELE9BQU87QUFFTCxhQUFLLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ3RCLGVBQU0sR0FBRyxPQUFPLElBQUksR0FBRztBQUNyQixlQUFLLE1BQU0sS0FBSztBQUFBLFlBQ2QsS0FBSztBQUFBLFlBQWEsS0FBSztBQUFBLFlBQ3ZCLENBQUMsR0FBRyxTQUFTLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxTQUFTLENBQUM7QUFBQSxVQUFDO0FBQUEsUUFDaEU7QUFDQSxhQUFLLE1BQU0sS0FBSztBQUFBLFVBQ2QsS0FBSztBQUFBLFVBQWEsS0FBSztBQUFBLFVBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLFdBQVcsV0FBVyxDQUFDLENBQUM7QUFBQSxRQUFDO0FBQUEsTUFDdkU7QUFHQSxXQUFLLFdBQVcsS0FBSyxJQUFJLE1BQU0sQ0FBQztBQUNoQyxZQUFNLEtBQUssUUFBUTtBQUNuQixXQUFLLGdCQUFnQjtBQUdyQix1QkFBaUJELE9BQU0sS0FBSyxhQUFhLGNBQWM7QUFFdkQsV0FBSyxlQUFlLFdBQVcsZUFBZSxPQUFPLElBQUksQ0FBQztBQUUxRCxVQUFJLFdBQVcsZUFBZSxPQUFPLElBQUksS0FBSztBQUM5QyxVQUFHLFVBQVU7QUFDWCx1QkFBZSxhQUFhLEdBQUcsS0FBSyxZQUFZLFFBQVE7QUFBQSxNQUMxRDtBQUNBLFdBQUssS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDckIsYUFBTSxlQUFlLE9BQU8sSUFBSSxHQUFHO0FBQ2pDLGFBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxhQUFhLEtBQUssSUFBSTtBQUFBLFVBQzlDLGVBQWUsU0FBUztBQUFBLFVBQ3hCLGVBQWUsU0FBUztBQUFBLFVBQ3hCLGVBQWUsU0FBUztBQUFBLFVBQ3hCLGVBQWUsU0FBUztBQUFBLFFBQzFCLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQUVBLFVBQU0sSUFBSSxVQUFVLFVBQVUsU0FBUyxPQUFPLFFBQVEsUUFBUTtBQUU1RCxVQUFJLGNBQWMsTUFBTSxPQUFPO0FBQy9CLFVBQUcsZ0JBQWdCLEdBQUc7QUFDcEIsZUFBTztBQUFBLE1BQ1Q7QUFHQSxXQUFLLE9BQU8sUUFBUSxLQUFLLFVBQVUsS0FBSyxTQUFTO0FBR2pELFVBQUcsS0FBSyxrQkFBa0IsS0FBSyxlQUFlLEtBQUssV0FBVztBQUU1RCxpQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGlCQUFPLFNBQVMsS0FBSyxVQUFVLE1BQU0sTUFBTSxTQUFTLENBQUM7QUFBQSxRQUN2RDtBQUNBLGFBQUssaUJBQWlCLEtBQUs7QUFBQSxNQUM3QixPQUFPO0FBRUwsWUFBSSxnQkFBZ0IsS0FBSyxZQUFZLGVBQWUsS0FBSztBQUN6RCxZQUFHLGVBQWUsR0FBRztBQUNuQix5QkFBZSxLQUFLLFlBQVk7QUFBQSxRQUNsQztBQUdBLGFBQUssZUFBZSxNQUFNO0FBQzFCLGlCQUFRLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxFQUFFLEdBQUc7QUFDbEMsZUFBSyxlQUFlLFNBQVMsTUFBTSxTQUFTLElBQUksS0FBSyxVQUFVLEVBQUU7QUFBQSxRQUNuRTtBQUVBLFlBQUcsZ0JBQWdCLEtBQUssUUFBUTtBQUU5QixjQUFHLFFBQVE7QUFFVCxnQkFBSSxXQUFXLGNBQWMsS0FBSztBQUNsQyxpQkFBSyxpQkFBaUI7QUFFdEIsaUJBQUssZUFBZSxTQUFTLEtBQUssWUFBWSxRQUFRO0FBQUEsVUFDeEQsT0FBTztBQUNMLGlCQUFLLGlCQUFpQixLQUFLO0FBQUEsVUFDN0I7QUFHQSxtQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGlCQUFLLFVBQVUsS0FBSyxLQUFLLGVBQWUsU0FBUztBQUFBLFVBQ25EO0FBQ0EsZUFBSyxlQUFlLFFBQVEsS0FBSztBQUFBLFFBQ25DO0FBR0EsWUFBRyxLQUFLLGdCQUFnQixHQUFHO0FBQ3pCLGVBQUssZUFBZSxTQUFTLEtBQUssYUFBYTtBQUFBLFFBQ2pEO0FBRUEsWUFBRyxlQUFlLEtBQUssQ0FBQyxRQUFRO0FBRzlCLGdCQUFNLFFBQVEsS0FBSztBQUNuQixpQkFBTyxTQUFTLEtBQUssZUFBZTtBQUFBLFlBQ2xDLGVBQWUsS0FBSztBQUFBLFVBQWEsQ0FBQztBQUNwQyxlQUFLLGdCQUFnQjtBQUNyQixpQkFBTztBQUFBLFFBQ1Q7QUFFQSxlQUFPLFNBQVMsS0FBSyxlQUFlO0FBQUEsVUFDbEMsY0FBYyxLQUFLO0FBQUEsUUFBYSxDQUFDO0FBQ25DLGFBQUssZ0JBQWdCO0FBQUEsTUFDdkI7QUFHQSxXQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssYUFBYSxLQUFLLElBQUksS0FBSyxTQUFTO0FBRzlELFlBQU0sS0FBSyxRQUFRO0FBQUEsSUFDckI7QUFFQSxVQUFNLElBQUksVUFBVSxVQUFVLFNBQVMsT0FBTyxRQUFRLFFBQVE7QUFFNUQsVUFBSSxjQUFjLE1BQU0sT0FBTztBQUMvQixVQUFHLGNBQWMsS0FBSyxhQUFhLEVBQUUsVUFBVSxjQUFjLElBQUk7QUFDL0QsZUFBTztBQUFBLE1BQ1Q7QUFHQSxXQUFLLE9BQU8sUUFBUSxLQUFLLFVBQVUsS0FBSyxTQUFTO0FBR2pELFlBQU0sS0FBSyxRQUFRO0FBR25CLFdBQUssV0FBVyxLQUFLLE1BQU0sU0FBUztBQUNwQyxXQUFLLFdBQVcsS0FBSyxNQUFNLFNBQVM7QUFDcEMsV0FBSyxXQUFXLEtBQUssTUFBTSxTQUFTO0FBQ3BDLFdBQUssV0FBVyxLQUFLLE1BQU0sU0FBUztBQUNwQyxXQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssYUFBYSxLQUFLLElBQUksS0FBSyxVQUFVO0FBRy9ELGVBQVEsSUFBSSxHQUFHLElBQUksS0FBSyxPQUFPLEVBQUUsR0FBRztBQUNsQyxlQUFPLFNBQVMsS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEVBQUU7QUFBQSxNQUN4RDtBQUdBLFVBQUcsY0FBYyxLQUFLLFdBQVc7QUFDL0IsYUFBSyxpQkFBaUIsY0FBYyxLQUFLO0FBQUEsTUFDM0MsT0FBTztBQUNMLGFBQUssaUJBQWlCLEtBQUs7QUFBQSxNQUM3QjtBQUFBLElBQ0Y7QUFFQSxVQUFNLElBQUksVUFBVSxjQUFjLFNBQVMsUUFBUUMsVUFBUztBQUMxRCxVQUFJLE9BQU87QUFHWCxVQUFHQSxTQUFRLFdBQVdBLFNBQVEsVUFBVTtBQUN0QyxlQUFPLFNBQVMsS0FBSyxZQUFZQSxTQUFRLFFBQVE7QUFBQSxNQUNuRDtBQUdBLFdBQUssTUFBTUQsT0FBTSxLQUFLLGFBQWE7QUFHbkMsVUFBSSxVQUFVLEtBQUssYUFBYSxPQUFPLFdBQVcsS0FBSyxnQkFBZ0IsQ0FBQyxDQUFDO0FBR3pFLFdBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxhQUFhLEtBQUssSUFBSSxPQUFPO0FBR3ZELFVBQUksTUFBTSxDQUFDO0FBQ1gsV0FBSyxPQUFPLFFBQVEsS0FBSyxLQUFLLEdBQUc7QUFDakMsZUFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUFHO0FBQ2xDLGFBQUssSUFBSSxTQUFTLEtBQUssR0FBRyxLQUFLLElBQUksRUFBRTtBQUFBLE1BQ3ZDO0FBR0EsV0FBSyxJQUFJLFNBQVMsS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLGFBQWEsRUFBRTtBQUczRCxVQUFHQyxTQUFRLFdBQVcsS0FBSyxJQUFJLE1BQU0sTUFBTSxLQUFLLE1BQU07QUFDcEQsZUFBTztBQUFBLE1BQ1Q7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQTJCQSxVQUFNLElBQUksVUFBVSxXQUFXLFNBQVMsR0FBRyxHQUFHO0FBQzVDLFVBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDckIsVUFBSSxNQUFNLEVBQUUsTUFBTSxDQUFDO0FBR25CLGVBQVEsSUFBSSxHQUFHLElBQUksS0FBSyxFQUFFLEdBQUc7QUFJM0IsWUFBSSxNQUFNLEVBQUcsSUFBSSxLQUFNLEtBQU0sS0FBTSxLQUFLLElBQUk7QUFDNUMsWUFBRyxLQUFLO0FBQ04sY0FBSSxNQUFNLElBQUk7QUFDZCxjQUFJLE1BQU0sSUFBSTtBQUNkLGNBQUksTUFBTSxJQUFJO0FBQ2QsY0FBSSxNQUFNLElBQUk7QUFBQSxRQUNoQjtBQUlBLGFBQUssSUFBSSxLQUFLLEdBQUc7QUFBQSxNQUNuQjtBQUVBLGFBQU87QUFBQSxJQUNUO0FBRUEsVUFBTSxJQUFJLFVBQVUsTUFBTSxTQUFTLEdBQUcsS0FBSztBQUd6QyxVQUFJLE1BQU0sRUFBRSxLQUFLO0FBTWpCLGVBQVEsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDekIsWUFBSSxLQUFNLEVBQUUsT0FBTyxLQUFPLEVBQUUsSUFBSSxLQUFLLE1BQU07QUFBQSxNQUM3QztBQUVBLFVBQUksS0FBSyxFQUFFLE9BQU87QUFLbEIsVUFBRyxLQUFLO0FBQ04sWUFBSSxNQUFNLEtBQUs7QUFBQSxNQUNqQjtBQUFBLElBQ0Y7QUFFQSxVQUFNLElBQUksVUFBVSxnQkFBZ0IsU0FBUyxHQUFHO0FBRTlDLFVBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDbkIsZUFBUSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUMxQixZQUFJLE1BQU8sSUFBSSxJQUFLO0FBQ3BCLFlBQUksTUFBTyxFQUFFLFVBQVcsSUFBSyxJQUFJLEtBQU0sSUFBTTtBQUM3QyxZQUFJLEtBQUssS0FBSyxHQUFHLEdBQUc7QUFDcEIsVUFBRSxNQUFNLEdBQUc7QUFDWCxVQUFFLE1BQU0sR0FBRztBQUNYLFVBQUUsTUFBTSxHQUFHO0FBQ1gsVUFBRSxNQUFNLEdBQUc7QUFBQSxNQUNiO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFhQSxVQUFNLElBQUksVUFBVSxRQUFRLFNBQVMsR0FBRyxHQUFHLEdBQUc7QUFDNUMsUUFBRSxNQUFNLEVBQUU7QUFDVixRQUFFLE1BQU0sRUFBRTtBQUNWLFFBQUUsTUFBTSxFQUFFO0FBQ1YsUUFBRSxNQUFNLEVBQUU7QUFDVixhQUFPLEtBQUssY0FBYyxDQUFDO0FBQUEsSUFFN0I7QUFpQkEsVUFBTSxJQUFJLFVBQVUsb0JBQW9CLFNBQVMsR0FBRyxNQUFNO0FBSXhELFVBQUksYUFBYSxJQUFJO0FBQ3JCLFVBQUksU0FBUyxJQUFJO0FBQ2pCLFVBQUksT0FBTyxLQUFLO0FBQ2hCLFVBQUksSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUN0QixlQUFRLElBQUksR0FBRyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzVCLFlBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDckIsWUFBSSxNQUFPLElBQUksU0FBVTtBQUN6QixZQUFJLFFBQVMsU0FBUyxJQUFLLElBQUksVUFBVztBQUMxQyxZQUFJLE9BQVEsS0FBTSxPQUFPLEtBQU87QUFDaEMsVUFBRSxLQUFLLEtBQUsscUJBQXFCLEtBQUssU0FBUyxLQUFLLENBQUMsR0FBRyxJQUFJO0FBQUEsTUFDOUQ7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQVNBLFVBQU0sSUFBSSxVQUFVLHVCQUF1QixTQUFTLEtBQUssTUFBTTtBQUk3RCxVQUFJLE9BQU8sS0FBSztBQUNoQixVQUFJLE9BQU8sU0FBUztBQUNwQixVQUFJLElBQUksSUFBSSxNQUFNLElBQUk7QUFDdEIsUUFBRSxRQUFRLElBQUksTUFBTSxDQUFDO0FBQ3JCLFVBQUksSUFBSSxTQUFTO0FBQ2pCLGFBQU0sSUFBSSxHQUFHO0FBRVgsYUFBSyxJQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDNUIsY0FBTTtBQUFBLE1BQ1I7QUFDQSxVQUFJO0FBQ0osYUFBTSxJQUFJLE1BQU07QUFDZCxpQkFBUSxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUN6QixjQUFJLE1BQU0sRUFBRTtBQUNaLGNBQUksTUFBTSxFQUFFO0FBQ1osWUFBRSxJQUFJLEtBQUs7QUFBQSxZQUNULElBQUksS0FBSyxJQUFJO0FBQUEsWUFDYixJQUFJLEtBQUssSUFBSTtBQUFBLFlBQ2IsSUFBSSxLQUFLLElBQUk7QUFBQSxZQUNiLElBQUksS0FBSyxJQUFJO0FBQUEsVUFDZjtBQUFBLFFBQ0Y7QUFDQSxhQUFLO0FBQUEsTUFDUDtBQUNBLFFBQUUsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFHbEIsV0FBSSxJQUFJLE9BQU8sR0FBRyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQy9CLFlBQUksSUFBSSxFQUFFLElBQUk7QUFDZCxVQUFFLEtBQUssQ0FBQyxJQUFJLEtBQUssRUFBRSxJQUFJLElBQUksS0FBSyxFQUFFLElBQUksSUFBSSxLQUFLLEVBQUUsSUFBSSxJQUFJLEtBQUssRUFBRSxFQUFFO0FBQUEsTUFDcEU7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUlBLGFBQVMsWUFBWSxJQUFJLFdBQVc7QUFDbEMsVUFBRyxPQUFPLE9BQU8sVUFBVTtBQUV6QixhQUFLRCxPQUFNLEtBQUssYUFBYSxFQUFFO0FBQUEsTUFDakM7QUFFQSxVQUFHQSxPQUFNLEtBQUssUUFBUSxFQUFFLEtBQUssR0FBRyxTQUFTLEdBQUc7QUFFMUMsWUFBSSxNQUFNO0FBQ1YsYUFBS0EsT0FBTSxLQUFLLGFBQWE7QUFDN0IsaUJBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUUsR0FBRztBQUNsQyxhQUFHLFFBQVEsSUFBSSxFQUFFO0FBQUEsUUFDbkI7QUFBQSxNQUNGO0FBRUEsVUFBRyxHQUFHLE9BQU8sSUFBSSxXQUFXO0FBQzFCLGNBQU0sSUFBSTtBQUFBLFVBQ1IsNEJBQTRCLEdBQUcsT0FBTyxJQUN0Qyx5QkFBeUIsWUFBWTtBQUFBLFFBQVM7QUFBQSxNQUNsRDtBQUVBLFVBQUcsQ0FBQ0EsT0FBTSxLQUFLLFFBQVEsRUFBRSxHQUFHO0FBRTFCLFlBQUksT0FBTyxDQUFDO0FBQ1osWUFBSSxTQUFTLFlBQVk7QUFDekIsaUJBQVEsSUFBSSxHQUFHLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDOUIsZUFBSyxLQUFLLEdBQUcsU0FBUyxDQUFDO0FBQUEsUUFDekI7QUFDQSxhQUFLO0FBQUEsTUFDUDtBQUVBLGFBQU87QUFBQSxJQUNUO0FBRUEsYUFBUyxNQUFNLE9BQU87QUFFcEIsWUFBTSxNQUFNLFNBQVMsS0FBTSxNQUFNLE1BQU0sU0FBUyxLQUFLLElBQUs7QUFBQSxJQUM1RDtBQUVBLGFBQVMsV0FBVyxLQUFLO0FBRXZCLGFBQU8sQ0FBRSxNQUFNLGFBQWUsR0FBRyxNQUFNLFVBQVU7QUFBQSxJQUNuRDtBQUFBO0FBQUE7OztBQ3QrQkE7QUFBQSx1Q0FBQUcsVUFBQUMsU0FBQTtBQWlCQSxRQUFJQyxTQUFRO0FBQ1o7QUFDQTtBQUNBO0FBR0EsSUFBQUQsUUFBTyxVQUFVQyxPQUFNLE1BQU1BLE9BQU0sT0FBTyxDQUFDO0FBcUIzQyxJQUFBQSxPQUFNLElBQUksa0JBQWtCLFNBQVMsS0FBSyxJQUFJLFFBQVEsTUFBTTtBQUMxRCxVQUFJLFNBQVMsY0FBYztBQUFBLFFBQ3pCO0FBQUEsUUFDQTtBQUFBLFFBQ0EsU0FBUztBQUFBLFFBQ1Q7QUFBQSxNQUNGLENBQUM7QUFDRCxhQUFPLE1BQU0sRUFBRTtBQUNmLGFBQU87QUFBQSxJQUNUO0FBaUJBLElBQUFBLE9BQU0sSUFBSSx5QkFBeUIsU0FBUyxLQUFLLE1BQU07QUFDckQsYUFBTyxjQUFjO0FBQUEsUUFDbkI7QUFBQSxRQUNBLFFBQVE7QUFBQSxRQUNSLFNBQVM7QUFBQSxRQUNUO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQXFCQSxJQUFBQSxPQUFNLElBQUksa0JBQWtCLFNBQVMsS0FBSyxJQUFJLFFBQVEsTUFBTTtBQUMxRCxVQUFJLFNBQVMsY0FBYztBQUFBLFFBQ3pCO0FBQUEsUUFDQTtBQUFBLFFBQ0EsU0FBUztBQUFBLFFBQ1Q7QUFBQSxNQUNGLENBQUM7QUFDRCxhQUFPLE1BQU0sRUFBRTtBQUNmLGFBQU87QUFBQSxJQUNUO0FBaUJBLElBQUFBLE9BQU0sSUFBSSx5QkFBeUIsU0FBUyxLQUFLLE1BQU07QUFDckQsYUFBTyxjQUFjO0FBQUEsUUFDbkI7QUFBQSxRQUNBLFFBQVE7QUFBQSxRQUNSLFNBQVM7QUFBQSxRQUNUO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQVVBLElBQUFBLE9BQU0sSUFBSSxZQUFZLFNBQVNDLE9BQU0sTUFBTTtBQUN6QyxVQUFHLENBQUMsTUFBTTtBQUNSLG1CQUFXO0FBQUEsTUFDYjtBQUNBLFVBQUlDLFFBQU87QUFDWCxNQUFBQSxNQUFLLE9BQU9EO0FBQ1osTUFBQUMsTUFBSyxPQUFPLElBQUksS0FBSztBQUFBLFFBQ25CLFdBQVc7QUFBQSxRQUNYLFFBQVE7QUFBQSxVQUNOLFNBQVMsU0FBUyxTQUFTLFVBQVU7QUFDbkMsbUJBQU8sYUFBYUEsTUFBSyxJQUFJLFNBQVMsVUFBVSxLQUFLO0FBQUEsVUFDdkQ7QUFBQSxVQUNBLFNBQVMsU0FBUyxTQUFTLFVBQVU7QUFDbkMsbUJBQU8sYUFBYUEsTUFBSyxJQUFJLFNBQVMsVUFBVSxJQUFJO0FBQUEsVUFDdEQ7QUFBQSxRQUNGO0FBQUEsTUFDRixDQUFDO0FBQ0QsTUFBQUEsTUFBSyxRQUFRO0FBQUEsSUFDZjtBQVVBLElBQUFGLE9BQU0sSUFBSSxVQUFVLFVBQVUsYUFBYSxTQUFTRyxVQUFTO0FBQzNELFVBQUcsS0FBSyxPQUFPO0FBQ2I7QUFBQSxNQUNGO0FBRUEsVUFBSSxNQUFNQSxTQUFRO0FBQ2xCLFVBQUk7QUFPSixVQUFHLE9BQU8sUUFBUSxhQUNmLElBQUksV0FBVyxNQUFNLElBQUksV0FBVyxNQUFNLElBQUksV0FBVyxLQUFLO0FBRS9ELGNBQU1ILE9BQU0sS0FBSyxhQUFhLEdBQUc7QUFBQSxNQUNuQyxXQUFVQSxPQUFNLEtBQUssUUFBUSxHQUFHLE1BQzdCLElBQUksV0FBVyxNQUFNLElBQUksV0FBVyxNQUFNLElBQUksV0FBVyxLQUFLO0FBRS9ELGNBQU07QUFDTixjQUFNQSxPQUFNLEtBQUssYUFBYTtBQUM5QixpQkFBUSxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQ2xDLGNBQUksUUFBUSxJQUFJLEVBQUU7QUFBQSxRQUNwQjtBQUFBLE1BQ0Y7QUFHQSxVQUFHLENBQUNBLE9BQU0sS0FBSyxRQUFRLEdBQUcsR0FBRztBQUMzQixjQUFNO0FBQ04sY0FBTSxDQUFDO0FBR1AsWUFBSSxNQUFNLElBQUksT0FBTztBQUNyQixZQUFHLFFBQVEsTUFBTSxRQUFRLE1BQU0sUUFBUSxJQUFJO0FBQ3pDLGdCQUFNLFFBQVE7QUFDZCxtQkFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUUsR0FBRztBQUMzQixnQkFBSSxLQUFLLElBQUksU0FBUyxDQUFDO0FBQUEsVUFDekI7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUdBLFVBQUcsQ0FBQ0EsT0FBTSxLQUFLLFFBQVEsR0FBRyxLQUN4QixFQUFFLElBQUksV0FBVyxLQUFLLElBQUksV0FBVyxLQUFLLElBQUksV0FBVyxJQUFJO0FBQzdELGNBQU0sSUFBSSxNQUFNLHdCQUF3QjtBQUFBLE1BQzFDO0FBR0EsVUFBSSxPQUFPLEtBQUssS0FBSztBQUNyQixVQUFJLFlBQWEsQ0FBQyxPQUFPLE9BQU8sT0FBTyxLQUFLLEVBQUUsUUFBUSxJQUFJLE1BQU07QUFHaEUsV0FBSyxLQUFLLFdBQVcsS0FBS0csU0FBUSxXQUFXLENBQUMsU0FBUztBQUN2RCxXQUFLLFFBQVE7QUFBQSxJQUNmO0FBVUEsSUFBQUgsT0FBTSxJQUFJLGFBQWEsU0FBUyxLQUFLSSxVQUFTO0FBQzVDLFVBQUcsQ0FBQyxNQUFNO0FBQ1IsbUJBQVc7QUFBQSxNQUNiO0FBQ0EsYUFBTyxXQUFXLEtBQUtBLFFBQU87QUFBQSxJQUNoQztBQVVBLElBQUFKLE9BQU0sSUFBSSxlQUFlO0FBSXpCLHNCQUFrQixXQUFXQSxPQUFNLE9BQU8sTUFBTSxHQUFHO0FBQ25ELHNCQUFrQixXQUFXQSxPQUFNLE9BQU8sTUFBTSxHQUFHO0FBQ25ELHNCQUFrQixXQUFXQSxPQUFNLE9BQU8sTUFBTSxHQUFHO0FBQ25ELHNCQUFrQixXQUFXQSxPQUFNLE9BQU8sTUFBTSxHQUFHO0FBQ25ELHNCQUFrQixXQUFXQSxPQUFNLE9BQU8sTUFBTSxHQUFHO0FBQ25ELHNCQUFrQixXQUFXQSxPQUFNLE9BQU8sTUFBTSxHQUFHO0FBRW5ELGFBQVMsa0JBQWtCQyxPQUFNLE1BQU07QUFDckMsVUFBSSxVQUFVLFdBQVc7QUFDdkIsZUFBTyxJQUFJRCxPQUFNLElBQUksVUFBVUMsT0FBTSxJQUFJO0FBQUEsTUFDM0M7QUFDQSxNQUFBRCxPQUFNLE9BQU8sa0JBQWtCQyxPQUFNLE9BQU87QUFBQSxJQUM5QztBQUlBLFFBQUksT0FBTztBQUNYLFFBQUksS0FBSztBQUNULFFBQUk7QUFDSixRQUFJO0FBQ0osUUFBSTtBQUNKLFFBQUk7QUFDSixRQUFJO0FBcUtKLGFBQVMsYUFBYTtBQUNwQixhQUFPO0FBZVAsYUFBTyxDQUFDLEdBQU0sR0FBTSxHQUFNLEdBQU0sR0FBTSxJQUFNLElBQU0sSUFBTSxLQUFNLElBQU0sRUFBSTtBQUd4RSxVQUFJLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFDekIsZUFBUSxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUUsR0FBRztBQUMzQixjQUFNLEtBQUssS0FBSztBQUNoQixjQUFNLElBQUksT0FBUSxJQUFJLE9BQVEsSUFBSTtBQUFBLE1BQ3BDO0FBR0EsYUFBTyxJQUFJLE1BQU0sR0FBRztBQUNwQixjQUFRLElBQUksTUFBTSxHQUFHO0FBQ3JCLFlBQU0sSUFBSSxNQUFNLENBQUM7QUFDakIsYUFBTyxJQUFJLE1BQU0sQ0FBQztBQUNsQixlQUFRLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3pCLFlBQUksS0FBSyxJQUFJLE1BQU0sR0FBRztBQUN0QixhQUFLLEtBQUssSUFBSSxNQUFNLEdBQUc7QUFBQSxNQUN6QjtBQUNBLFVBQUksSUFBSSxHQUFHLEtBQUssR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSTtBQUM1QyxlQUFRLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBNkQzQixhQUFLLEtBQU0sTUFBTSxJQUFNLE1BQU0sSUFBTSxNQUFNLElBQU0sTUFBTTtBQUNyRCxhQUFNLE1BQU0sSUFBTSxLQUFLLE1BQU87QUFHOUIsYUFBSyxLQUFLO0FBQ1YsY0FBTSxNQUFNO0FBZ0VaLGNBQU0sTUFBTTtBQUNaLGFBQUssTUFBTTtBQUNYLGFBQUssTUFBTTtBQUNYLGFBQUssTUFBTTtBQUNYLGFBQ0csT0FBTyxLQUNQLE1BQU0sS0FDTixNQUFNLEtBQ04sS0FBSztBQUNSLGVBQ0csS0FBSyxLQUFLLE9BQU8sTUFDakIsSUFBSSxPQUFPLE1BQ1gsSUFBSSxLQUFLLE9BQU8sS0FDaEIsSUFBSSxLQUFLO0FBRVosaUJBQVEsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDekIsY0FBSSxHQUFHLEtBQUs7QUFDWixlQUFLLEdBQUcsTUFBTTtBQUdkLGVBQUssTUFBTSxLQUFLLE9BQU87QUFDdkIsZ0JBQU0sT0FBTyxLQUFLLFFBQVE7QUFBQSxRQUM1QjtBQUdBLFlBQUcsTUFBTSxHQUFHO0FBRVYsY0FBSSxLQUFLO0FBQUEsUUFDWCxPQUFPO0FBR0wsY0FBSSxLQUFLLE1BQU0sTUFBTSxNQUFNLEtBQUs7QUFDaEMsZ0JBQU0sTUFBTSxNQUFNO0FBQUEsUUFDcEI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQTBCQSxhQUFTLFdBQVcsS0FBS0csVUFBUztBQUVoQyxVQUFJLElBQUksSUFBSSxNQUFNLENBQUM7QUFhbkIsVUFBSSxNQUFNLE1BQU07QUFDaEIsVUFBSSxLQUFLLEVBQUU7QUFDWCxVQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLFVBQUksTUFBTSxLQUFLO0FBQ2YsZUFBUSxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUUsR0FBRztBQUM1QixlQUFPLEVBQUUsSUFBSTtBQUNiLFlBQUcsSUFBSSxPQUFPLEdBQUc7QUFFZixpQkFDRSxLQUFLLFNBQVMsS0FBSyxRQUFRLEtBQzNCLEtBQUssU0FBUyxJQUFJLFFBQVEsS0FDMUIsS0FBSyxPQUFPLFFBQVEsSUFDcEIsS0FBSyxTQUFTLE1BQU8sS0FBSyxRQUFRO0FBQ3BDO0FBQUEsUUFDRixXQUFVLEtBQUssS0FBTSxJQUFJLE9BQU8sR0FBSTtBQUVsQyxpQkFDRSxLQUFLLFNBQVMsT0FBTyxLQUNyQixLQUFLLFNBQVMsS0FBSyxRQUFRLEtBQzNCLEtBQUssU0FBUyxJQUFJLFFBQVEsSUFDMUIsS0FBSyxPQUFPO0FBQUEsUUFDaEI7QUFDQSxVQUFFLEtBQUssRUFBRSxJQUFJLE1BQU07QUFBQSxNQUNyQjtBQWlEQSxVQUFHQSxVQUFTO0FBQ1YsWUFBSTtBQUNKLFlBQUksS0FBSyxLQUFLO0FBQ2QsWUFBSSxLQUFLLEtBQUs7QUFDZCxZQUFJLEtBQUssS0FBSztBQUNkLFlBQUksS0FBSyxLQUFLO0FBQ2QsWUFBSSxPQUFPLEVBQUUsTUFBTSxDQUFDO0FBQ3BCLGNBQU0sRUFBRTtBQUNSLGlCQUFRLElBQUksR0FBRyxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUl4RCxjQUFHLE1BQU0sS0FBSyxNQUFPLE1BQU0sSUFBSztBQUM5QixpQkFBSyxLQUFLLEVBQUU7QUFDWixpQkFBSyxJQUFJLEtBQUssRUFBRSxLQUFLO0FBQ3JCLGlCQUFLLElBQUksS0FBSyxFQUFFLEtBQUs7QUFDckIsaUJBQUssSUFBSSxLQUFLLEVBQUUsS0FBSztBQUFBLFVBQ3ZCLE9BQU87QUFLTCxxQkFBUSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUMxQixvQkFBTSxFQUFFLEtBQUs7QUFDYixtQkFBSyxLQUFLLElBQUUsQ0FBQyxNQUNYLEdBQUcsS0FBSyxRQUFRLE9BQ2hCLEdBQUcsS0FBSyxRQUFRLEtBQUssUUFDckIsR0FBRyxLQUFLLFFBQVEsSUFBSSxRQUNwQixHQUFHLEtBQUssTUFBTTtBQUFBLFlBQ2xCO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxZQUFJO0FBQUEsTUFDTjtBQUVBLGFBQU87QUFBQSxJQUNUO0FBV0EsYUFBUyxhQUFhLEdBQUcsT0FBTyxRQUFRQSxVQUFTO0FBdUMvQyxVQUFJLEtBQUssRUFBRSxTQUFTLElBQUk7QUFDeEIsVUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQ3BCLFVBQUdBLFVBQVM7QUFDVixhQUFLLEtBQUs7QUFDVixhQUFLLEtBQUs7QUFDVixhQUFLLEtBQUs7QUFDVixhQUFLLEtBQUs7QUFDVixjQUFNO0FBQUEsTUFDUixPQUFPO0FBQ0wsYUFBSyxJQUFJO0FBQ1QsYUFBSyxJQUFJO0FBQ1QsYUFBSyxJQUFJO0FBQ1QsYUFBSyxJQUFJO0FBQ1QsY0FBTTtBQUFBLE1BQ1I7QUFDQSxVQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxJQUFJO0FBQ3hCLFVBQUksTUFBTSxLQUFLLEVBQUU7QUFDakIsVUFBSSxNQUFNQSxXQUFVLElBQUksS0FBSyxFQUFFO0FBQy9CLFVBQUksTUFBTSxLQUFLLEVBQUU7QUFDakIsVUFBSSxNQUFNQSxXQUFVLElBQUksS0FBSyxFQUFFO0FBQy9CLFVBQUksSUFBSTtBQVFSLGVBQVEsUUFBUSxHQUFHLFFBQVEsSUFBSSxFQUFFLE9BQU87QUFvSHRDLGFBQ0UsR0FBRyxNQUFNLE1BQ1QsR0FBRyxNQUFNLEtBQUssT0FDZCxHQUFHLE1BQU0sSUFBSSxPQUNiLEdBQUcsSUFBSSxPQUFPLEVBQUUsRUFBRTtBQUNwQixhQUNFLEdBQUcsTUFBTSxNQUNULEdBQUcsTUFBTSxLQUFLLE9BQ2QsR0FBRyxNQUFNLElBQUksT0FDYixHQUFHLElBQUksT0FBTyxFQUFFLEVBQUU7QUFDcEIsYUFDRSxHQUFHLE1BQU0sTUFDVCxHQUFHLE1BQU0sS0FBSyxPQUNkLEdBQUcsTUFBTSxJQUFJLE9BQ2IsR0FBRyxJQUFJLE9BQU8sRUFBRSxFQUFFO0FBQ3BCLFlBQ0UsR0FBRyxNQUFNLE1BQ1QsR0FBRyxNQUFNLEtBQUssT0FDZCxHQUFHLE1BQU0sSUFBSSxPQUNiLEdBQUcsSUFBSSxPQUFPLEVBQUUsRUFBRTtBQUNwQixZQUFJO0FBQ0osWUFBSTtBQUNKLFlBQUk7QUFBQSxNQUNOO0FBY0EsYUFBTyxLQUNKLElBQUksTUFBTSxPQUFPLEtBQ2pCLElBQUksTUFBTSxLQUFLLFFBQVEsS0FDdkIsSUFBSSxNQUFNLElBQUksUUFBUSxJQUN0QixJQUFJLElBQUksT0FBUSxFQUFFLEVBQUU7QUFDdkIsYUFBT0EsV0FBVSxJQUFJLEtBQ2xCLElBQUksTUFBTSxPQUFPLEtBQ2pCLElBQUksTUFBTSxLQUFLLFFBQVEsS0FDdkIsSUFBSSxNQUFNLElBQUksUUFBUSxJQUN0QixJQUFJLElBQUksT0FBUSxFQUFFLEVBQUU7QUFDdkIsYUFBTyxLQUNKLElBQUksTUFBTSxPQUFPLEtBQ2pCLElBQUksTUFBTSxLQUFLLFFBQVEsS0FDdkIsSUFBSSxNQUFNLElBQUksUUFBUSxJQUN0QixJQUFJLElBQUksT0FBUSxFQUFFLEVBQUU7QUFDdkIsYUFBT0EsV0FBVSxJQUFJLEtBQ2xCLElBQUksTUFBTSxPQUFPLEtBQ2pCLElBQUksTUFBTSxLQUFLLFFBQVEsS0FDdkIsSUFBSSxNQUFNLElBQUksUUFBUSxJQUN0QixJQUFJLElBQUksT0FBUSxFQUFFLEVBQUU7QUFBQSxJQUN6QjtBQXNCQSxhQUFTLGNBQWNELFVBQVM7QUFDOUIsTUFBQUEsV0FBVUEsWUFBVyxDQUFDO0FBQ3RCLFVBQUksUUFBUUEsU0FBUSxRQUFRLE9BQU8sWUFBWTtBQUMvQyxVQUFJLFlBQVksU0FBUztBQUV6QixVQUFJO0FBQ0osVUFBR0EsU0FBUSxTQUFTO0FBQ2xCLGlCQUFTSCxPQUFNLE9BQU8sZUFBZSxXQUFXRyxTQUFRLEdBQUc7QUFBQSxNQUM3RCxPQUFPO0FBQ0wsaUJBQVNILE9BQU0sT0FBTyxhQUFhLFdBQVdHLFNBQVEsR0FBRztBQUFBLE1BQzNEO0FBR0EsVUFBSSxRQUFRLE9BQU87QUFDbkIsYUFBTyxRQUFRLFNBQVMsSUFBSUEsVUFBUztBQUVuQyxZQUFJLFNBQVM7QUFDYixZQUFHQSxvQkFBbUJILE9BQU0sS0FBSyxZQUFZO0FBQzNDLG1CQUFTRztBQUNULFVBQUFBLFdBQVUsQ0FBQztBQUFBLFFBQ2I7QUFDQSxRQUFBQSxXQUFVQSxZQUFXLENBQUM7QUFDdEIsUUFBQUEsU0FBUSxTQUFTO0FBQ2pCLFFBQUFBLFNBQVEsS0FBSztBQUNiLGNBQU0sS0FBSyxRQUFRQSxRQUFPO0FBQUEsTUFDNUI7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQUFBO0FBQUE7OztBQ2xrQ0E7QUFBQSx1Q0FBQUUsVUFBQUMsU0FBQTtBQStCQSxRQUFJQyxTQUFRO0FBQ1o7QUFDQTtBQUNBO0FBR0EsSUFBQUQsUUFBTyxVQUFVQyxPQUFNLE1BQU1BLE9BQU0sT0FBTyxDQUFDO0FBc0IzQyxJQUFBQSxPQUFNLElBQUksa0JBQWtCLFNBQVMsS0FBSyxJQUFJLFFBQVEsTUFBTTtBQUMxRCxVQUFJLFNBQVMsY0FBYztBQUFBLFFBQ3pCO0FBQUEsUUFDQTtBQUFBLFFBQ0EsU0FBUztBQUFBLFFBQ1QsTUFBTSxTQUFTLE9BQU8sT0FBTyxRQUFRO0FBQUEsTUFDdkMsQ0FBQztBQUNELGFBQU8sTUFBTSxFQUFFO0FBQ2YsYUFBTztBQUFBLElBQ1Q7QUFnQkEsSUFBQUEsT0FBTSxJQUFJLHlCQUF5QixTQUFTLEtBQUssTUFBTTtBQUNyRCxhQUFPLGNBQWM7QUFBQSxRQUNuQjtBQUFBLFFBQ0EsUUFBUTtBQUFBLFFBQ1IsU0FBUztBQUFBLFFBQ1Q7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBc0JBLElBQUFBLE9BQU0sSUFBSSxrQkFBa0IsU0FBUyxLQUFLLElBQUksUUFBUSxNQUFNO0FBQzFELFVBQUksU0FBUyxjQUFjO0FBQUEsUUFDekI7QUFBQSxRQUNBO0FBQUEsUUFDQSxTQUFTO0FBQUEsUUFDVCxNQUFNLFNBQVMsT0FBTyxPQUFPLFFBQVE7QUFBQSxNQUN2QyxDQUFDO0FBQ0QsYUFBTyxNQUFNLEVBQUU7QUFDZixhQUFPO0FBQUEsSUFDVDtBQWdCQSxJQUFBQSxPQUFNLElBQUkseUJBQXlCLFNBQVMsS0FBSyxNQUFNO0FBQ3JELGFBQU8sY0FBYztBQUFBLFFBQ25CO0FBQUEsUUFDQSxRQUFRO0FBQUEsUUFDUixTQUFTO0FBQUEsUUFDVDtBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0g7QUFVQSxJQUFBQSxPQUFNLElBQUksWUFBWSxTQUFTQyxPQUFNLE1BQU07QUFDekMsVUFBSUMsUUFBTztBQUNYLE1BQUFBLE1BQUssT0FBT0Q7QUFDWixNQUFBQyxNQUFLLE9BQU8sSUFBSSxLQUFLO0FBQUEsUUFDbkIsV0FBVztBQUFBLFFBQ1gsUUFBUTtBQUFBLFVBQ04sU0FBUyxTQUFTLFNBQVMsVUFBVTtBQUNuQyxtQkFBTyxhQUFhQSxNQUFLLE9BQU8sU0FBUyxVQUFVLEtBQUs7QUFBQSxVQUMxRDtBQUFBLFVBQ0EsU0FBUyxTQUFTLFNBQVMsVUFBVTtBQUNuQyxtQkFBTyxhQUFhQSxNQUFLLE9BQU8sU0FBUyxVQUFVLElBQUk7QUFBQSxVQUN6RDtBQUFBLFFBQ0Y7QUFBQSxNQUNGLENBQUM7QUFDRCxNQUFBQSxNQUFLLFFBQVE7QUFBQSxJQUNmO0FBVUEsSUFBQUYsT0FBTSxJQUFJLFVBQVUsVUFBVSxhQUFhLFNBQVNHLFVBQVM7QUFDM0QsVUFBRyxLQUFLLE9BQU87QUFDYjtBQUFBLE1BQ0Y7QUFFQSxVQUFJLE1BQU1ILE9BQU0sS0FBSyxhQUFhRyxTQUFRLEdBQUc7QUFDN0MsVUFBRyxLQUFLLEtBQUssUUFBUSxNQUFNLE1BQU0sR0FBRztBQUNsQyxZQUFHLElBQUksT0FBTyxNQUFNLElBQUk7QUFDdEIsZ0JBQU0sSUFBSSxNQUFNLGtDQUFrQyxJQUFJLE9BQU8sSUFBSSxDQUFDO0FBQUEsUUFDcEU7QUFBQSxNQUNGO0FBR0EsV0FBSyxRQUFRLFlBQVksR0FBRztBQUM1QixXQUFLLFFBQVE7QUFBQSxJQUNmO0FBSUEsc0JBQWtCLFdBQVdILE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFDbkQsc0JBQWtCLFdBQVdBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFDbkQsc0JBQWtCLFdBQVdBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFDbkQsc0JBQWtCLFdBQVdBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFDbkQsc0JBQWtCLFdBQVdBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFFbkQsc0JBQWtCLFlBQVlBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFDcEQsc0JBQWtCLFlBQVlBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFDcEQsc0JBQWtCLFlBQVlBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFDcEQsc0JBQWtCLFlBQVlBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFDcEQsc0JBQWtCLFlBQVlBLE9BQU0sT0FBTyxNQUFNLEdBQUc7QUFFcEQsYUFBUyxrQkFBa0JDLE9BQU0sTUFBTTtBQUNyQyxVQUFJLFVBQVUsV0FBVztBQUN2QixlQUFPLElBQUlELE9BQU0sSUFBSSxVQUFVQyxPQUFNLElBQUk7QUFBQSxNQUMzQztBQUNBLE1BQUFELE9BQU0sT0FBTyxrQkFBa0JDLE9BQU0sT0FBTztBQUFBLElBQzlDO0FBSUEsUUFBSSxjQUFjLENBQUMsVUFBVSxHQUFFLE9BQVEsVUFBVSxVQUFVLE9BQVEsR0FBSSxPQUFRLE1BQU0sVUFBVSxVQUFVLE1BQU0sVUFBVSxVQUFVLFVBQVUsR0FBSSxNQUFNLFVBQVUsVUFBVSxPQUFRLE9BQVEsVUFBVSxVQUFVLFVBQVUsT0FBUSxVQUFVLFVBQVUsT0FBUSxHQUFFLE1BQU0sT0FBUSxVQUFVLE9BQVEsVUFBVSxHQUFJLFVBQVUsVUFBVSxVQUFVLFVBQVUsTUFBTSxVQUFVLE9BQVEsT0FBUSxVQUFVLE1BQU0sR0FBSSxVQUFVLE9BQVEsVUFBVSxPQUFRLFVBQVUsVUFBVSxVQUFVLE1BQU0sT0FBUSxVQUFVLE1BQU0sVUFBVSxVQUFVLEdBQUUsT0FBUSxPQUFRLEdBQUUsUUFBUztBQUMxaEIsUUFBSSxjQUFjLENBQUMsYUFBWSxhQUFZLE9BQU8sU0FBUyxTQUFTLElBQUssYUFBWSxhQUFZLGFBQVksYUFBWSxhQUFZLGFBQVksYUFBWSxTQUFTLElBQUssYUFBWSxTQUFTLFNBQVMsYUFBWSxHQUFFLGFBQVksT0FBTyxTQUFTLGFBQVksU0FBUyxhQUFZLEdBQUUsU0FBUyxPQUFPLGFBQVksYUFBWSxPQUFPLEdBQUUsU0FBUyxhQUFZLFNBQVMsYUFBWSxhQUFZLGFBQVksT0FBTyxhQUFZLGFBQVksSUFBSyxhQUFZLFNBQVMsSUFBSyxPQUFPLGFBQVksT0FBTyxhQUFZLFNBQVMsYUFBWSxTQUFTLGFBQVksYUFBWSxTQUFTLFNBQVMsR0FBRSxhQUFZLE9BQU8sYUFBWSxhQUFZLGFBQVksT0FBUTtBQUN0bkIsUUFBSSxjQUFjLENBQUMsS0FBTSxXQUFVLEdBQUUsV0FBVSxXQUFVLEdBQUUsUUFBUSxXQUFVLFFBQVEsV0FBVSxXQUFVLFFBQVEsV0FBVSxRQUFRLFdBQVUsS0FBTSxXQUFVLEdBQUksV0FBVSxLQUFNLFFBQVEsV0FBVSxXQUFVLFFBQVEsV0FBVSxRQUFRLFFBQVEsV0FBVSxHQUFJLFdBQVUsS0FBTSxXQUFVLFdBQVUsV0FBVSxRQUFRLEtBQU0sUUFBUSxXQUFVLFdBQVUsR0FBRSxLQUFNLFFBQVEsV0FBVSxXQUFVLFdBQVUsS0FBTSxHQUFFLFdBQVUsV0FBVSxRQUFRLFdBQVUsV0FBVSxHQUFJLFFBQVEsUUFBUSxXQUFVLFdBQVUsV0FBVSxLQUFNLFdBQVUsUUFBUSxHQUFJLFdBQVUsTUFBTztBQUMxaEIsUUFBSSxjQUFjLENBQUMsU0FBUyxNQUFPLE1BQU8sS0FBSyxTQUFTLFNBQVMsU0FBUyxNQUFPLEdBQUUsU0FBUyxTQUFTLFNBQVMsS0FBSyxHQUFFLFNBQVMsU0FBUyxHQUFJLE1BQU8sU0FBUyxTQUFTLEtBQUssU0FBUyxNQUFPLE1BQU8sU0FBUyxHQUFJLE1BQU8sU0FBUyxNQUFPLFNBQVMsU0FBUyxLQUFLLFNBQVMsU0FBUyxTQUFTLFNBQVMsS0FBSyxHQUFFLEdBQUUsU0FBUyxNQUFPLFNBQVMsU0FBUyxHQUFJLFNBQVMsTUFBTyxNQUFPLEtBQUssU0FBUyxLQUFLLEdBQUksTUFBTyxTQUFTLE1BQU8sU0FBUyxTQUFTLE1BQU8sTUFBTyxTQUFTLFNBQVMsS0FBSyxTQUFTLE1BQU8sT0FBUTtBQUNsZSxRQUFJLGNBQWMsQ0FBQyxLQUFNLFVBQVUsVUFBVSxZQUFXLFFBQVEsS0FBTSxZQUFXLFVBQVUsWUFBVyxRQUFRLFVBQVUsWUFBVyxZQUFXLFlBQVcsUUFBUSxZQUFXLFVBQVUsWUFBVyxZQUFXLEdBQUUsWUFBVyxZQUFXLFlBQVcsVUFBVSxZQUFXLFlBQVcsR0FBRSxZQUFXLFVBQVUsVUFBVSxZQUFXLFFBQVEsUUFBUSxZQUFXLEtBQU0sVUFBVSxZQUFXLFVBQVUsWUFBVyxZQUFXLFVBQVUsWUFBVyxZQUFXLFVBQVUsWUFBVyxLQUFNLFVBQVUsWUFBVyxZQUFXLFFBQVEsWUFBVyxZQUFXLFVBQVUsR0FBRSxZQUFXLFlBQVcsUUFBUSxVQUFVLFlBQVcsUUFBUSxHQUFFLFlBQVcsVUFBVSxVQUFVO0FBQ2xuQixRQUFJLGNBQWMsQ0FBQyxXQUFXLFdBQVcsT0FBTyxXQUFXLFdBQVcsSUFBSyxXQUFXLFNBQVMsV0FBVyxTQUFTLFNBQVMsV0FBVyxTQUFTLFdBQVcsV0FBVyxPQUFPLEdBQUUsU0FBUyxXQUFXLE9BQU8sU0FBUyxXQUFXLElBQUssV0FBVyxXQUFXLEdBQUUsU0FBUyxXQUFXLE9BQU8sU0FBUyxXQUFXLFdBQVcsV0FBVyxJQUFLLFdBQVcsU0FBUyxXQUFXLFNBQVMsT0FBTyxXQUFXLFNBQVMsV0FBVyxXQUFXLE9BQU8sV0FBVyxXQUFXLFNBQVMsV0FBVyxTQUFTLFdBQVcsR0FBRSxXQUFXLElBQUssT0FBTyxXQUFXLFNBQVMsT0FBTyxTQUFTLFdBQVcsR0FBRSxXQUFXLFdBQVcsU0FBUyxTQUFVO0FBQ3RsQixRQUFJLGNBQWMsQ0FBQyxTQUFTLFVBQVUsVUFBVSxHQUFFLE1BQU0sVUFBVSxTQUFTLFVBQVUsVUFBVSxTQUFTLEdBQUUsVUFBVSxHQUFJLFVBQVUsVUFBVSxNQUFNLFVBQVUsU0FBUyxTQUFTLFVBQVUsVUFBVSxVQUFVLFVBQVUsU0FBUyxVQUFVLE1BQU0sTUFBTSxVQUFVLFNBQVMsR0FBSSxVQUFVLFNBQVMsVUFBVSxTQUFTLFNBQVMsVUFBVSxVQUFVLFVBQVUsVUFBVSxHQUFJLFNBQVMsVUFBVSxVQUFVLFNBQVMsVUFBVSxNQUFNLFNBQVMsVUFBVSxNQUFNLFVBQVUsVUFBVSxVQUFVLFNBQVMsR0FBRSxHQUFJLFVBQVUsR0FBRSxTQUFTLFVBQVUsTUFBTSxVQUFVLFVBQVUsTUFBTSxPQUFRO0FBQzFpQixRQUFJLGNBQWMsQ0FBQyxXQUFXLE1BQU8sUUFBUSxXQUFXLFdBQVcsV0FBVyxJQUFLLFdBQVcsUUFBUSxXQUFXLFdBQVcsUUFBUSxXQUFXLFFBQVEsTUFBTyxJQUFLLFdBQVcsV0FBVyxXQUFXLE1BQU8sUUFBUSxRQUFRLFdBQVcsV0FBVyxNQUFPLEdBQUUsR0FBRSxXQUFXLFdBQVcsV0FBVyxRQUFRLFFBQVEsUUFBUSxRQUFRLFdBQVcsTUFBTyxJQUFLLFdBQVcsTUFBTyxRQUFRLFdBQVcsSUFBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFFBQVEsV0FBVyxHQUFFLFdBQVcsUUFBUSxXQUFXLFdBQVcsV0FBVyxXQUFXLEdBQUUsV0FBVyxRQUFRLFFBQVEsTUFBTyxNQUFPLFFBQVEsV0FBVyxTQUFVO0FBU3RrQixhQUFTLFlBQVksS0FBSztBQUN4QixVQUFJLFlBQWEsQ0FBQyxHQUFFLEdBQUksV0FBVyxXQUFXLE9BQVEsT0FBUSxXQUFXLFdBQVcsS0FBTSxLQUFNLFdBQVcsV0FBVyxPQUFRLE9BQVEsV0FBVyxTQUFVLEdBQ3ZKLFlBQWEsQ0FBQyxHQUFFLEdBQUksU0FBUyxTQUFTLFVBQVUsVUFBVSxVQUFVLFVBQVUsS0FBTSxLQUFNLFNBQVMsU0FBUyxVQUFVLFVBQVUsVUFBVSxRQUFTLEdBQ25KLFlBQWEsQ0FBQyxHQUFFLEdBQUksTUFBTSxNQUFNLFVBQVUsVUFBVSxVQUFVLFVBQVUsR0FBRSxHQUFJLE1BQU0sTUFBTSxVQUFVLFVBQVUsVUFBVSxRQUFTLEdBQ2pJLFlBQWEsQ0FBQyxHQUFFLFNBQVMsV0FBVSxXQUFVLE1BQU8sU0FBUyxXQUFVLFdBQVUsUUFBUSxTQUFTLFdBQVUsV0FBVSxRQUFRLFNBQVMsV0FBVSxTQUFTLEdBQzFKLFlBQWEsQ0FBQyxHQUFFLFFBQVEsSUFBSyxRQUFRLEdBQUUsUUFBUSxJQUFLLFFBQVEsTUFBTyxRQUFRLE1BQU8sUUFBUSxNQUFPLFFBQVEsTUFBTyxNQUFPLEdBQ3ZILFlBQWEsQ0FBQyxHQUFFLE1BQU0sSUFBSyxNQUFNLEdBQUUsTUFBTSxJQUFLLE1BQU0sVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxRQUFTLEdBQ25JLFlBQWEsQ0FBQyxHQUFFLFdBQVcsUUFBUSxXQUFXLEdBQUksV0FBVyxRQUFRLFdBQVcsR0FBRSxXQUFXLFFBQVEsV0FBVyxHQUFJLFdBQVcsUUFBUSxTQUFVLEdBQ2pKLFlBQWEsQ0FBQyxHQUFFLE9BQVEsTUFBTSxPQUFRLFdBQVcsV0FBVyxXQUFXLFdBQVcsUUFBUSxRQUFRLFFBQVEsUUFBUSxXQUFXLFdBQVcsV0FBVyxTQUFVLEdBQzdKLFlBQWEsQ0FBQyxHQUFFLFFBQVEsR0FBRSxRQUFRLEdBQUksUUFBUSxHQUFJLFFBQVEsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxRQUFTLEdBQ3pJLFlBQWEsQ0FBQyxHQUFFLFdBQVcsR0FBSSxXQUFXLEdBQUUsV0FBVyxHQUFJLFdBQVcsTUFBTSxXQUFXLE1BQU0sV0FBVyxNQUFNLFdBQVcsTUFBTSxTQUFVLEdBQ3pJLGFBQWEsQ0FBQyxHQUFFLElBQUssR0FBRSxJQUFLLFNBQVMsU0FBUyxTQUFTLFNBQVMsTUFBTyxNQUFPLE1BQU8sTUFBTyxTQUFTLFNBQVMsU0FBUyxPQUFRLEdBQy9ILGFBQWEsQ0FBQyxHQUFFLFVBQVUsS0FBTSxVQUFVLFNBQVMsVUFBVSxTQUFTLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxRQUFTLEdBQy9KLGFBQWEsQ0FBQyxHQUFFLE1BQU8sV0FBVSxXQUFVLFFBQVEsUUFBUSxXQUFVLFdBQVUsSUFBSyxNQUFPLFdBQVUsV0FBVSxRQUFRLFFBQVEsV0FBVSxTQUFTLEdBQ2xKLGFBQWEsQ0FBQyxHQUFFLEdBQUksS0FBTSxLQUFNLEdBQUUsR0FBSSxLQUFNLEtBQU0sR0FBSSxHQUFJLEtBQU0sS0FBTSxHQUFJLEdBQUksS0FBTSxHQUFLO0FBSTdGLFVBQUksYUFBYSxJQUFJLE9BQU8sSUFBSSxJQUFJLElBQUk7QUFHeEMsVUFBSSxPQUFPLENBQUM7QUFHWixVQUFJLFNBQVMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBRTVELFVBQUksSUFBSSxHQUFHO0FBQ1gsZUFBUSxJQUFJLEdBQUcsSUFBSSxZQUFZLEtBQUs7QUFDbEMsWUFBSSxPQUFPLElBQUksU0FBUztBQUN4QixZQUFJLFFBQVEsSUFBSSxTQUFTO0FBRXpCLGVBQVEsU0FBUyxJQUFLLFNBQVM7QUFDL0IsaUJBQVM7QUFDVCxnQkFBUyxPQUFPO0FBRWhCLGVBQVEsVUFBVSxNQUFPLFFBQVE7QUFDakMsZ0JBQVE7QUFDUixpQkFBVSxPQUFPO0FBRWpCLGVBQVEsU0FBUyxJQUFLLFNBQVM7QUFDL0IsaUJBQVM7QUFDVCxnQkFBUyxPQUFPO0FBRWhCLGVBQVEsVUFBVSxNQUFPLFFBQVE7QUFDakMsZ0JBQVE7QUFDUixpQkFBVSxPQUFPO0FBRWpCLGVBQVEsU0FBUyxJQUFLLFNBQVM7QUFDL0IsaUJBQVM7QUFDVCxnQkFBUyxPQUFPO0FBRWhCLGVBQVEsVUFBVSxJQUFLLFFBQVE7QUFDL0IsZ0JBQVE7QUFDUixpQkFBVSxPQUFPO0FBRWpCLGVBQVEsU0FBUyxJQUFLLFNBQVM7QUFDL0IsaUJBQVM7QUFDVCxnQkFBUyxPQUFPO0FBR2hCLGNBQU8sUUFBUSxJQUFPLFVBQVUsS0FBTTtBQUd0QyxlQUFTLFNBQVMsS0FBUSxTQUFTLElBQUssV0FDcEMsVUFBVSxJQUFLLFFBQVksVUFBVSxLQUFNO0FBQy9DLGdCQUFRO0FBR1IsaUJBQVEsSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEVBQUUsR0FBRztBQUVyQyxjQUFHLE9BQU8sSUFBSTtBQUNaLG1CQUFRLFFBQVEsSUFBTSxTQUFTO0FBQy9CLG9CQUFTLFNBQVMsSUFBTSxVQUFVO0FBQUEsVUFDcEMsT0FBTztBQUNMLG1CQUFRLFFBQVEsSUFBTSxTQUFTO0FBQy9CLG9CQUFTLFNBQVMsSUFBTSxVQUFVO0FBQUEsVUFDcEM7QUFDQSxrQkFBUTtBQUNSLG1CQUFTO0FBT1QsY0FBSSxVQUNGLFVBQVUsU0FBUyxNQUFNLFVBQVcsU0FBUyxLQUFNLE1BQ25ELFVBQVcsU0FBUyxLQUFNLE1BQU8sVUFBVyxTQUFTLEtBQU0sTUFDM0QsVUFBVyxTQUFTLEtBQU0sTUFBTyxVQUFXLFNBQVMsSUFBSyxNQUMxRCxVQUFXLFNBQVMsSUFBSztBQUMzQixjQUFJLFdBQ0YsVUFBVSxVQUFVLE1BQU0sVUFBVyxVQUFVLEtBQU0sTUFDckQsVUFBVyxVQUFVLEtBQU0sTUFBTyxXQUFZLFVBQVUsS0FBTSxNQUM5RCxXQUFZLFVBQVUsS0FBTSxNQUFPLFdBQVksVUFBVSxJQUFLLE1BQzlELFdBQVksVUFBVSxJQUFLO0FBQzdCLGlCQUFRLGFBQWEsS0FBTSxXQUFXO0FBQ3RDLGVBQUssT0FBTyxVQUFVO0FBQ3RCLGVBQUssT0FBTyxXQUFZLE9BQU87QUFBQSxRQUNqQztBQUFBLE1BQ0Y7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQVdBLGFBQVMsYUFBYSxNQUFNLE9BQU8sUUFBUUcsVUFBUztBQUVsRCxVQUFJLGFBQWEsS0FBSyxXQUFXLEtBQUssSUFBSTtBQUMxQyxVQUFJO0FBQ0osVUFBRyxlQUFlLEdBQUc7QUFDbkIsa0JBQVVBLFdBQVUsQ0FBQyxJQUFJLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7QUFBQSxNQUM5QyxPQUFPO0FBQ0wsa0JBQVdBLFdBQ1QsQ0FBQyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxJQUNsQyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDO0FBQUEsTUFDcEM7QUFFQSxVQUFJO0FBRUosVUFBSSxPQUFPLE1BQU07QUFDakIsVUFBSSxRQUFRLE1BQU07QUFHbEIsYUFBUSxTQUFTLElBQUssU0FBUztBQUMvQixlQUFTO0FBQ1QsY0FBUyxPQUFPO0FBRWhCLGFBQVEsU0FBUyxLQUFNLFNBQVM7QUFDaEMsZUFBUztBQUNULGNBQVMsT0FBTztBQUVoQixhQUFRLFVBQVUsSUFBSyxRQUFRO0FBQy9CLGNBQVE7QUFDUixlQUFVLE9BQU87QUFFakIsYUFBUSxVQUFVLElBQUssUUFBUTtBQUMvQixjQUFRO0FBQ1IsZUFBVSxPQUFPO0FBRWpCLGFBQVEsU0FBUyxJQUFLLFNBQVM7QUFDL0IsZUFBUztBQUNULGNBQVMsT0FBTztBQUdoQixhQUFTLFFBQVEsSUFBTSxTQUFTO0FBQ2hDLGNBQVUsU0FBUyxJQUFNLFVBQVU7QUFFbkMsZUFBUSxJQUFJLEdBQUcsSUFBSSxZQUFZLEtBQUssR0FBRztBQUNyQyxZQUFJLFVBQVUsUUFBUSxJQUFJO0FBQzFCLFlBQUksVUFBVSxRQUFRLElBQUk7QUFHMUIsaUJBQVEsSUFBSSxRQUFRLElBQUksS0FBSyxTQUFTLEtBQUssU0FBUztBQUNsRCxjQUFJLFNBQVMsUUFBUSxLQUFLO0FBQzFCLGNBQUksVUFBVyxVQUFVLElBQU0sU0FBUyxNQUFPLEtBQUssSUFBSTtBQUd4RCxnQkFBTTtBQUNOLGlCQUFPO0FBQ1Asa0JBQVEsT0FDTixZQUFhLFdBQVcsS0FBTSxNQUM5QixZQUFhLFdBQVcsS0FBTSxNQUM5QixZQUFhLFdBQVksSUFBSyxNQUM5QixZQUFZLFNBQVMsTUFDckIsWUFBYSxXQUFXLEtBQU0sTUFDOUIsWUFBYSxXQUFXLEtBQU0sTUFDOUIsWUFBYSxXQUFZLElBQUssTUFDOUIsWUFBWSxTQUFTO0FBQUEsUUFDekI7QUFFQSxjQUFNO0FBQ04sZUFBTztBQUNQLGdCQUFRO0FBQUEsTUFDVjtBQUdBLGFBQVMsU0FBUyxJQUFNLFFBQVE7QUFDaEMsY0FBVSxVQUFVLElBQU0sU0FBUztBQUduQyxhQUFRLFNBQVMsSUFBSyxTQUFTO0FBQy9CLGVBQVM7QUFDVCxjQUFTLE9BQU87QUFFaEIsYUFBUSxVQUFVLElBQUssUUFBUTtBQUMvQixjQUFRO0FBQ1IsZUFBVSxPQUFPO0FBRWpCLGFBQVEsVUFBVSxJQUFLLFFBQVE7QUFDL0IsY0FBUTtBQUNSLGVBQVUsT0FBTztBQUVqQixhQUFRLFNBQVMsS0FBTSxTQUFTO0FBQ2hDLGVBQVM7QUFDVCxjQUFTLE9BQU87QUFFaEIsYUFBUSxTQUFTLElBQUssU0FBUztBQUMvQixlQUFTO0FBQ1QsY0FBUyxPQUFPO0FBRWhCLGFBQU8sS0FBSztBQUNaLGFBQU8sS0FBSztBQUFBLElBQ2Q7QUFxQkEsYUFBUyxjQUFjRCxVQUFTO0FBQzlCLE1BQUFBLFdBQVVBLFlBQVcsQ0FBQztBQUN0QixVQUFJLFFBQVFBLFNBQVEsUUFBUSxPQUFPLFlBQVk7QUFDL0MsVUFBSSxZQUFZLFNBQVM7QUFFekIsVUFBSTtBQUNKLFVBQUdBLFNBQVEsU0FBUztBQUNsQixpQkFBU0gsT0FBTSxPQUFPLGVBQWUsV0FBV0csU0FBUSxHQUFHO0FBQUEsTUFDN0QsT0FBTztBQUNMLGlCQUFTSCxPQUFNLE9BQU8sYUFBYSxXQUFXRyxTQUFRLEdBQUc7QUFBQSxNQUMzRDtBQUdBLFVBQUksUUFBUSxPQUFPO0FBQ25CLGFBQU8sUUFBUSxTQUFTLElBQUlBLFVBQVM7QUFFbkMsWUFBSSxTQUFTO0FBQ2IsWUFBR0Esb0JBQW1CSCxPQUFNLEtBQUssWUFBWTtBQUMzQyxtQkFBU0c7QUFDVCxVQUFBQSxXQUFVLENBQUM7QUFBQSxRQUNiO0FBQ0EsUUFBQUEsV0FBVUEsWUFBVyxDQUFDO0FBQ3RCLFFBQUFBLFNBQVEsU0FBUztBQUNqQixRQUFBQSxTQUFRLEtBQUs7QUFDYixjQUFNLEtBQUssUUFBUUEsUUFBTztBQUFBLE1BQzVCO0FBRUEsYUFBTztBQUFBLElBQ1Q7QUFBQTtBQUFBOzs7QUMvZUE7QUFBQSxzQ0FBQUUsVUFBQUMsU0FBQTtBQU9BLFFBQUlDLFNBQVE7QUFFWixJQUFBRCxRQUFPLFVBQVVDLE9BQU0sS0FBS0EsT0FBTSxNQUFNLENBQUM7QUFDekMsSUFBQUEsT0FBTSxHQUFHLGFBQWFBLE9BQU0sR0FBRyxjQUFjLENBQUM7QUFBQTtBQUFBOzs7QUNWOUM7QUFBQSx3Q0FBQUMsVUFBQUMsU0FBQTtBQVNBLFFBQUlDLFNBQVE7QUFDWjtBQUNBO0FBR0EsUUFBSSxPQUFPRCxRQUFPLFVBQVVDLE9BQU0sT0FBT0EsT0FBTSxRQUFRLENBQUM7QUFPeEQsU0FBSyxTQUFTLFdBQVc7QUFFdkIsVUFBSSxPQUFPO0FBR1gsVUFBSSxNQUFNO0FBR1YsVUFBSSxZQUFZO0FBR2hCLFVBQUksWUFBWTtBQUdoQixVQUFJLE1BQU0sQ0FBQztBQVVYLFVBQUksUUFBUSxTQUFTLElBQUksS0FBSztBQUM1QixZQUFHLE9BQU8sTUFBTTtBQUNkLGNBQUcsT0FBTyxPQUFPLFVBQVU7QUFFekIsaUJBQUssR0FBRyxZQUFZO0FBQ3BCLGdCQUFHLE1BQU1BLE9BQU0sR0FBRyxZQUFZO0FBQzVCLG9CQUFNQSxPQUFNLEdBQUcsV0FBVyxJQUFJLE9BQU87QUFBQSxZQUN2QyxPQUFPO0FBQ0wsb0JBQU0sSUFBSSxNQUFNLDZCQUE2QixLQUFLLEdBQUc7QUFBQSxZQUN2RDtBQUFBLFVBQ0YsT0FBTztBQUVMLGtCQUFNO0FBQUEsVUFDUjtBQUFBLFFBQ0Y7QUFFQSxZQUFHLFFBQVEsTUFBTTtBQUVmLGdCQUFNO0FBQUEsUUFDUixPQUFPO0FBQ0wsY0FBRyxPQUFPLFFBQVEsVUFBVTtBQUUxQixrQkFBTUEsT0FBTSxLQUFLLGFBQWEsR0FBRztBQUFBLFVBQ25DLFdBQVVBLE9BQU0sS0FBSyxRQUFRLEdBQUcsR0FBRztBQUVqQyxnQkFBSSxNQUFNO0FBQ1Ysa0JBQU1BLE9BQU0sS0FBSyxhQUFhO0FBQzlCLHFCQUFRLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDbEMsa0JBQUksUUFBUSxJQUFJLEVBQUU7QUFBQSxZQUNwQjtBQUFBLFVBQ0Y7QUFHQSxjQUFJLFNBQVMsSUFBSSxPQUFPO0FBQ3hCLGNBQUcsU0FBUyxJQUFJLGFBQWE7QUFDM0IsZ0JBQUksTUFBTTtBQUNWLGdCQUFJLE9BQU8sSUFBSSxNQUFNLENBQUM7QUFDdEIsa0JBQU0sSUFBSSxPQUFPO0FBQUEsVUFDbkI7QUFLQSxzQkFBWUEsT0FBTSxLQUFLLGFBQWE7QUFDcEMsc0JBQVlBLE9BQU0sS0FBSyxhQUFhO0FBQ3BDLG1CQUFTLElBQUksT0FBTztBQUNwQixtQkFBUSxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUM5QixnQkFBSSxNQUFNLElBQUksR0FBRyxDQUFDO0FBQ2xCLHNCQUFVLFFBQVEsS0FBTyxHQUFHO0FBQzVCLHNCQUFVLFFBQVEsS0FBTyxHQUFHO0FBQUEsVUFDOUI7QUFHQSxjQUFHLFNBQVMsSUFBSSxhQUFhO0FBQzNCLGdCQUFJLE1BQU0sSUFBSSxjQUFjO0FBQzVCLHFCQUFRLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQzNCLHdCQUFVLFFBQVEsRUFBSTtBQUN0Qix3QkFBVSxRQUFRLEVBQUk7QUFBQSxZQUN4QjtBQUFBLFVBQ0Y7QUFDQSxpQkFBTztBQUNQLHNCQUFZLFVBQVUsTUFBTTtBQUM1QixzQkFBWSxVQUFVLE1BQU07QUFBQSxRQUM5QjtBQU1BLFlBQUksTUFBTTtBQUNWLFlBQUksT0FBTyxTQUFTO0FBQUEsTUFDdEI7QUFPQSxVQUFJLFNBQVMsU0FBUyxPQUFPO0FBQzNCLFlBQUksT0FBTyxLQUFLO0FBQUEsTUFDbEI7QUFPQSxVQUFJLFNBQVMsV0FBVztBQUd0QixZQUFJLFFBQVEsSUFBSSxPQUFPLEVBQUUsTUFBTTtBQUMvQixZQUFJLE1BQU07QUFDVixZQUFJLE9BQU8sU0FBUztBQUNwQixZQUFJLE9BQU8sS0FBSztBQUNoQixlQUFPLElBQUksT0FBTztBQUFBLE1BQ3BCO0FBRUEsVUFBSSxTQUFTLElBQUk7QUFFakIsYUFBTztBQUFBLElBQ1Q7QUFBQTtBQUFBOzs7QUNqSkE7QUFBQSwwQ0FBQUMsVUFBQUMsU0FBQTtBQVNBLFFBQUlDLFNBQVE7QUFDWjtBQUNBO0FBQ0E7QUFFQSxRQUFJLFFBQVFBLE9BQU0sUUFBUUEsT0FBTSxTQUFTLENBQUM7QUFFMUMsUUFBSUM7QUFDSixRQUFHRCxPQUFNLEtBQUssWUFBWSxDQUFDQSxPQUFNLFFBQVEsbUJBQW1CO0FBQzFELE1BQUFDLFVBQVMsUUFBUTtBQUFBLElBQ25CO0FBa0JBLElBQUFGLFFBQU8sVUFBVUMsT0FBTSxTQUFTLE1BQU0sU0FBUyxTQUM3QyxHQUFHLEdBQUcsR0FBRyxPQUFPLElBQUksVUFBVTtBQUM5QixVQUFHLE9BQU8sT0FBTyxZQUFZO0FBQzNCLG1CQUFXO0FBQ1gsYUFBSztBQUFBLE1BQ1A7QUFJQSxVQUFHQSxPQUFNLEtBQUssWUFBWSxDQUFDQSxPQUFNLFFBQVEscUJBQ3ZDQyxRQUFPLFdBQVcsT0FBTyxRQUFRLE9BQU8sT0FBTyxjQUM5Q0EsUUFBTyxXQUFXLFNBQVMsTUFBTSxDQUFDLE1BQU0sT0FBTyxVQUFVO0FBQzFELFlBQUcsT0FBTyxPQUFPLFVBQVU7QUFFekIsZUFBSztBQUFBLFFBQ1A7QUFDQSxZQUFJLE9BQU8sS0FBSyxHQUFHLFFBQVE7QUFDM0IsWUFBSSxPQUFPLEtBQUssR0FBRyxRQUFRO0FBQzNCLFlBQUcsQ0FBQyxVQUFVO0FBQ1osY0FBR0EsUUFBTyxXQUFXLFdBQVcsR0FBRztBQUNqQyxtQkFBT0EsUUFBTyxXQUFXLEdBQUcsR0FBRyxHQUFHLEtBQUssRUFBRSxTQUFTLFFBQVE7QUFBQSxVQUM1RDtBQUNBLGlCQUFPQSxRQUFPLFdBQVcsR0FBRyxHQUFHLEdBQUcsT0FBTyxFQUFFLEVBQUUsU0FBUyxRQUFRO0FBQUEsUUFDaEU7QUFDQSxZQUFHQSxRQUFPLFdBQVcsV0FBVyxHQUFHO0FBQ2pDLGlCQUFPQSxRQUFPLE9BQU8sR0FBRyxHQUFHLEdBQUcsT0FBTyxTQUFTQyxNQUFLLEtBQUs7QUFDdEQsZ0JBQUdBLE1BQUs7QUFDTixxQkFBTyxTQUFTQSxJQUFHO0FBQUEsWUFDckI7QUFDQSxxQkFBUyxNQUFNLElBQUksU0FBUyxRQUFRLENBQUM7QUFBQSxVQUN2QyxDQUFDO0FBQUEsUUFDSDtBQUNBLGVBQU9ELFFBQU8sT0FBTyxHQUFHLEdBQUcsR0FBRyxPQUFPLElBQUksU0FBU0MsTUFBSyxLQUFLO0FBQzFELGNBQUdBLE1BQUs7QUFDTixtQkFBTyxTQUFTQSxJQUFHO0FBQUEsVUFDckI7QUFDQSxtQkFBUyxNQUFNLElBQUksU0FBUyxRQUFRLENBQUM7QUFBQSxRQUN2QyxDQUFDO0FBQUEsTUFDSDtBQUVBLFVBQUcsT0FBTyxPQUFPLGVBQWUsT0FBTyxNQUFNO0FBRTNDLGFBQUs7QUFBQSxNQUNQO0FBQ0EsVUFBRyxPQUFPLE9BQU8sVUFBVTtBQUN6QixZQUFHLEVBQUUsTUFBTUYsT0FBTSxHQUFHLGFBQWE7QUFDL0IsZ0JBQU0sSUFBSSxNQUFNLDZCQUE2QixFQUFFO0FBQUEsUUFDakQ7QUFDQSxhQUFLQSxPQUFNLEdBQUcsSUFBSSxPQUFPO0FBQUEsTUFDM0I7QUFFQSxVQUFJLE9BQU8sR0FBRztBQUlkLFVBQUcsUUFBUyxhQUFhLE1BQU87QUFDOUIsWUFBSSxNQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDOUMsWUFBRyxVQUFVO0FBQ1gsaUJBQU8sU0FBUyxHQUFHO0FBQUEsUUFDckI7QUFDQSxjQUFNO0FBQUEsTUFDUjtBQVFBLFVBQUksTUFBTSxLQUFLLEtBQUssUUFBUSxJQUFJO0FBQ2hDLFVBQUksSUFBSSxTQUFTLE1BQU0sS0FBSztBQTJCNUIsVUFBSSxNQUFNQSxPQUFNLEtBQUssT0FBTztBQUM1QixVQUFJLE1BQU0sSUFBSSxDQUFDO0FBQ2YsVUFBSSxLQUFLO0FBQ1QsVUFBSSxLQUFLLEtBQUs7QUFHZCxVQUFHLENBQUMsVUFBVTtBQUNaLGlCQUFRLElBQUksR0FBRyxLQUFLLEtBQUssRUFBRSxHQUFHO0FBRTVCLGNBQUksTUFBTSxNQUFNLElBQUk7QUFDcEIsY0FBSSxPQUFPLENBQUM7QUFDWixjQUFJLE9BQU9BLE9BQU0sS0FBSyxhQUFhLENBQUMsQ0FBQztBQUNyQyxnQkFBTSxPQUFPLElBQUksT0FBTyxFQUFFLFNBQVM7QUFHbkMsbUJBQVEsSUFBSSxHQUFHLEtBQUssR0FBRyxFQUFFLEdBQUc7QUFDMUIsZ0JBQUksTUFBTSxNQUFNLElBQUk7QUFDcEIsZ0JBQUksT0FBTyxJQUFJO0FBQ2Ysa0JBQU0sSUFBSSxPQUFPLEVBQUUsU0FBUztBQUU1QixrQkFBTUEsT0FBTSxLQUFLLFNBQVMsS0FBSyxLQUFLLElBQUk7QUFDeEMsbUJBQU87QUFBQSxVQUNUO0FBTUEsZ0JBQU8sSUFBSSxNQUFPLE1BQU0sSUFBSSxPQUFPLEdBQUcsQ0FBQztBQUFBLFFBQ3pDO0FBRUEsZUFBTztBQUFBLE1BQ1Q7QUFHQSxVQUFJLElBQUksR0FBRztBQUNYLGVBQVMsUUFBUTtBQUNmLFlBQUcsSUFBSSxLQUFLO0FBRVYsaUJBQU8sU0FBUyxNQUFNLEVBQUU7QUFBQSxRQUMxQjtBQUdBLFlBQUksTUFBTSxNQUFNLElBQUk7QUFDcEIsWUFBSSxPQUFPLENBQUM7QUFDWixZQUFJLE9BQU9BLE9BQU0sS0FBSyxhQUFhLENBQUMsQ0FBQztBQUNyQyxjQUFNLE9BQU8sSUFBSSxPQUFPLEVBQUUsU0FBUztBQUduQyxZQUFJO0FBQ0osY0FBTTtBQUFBLE1BQ1I7QUFFQSxlQUFTLFFBQVE7QUFDZixZQUFHLEtBQUssR0FBRztBQUNULGNBQUksTUFBTSxNQUFNLElBQUk7QUFDcEIsY0FBSSxPQUFPLElBQUk7QUFDZixnQkFBTSxJQUFJLE9BQU8sRUFBRSxTQUFTO0FBRTVCLGdCQUFNQSxPQUFNLEtBQUssU0FBUyxLQUFLLEtBQUssSUFBSTtBQUN4QyxpQkFBTztBQUNQLFlBQUU7QUFDRixpQkFBT0EsT0FBTSxLQUFLLGFBQWEsS0FBSztBQUFBLFFBQ3RDO0FBTUEsY0FBTyxJQUFJLE1BQU8sTUFBTSxJQUFJLE9BQU8sR0FBRyxDQUFDO0FBRXZDLFVBQUU7QUFDRixjQUFNO0FBQUEsTUFDUjtBQUVBLFlBQU07QUFBQSxJQUNSO0FBQUE7QUFBQTs7O0FDbE5BO0FBQUEsdUNBQUFHLFVBQUFDLFNBQUE7QUE0QkEsUUFBSUMsU0FBUTtBQUNaO0FBR0EsUUFBSSxNQUFNRCxRQUFPLFVBQVVDLE9BQU0sTUFBTUEsT0FBTSxPQUFPLENBQUM7QUFXckQsUUFBSSxTQUFTLFNBQVMsS0FBS0MsVUFBUztBQUNsQyxNQUFBQSxXQUFVQSxZQUFXLENBQUM7QUFDdEIsVUFBSSxPQUFPLGdCQUFnQixJQUFJLE9BQU87QUFHdEMsVUFBSTtBQUNKLFVBQUcsSUFBSSxVQUFVO0FBQ2YsaUJBQVM7QUFBQSxVQUNQLE1BQU07QUFBQSxVQUNOLFFBQVEsQ0FBQyxPQUFPLElBQUksU0FBUyxPQUFPLEdBQUcsSUFBSSxTQUFTLElBQUk7QUFBQSxRQUMxRDtBQUNBLGdCQUFRLFdBQVcsTUFBTTtBQUFBLE1BQzNCO0FBQ0EsVUFBRyxJQUFJLGVBQWU7QUFDcEIsaUJBQVMsRUFBQyxNQUFNLGtCQUFrQixRQUFRLENBQUMsSUFBSSxhQUFhLEVBQUM7QUFDN0QsZ0JBQVEsV0FBVyxNQUFNO0FBQUEsTUFDM0I7QUFDQSxVQUFHLElBQUksU0FBUztBQUNkLGlCQUFTLEVBQUMsTUFBTSxZQUFZLFFBQVEsQ0FBQyxJQUFJLFFBQVEsU0FBUyxFQUFDO0FBQzNELFlBQUcsSUFBSSxRQUFRLFlBQVk7QUFDekIsaUJBQU8sT0FBTyxLQUFLLElBQUksUUFBUSxVQUFVO0FBQUEsUUFDM0M7QUFDQSxnQkFBUSxXQUFXLE1BQU07QUFBQSxNQUMzQjtBQUVBLFVBQUcsSUFBSSxTQUFTO0FBRWQsaUJBQVEsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLFFBQVEsRUFBRSxHQUFHO0FBQzFDLGtCQUFRLFdBQVcsSUFBSSxRQUFRLEVBQUU7QUFBQSxRQUNuQztBQUFBLE1BQ0Y7QUFHQSxVQUFHLElBQUksVUFBVTtBQUNmLGdCQUFRO0FBQUEsTUFDVjtBQUdBLGNBQVFELE9BQU0sS0FBSyxTQUFTLElBQUksTUFBTUMsU0FBUSxXQUFXLEVBQUUsSUFBSTtBQUUvRCxjQUFRLGNBQWMsSUFBSSxPQUFPO0FBQ2pDLGFBQU87QUFBQSxJQUNUO0FBU0EsUUFBSSxTQUFTLFNBQVMsS0FBSztBQUN6QixVQUFJLE9BQU8sQ0FBQztBQUdaLFVBQUksV0FBVztBQUNmLFVBQUksVUFBVTtBQUNkLFVBQUksUUFBUTtBQUNaLFVBQUk7QUFDSixhQUFNLE1BQU07QUFDVixnQkFBUSxTQUFTLEtBQUssR0FBRztBQUN6QixZQUFHLENBQUMsT0FBTztBQUNUO0FBQUEsUUFDRjtBQUlBLFlBQUksT0FBTyxNQUFNO0FBQ2pCLFlBQUcsU0FBUywyQkFBMkI7QUFDckMsaUJBQU87QUFBQSxRQUNUO0FBRUEsWUFBSSxNQUFNO0FBQUEsVUFDUjtBQUFBLFVBQ0EsVUFBVTtBQUFBLFVBQ1YsZUFBZTtBQUFBLFVBQ2YsU0FBUztBQUFBLFVBQ1QsU0FBUyxDQUFDO0FBQUEsVUFDVixNQUFNRCxPQUFNLEtBQUssU0FBUyxNQUFNLEVBQUU7QUFBQSxRQUNwQztBQUNBLGFBQUssS0FBSyxHQUFHO0FBR2IsWUFBRyxDQUFDLE1BQU0sSUFBSTtBQUNaO0FBQUEsUUFDRjtBQUdBLFlBQUksUUFBUSxNQUFNLEdBQUcsTUFBTSxLQUFLO0FBQ2hDLFlBQUksS0FBSztBQUNULGVBQU0sU0FBUyxLQUFLLE1BQU0sUUFBUTtBQUVoQyxjQUFJLE9BQU8sTUFBTSxJQUFJLFFBQVEsUUFBUSxFQUFFO0FBR3ZDLG1CQUFRLEtBQUssS0FBSyxHQUFHLEtBQUssTUFBTSxRQUFRLEVBQUUsSUFBSTtBQUM1QyxnQkFBSSxPQUFPLE1BQU07QUFDakIsZ0JBQUcsQ0FBQyxLQUFLLEtBQUssS0FBSyxFQUFFLEdBQUc7QUFDdEI7QUFBQSxZQUNGO0FBQ0Esb0JBQVE7QUFDUixpQkFBSztBQUFBLFVBQ1A7QUFHQSxrQkFBUSxLQUFLLE1BQU0sT0FBTztBQUMxQixjQUFHLE9BQU87QUFDUixnQkFBSSxTQUFTLEVBQUMsTUFBTSxNQUFNLElBQUksUUFBUSxDQUFDLEVBQUM7QUFDeEMsZ0JBQUksU0FBUyxNQUFNLEdBQUcsTUFBTSxHQUFHO0FBQy9CLHFCQUFRLEtBQUssR0FBRyxLQUFLLE9BQU8sUUFBUSxFQUFFLElBQUk7QUFDeEMscUJBQU8sT0FBTyxLQUFLLE1BQU0sT0FBTyxHQUFHLENBQUM7QUFBQSxZQUN0QztBQUdBLGdCQUFHLENBQUMsSUFBSSxVQUFVO0FBQ2hCLGtCQUFHLE9BQU8sU0FBUyxhQUFhO0FBQzlCLHNCQUFNLElBQUksTUFBTSxtRkFDNEI7QUFBQSxjQUM5QyxXQUFVLE9BQU8sT0FBTyxXQUFXLEdBQUc7QUFDcEMsc0JBQU0sSUFBSSxNQUFNLGdGQUNtQjtBQUFBLGNBQ3JDO0FBQ0Esa0JBQUksV0FBVyxFQUFDLFNBQVMsT0FBTyxJQUFJLE1BQU0sT0FBTyxHQUFFO0FBQUEsWUFDckQsV0FBVSxDQUFDLElBQUksaUJBQWlCLE9BQU8sU0FBUyxrQkFBa0I7QUFFaEUsa0JBQUksZ0JBQWdCLE9BQU8sTUFBTTtBQUFBLFlBQ25DLFdBQVUsQ0FBQyxJQUFJLFdBQVcsT0FBTyxTQUFTLFlBQVk7QUFFcEQsa0JBQUcsT0FBTyxPQUFPLFdBQVcsR0FBRztBQUM3QixzQkFBTSxJQUFJLE1BQU0sdUZBQzJCO0FBQUEsY0FDN0M7QUFDQSxrQkFBSSxVQUFVLEVBQUMsV0FBVyxPQUFPLElBQUksWUFBWSxPQUFPLE1BQU0sS0FBSTtBQUFBLFlBQ3BFLE9BQU87QUFDTCxrQkFBSSxRQUFRLEtBQUssTUFBTTtBQUFBLFlBQ3pCO0FBQUEsVUFDRjtBQUVBLFlBQUU7QUFBQSxRQUNKO0FBRUEsWUFBRyxJQUFJLGFBQWEsZUFBZSxDQUFDLElBQUksU0FBUztBQUMvQyxnQkFBTSxJQUFJLE1BQU0scUdBQ3lDO0FBQUEsUUFDM0Q7QUFBQSxNQUNGO0FBRUEsVUFBRyxLQUFLLFdBQVcsR0FBRztBQUNwQixjQUFNLElBQUksTUFBTSxnQ0FBZ0M7QUFBQSxNQUNsRDtBQUVBLGFBQU87QUFBQSxJQUNUO0FBRUEsYUFBUyxXQUFXLFFBQVE7QUFDMUIsVUFBSSxPQUFPLE9BQU8sT0FBTztBQUd6QixVQUFJLFNBQVMsQ0FBQztBQUNkLFVBQUksY0FBYyxTQUFTLE9BQU8sSUFBSTtBQUNwQyxlQUFPLE1BQU07QUFBQSxNQUNmO0FBQ0EsZUFBUSxJQUFJLEdBQUcsSUFBSSxPQUFPLE9BQU8sUUFBUSxFQUFFLEdBQUc7QUFDNUMsZUFBTyxLQUFLLE9BQU8sT0FBTyxHQUFHLFFBQVEsY0FBYyxXQUFXLENBQUM7QUFBQSxNQUNqRTtBQUNBLGNBQVEsT0FBTyxLQUFLLEdBQUcsSUFBSTtBQUczQixVQUFJRSxVQUFTO0FBQ2IsVUFBSSxZQUFZO0FBQ2hCLGVBQVEsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEVBQUUsR0FBRyxFQUFFQSxTQUFRO0FBQzdDLFlBQUdBLFVBQVMsTUFBTSxjQUFjLElBQUk7QUFDbEMsY0FBSSxTQUFTLEtBQUs7QUFDbEIsY0FBRyxXQUFXLEtBQUs7QUFDakIsY0FBRTtBQUNGLG1CQUFPLEtBQUssT0FBTyxHQUFHLFNBQVMsSUFBSSxVQUFVLEtBQUssT0FBTyxTQUFTO0FBQUEsVUFDcEUsT0FBTztBQUNMLG1CQUFPLEtBQUssT0FBTyxHQUFHLFNBQVMsSUFDN0IsU0FBUyxTQUFTLEtBQUssT0FBTyxZQUFZLENBQUM7QUFBQSxVQUMvQztBQUNBLFVBQUFBLFVBQVUsSUFBSSxZQUFZO0FBQzFCLHNCQUFZO0FBQ1osWUFBRTtBQUFBLFFBQ0osV0FBVSxLQUFLLE9BQU8sT0FBTyxLQUFLLE9BQU8sT0FBUSxLQUFLLE9BQU8sS0FBSztBQUNoRSxzQkFBWTtBQUFBLFFBQ2Q7QUFBQSxNQUNGO0FBRUEsYUFBTztBQUFBLElBQ1Q7QUFFQSxhQUFTLE1BQU0sS0FBSztBQUNsQixhQUFPLElBQUksUUFBUSxRQUFRLEVBQUU7QUFBQSxJQUMvQjtBQUFBO0FBQUE7OztBQzVPQTtBQUFBLDBDQUFBQyxVQUFBQyxTQUFBO0FBU0EsUUFBSUMsU0FBUTtBQUNaO0FBQ0E7QUFFQSxRQUFJQyxVQUFTRixRQUFPLFVBQVVDLE9BQU0sU0FBU0EsT0FBTSxVQUFVLENBQUM7QUFDOUQsSUFBQUEsT0FBTSxHQUFHLFNBQVNBLE9BQU0sR0FBRyxXQUFXLFNBQVNDO0FBTy9DLElBQUFBLFFBQU8sU0FBUyxXQUFXO0FBRXpCLFVBQUcsQ0FBQyxjQUFjO0FBQ2hCLGNBQU07QUFBQSxNQUNSO0FBR0EsVUFBSSxTQUFTO0FBR2IsVUFBSSxTQUFTRCxPQUFNLEtBQUssYUFBYTtBQUdyQyxVQUFJLEtBQUssSUFBSSxNQUFNLEVBQUU7QUFHckIsVUFBSSxLQUFLO0FBQUEsUUFDUCxXQUFXO0FBQUEsUUFDWCxhQUFhO0FBQUEsUUFDYixjQUFjO0FBQUEsUUFFZCxlQUFlO0FBQUEsUUFFZixtQkFBbUI7QUFBQSxRQUVuQixtQkFBbUI7QUFBQSxNQUNyQjtBQU9BLFNBQUcsUUFBUSxXQUFXO0FBRXBCLFdBQUcsZ0JBQWdCO0FBR25CLFdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLENBQUM7QUFDN0MsWUFBSSxTQUFTLEdBQUcsb0JBQW9CO0FBQ3BDLGlCQUFRLElBQUksR0FBRyxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQzlCLGFBQUcsa0JBQWtCLEtBQUssQ0FBQztBQUFBLFFBQzdCO0FBQ0EsaUJBQVNBLE9BQU0sS0FBSyxhQUFhO0FBQ2pDLGlCQUFTO0FBQUEsVUFDUCxJQUFJO0FBQUEsVUFDSixJQUFJO0FBQUEsVUFDSixJQUFJO0FBQUEsVUFDSixJQUFJO0FBQUEsVUFDSixJQUFJO0FBQUEsVUFDSixJQUFJO0FBQUEsVUFDSixJQUFJO0FBQUEsVUFDSixJQUFJO0FBQUEsUUFDTjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBRUEsU0FBRyxNQUFNO0FBWVQsU0FBRyxTQUFTLFNBQVMsS0FBSyxVQUFVO0FBQ2xDLFlBQUcsYUFBYSxRQUFRO0FBQ3RCLGdCQUFNQSxPQUFNLEtBQUssV0FBVyxHQUFHO0FBQUEsUUFDakM7QUFHQSxZQUFJLE1BQU0sSUFBSTtBQUNkLFdBQUcsaUJBQWlCO0FBQ3BCLGNBQU0sQ0FBRSxNQUFNLGVBQWlCLEdBQUcsUUFBUSxDQUFDO0FBQzNDLGlCQUFRLElBQUksR0FBRyxrQkFBa0IsU0FBUyxHQUFHLEtBQUssR0FBRyxFQUFFLEdBQUc7QUFDeEQsYUFBRyxrQkFBa0IsTUFBTSxJQUFJO0FBQy9CLGNBQUksS0FBSyxJQUFJLE1BQU8sR0FBRyxrQkFBa0IsS0FBSyxlQUFpQjtBQUMvRCxhQUFHLGtCQUFrQixLQUFLLEdBQUcsa0JBQWtCLE9BQU87QUFDdEQsY0FBSSxLQUFPLElBQUksS0FBSyxlQUFpQjtBQUFBLFFBQ3ZDO0FBR0EsZUFBTyxTQUFTLEdBQUc7QUFHbkIsZ0JBQVEsUUFBUSxJQUFJLE1BQU07QUFHMUIsWUFBRyxPQUFPLE9BQU8sUUFBUSxPQUFPLE9BQU8sTUFBTSxHQUFHO0FBQzlDLGlCQUFPLFFBQVE7QUFBQSxRQUNqQjtBQUVBLGVBQU87QUFBQSxNQUNUO0FBT0EsU0FBRyxTQUFTLFdBQVc7QUFxQnJCLFlBQUksYUFBYUEsT0FBTSxLQUFLLGFBQWE7QUFDekMsbUJBQVcsU0FBUyxPQUFPLE1BQU0sQ0FBQztBQUdsQyxZQUFJLFlBQ0YsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsU0FBUyxLQUNuRCxHQUFHO0FBS0wsWUFBSSxXQUFXLFlBQWEsR0FBRyxjQUFjO0FBQzdDLG1CQUFXLFNBQVMsU0FBUyxPQUFPLEdBQUcsR0FBRyxjQUFjLFFBQVEsQ0FBQztBQUlqRSxZQUFJLE1BQU07QUFDVixZQUFJLE9BQU8sR0FBRyxrQkFBa0IsS0FBSztBQUNyQyxpQkFBUSxJQUFJLEdBQUcsSUFBSSxHQUFHLGtCQUFrQixTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQ3ZELGlCQUFPLEdBQUcsa0JBQWtCLElBQUksS0FBSztBQUNyQyxrQkFBUyxPQUFPLGVBQWlCO0FBQ2pDLGtCQUFRO0FBQ1IscUJBQVcsU0FBUyxTQUFTLENBQUM7QUFDOUIsaUJBQU8sU0FBUztBQUFBLFFBQ2xCO0FBQ0EsbUJBQVcsU0FBUyxJQUFJO0FBRXhCLFlBQUksS0FBSztBQUFBLFVBQ1AsSUFBSSxPQUFPO0FBQUEsVUFDWCxJQUFJLE9BQU87QUFBQSxVQUNYLElBQUksT0FBTztBQUFBLFVBQ1gsSUFBSSxPQUFPO0FBQUEsVUFDWCxJQUFJLE9BQU87QUFBQSxVQUNYLElBQUksT0FBTztBQUFBLFVBQ1gsSUFBSSxPQUFPO0FBQUEsVUFDWCxJQUFJLE9BQU87QUFBQSxRQUNiO0FBQ0EsZ0JBQVEsSUFBSSxJQUFJLFVBQVU7QUFDMUIsWUFBSSxPQUFPQSxPQUFNLEtBQUssYUFBYTtBQUNuQyxhQUFLLFNBQVMsR0FBRyxFQUFFO0FBQ25CLGFBQUssU0FBUyxHQUFHLEVBQUU7QUFDbkIsYUFBSyxTQUFTLEdBQUcsRUFBRTtBQUNuQixhQUFLLFNBQVMsR0FBRyxFQUFFO0FBQ25CLGFBQUssU0FBUyxHQUFHLEVBQUU7QUFDbkIsYUFBSyxTQUFTLEdBQUcsRUFBRTtBQUNuQixhQUFLLFNBQVMsR0FBRyxFQUFFO0FBQ25CLGFBQUssU0FBUyxHQUFHLEVBQUU7QUFDbkIsZUFBTztBQUFBLE1BQ1Q7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQUdBLFFBQUksV0FBVztBQUNmLFFBQUksZUFBZTtBQUduQixRQUFJLEtBQUs7QUFLVCxhQUFTLFFBQVE7QUFFZixpQkFBVyxPQUFPLGFBQWEsR0FBRztBQUNsQyxrQkFBWUEsT0FBTSxLQUFLLFdBQVcsT0FBTyxhQUFhLENBQUksR0FBRyxFQUFFO0FBRy9ELFdBQUs7QUFBQSxRQUNIO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFDcEM7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUNwQztBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsUUFBWTtBQUFBLFFBQ3BDO0FBQUEsUUFBWTtBQUFBLFFBQVk7QUFBQSxRQUFZO0FBQUEsTUFBVTtBQUdoRCxxQkFBZTtBQUFBLElBQ2pCO0FBU0EsYUFBUyxRQUFRLEdBQUcsR0FBRyxPQUFPO0FBRTVCLFVBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ3JELFVBQUksTUFBTSxNQUFNLE9BQU87QUFDdkIsYUFBTSxPQUFPLElBQUk7QUFHZixhQUFJLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxHQUFHO0FBQ3RCLFlBQUUsS0FBSyxNQUFNLFNBQVM7QUFBQSxRQUN4QjtBQUNBLGVBQU0sSUFBSSxJQUFJLEVBQUUsR0FBRztBQUVqQixlQUFLLEVBQUUsSUFBSTtBQUNYLGdCQUNJLE9BQU8sS0FBTyxNQUFNLE9BQ3BCLE9BQU8sS0FBTyxNQUFNLE1BQ3JCLE9BQU87QUFFVixlQUFLLEVBQUUsSUFBSTtBQUNYLGdCQUNJLE9BQU8sSUFBTSxNQUFNLE9BQ25CLE9BQU8sS0FBTyxNQUFNLE1BQ3JCLE9BQU87QUFFVixZQUFFLEtBQU0sS0FBSyxFQUFFLElBQUksS0FBSyxLQUFLLEVBQUUsSUFBSSxNQUFPO0FBQUEsUUFDNUM7QUFHQSxZQUFJLEVBQUU7QUFDTixZQUFJLEVBQUU7QUFDTixZQUFJLEVBQUU7QUFDTixZQUFJLEVBQUU7QUFDTixZQUFJLEVBQUU7QUFDTixZQUFJLEVBQUU7QUFDTixZQUFJLEVBQUU7QUFDTixZQUFJLEVBQUU7QUFHTixhQUFJLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxHQUFHO0FBRXRCLGdCQUNJLE1BQU0sSUFBTSxLQUFLLE9BQ2pCLE1BQU0sS0FBTyxLQUFLLE9BQ2xCLE1BQU0sS0FBTyxLQUFLO0FBRXRCLGVBQUssSUFBSyxLQUFLLElBQUk7QUFFbkIsZ0JBQ0ksTUFBTSxJQUFNLEtBQUssT0FDakIsTUFBTSxLQUFPLEtBQUssT0FDbEIsTUFBTSxLQUFPLEtBQUs7QUFFdEIsZ0JBQU8sSUFBSSxJQUFNLEtBQUssSUFBSTtBQUcxQixlQUFLLElBQUksS0FBSyxLQUFLLEdBQUcsS0FBSyxFQUFFO0FBQzdCLGVBQUssS0FBSztBQUNWLGNBQUk7QUFDSixjQUFJO0FBQ0osY0FBSTtBQUdKLGNBQUssSUFBSSxPQUFRO0FBQ2pCLGNBQUk7QUFDSixjQUFJO0FBQ0osY0FBSTtBQUdKLGNBQUssS0FBSyxPQUFRO0FBQUEsUUFDcEI7QUFHQSxVQUFFLEtBQU0sRUFBRSxLQUFLLElBQUs7QUFDcEIsVUFBRSxLQUFNLEVBQUUsS0FBSyxJQUFLO0FBQ3BCLFVBQUUsS0FBTSxFQUFFLEtBQUssSUFBSztBQUNwQixVQUFFLEtBQU0sRUFBRSxLQUFLLElBQUs7QUFDcEIsVUFBRSxLQUFNLEVBQUUsS0FBSyxJQUFLO0FBQ3BCLFVBQUUsS0FBTSxFQUFFLEtBQUssSUFBSztBQUNwQixVQUFFLEtBQU0sRUFBRSxLQUFLLElBQUs7QUFDcEIsVUFBRSxLQUFNLEVBQUUsS0FBSyxJQUFLO0FBQ3BCLGVBQU87QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUFBO0FBQUE7OztBQ3RVQTtBQUFBLHdDQUFBRSxVQUFBQyxTQUFBO0FBV0EsUUFBSUMsU0FBUTtBQUNaO0FBRUEsUUFBSSxVQUFVO0FBQ2QsUUFBR0EsT0FBTSxLQUFLLFlBQVksQ0FBQ0EsT0FBTSxRQUFRLHFCQUN2QyxDQUFDLFFBQVEsU0FBUyxnQkFBZ0I7QUFDbEMsZ0JBQVUsUUFBUTtBQUFBLElBQ3BCO0FBR0EsUUFBSSxPQUFPRCxRQUFPLFVBQVVDLE9BQU0sT0FBT0EsT0FBTSxRQUFRLENBQUM7QUFvQnhELFNBQUssU0FBUyxTQUFTLFFBQVE7QUFDN0IsVUFBSSxNQUFNO0FBQUEsUUFDUjtBQUFBLFFBQ0EsS0FBSztBQUFBLFFBQ0wsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLFFBRU4sU0FBUztBQUFBLFFBRVQsV0FBVztBQUFBLFFBRVgsVUFBVTtBQUFBLE1BQ1o7QUFHQSxVQUFJLEtBQUssT0FBTztBQUNoQixVQUFJLFFBQVEsSUFBSSxNQUFNLEVBQUU7QUFDeEIsZUFBUSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUMxQixjQUFNLEtBQUssR0FBRyxPQUFPO0FBQUEsTUFDdkI7QUFDQSxVQUFJLFFBQVE7QUFHWixVQUFJLE9BQU87QUFZWCxVQUFJLFdBQVcsU0FBUyxPQUFPLFVBQVU7QUFFdkMsWUFBRyxDQUFDLFVBQVU7QUFDWixpQkFBTyxJQUFJLGFBQWEsS0FBSztBQUFBLFFBQy9CO0FBR0EsWUFBSSxTQUFTLElBQUksT0FBTztBQUN4QixZQUFJLFlBQVksSUFBSSxPQUFPO0FBQzNCLFlBQUksWUFBWSxJQUFJLE9BQU87QUFDM0IsWUFBSSxhQUFhLElBQUksT0FBTztBQUM1QixZQUFJLElBQUlBLE9BQU0sS0FBSyxhQUFhO0FBT2hDLFlBQUksTUFBTTtBQUVWLFFBQUFDLFVBQVM7QUFFVCxpQkFBU0EsVUFBUyxLQUFLO0FBQ3JCLGNBQUcsS0FBSztBQUNOLG1CQUFPLFNBQVMsR0FBRztBQUFBLFVBQ3JCO0FBR0EsY0FBRyxFQUFFLE9BQU8sS0FBSyxPQUFPO0FBQ3RCLG1CQUFPLFNBQVMsTUFBTSxFQUFFLFNBQVMsS0FBSyxDQUFDO0FBQUEsVUFDekM7QUFHQSxjQUFHLElBQUksWUFBWSxTQUFTO0FBQzFCLGdCQUFJLE1BQU07QUFBQSxVQUNaO0FBRUEsY0FBRyxJQUFJLFFBQVEsTUFBTTtBQUVuQixtQkFBT0QsT0FBTSxLQUFLLFNBQVMsV0FBVztBQUNwQyxzQkFBUUMsU0FBUTtBQUFBLFlBQ2xCLENBQUM7QUFBQSxVQUNIO0FBR0EsY0FBSSxRQUFRLE9BQU8sSUFBSSxLQUFLLElBQUksSUFBSTtBQUNwQyxjQUFJLGFBQWEsTUFBTTtBQUN2QixZQUFFLFNBQVMsS0FBSztBQUdoQixjQUFJLE1BQU0sVUFBVSxPQUFPLElBQUksS0FBSyxVQUFVLElBQUksSUFBSSxDQUFDLENBQUM7QUFDeEQsY0FBSSxPQUFPLFdBQVcsT0FBTyxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUM7QUFFL0MsVUFBQUQsT0FBTSxLQUFLLGFBQWFDLFNBQVE7QUFBQSxRQUNsQztBQUFBLE1BQ0Y7QUFTQSxVQUFJLGVBQWUsU0FBUyxPQUFPO0FBRWpDLFlBQUksU0FBUyxJQUFJLE9BQU87QUFDeEIsWUFBSSxZQUFZLElBQUksT0FBTztBQUMzQixZQUFJLFlBQVksSUFBSSxPQUFPO0FBQzNCLFlBQUksYUFBYSxJQUFJLE9BQU87QUFPNUIsWUFBSSxNQUFNO0FBRVYsWUFBSSxJQUFJRCxPQUFNLEtBQUssYUFBYTtBQUNoQyxlQUFNLEVBQUUsT0FBTyxJQUFJLE9BQU87QUFFeEIsY0FBRyxJQUFJLFlBQVksU0FBUztBQUMxQixnQkFBSSxNQUFNO0FBQUEsVUFDWjtBQUVBLGNBQUcsSUFBSSxRQUFRLE1BQU07QUFDbkIsd0JBQVk7QUFBQSxVQUNkO0FBR0EsY0FBSSxRQUFRLE9BQU8sSUFBSSxLQUFLLElBQUksSUFBSTtBQUNwQyxjQUFJLGFBQWEsTUFBTTtBQUN2QixZQUFFLFNBQVMsS0FBSztBQUdoQixjQUFJLE1BQU0sVUFBVSxPQUFPLElBQUksS0FBSyxVQUFVLElBQUksSUFBSSxDQUFDLENBQUM7QUFDeEQsY0FBSSxPQUFPLFdBQVcsT0FBTyxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUM7QUFBQSxRQUNqRDtBQUVBLGVBQU8sRUFBRSxTQUFTLEtBQUs7QUFBQSxNQUN6QjtBQU9BLGVBQVMsUUFBUSxVQUFVO0FBQ3pCLFlBQUcsSUFBSSxNQUFNLEdBQUcsaUJBQWlCLElBQUk7QUFDbkMsZ0JBQU07QUFDTixpQkFBTyxTQUFTO0FBQUEsUUFDbEI7QUFFQSxZQUFJLFNBQVUsS0FBSyxJQUFJLE1BQU0sR0FBRyxpQkFBa0I7QUFDbEQsWUFBSSxTQUFTLFFBQVEsU0FBUyxLQUFLLE9BQU87QUFDeEMsY0FBRyxLQUFLO0FBQ04sbUJBQU8sU0FBUyxHQUFHO0FBQUEsVUFDckI7QUFDQSxjQUFJLFFBQVEsS0FBSztBQUNqQixnQkFBTTtBQUNOLG1CQUFTO0FBQUEsUUFDWCxDQUFDO0FBQUEsTUFDSDtBQUtBLGVBQVMsY0FBYztBQUNyQixZQUFHLElBQUksTUFBTSxHQUFHLGlCQUFpQixJQUFJO0FBQ25DLGlCQUFPLE1BQU07QUFBQSxRQUNmO0FBRUEsWUFBSSxTQUFVLEtBQUssSUFBSSxNQUFNLEdBQUcsaUJBQWtCO0FBQ2xELFlBQUksUUFBUSxJQUFJLGFBQWEsTUFBTSxDQUFDO0FBQ3BDLGNBQU07QUFBQSxNQUNSO0FBS0EsZUFBUyxRQUFRO0FBRWYsWUFBSSxVQUFXLElBQUksWUFBWSxhQUFjLElBQUksSUFBSSxVQUFVO0FBTy9ELFlBQUlFLE1BQUssSUFBSSxPQUFPLEdBQUcsT0FBTztBQUc5QixRQUFBQSxJQUFHLE9BQU8sSUFBSSxRQUFRO0FBSXRCLFlBQUksU0FBUztBQUNiLGlCQUFRLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxHQUFHO0FBQzFCLGNBQUcsSUFBSSxVQUFVLFdBQVcsR0FBRztBQUM3QixZQUFBQSxJQUFHLE9BQU8sSUFBSSxNQUFNLEdBQUcsT0FBTyxFQUFFLFNBQVMsQ0FBQztBQUMxQyxnQkFBSSxNQUFNLEdBQUcsTUFBTTtBQUFBLFVBQ3JCO0FBQ0EsbUJBQVMsVUFBVTtBQUFBLFFBQ3JCO0FBR0EsWUFBSSxXQUFXQSxJQUFHLE9BQU8sRUFBRSxTQUFTO0FBTXBDLFFBQUFBLElBQUcsTUFBTTtBQUNULFFBQUFBLElBQUcsT0FBTyxJQUFJLFFBQVE7QUFDdEIsWUFBSSxZQUFZQSxJQUFHLE9BQU8sRUFBRSxTQUFTO0FBR3JDLFlBQUksTUFBTSxJQUFJLE9BQU8sVUFBVSxJQUFJLFFBQVE7QUFDM0MsWUFBSSxPQUFPLElBQUksT0FBTyxXQUFXLFNBQVM7QUFDMUMsWUFBSSxZQUFZO0FBQUEsTUFDbEI7QUFVQSxlQUFTLGdCQUFnQixRQUFRO0FBRS9CLFlBQUksa0JBQWtCO0FBQ3RCLFlBQUksY0FBY0YsT0FBTSxLQUFLO0FBQzdCLFlBQUlHLFdBQVUsWUFBWSxVQUFVLFlBQVk7QUFDaEQsWUFBR0EsWUFBV0EsU0FBUSxpQkFBaUI7QUFDckMsNEJBQWtCLFNBQVMsS0FBSztBQUM5QixtQkFBT0EsU0FBUSxnQkFBZ0IsR0FBRztBQUFBLFVBQ3BDO0FBQUEsUUFDRjtBQUVBLFlBQUksSUFBSUgsT0FBTSxLQUFLLGFBQWE7QUFDaEMsWUFBRyxpQkFBaUI7QUFDbEIsaUJBQU0sRUFBRSxPQUFPLElBQUksUUFBUTtBQUd6QixnQkFBSSxRQUFRLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSSxTQUFTLEVBQUUsT0FBTyxHQUFHLEtBQUssSUFBSSxDQUFDO0FBQ2hFLGdCQUFJLFVBQVUsSUFBSSxZQUFZLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDL0MsZ0JBQUk7QUFDRiw4QkFBZ0IsT0FBTztBQUN2Qix1QkFBUUksS0FBSSxHQUFHQSxLQUFJLFFBQVEsUUFBUSxFQUFFQSxJQUFHO0FBQ3RDLGtCQUFFLFNBQVMsUUFBUUEsR0FBRTtBQUFBLGNBQ3ZCO0FBQUEsWUFDRixTQUFRLEdBQU47QUFFQSxrQkFBRyxFQUFFLE9BQU8sdUJBQXVCLGVBQ2pDLGFBQWEscUJBQXFCO0FBQ2xDLHNCQUFNO0FBQUEsY0FDUjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUdBLFlBQUcsRUFBRSxPQUFPLElBQUksUUFBUTtBQUl0QixjQUFJLElBQUksSUFBSTtBQUNaLGNBQUksT0FBTyxLQUFLLE1BQU0sS0FBSyxPQUFPLElBQUksS0FBUTtBQUM5QyxpQkFBTSxFQUFFLE9BQU8sSUFBSSxRQUFRO0FBQ3pCLGlCQUFLLFNBQVMsT0FBTztBQUNyQixpQkFBSyxTQUFTLFFBQVE7QUFDdEIsbUJBQU8sS0FBSyxVQUFXO0FBQ3ZCLGtCQUFNLE1BQU07QUFDWixrQkFBTSxLQUFLLGVBQWUsTUFBTTtBQUNoQyxtQkFBTyxLQUFLO0FBR1oscUJBQVFBLEtBQUksR0FBR0EsS0FBSSxHQUFHLEVBQUVBLElBQUc7QUFFekIscUJBQU8sVUFBVUEsTUFBSztBQUN0QixzQkFBUSxLQUFLLE1BQU0sS0FBSyxPQUFPLElBQUksR0FBTTtBQUN6QyxnQkFBRSxRQUFRLE9BQU8sR0FBSTtBQUFBLFlBQ3ZCO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFFQSxlQUFPLEVBQUUsU0FBUyxNQUFNO0FBQUEsTUFDMUI7QUFFQSxVQUFHLFNBQVM7QUFFVixZQUFJLFdBQVcsU0FBUyxRQUFRLFVBQVU7QUFDeEMsa0JBQVEsWUFBWSxRQUFRLFNBQVMsS0FBSyxPQUFPO0FBQy9DLGdCQUFHLEtBQUs7QUFDTixxQkFBTyxTQUFTLEdBQUc7QUFBQSxZQUNyQjtBQUNBLHFCQUFTLE1BQU0sTUFBTSxTQUFTLENBQUM7QUFBQSxVQUNqQyxDQUFDO0FBQUEsUUFDSDtBQUVBLFlBQUksZUFBZSxTQUFTLFFBQVE7QUFDbEMsaUJBQU8sUUFBUSxZQUFZLE1BQU0sRUFBRSxTQUFTO0FBQUEsUUFDOUM7QUFBQSxNQUNGLE9BQU87QUFDTCxZQUFJLFdBQVcsU0FBUyxRQUFRLFVBQVU7QUFDeEMsY0FBSTtBQUNGLHFCQUFTLE1BQU0sZ0JBQWdCLE1BQU0sQ0FBQztBQUFBLFVBQ3hDLFNBQVEsR0FBTjtBQUNBLHFCQUFTLENBQUM7QUFBQSxVQUNaO0FBQUEsUUFDRjtBQUNBLFlBQUksZUFBZTtBQUFBLE1BQ3JCO0FBT0EsVUFBSSxVQUFVLFNBQVMsT0FBTztBQUU1QixZQUFJLFFBQVEsTUFBTTtBQUNsQixpQkFBUUEsS0FBSSxHQUFHQSxLQUFJLE9BQU8sRUFBRUEsSUFBRztBQUM3QixjQUFJLE1BQU0sSUFBSSxNQUFNLE9BQU8sTUFBTSxPQUFPQSxJQUFHLENBQUMsQ0FBQztBQUM3QyxjQUFJLE9BQVEsSUFBSSxTQUFTLEtBQU0sSUFBSSxJQUFJLE9BQU87QUFBQSxRQUNoRDtBQUFBLE1BQ0Y7QUFRQSxVQUFJLGFBQWEsU0FBU0EsSUFBRyxHQUFHO0FBQzlCLFlBQUksUUFBUTtBQUNaLGlCQUFRLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSyxHQUFHO0FBQzVCLG1CQUFTLE9BQU8sYUFBY0EsTUFBSyxJQUFLLEdBQUk7QUFBQSxRQUM5QztBQUNBLFlBQUksUUFBUSxLQUFLO0FBQUEsTUFDbkI7QUFVQSxVQUFJLGlCQUFpQixTQUFTLFFBQVE7QUFFcEMsWUFBRyxXQUFXLE1BQU07QUFDbEIsY0FBSSxXQUFXLFNBQVMsUUFBUSxVQUFVO0FBQ3hDLHFCQUFTQyxVQUFTLEdBQUc7QUFDbkIsa0JBQUksT0FBTyxFQUFFO0FBQ2Isa0JBQUcsS0FBSyxTQUFTLEtBQUssTUFBTSxNQUFNO0FBQ2hDLHFCQUFLLG9CQUFvQixXQUFXQSxTQUFRO0FBQzVDLHlCQUFTLEtBQUssTUFBTSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSztBQUFBLGNBQ3JEO0FBQUEsWUFDRjtBQUNBLGlCQUFLLGlCQUFpQixXQUFXQSxTQUFRO0FBQ3pDLGlCQUFLLFlBQVksRUFBQyxPQUFPLEVBQUMsTUFBTSxFQUFDLE9BQWMsRUFBQyxFQUFDLENBQUM7QUFBQSxVQUNwRDtBQUFBLFFBQ0YsT0FBTztBQUVMLGNBQUksV0FBVyxTQUFTLEdBQUc7QUFDekIsZ0JBQUksT0FBTyxFQUFFO0FBQ2IsZ0JBQUcsS0FBSyxTQUFTLEtBQUssTUFBTSxNQUFNO0FBQ2hDLGtCQUFJLFNBQVMsS0FBSyxNQUFNLEtBQUssUUFBUSxTQUFTLEtBQUssT0FBTztBQUN4RCx1QkFBTyxZQUFZLEVBQUMsT0FBTyxFQUFDLE1BQU0sRUFBQyxLQUFVLE1BQVksRUFBQyxFQUFDLENBQUM7QUFBQSxjQUM5RCxDQUFDO0FBQUEsWUFDSDtBQUFBLFVBQ0Y7QUFFQSxpQkFBTyxpQkFBaUIsV0FBVyxRQUFRO0FBQUEsUUFDN0M7QUFBQSxNQUNGO0FBRUEsYUFBTztBQUFBLElBQ1Q7QUFBQTtBQUFBOzs7QUNsYUE7QUFBQSwwQ0FBQUMsVUFBQUMsU0FBQTtBQWVBLFFBQUlDLFNBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUVBLEtBQUMsV0FBVztBQUdaLFVBQUdBLE9BQU0sVUFBVUEsT0FBTSxPQUFPLFVBQVU7QUFDeEMsUUFBQUQsUUFBTyxVQUFVQyxPQUFNO0FBQ3ZCO0FBQUEsTUFDRjtBQUVBLE9BQUMsU0FBU0MsU0FBUTtBQUdsQixZQUFJLFdBQVcsQ0FBQztBQUNoQixZQUFJLG1CQUFtQixJQUFJLE1BQU0sQ0FBQztBQUNsQyxZQUFJLG1CQUFtQkQsT0FBTSxLQUFLLGFBQWE7QUFDL0MsaUJBQVMsWUFBWSxTQUFTRSxNQUFLO0FBRWpDLGNBQUksTUFBTUYsT0FBTSxLQUFLLGFBQWFFLElBQUc7QUFDckMsVUFBQUEsT0FBTSxJQUFJLE1BQU0sQ0FBQztBQUNqQixVQUFBQSxLQUFJLEtBQUssSUFBSSxTQUFTO0FBQ3RCLFVBQUFBLEtBQUksS0FBSyxJQUFJLFNBQVM7QUFDdEIsVUFBQUEsS0FBSSxLQUFLLElBQUksU0FBUztBQUN0QixVQUFBQSxLQUFJLEtBQUssSUFBSSxTQUFTO0FBR3RCLGlCQUFPRixPQUFNLElBQUksV0FBV0UsTUFBSyxLQUFLO0FBQUEsUUFDeEM7QUFDQSxpQkFBUyxhQUFhLFNBQVMsTUFBTTtBQUVuQyxjQUFJLE1BQU1GLE9BQU0sS0FBSyxhQUFhLElBQUk7QUFDdEMsaUJBQU8sSUFBSSxNQUFNLENBQUM7QUFDbEIsZUFBSyxLQUFLLElBQUksU0FBUztBQUN2QixlQUFLLEtBQUssSUFBSSxTQUFTO0FBQ3ZCLGVBQUssS0FBSyxJQUFJLFNBQVM7QUFDdkIsZUFBSyxLQUFLLElBQUksU0FBUztBQUN2QixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxpQkFBUyxTQUFTLFNBQVNFLE1BQUssTUFBTTtBQUNwQyxVQUFBRixPQUFNLElBQUksYUFBYUUsTUFBSyxNQUFNLGtCQUFrQixLQUFLO0FBQ3pELDJCQUFpQixTQUFTLGlCQUFpQixFQUFFO0FBQzdDLDJCQUFpQixTQUFTLGlCQUFpQixFQUFFO0FBQzdDLDJCQUFpQixTQUFTLGlCQUFpQixFQUFFO0FBQzdDLDJCQUFpQixTQUFTLGlCQUFpQixFQUFFO0FBQzdDLGlCQUFPLGlCQUFpQixTQUFTO0FBQUEsUUFDbkM7QUFDQSxpQkFBUyxZQUFZLFNBQVMsTUFBTTtBQUVsQyxZQUFFLEtBQUs7QUFDUCxpQkFBTztBQUFBLFFBQ1Q7QUFDQSxpQkFBUyxLQUFLRixPQUFNLEdBQUc7QUFLdkIsaUJBQVMsWUFBWTtBQUNuQixjQUFJLE1BQU1BLE9BQU0sS0FBSyxPQUFPLFFBQVE7QUFjcEMsY0FBSSxXQUFXLFNBQVMsT0FBTyxVQUFVO0FBQ3ZDLG1CQUFPLElBQUksU0FBUyxPQUFPLFFBQVE7QUFBQSxVQUNyQztBQVlBLGNBQUksZUFBZSxTQUFTLE9BQU87QUFDakMsbUJBQU8sSUFBSSxTQUFTLEtBQUs7QUFBQSxVQUMzQjtBQUVBLGlCQUFPO0FBQUEsUUFDVDtBQUdBLFlBQUksT0FBTyxVQUFVO0FBSXJCLFlBQUksa0JBQWtCO0FBQ3RCLFlBQUksY0FBY0EsT0FBTSxLQUFLO0FBQzdCLFlBQUksVUFBVSxZQUFZLFVBQVUsWUFBWTtBQUNoRCxZQUFHLFdBQVcsUUFBUSxpQkFBaUI7QUFDckMsNEJBQWtCLFNBQVMsS0FBSztBQUM5QixtQkFBTyxRQUFRLGdCQUFnQixHQUFHO0FBQUEsVUFDcEM7QUFBQSxRQUNGO0FBRUEsWUFBR0EsT0FBTSxRQUFRLHFCQUNkLENBQUNBLE9BQU0sS0FBSyxZQUFZLENBQUMsaUJBQWtCO0FBRzVDLGNBQUcsT0FBTyxXQUFXLGVBQWUsT0FBTyxhQUFhLFFBQVc7QUFBQSxVQUVuRTtBQUdBLGVBQUssV0FBVyxDQUFDLElBQUksS0FBSyxHQUFHLEVBQUU7QUFHL0IsY0FBRyxPQUFPLGNBQWUsYUFBYTtBQUNwQyxnQkFBSSxZQUFZO0FBQ2hCLHFCQUFRLE9BQU8sV0FBVztBQUN4QixrQkFBSTtBQUNGLG9CQUFHLE9BQU8sVUFBVSxRQUFTLFVBQVU7QUFDckMsK0JBQWEsVUFBVTtBQUFBLGdCQUN6QjtBQUFBLGNBQ0YsU0FBUSxHQUFOO0FBQUEsY0FPRjtBQUFBLFlBQ0Y7QUFDQSxpQkFBSyxRQUFRLFNBQVM7QUFDdEIsd0JBQVk7QUFBQSxVQUNkO0FBR0EsY0FBR0MsU0FBUTtBQUVULFlBQUFBLFFBQU8sRUFBRSxVQUFVLFNBQVMsR0FBRztBQUU3QixtQkFBSyxXQUFXLEVBQUUsU0FBUyxFQUFFO0FBQzdCLG1CQUFLLFdBQVcsRUFBRSxTQUFTLEVBQUU7QUFBQSxZQUMvQixDQUFDO0FBR0QsWUFBQUEsUUFBTyxFQUFFLFNBQVMsU0FBUyxHQUFHO0FBQzVCLG1CQUFLLFdBQVcsRUFBRSxVQUFVLENBQUM7QUFBQSxZQUMvQixDQUFDO0FBQUEsVUFDSDtBQUFBLFFBQ0Y7QUFHQSxZQUFHLENBQUNELE9BQU0sUUFBUTtBQUNoQixVQUFBQSxPQUFNLFNBQVM7QUFBQSxRQUNqQixPQUFPO0FBRUwsbUJBQVEsT0FBTyxNQUFNO0FBQ25CLFlBQUFBLE9BQU0sT0FBTyxPQUFPLEtBQUs7QUFBQSxVQUMzQjtBQUFBLFFBQ0Y7QUFHQSxRQUFBQSxPQUFNLE9BQU8saUJBQWlCO0FBRTlCLFFBQUFELFFBQU8sVUFBVUMsT0FBTTtBQUFBLE1BRXZCLEdBQUcsT0FBTyxXQUFZLGNBQWMsU0FBUyxJQUFJO0FBQUEsSUFFakQsR0FBRztBQUFBO0FBQUE7OztBQzlMSDtBQUFBLHVDQUFBRyxVQUFBQyxTQUFBO0FBVUEsUUFBSUMsU0FBUTtBQUNaO0FBRUEsUUFBSSxVQUFVO0FBQUEsTUFDWjtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQzFGO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFDMUY7QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUMxRjtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQzFGO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFDMUY7QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUMxRjtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQzFGO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFDMUY7QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUMxRjtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQzFGO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFDMUY7QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUMxRjtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQzFGO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQU07QUFBQSxNQUFN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QUFBQSxRQUFDO0FBQUEsUUFFbkIsS0FBSztBQUFBLFVBQU8sS0FBSyxNQUFNO0FBQUEsVUFBVyxLQUFLLEtBQUs7QUFBQSxVQUFTO0FBQUEsVUFDbkQsV0FBVyxJQUFJLENBQUM7QUFBQSxRQUFDO0FBQUEsUUFFbkIsS0FBSztBQUFBLFVBQU8sS0FBSyxNQUFNO0FBQUEsVUFBVyxLQUFLLEtBQUs7QUFBQSxVQUFTO0FBQUEsVUFDbkQsV0FBVyxJQUFJLENBQUM7QUFBQSxRQUFDO0FBQUEsUUFFbkIsS0FBSztBQUFBLFVBQU8sS0FBSyxNQUFNO0FBQUEsVUFBVyxLQUFLLEtBQUs7QUFBQSxVQUFTO0FBQUEsVUFDbkQsV0FBVyxJQUFJLENBQUM7QUFBQSxRQUFDO0FBQUEsUUFFbkIsS0FBSztBQUFBLFVBQU8sS0FBSyxNQUFNO0FBQUEsVUFBVyxLQUFLLEtBQUs7QUFBQSxVQUFTO0FBQUEsVUFDbkQsV0FBVyxJQUFJLENBQUM7QUFBQSxRQUFDO0FBQUEsUUFFbkIsS0FBSztBQUFBLFVBQU8sS0FBSyxNQUFNO0FBQUEsVUFBVyxLQUFLLEtBQUs7QUFBQSxVQUFTO0FBQUEsVUFDbkQsV0FBVyxJQUFJLEVBQUU7QUFBQSxRQUFDO0FBQUEsUUFFcEIsS0FBSztBQUFBLFVBQU8sS0FBSyxNQUFNO0FBQUEsVUFBVyxLQUFLLEtBQUs7QUFBQSxVQUFTO0FBQUEsVUFDbkQsV0FBVyxJQUFJLEVBQUU7QUFBQSxRQUFDO0FBQUEsUUFFcEIsS0FBSztBQUFBLFVBQU8sS0FBSyxNQUFNO0FBQUEsVUFBVyxLQUFLLEtBQUs7QUFBQSxVQUFTO0FBQUEsVUFDbkQsV0FBVyxJQUFJLElBQUk7QUFBQSxRQUFDO0FBQUEsTUFDeEIsQ0FBQztBQUFBLElBQ0g7QUFTQSxRQUFJLG9CQUFvQixTQUFTLEtBQUs7QUFFcEMsVUFBSSxVQUFVLENBQUM7QUFDZixVQUFJLFNBQVMsQ0FBQztBQUNkLFVBQUcsS0FBSyxTQUFTLEtBQUssb0JBQW9CLFNBQVMsTUFBTSxHQUFHO0FBRTFELFlBQUksTUFBTSxLQUFLLFNBQVMsUUFBUSxZQUFZ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U0FBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksU0FBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksU0FBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksU0FBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksU0FBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksU0FBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksU0FBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxTQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksU0FBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksU0FBVTtBQUFBLFFBQ2pELENBQUMsV0FBWSxTQUFVO0FBQUEsUUFBRyxDQUFDLFdBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxTQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxVQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ2pELENBQUMsWUFBWSxTQUFVO0FBQUEsUUFBRyxDQUFDLFlBQVksVUFBVTtBQUFBLE1BQ25EO0FBR0EsZ0JBQVUsQ0FBQztBQUNYLGNBQVEsYUFBYTtBQUFBLFFBQ25CLENBQUMsWUFBWSxVQUFVO0FBQUEsUUFDdkIsQ0FBQyxZQUFZLFVBQVU7QUFBQSxRQUN2QixDQUFDLFlBQVksVUFBVTtBQUFBLFFBQ3ZCLENBQUMsWUFBWSxVQUFVO0FBQUEsUUFDdkIsQ0FBQyxZQUFZLFVBQVU7QUFBQSxRQUN2QixDQUFDLFlBQVksU0FBVTtBQUFBLFFBQ3ZCLENBQUMs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QUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRyxLQUFLLFFBQVMsTUFBTSxFQUFHLEtBQUssUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRyxLQUFLLFFBQVMsTUFBTSxFQUFHLEtBQUssUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixLQUFNLEVBQUUsTUFBTSxPQUFRLEVBQUUsTUFBTSxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixNQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixNQUFNLEVBQUUsTUFBTSxPQUFRLEVBQUUsTUFBTSxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixNQUFNLEVBQUUsTUFBTSxPQUFRLEVBQUUsTUFBTSxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixNQUFNLEVBQUUsTUFBTSxPQUFRLEVBQUUsTUFBTSxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixNQUFNLEVBQUUsTUFBTSxPQUFRLEVBQUUsTUFBTSxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixNQUFNLEVBQUUsTUFBTSxPQUFRLEVBQUUsTUFBTSxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUztBQUV4RixVQUFJLEtBQUssSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLElBQ3BFLEtBQUss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V0FBTSxLQUFNLEtBQUs7QUFDbEIsWUFBTSxNQUFNLE1BQU07QUFDbEIsWUFBTSxNQUFNLE1BQU07QUFDbEIsWUFBTSxNQUFNLE1BQU07QUFDbEIsWUFBTSxNQUFNLE1BQU07QUFDbEIsWUFBTSxNQUFNLE1BQU07QUFDbEIsWUFBTSxNQUFNLE1BQU07QUFFbEIsUUFBRyxLQUFLLE9BQVEsSUFBSTtBQUNwQixRQUFHLEtBQUssT0FBUSxJQUFJO0FBQ3BCLFFBQUcsS0FBSyxPQUFPLEtBQUs7QUFDcEIsUUFBRyxLQUFLLE9BQU8sS0FBSztBQUVwQixRQUFHLEtBQUssT0FBUSxJQUFJO0FBQ3BCLFFBQUcsS0FBSyxPQUFRLElBQUk7QUFDcEIsUUFBRyxLQUFLLE9BQU8sS0FBSztBQUNwQixRQUFHLEtBQUssT0FBTyxLQUFLO0FBRXBCLFFBQUcsS0FBSyxPQUFRLElBQUk7QUFDcEIsUUFBRyxLQUFLLE9BQVEsSUFBSTtBQUNwQixRQUFFLE1BQU0sT0FBTyxLQUFLO0FBQ3BCLFFBQUUsTUFBTSxPQUFPLEtBQUs7QUFFcEIsUUFBRSxNQUFNLE9BQVEsSUFBSTtBQUNwQixRQUFFLE1BQU0sT0FBUSxJQUFJO0FBQ3BCLFFBQUUsTUFBTSxPQUFPLEtBQUs7QUFDcEIsUUFBRSxNQUFNLE9BQU8sS0FBSztBQUVwQixRQUFFLE1BQU0sT0FBUSxJQUFJO0FBQ3BCLFFBQUUsTUFBTSxPQUFRLElBQUk7QUFDcEIsUUFBRSxNQUFNLE9BQU8sS0FBSztBQUNwQixRQUFFLE1BQU0sT0FBTyxLQUFLO0FBRXBCLFFBQUUsTUFBTSxPQUFRLElBQUk7QUFDcEIsUUFBRSxNQUFNLE9BQVEsSUFBSTtBQUNwQixRQUFFLE1BQU0sT0FBTyxLQUFLO0FBQ3BCLFFBQUUsTUFBTSxPQUFPLEtBQUs7QUFFcEIsUUFBRSxNQUFNLE9BQVEsSUFBSTtBQUNwQixRQUFFLE1BQU0sT0FBUSxJQUFJO0FBQ3BCLFFBQUUsTUFBTSxPQUFPLEtBQUs7QUFDcEIsUUFBRSxNQUFNLE9BQU8sS0FBSztBQUVwQixRQUFFLE1BQU0sT0FBUSxJQUFJO0FBQ3BCLFFBQUUsTUFBTSxPQUFRLElBQUk7QUFDcEIsUUFBRSxNQUFNLE9BQU8sS0FBSztBQUNwQixRQUFFLE1BQU0sT0FBTyxLQUFLO0FBRXBCLFFBQUUsTUFBTSxPQUFRLElBQUk7QUFDcEIsUUFBRSxNQUFNLE9BQVEsSUFBSTtBQUNwQixRQUFFLE1BQU0sT0FBTyxLQUFLO0FBQ3BCLFFBQUUsTUFBTSxPQUFPLEtBQUs7QUFFcEIsUUFBRSxNQUFNLE9BQVEsSUFBSTtBQUNwQixRQUFFLE1BQU0sT0FBUSxJQUFJO0FBQ3BCLFFBQUUsTUFBTSxPQUFPLEtBQUs7QUFDcEIsUUFBRSxNQUFNLE9BQU8sS0FBSztBQUVwQixRQUFFLE1BQU0sUUFBUyxJQUFJO0FBQ3JCLFFBQUUsTUFBTSxRQUFTLElBQUk7QUFDckIsUUFBRSxNQUFNLFFBQVEsS0FBSztBQUNyQixRQUFFLE1BQU0sUUFBUSxLQUFLO0FBRXJCLFFBQUUsTUFBTSxRQUFTLElBQUk7QUFDckIsUUFBRSxNQUFNLFFBQVMsSUFBSTtBQUNyQixRQUFFLE1BQU0sUUFBUSxLQUFLO0FBQ3JCLFFBQUUsTUFBTSxRQUFRLEtBQUs7QUFFckIsUUFBRSxNQUFNLFFBQVMsSUFBSTtBQUNyQixRQUFFLE1BQU0sUUFBUyxJQUFJO0FBQ3JCLFFBQUUsTUFBTSxRQUFRLEtBQUs7QUFDckIsUUFBRSxNQUFNLFFBQVEsS0FBSztBQUVyQixRQUFFLE1BQU0sUUFBUyxJQUFJO0FBQ3JCLFFBQUUsTUFBTSxRQUFTLElBQUk7QUFDckIsUUFBRSxNQUFNLFFBQVEsS0FBSztBQUNyQixRQUFFLE1BQU0sUUFBUSxLQUFLO0FBRXJCLFFBQUUsTUFBTSxRQUFTLElBQUk7QUFDckIsUUFBRSxNQUFNLFFBQVMsSUFBSTtBQUNyQixRQUFFLE1BQU0sUUFBUSxLQUFLO0FBQ3JCLFFBQUUsTUFBTSxRQUFRLEtBQUs7QUFFckIsUUFBRSxNQUFNLFFBQVMsSUFBSTtBQUNyQixRQUFFLE1BQU0sUUFBUyxJQUFJO0FBQ3JCLFFBQUUsTUFBTSxRQUFRLEtBQUs7QUFDckIsUUFBRSxNQUFNLFFBQVEsS0FBSztBQUFBLElBQ3ZCO0FBRUEsYUFBUyxjQUFjLEdBQUUsR0FBRSxHQUFFLEdBQUc7QUFDOUIsVUFBSSxLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRyxLQUFLLFFBQVMsTUFBTSxFQUFHLEtBQUssUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRyxLQUFLLFFBQVMsTUFBTSxFQUFHLEtBQUssUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRyxLQUFLLFFBQVMsTUFBTSxFQUFHLEtBQUssUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixLQUFNLEVBQUUsTUFBTSxPQUFRLEVBQUUsTUFBTSxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRyxLQUFLLFFBQVMsTUFBTSxFQUFHLEtBQUssUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRyxLQUFLLFFBQVMsTUFBTSxFQUFHLEtBQUssUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRyxLQUFLLFFBQVMsTUFBTSxFQUFHLEtBQUssUUFBUyxJQUNwRixLQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FBSyxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixLQUFNLEVBQUUsTUFBTSxPQUFRLEVBQUUsTUFBTSxRQUFTLEtBQUssRUFBRSxNQUFNLFFBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUyxJQUNwRixNQUFNLEVBQUcsS0FBSyxPQUFRLEVBQUcsS0FB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LElBQ3ZDLENBQUM7QUFBQSxFQUNIO0FBRUEsWUFBVTtBQUVWLGFBQVcsR0FBRyxVQUFVLE1BQU07QUFDNUIsaUJBQWE7QUFBQSxFQUNmLENBQUM7QUFDSDtBQUVBLG9CQUFJLFVBQVUsRUFBRSxLQUFLLFlBQVk7QUFFakMsb0JBQUksR0FBRyxxQkFBcUIsTUFBTTtBQUNoQyxNQUFJLGFBQWEsVUFBVTtBQUN6Qix3QkFBSSxLQUFLO0FBQUEsRUFDWDtBQUNGLENBQUM7QUFFRCxvQkFBSSxHQUFHLFlBQVksTUFBTTtBQUN2QixNQUFJLGVBQWUsTUFBTTtBQUN2QixpQkFBYTtBQUFBLEVBQ2Y7QUFDRixDQUFDOyIsCiAgIm5hbWVzIjogWyJuYW1lIiwgImVuY29kZSIsICJsZW5ndGgiLCAiaSIsICJqIiwgImRlY29kZSIsICJzdHJpbmciLCAibmFtZSIsICJkZWNvZGVycyIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImFscGhhYmV0IiwgInN0cmluZyIsICJjb2RlcyIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImVuY29kZSIsICJkZWNvZGUiLCAiZGVjb2RlIiwgImluaXRfdmFyaW50IiwgImNvZGUiLCAiZGVjb2RlIiwgImVxdWFscyIsICJpbml0X3ZhcmludCIsICJjb2RlIiwgImRpZ2VzdCIsICJmcm9tIiwgIm5hbWUiLCAiY29kZSIsICJlbmNvZGUiLCAiZGlnZXN0IiwgImZyb20iLCAiY3J5cHRvIiwgImlkZW50aXR5X2V4cG9ydHMiLCAiaWRlbnRpdHkiLCAiZW5jb2RlIiwgImluaXRfaWRlbnRpdHkiLCAiaW5pdF92YXJpbnQiLCAidmVyc2lvbiIsICJjb2RlIiwgImRpZ2VzdCIsICJlcXVhbHMiLCAiYmFzZSIsICJkZWNvZGUiLCAibGVuZ3RoIiwgImNpZCIsICJtZXNzYWdlIiwgImluaXRfdmFyaW50IiwgImluaXRfaWRlbnRpdHkiLCAiaWRlbnRpdHlfZXhwb3J0cyIsICJuYW1lIiwgImVuY29kZSIsICJkZWNvZGUiLCAic3RyaW5nIiwgInRvU3RyaW5nIiwgImJhc2UiLCAibGVuZ3RoIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInBhcmFtcyIsICJvZmZzZXQiLCAiZXhwb3J0cyIsICJiYXNlNjQiLCAibGVuZ3RoIiwgInN0cmluZyIsICJlbmNvZGUiLCAiaSIsICJkZWNvZGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiRXZlbnRFbWl0dGVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInNpZ24iLCAiZXhwb3J0cyIsICJzdHJpbmciLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiYWxsb2MiLCAic2l6ZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJMb25nQml0cyIsICJzaWduIiwgImZyb20iLCAidW5zaWduZWQiLCAibGVuZ3RoIiwgImV4cG9ydHMiLCAiQnVmZmVyIiwgInVuc2lnbmVkIiwgIm1lcmdlIiwgInNyYyIsICJuYW1lIiwgIm1lc3NhZ2UiLCAiaSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJXcml0ZXIiLCAiTG9uZ0JpdHMiLCAiYmFzZTY0IiwgIm5vb3AiLCAiY3JlYXRlIiwgImFsbG9jIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIldyaXRlciIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJSZWFkZXIiLCAiTG9uZ0JpdHMiLCAicmVhZGVyIiwgImNyZWF0ZV9hcnJheSIsICJjcmVhdGUiLCAiYnVmZmVyIiwgImxlbmd0aCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJSZWFkZXIiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAic2VsZiIsICJlcnIiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInRvU3RyaW5nIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImlucXVpcmUiLCAib3B0aW9ucyIsICJleHBvcnRzIiwgInBhdGgiLCAiaXNBYnNvbHV0ZSIsICJub3JtYWxpemUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJuYW1lIiwgIm9wdGlvbnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAibmFtZSIsICJvcHRpb25zIiwgInNlbGYiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAibmFtZSIsICJvcHRpb25zIiwgIm5hbWVzIiwgImRlZmluZSIsICJwYXRoIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIm5hbWUiLCAib3B0aW9ucyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJuYW1lIiwgIm9wdGlvbnMiLCAicmVxdWlyZV9zZXJ2aWNlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIm5hbWUiLCAib3B0aW9ucyIsICJuYW1lcyIsICJtZXRob2RzIiwgImNyZWF0ZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJjcmVhdGUiLCAiZW5jb2RlIiwgIm1lc3NhZ2UiLCAiZGVjb2RlIiwgInJlYWRlciIsICJ2ZXJpZnkiLCAib3B0aW9ucyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmaWVsZCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibmFtZSIsICJtZXNzYWdlIiwgIm9wdGlvbnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiUmVhZGVyIiwgIldyaXRlciIsICJuYW1lIiwgIm9wdGlvbnMiLCAibmFtZXMiLCAiY3JlYXRlIiwgIm1lc3NhZ2UiLCAicmVhZGVyIiwgImxlbmd0aCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJvcHRpb25zIiwgInNlbGYiLCAiZmlsZW5hbWUiLCAicHJvY2VzcyIsICJyZXNvbHZlZCIsICJpIiwgInNvdXJjZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJuYW1lIiwgInBhdGgiLCAiZHN0IiwgInZhbHVlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIm5hbWUiLCAib3B0aW9ucyIsICJwYXRoIiwgIm9wdCIsICJ0b1N0cmluZyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJuYW1lIiwgIm9wdGlvbnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAidW5lc2NhcGUiLCAibGVuZ3RoIiwgImVxdWFscyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJvcHRpb25zIiwgIm5hbWUiLCAidG9rZW4iLCAic2lnbiIsICJ2YWx1ZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJuYW1lIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInJlYWRlciIsICJwYiIsICJtZXNzYWdlIiwgImltcG9ydF9wcm90b2J1ZmpzIiwgIm1ldGhvZHMiLCAicGIiLCAiY3JlYXRlQ29kZWMiLCAibmFtZSIsICJlbmNvZGUiLCAiZGVjb2RlIiwgIkNPREVDX1RZUEVTIiwgImVuY29kZSIsICJkZWNvZGUiLCAicmVhZGVyIiwgImNyZWF0ZUNvZGVjIiwgImVuY29kZSIsICJkZWNvZGUiLCAiY3JlYXRlQ29kZWMiLCAiaW5pdF9zcmMiLCAiaW5pdF9zcmMiLCAiS2V5VHlwZSIsICJfX0tleVR5cGVWYWx1ZXMiLCAiUHVibGljS2V5IiwgInJlYWRlciIsICJsZW5ndGgiLCAiUHJpdmF0ZUtleSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJhbHBoYWJldCIsICJiYXNlIiwgInRhYmxlIiwgInJlcXVpcmVfdXRpbCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJoYW5kbGVyIiwgIm9wdGlvbnMiLCAic3JjIiwgImVtcHR5IiwgImNvZGUiLCAiYXZnIiwgIm1hcCIsICJjYWxsYmFjayIsICJpIiwgIm92ZXJsYXAiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZm9yZ2UiLCAibmFtZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJvcHRpb25zIiwgImxlbmd0aCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJuYW1lIiwgIm9wdGlvbnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZm9yZ2UiLCAib3B0aW9ucyIsICJwYWRkaW5nIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImZvcmdlIiwgIm5hbWUiLCAic2VsZiIsICJvcHRpb25zIiwgImRlY3J5cHQiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZm9yZ2UiLCAibmFtZSIsICJzZWxmIiwgIm9wdGlvbnMiLCAiZGVjcnlwdCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJjcnlwdG8iLCAiZXJyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImZvcmdlIiwgIm9wdGlvbnMiLCAibGVuZ3RoIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImZvcmdlIiwgInNoYTI1NiIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJnZW5lcmF0ZSIsICJtZCIsICJfY3J5cHRvIiwgImkiLCAibGlzdGVuZXIiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZm9yZ2UiLCAialF1ZXJ5IiwgImtleSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJ3b3JkIiwgImVuY3J5cHQiLCAicGFkZGluZyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJtZXNzYWdlIiwgIm9wdGlvbnMiLCAiY29kZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmb3JnZSIsICJvcHRpb25zIiwgImdlbmVyYXRlIiwgImkiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZm9yZ2UiLCAiZGlnZXN0IiwgIm9wdGlvbnMiLCAicGFpciIsICJlIiwgImtleXBhaXIiLCAia2V5IiwgImQiLCAiZ2VuZXJhdGUiLCAiY2FsbGJhY2siLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZm9yZ2UiLCAib3B0aW9ucyIsICJrZXkiLCAiaXYiLCAibGVuZ3RoIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImNvZGUiLCAiZnJvbVN0cmluZyIsICJzdHJpbmciLCAiYmFzZSIsICJjcmVhdGUiLCAiY3J5cHRvIiwgImltcG9ydF9jcnlwdG8iLCAiZXJyY29kZSIsICJmcm9tU3RyaW5nIiwgImNyZWF0ZSIsICJlcnJjb2RlIiwgImNyeXB0byIsICJpbXBvcnRfY3J5cHRvIiwgImltcG9ydF9lcnJfY29kZSIsICJjcmVhdGUiLCAiZGlnZXN0IiwgImNyeXB0byIsICJjaXBoZXIiLCAiZW5jcnlwdCIsICJmcm9tU3RyaW5nIiwgImRlY3J5cHQiLCAiaW1wb3J0X2NyeXB0byIsICJjcmVhdGUiLCAiZXF1YWxzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImZvcmdlIiwgInNoYTUxMiIsICJtb2QiLCAibGVuZ3RoIiwgImNyeXB0byIsICJtZXNzYWdlIiwgIlYiLCAiZCIsICJiYXNlIiwgIndpbmRvdyIsICJuYW1lIiwgInJhbmRvbUJ5dGVzIiwgIm1lc3NhZ2VzIiwgImxlbmd0aCIsICJlcnJjb2RlIiwgImltcG9ydF9lcnJfY29kZSIsICJ0b1N0cmluZyIsICJmb3JnZSIsICJmcm9tU3RyaW5nIiwgImZvcmdlIiwgInRvU3RyaW5nIiwgImVycmNvZGUiLCAiZnJvbVN0cmluZyIsICJpbXBvcnRfZm9yZ2UiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImVycmNvZGUiLCAiY3J5cHRvIiwgImltcG9ydF9jcnlwdG8iLCAiaW1wb3J0X3V0aWwiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImNyZWF0ZSIsICJpbXBvcnRfZXJyX2NvZGUiLCAiaW1wb3J0X2ZvcmdlIiwgImVxdWFscyIsICJtZXNzYWdlIiwgImVycmNvZGUiLCAidG9TdHJpbmciLCAiZm9yZ2UiLCAib3B0aW9ucyIsICJjb25jYXRCeXRlcyIsICJsZW5ndGgiLCAiYnl0ZXNUb0hleCIsICJoZXhlcyIsICJoZXhUb0J5dGVzIiwgIm1vZCIsICJfMW4iLCAiQ1VSVkUiLCAiXzBuIiwgImludmVydCIsICJpbnZlcnRCYXRjaCIsICJwb3cyIiwgIl8ybiIsICJlbnN1cmVCeXRlcyIsICJub3JtYWxpemVTY2FsYXIiLCAiUE9XXzJfMjU2IiwgIlBvaW50IiwgInV0aWxzIiwgImdldFB1YmxpY0tleSIsICJzaWduIiwgIm1lc3NhZ2UiLCAiU2lnbmF0dXJlIiwgInZlcmlmeSIsICJub2RlQ3J5cHRvIiwgInBvaW50UHJlY29tcHV0ZXMiLCAiY3J5cHRvIiwgImluaXRfZXNtIiwgImJhc2UiLCAid2luZG93IiwgInJhbmRvbUJ5dGVzIiwgIm1lc3NhZ2VzIiwgImdlbmVyYXRlS2V5IiwgInV0aWxzIiwgImdldFB1YmxpY0tleSIsICJoYXNoQW5kU2lnbiIsICJzaWduIiwgImhhc2hBbmRWZXJpZnkiLCAidmVyaWZ5IiwgImluaXRfZXNtIiwgImdlbmVyYXRlS2V5UGFpciIsICJwcml2YXRlS2V5Qnl0ZXMiLCAicHVibGljS2V5Qnl0ZXMiLCAiZ2VuZXJhdGVLZXkiLCAibGVuZ3RoIiwgImVycmNvZGUiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImluaXRfaWRlbnRpdHkiLCAiaGFzaEFuZFZlcmlmeSIsICJlcXVhbHMiLCAibWVzc2FnZSIsICJoYXNoQW5kU2lnbiIsICJpZGVudGl0eSIsICJnZW5lcmF0ZUtleSIsICJoYXNoQW5kU2lnbiIsICJkaWdlc3QiLCAiZXJyY29kZSIsICJoYXNoQW5kVmVyaWZ5IiwgImltcG9ydF9lcnJfY29kZSIsICJnZW5lcmF0ZUtleVBhaXIiLCAiZ2VuZXJhdGVLZXkiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImhhc2hBbmRWZXJpZnkiLCAiZXF1YWxzIiwgIm1lc3NhZ2UiLCAiaGFzaEFuZFNpZ24iLCAidG9TdHJpbmciLCAiZXJyY29kZSIsICJrZXlzX2V4cG9ydHMiLCAiZ2VuZXJhdGVLZXlQYWlyIiwgImdlbmVyYXRlS2V5UGFpckZyb21TZWVkIiwgInVubWFyc2hhbFByaXZhdGVLZXkiLCAiZXJyY29kZSIsICJrZXkiLCAiZm9yZ2UiLCAiZnJvbVN0cmluZyIsICJpbXBvcnRfYXNuMSIsICJpbXBvcnRfZm9yZ2UiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImluaXRfa2V5cyIsICJpbml0X3NyYyIsICJkZWNvZGUiLCAiaWRlbnRpdHkiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImluaXRfc3JjIiwgImluaXRfaWRlbnRpdHkiLCAiX2EiLCAiZXF1YWxzIiwgImluaXRfc3JjIiwgIlBlZXJJZFByb3RvIiwgInJlYWRlciIsICJsZW5ndGgiLCAiZnJvbVN0cmluZyIsICJ1bm1hcnNoYWxQcml2YXRlS2V5IiwgImluaXRfc3JjIiwgImluaXRfa2V5cyIsICJnZW5lcmF0ZUtleVBhaXIiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAib3B0aW9ucyIsICJuYW1lIiwgInJlcXVpcmVfY29tbW9uIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImNvZXJjZSIsICJkZWJ1ZyIsICJzZWxmIiwgIm5hbWUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAib3MiLCAic2lnbiIsICJ2ZXJzaW9uIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImxvZyIsICJuYW1lIiwgInVzZUNvbG9ycyIsICJkZWJ1ZyIsICJyZXF1aXJlX3NyYyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJuYW1lIiwgImRlYnVnIiwgImluaXRfc3JjIiwgIm9wdGlvbnMiLCAib3B0aW9ucyIsICJwdXNoYWJsZSIsICJfcHVzaGFibGUiLCAiaW5pdF9zcmMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiRml4ZWRGSUZPIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIkZJRk8iLCAib3B0aW9ucyIsICJwdXNoYWJsZSIsICJuZXh0IiwgIl9wdXNoYWJsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJwdXNoYWJsZSIsICJtZXJnZSIsICJpbml0X3NyYyIsICJtZXJnZSIsICJpbml0X3NyYyIsICJpbml0X3NyYyIsICJpbXBvcnRfY3J5cHRvIiwgImNyeXB0byIsICJpbXBvcnRfZXJyX2NvZGUiLCAiaW1wb3J0X3V0aWwiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImluaXRfc3JjIiwgImluaXRfa2V5cyIsICJpbml0X2Vycm9ycyIsICJtZXNzYWdlcyIsICJjb2RlcyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJfX2NvbW1vbkpTIiwgIm1vZCIsICJ0YWJsZSIsICJiYXNlNjQiLCAicmVxdWlyZV94c2Fsc2EyMCIsICJleHBvcnRzMiIsICJtb2R1bGUyIiwgInJlcXVpcmVfeHNhbHNhMjAiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAieHNhbHNhMjAiLCAiZ2VuZXJhdGVLZXkiLCAidG9TdHJpbmciLCAiZnJvbVN0cmluZyIsICJpbml0X3NyYyIsICJ4c2Fsc2EyMCIsICJ0b1N0cmluZyIsICJmcm9tU3RyaW5nIiwgImluaXRfc3JjIiwgInN5bWJvbCIsICJpbml0X3NyYyIsICJsZW5ndGgiLCAiZXF1YWxzIiwgInJlYWRlciIsICJpbml0X3NyYyIsICJzb3VyY2UiLCAiaW5pdF9zcmMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAibWFwIiwgImdlbmVyYXRlS2V5IiwgImltcG9ydF9lcnJfY29kZSIsICJsb2ciLCAiaW5pdF9zcmMiLCAiaW5pdF9lcnJvcnMiLCAiZXJyQ29kZSIsICJtYXAiLCAiY29kZXMiLCAiaW5pdF9lcnJvcnMiLCAiaW5pdF9zcmMiLCAiRW52ZWxvcGUiLCAicmVhZGVyIiwgImxlbmd0aCIsICJpbml0X3NyYyIsICJpbml0X3NyYyIsICJ1bnNpZ25lZCIsICJzaWduIiwgIk4xIiwgIk4yIiwgIk4zIiwgIk40IiwgIk41IiwgIk42IiwgIk43IiwgIk44IiwgIk45IiwgImluaXRfc3JjIiwgImltcG9ydF9lcnJfY29kZSIsICJpbml0X2tleXMiLCAiaW5pdF9lcnJvcnMiLCAiaW5pdF9zcmMiLCAiZXF1YWxzIiwgInVubWFyc2hhbFByaXZhdGVLZXkiLCAiZXJyQ29kZSIsICJjb2RlcyIsICJmcm9tU3RyaW5nIiwgIm9wdGlvbnMiLCAidm0iLCAidG9TdHJpbmciLCAib3B0aW9ucyIsICJjbG9uZWRSZWdleHAiLCAic3RyaW5nIiwgInN0cmluZyIsICJ0b1N0cmluZyIsICJ3b3JkIiwgImxlbmd0aCIsICJzdHJpbmciLCAiY29kZSIsICJuYW1lIiwgInBhdGgiLCAiY29kZXMiLCAibmFtZXMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZW5jb2RlIiwgIk1TQiIsICJSRVNUIiwgIk1TQkFMTCIsICJJTlQiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAicmVhZCIsICJNU0IiLCAiUkVTVCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJOMSIsICJOMiIsICJOMyIsICJONCIsICJONSIsICJONiIsICJONyIsICJOOCIsICJOOSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJ0b1N0cmluZyIsICJmcm9tU3RyaW5nIiwgInZhcmludCIsICJkZWNvZGUiLCAiaW1wb3J0X3ZhcmludCIsICJ2YXJpbnQiLCAiY29kZSIsICJ0b1N0cmluZyIsICJmcm9tU3RyaW5nIiwgImltcG9ydF92YXJpbnQiLCAiaW5pdF9jb2RlYyIsICJpbXBvcnRfdmFyaW50IiwgImltcG9ydF9lcnJfY29kZSIsICJzeW1ib2wiLCAiaW5pdF9zcmMiLCAiaW5pdF9jb2RlYyIsICJmcm9tU3RyaW5nIiwgImNvZGVzIiwgImNvZGUiLCAidmFyaW50IiwgInR1cGxlIiwgIm5hbWVzIiwgInRvU3RyaW5nIiwgInBhdGgiLCAiZXF1YWxzIiwgIm9wdGlvbnMiLCAiZXJyQ29kZSIsICJhIiwgImIiLCAiaW5pdF9zcmMiLCAiUGVlclJlY29yZCIsICJBZGRyZXNzSW5mbyIsICJfY29kZWMiLCAicmVhZGVyIiwgImxlbmd0aCIsICJQZWVyUmVjb3JkIiwgImluaXRfcGVlcl9yZWNvcmQiLCAiaW5pdF9zcmMiLCAiaW5pdF9zcmMiLCAiaW5pdF9lbnZlbG9wZSIsICJpbml0X3BlZXJfcmVjb3JkIiwgImluaXRfc3JjIiwgImluaXRfc3JjIiwgIm9wdGlvbnMiLCAibWVzc2FnZSIsICJtc2dJZCIsICJfYSIsICJtZXNzYWdlIiwgInJlcXVpcmVfbG9uZ2JpdHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiTG9uZ0JpdHMiLCAic2lnbiIsICJmcm9tIiwgInVuc2lnbmVkIiwgImxlbmd0aCIsICJyZXF1aXJlX21pbmltYWwiLCAiZXhwb3J0cyIsICJCdWZmZXIiLCAidW5zaWduZWQiLCAibWVyZ2UiLCAic3JjIiwgIm5hbWUiLCAibWVzc2FnZSIsICJ0b1N0cmluZyIsICJpIiwgInJlcXVpcmVfd3JpdGVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIldyaXRlciIsICJMb25nQml0cyIsICJiYXNlNjQiLCAibm9vcCIsICJjcmVhdGUiLCAiYWxsb2MiLCAicmVxdWlyZV93cml0ZXJfYnVmZmVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIldyaXRlciIsICJyZXF1aXJlX3JlYWRlciIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJSZWFkZXIiLCAiTG9uZ0JpdHMiLCAicmVhZGVyIiwgImNyZWF0ZV9hcnJheSIsICJjcmVhdGUiLCAiYnVmZmVyIiwgImxlbmd0aCIsICJyZXF1aXJlX3JlYWRlcl9idWZmZXIiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiUmVhZGVyIiwgInJlcXVpcmVfc2VydmljZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJzZWxmIiwgImVyciIsICJyZXF1aXJlX3JwYyIsICJleHBvcnRzIiwgInJlcXVpcmVfcm9vdHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAicmVxdWlyZV9pbmRleF9taW5pbWFsIiwgImV4cG9ydHMiLCAicmVxdWlyZV9taW5pbWFsIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImdsb2JhbCIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJSUEMiLCAiZW5jb2RlIiwgImRlY29kZSIsICIkb25lT2ZGaWVsZHMiLCAiY2pzIiwgIm1lc3NhZ2VzIiwgIm1zZ0lkIiwgInRvU3RyaW5nIiwgImluaXRfc3JjIiwgIlNpZ25hdHVyZVBvbGljeSIsICJQdWJsaXNoQ29uZmlnVHlwZSIsICJNZXNzYWdlQWNjZXB0YW5jZSIsICJSZWplY3RSZWFzb24iLCAiVmFsaWRhdGVFcnJvciIsICJNZXNzYWdlU3RhdHVzIiwgInVubWFyc2hhbFByaXZhdGVLZXkiLCAiaW5pdF9rZXlzIiwgImluaXRfc3JjIiwgImluaXRfY29uc3RhbnRzIiwgImVycmNvZGUiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImluaXRfY29uc3RhbnRzIiwgImltcG9ydF9lcnJfY29kZSIsICJpbml0X2NvbnN0YW50cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJEZW5xdWUiLCAib3B0aW9ucyIsICJsZW5ndGgiLCAiRGVsaXZlcnlSZWNvcmRTdGF0dXMiLCAiRGVucXVlIiwgImltcG9ydF9lcnJfY29kZSIsICJpbml0X3NyYyIsICJlcnJDb2RlIiwgImxvZyIsICJpbml0X3NyYyIsICJfYSIsICJmcm9tIiwgImZyb20iLCAibXNnSWQiLCAiX2EiLCAiX2EiLCAiTWVzc2FnZVNvdXJjZSIsICJJbmNsdXNpb25SZWFzb24iLCAiQ2h1cm5SZWFzb24iLCAiU2NvcmVQZW5hbHR5IiwgIklIYXZlSWdub3JlUmVhc29uIiwgIlNjb3JlVGhyZXNob2xkIiwgInRvU3RyaW5nIiwgImVxdWFscyIsICJpbml0X2tleXMiLCAiaW5pdF9zcmMiLCAiZnJvbVN0cmluZyIsICJpbml0X2Vycm9ycyIsICJpbXBvcnRfZXJyX2NvZGUiLCAiaW5pdF91dGlscyIsICJpbml0X3NyYyIsICJpbml0X2Vycm9ycyIsICJmcm9tU3RyaW5nIiwgIm1zZ0lkIiwgImluaXRfdXRpbHMiLCAibWVzc2FnZSIsICJjb2RlIiwgImluaXRfc3JjIiwgIm9wdGlvbnMiLCAiZXJyIiwgImluaXRfc3JjIiwgImFsbG9jVW5zYWZlIiwgIl9hIiwgImluaXRfYWxsb2MiLCAiZW5jb2RlIiwgIm9wdGlvbnMiLCAibGVuZ3RoIiwgImluaXRfZW5jb2RlIiwgImluaXRfc3JjIiwgImluaXRfYWxsb2MiLCAiYWxsb2NVbnNhZmUiLCAiZGVjb2RlIiwgIm9wdGlvbnMiLCAiZXJyQ29kZSIsICJpbXBvcnRfZXJyX2NvZGUiLCAiaW5pdF9kZWNvZGUiLCAiaW5pdF9zcmMiLCAiUmVhZE1vZGUiLCAibGVuZ3RoIiwgInJlYWRlciIsICJpbml0X3NyYyIsICJpbml0X2VuY29kZSIsICJpbml0X2RlY29kZSIsICJpbml0X3NyYyIsICJlbmNvZGUiLCAiZGVjb2RlIiwgInNyY19leHBvcnRzIiwgImluaXRfc3JjIiwgIkdvc3NpcFN0YXR1c0NvZGUiLCAib3B0aW9ucyIsICJfYSIsICJtdWx0aWNvZGVjIiwgImZyb20iLCAibWVzc2FnZSIsICJtc2dJZCIsICJlcnJDb2RlIiwgImlkIiwgIm9zIiwgInBhdGgiLCAiY3JlYXRlRWQyNTUxOVBlZXJJZCIsICJQcmVTaGFyZWRLZXlDb25uZWN0aW9uUHJvdGVjdG9yIiwgIkdvc3NpcFN1YiIsICJjcmVhdGVGcm9tUHJpdktleSIsICJ1bm1hcnNoYWxQcml2YXRlS2V5IiwgInRvU3RyaW5nIl0KfQo=
